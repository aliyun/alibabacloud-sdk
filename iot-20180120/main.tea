/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'ap-northeast-2-pop' = 'iot.aliyuncs.com',
    'ap-south-1' = 'iot.aliyuncs.com',
    'ap-southeast-2' = 'iot.aliyuncs.com',
    'ap-southeast-3' = 'iot.aliyuncs.com',
    'ap-southeast-5' = 'iot.aliyuncs.com',
    'cn-beijing-finance-1' = 'iot.aliyuncs.com',
    'cn-beijing-finance-pop' = 'iot.aliyuncs.com',
    'cn-beijing-gov-1' = 'iot.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'iot.aliyuncs.com',
    'cn-chengdu' = 'iot.aliyuncs.com',
    'cn-edge-1' = 'iot.aliyuncs.com',
    'cn-fujian' = 'iot.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'iot.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'iot.aliyuncs.com',
    'cn-hangzhou-finance' = 'iot.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'iot.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'iot.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'iot.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'iot.aliyuncs.com',
    'cn-hangzhou-test-306' = 'iot.aliyuncs.com',
    'cn-hongkong' = 'iot.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'iot.aliyuncs.com',
    'cn-huhehaote' = 'iot.aliyuncs.com',
    'cn-huhehaote-nebula-1' = 'iot.aliyuncs.com',
    'cn-qingdao' = 'iot.aliyuncs.com',
    'cn-qingdao-nebula' = 'iot.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'iot.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'iot.aliyuncs.com',
    'cn-shanghai-finance-1' = 'iot.aliyuncs.com',
    'cn-shanghai-inner' = 'iot.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'iot.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'iot.aliyuncs.com',
    'cn-shenzhen-inner' = 'iot.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'iot.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'iot.aliyuncs.com',
    'cn-wuhan' = 'iot.aliyuncs.com',
    'cn-wulanchabu' = 'iot.aliyuncs.com',
    'cn-yushanfang' = 'iot.aliyuncs.com',
    'cn-zhangbei' = 'iot.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'iot.aliyuncs.com',
    'cn-zhangjiakou' = 'iot.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'iot.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'iot.aliyuncs.com',
    'eu-west-1' = 'iot.aliyuncs.com',
    'eu-west-1-oxs' = 'iot.aliyuncs.com',
    'me-east-1' = 'iot.aliyuncs.com',
    'rus-west-1-pop' = 'iot.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('iot', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddDataForApiSourceRequest {
  apiId?: string(name='ApiId', description='This parameter is required.'),
  content?: string(name='Content', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
}

model AddDataForApiSourceResponseBody = {
  code?: string(name='Code'),
  data?: long(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddDataForApiSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDataForApiSourceResponseBody(name='body'),
}

/**
 * @param request AddDataForApiSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDataForApiSourceResponse
 */
async function addDataForApiSourceWithOptions(request: AddDataForApiSourceRequest, runtime: Util.RuntimeOptions): AddDataForApiSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiId)) {
    query['ApiId'] = request.apiId;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDataForApiSource',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddDataForApiSourceRequest
 * @return AddDataForApiSourceResponse
 */
async function addDataForApiSource(request: AddDataForApiSourceRequest): AddDataForApiSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDataForApiSourceWithOptions(request, runtime);
}

model AddDeviceToSharePromotionRequest {
  deviceSimpleInfoList?: [ 
    {
      deviceName?: string(name='DeviceName', description='This parameter is required.'),
      productKey?: string(name='ProductKey', description='This parameter is required.'),
    }
  ](name='DeviceSimpleInfoList', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  sharePromotionActivityId?: string(name='SharePromotionActivityId', description='This parameter is required.'),
  shareTaskCode?: string(name='ShareTaskCode', description='This parameter is required.'),
}

model AddDeviceToSharePromotionResponseBody = {
  code?: string(name='Code'),
  data?: {
    failDeviceSimpleInfoList?: {
      item?: [ 
      {
        deviceName?: string(name='DeviceName'),
        failCode?: int32(name='FailCode'),
        failReason?: string(name='FailReason'),
        productKey?: string(name='ProductKey'),
      }
    ](name='item')
    }(name='FailDeviceSimpleInfoList'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddDeviceToSharePromotionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddDeviceToSharePromotionResponseBody(name='body'),
}

/**
 * @param request AddDeviceToSharePromotionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddDeviceToSharePromotionResponse
 */
async function addDeviceToSharePromotionWithOptions(request: AddDeviceToSharePromotionRequest, runtime: Util.RuntimeOptions): AddDeviceToSharePromotionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSimpleInfoList)) {
    body['DeviceSimpleInfoList'] = request.deviceSimpleInfoList;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.sharePromotionActivityId)) {
    body['SharePromotionActivityId'] = request.sharePromotionActivityId;
  }
  if (!Util.isUnset(request.shareTaskCode)) {
    body['ShareTaskCode'] = request.shareTaskCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddDeviceToSharePromotion',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddDeviceToSharePromotionRequest
 * @return AddDeviceToSharePromotionResponse
 */
async function addDeviceToSharePromotion(request: AddDeviceToSharePromotionRequest): AddDeviceToSharePromotionResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDeviceToSharePromotionWithOptions(request, runtime);
}

model AddPowerStationRequest {
  algorithmInstanceUid?: string(name='AlgorithmInstanceUid', description='This parameter is required.'),
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  powerStationName?: string(name='PowerStationName', description='This parameter is required.'),
  ratedPower?: int32(name='RatedPower', description='This parameter is required.'),
}

model AddPowerStationResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddPowerStationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddPowerStationResponseBody(name='body'),
}

/**
 * @param request AddPowerStationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddPowerStationResponse
 */
async function addPowerStationWithOptions(request: AddPowerStationRequest, runtime: Util.RuntimeOptions): AddPowerStationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithmInstanceUid)) {
    query['AlgorithmInstanceUid'] = request.algorithmInstanceUid;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.powerStationName)) {
    query['PowerStationName'] = request.powerStationName;
  }
  if (!Util.isUnset(request.ratedPower)) {
    query['RatedPower'] = request.ratedPower;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPowerStation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddPowerStationRequest
 * @return AddPowerStationResponse
 */
async function addPowerStation(request: AddPowerStationRequest): AddPowerStationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPowerStationWithOptions(request, runtime);
}

model AddShareTaskDeviceRequest {
  iotIdList?: [ string ](name='IotIdList'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  shareTaskId?: string(name='ShareTaskId', description='This parameter is required.'),
}

model AddShareTaskDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    failSum?: int32(name='FailSum'),
    failedResultCsvFile?: string(name='FailedResultCsvFile'),
    progress?: int32(name='Progress'),
    progressId?: string(name='ProgressId'),
    successSum?: int32(name='SuccessSum'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddShareTaskDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddShareTaskDeviceResponseBody(name='body'),
}

/**
 * @param request AddShareTaskDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddShareTaskDeviceResponse
 */
async function addShareTaskDeviceWithOptions(request: AddShareTaskDeviceRequest, runtime: Util.RuntimeOptions): AddShareTaskDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotIdList)) {
    body['IotIdList'] = request.iotIdList;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.shareTaskId)) {
    body['ShareTaskId'] = request.shareTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddShareTaskDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddShareTaskDeviceRequest
 * @return AddShareTaskDeviceResponse
 */
async function addShareTaskDevice(request: AddShareTaskDeviceRequest): AddShareTaskDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addShareTaskDeviceWithOptions(request, runtime);
}

model AsyncRRpcRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  extInfo?: string(name='ExtInfo'),
  iotInstanceId?: string(name='IotInstanceId'),
  messageContent?: string(name='MessageContent', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  topicFullName?: string(name='TopicFullName'),
}

model AsyncRRpcResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  messageId?: long(name='MessageId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AsyncRRpcResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AsyncRRpcResponseBody(name='body'),
}

/**
 * @param request AsyncRRpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AsyncRRpcResponse
 */
async function asyncRRpcWithOptions(request: AsyncRRpcRequest, runtime: Util.RuntimeOptions): AsyncRRpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.extInfo)) {
    query['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.topicFullName)) {
    query['TopicFullName'] = request.topicFullName;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.messageContent)) {
    body['MessageContent'] = request.messageContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AsyncRRpc',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AsyncRRpcRequest
 * @return AsyncRRpcResponse
 */
async function asyncRRpc(request: AsyncRRpcRequest): AsyncRRpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return asyncRRpcWithOptions(request, runtime);
}

model AttachDestinationRequest {
  destinationId?: long(name='DestinationId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  isFailover?: boolean(name='IsFailover', description='This parameter is required.'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model AttachDestinationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AttachDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachDestinationResponseBody(name='body'),
}

/**
 * @param request AttachDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachDestinationResponse
 */
async function attachDestinationWithOptions(request: AttachDestinationRequest, runtime: Util.RuntimeOptions): AttachDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationId)) {
    query['DestinationId'] = request.destinationId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.isFailover)) {
    query['IsFailover'] = request.isFailover;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachDestination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AttachDestinationRequest
 * @return AttachDestinationResponse
 */
async function attachDestination(request: AttachDestinationRequest): AttachDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDestinationWithOptions(request, runtime);
}

model AttachParserDataSourceRequest {
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model AttachParserDataSourceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AttachParserDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachParserDataSourceResponseBody(name='body'),
}

/**
 * @param request AttachParserDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachParserDataSourceResponse
 */
async function attachParserDataSourceWithOptions(request: AttachParserDataSourceRequest, runtime: Util.RuntimeOptions): AttachParserDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachParserDataSource',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AttachParserDataSourceRequest
 * @return AttachParserDataSourceResponse
 */
async function attachParserDataSource(request: AttachParserDataSourceRequest): AttachParserDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachParserDataSourceWithOptions(request, runtime);
}

model BatchAddDataForApiSourceRequest {
  apiId?: string(name='ApiId', description='This parameter is required.'),
  contentList?: string(name='ContentList', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
}

model BatchAddDataForApiSourceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchAddDataForApiSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchAddDataForApiSourceResponseBody(name='body'),
}

/**
 * @param request BatchAddDataForApiSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchAddDataForApiSourceResponse
 */
async function batchAddDataForApiSourceWithOptions(request: BatchAddDataForApiSourceRequest, runtime: Util.RuntimeOptions): BatchAddDataForApiSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiId)) {
    query['ApiId'] = request.apiId;
  }
  if (!Util.isUnset(request.contentList)) {
    query['ContentList'] = request.contentList;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddDataForApiSource',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchAddDataForApiSourceRequest
 * @return BatchAddDataForApiSourceResponse
 */
async function batchAddDataForApiSource(request: BatchAddDataForApiSourceRequest): BatchAddDataForApiSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchAddDataForApiSourceWithOptions(request, runtime);
}

model BatchAddDeviceGroupRelationsRequest {
  device?: [ 
    {
      deviceName?: string(name='DeviceName', description='This parameter is required.'),
      productKey?: string(name='ProductKey', description='This parameter is required.'),
    }
  ](name='Device'),
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchAddDeviceGroupRelationsResponseBody = {
  alreadyRelatedGroupDeviceCount?: int32(name='AlreadyRelatedGroupDeviceCount'),
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  exceedTenGroupDeviceCount?: int32(name='ExceedTenGroupDeviceCount'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  successAddedDeviceCount?: int32(name='SuccessAddedDeviceCount'),
  validDeviceCount?: int32(name='ValidDeviceCount'),
}

model BatchAddDeviceGroupRelationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchAddDeviceGroupRelationsResponseBody(name='body'),
}

/**
 * @param request BatchAddDeviceGroupRelationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchAddDeviceGroupRelationsResponse
 */
async function batchAddDeviceGroupRelationsWithOptions(request: BatchAddDeviceGroupRelationsRequest, runtime: Util.RuntimeOptions): BatchAddDeviceGroupRelationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.device)) {
    query['Device'] = request.device;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddDeviceGroupRelations',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchAddDeviceGroupRelationsRequest
 * @return BatchAddDeviceGroupRelationsResponse
 */
async function batchAddDeviceGroupRelations(request: BatchAddDeviceGroupRelationsRequest): BatchAddDeviceGroupRelationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchAddDeviceGroupRelationsWithOptions(request, runtime);
}

model BatchAddThingTopoRequest {
  gwDeviceName?: string(name='GwDeviceName', description='This parameter is required.'),
  gwProductKey?: string(name='GwProductKey', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  topoAddItem?: [ 
    {
      clientId?: string(name='ClientId'),
      deviceName?: string(name='DeviceName', description='This parameter is required.'),
      productKey?: string(name='ProductKey', description='This parameter is required.'),
      sign?: string(name='Sign', description='This parameter is required.'),
      signMethod?: string(name='SignMethod', description='This parameter is required.'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='TopoAddItem', description='This parameter is required.'),
}

model BatchAddThingTopoResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchAddThingTopoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchAddThingTopoResponseBody(name='body'),
}

/**
 * @param request BatchAddThingTopoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchAddThingTopoResponse
 */
async function batchAddThingTopoWithOptions(request: BatchAddThingTopoRequest, runtime: Util.RuntimeOptions): BatchAddThingTopoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gwDeviceName)) {
    query['GwDeviceName'] = request.gwDeviceName;
  }
  if (!Util.isUnset(request.gwProductKey)) {
    query['GwProductKey'] = request.gwProductKey;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.topoAddItem)) {
    query['TopoAddItem'] = request.topoAddItem;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddThingTopo',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchAddThingTopoRequest
 * @return BatchAddThingTopoResponse
 */
async function batchAddThingTopo(request: BatchAddThingTopoRequest): BatchAddThingTopoResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchAddThingTopoWithOptions(request, runtime);
}

model BatchBindDeviceToEdgeInstanceWithDriverRequest {
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotIds?: [ string ](name='IotIds', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchBindDeviceToEdgeInstanceWithDriverResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchBindDeviceToEdgeInstanceWithDriverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchBindDeviceToEdgeInstanceWithDriverResponseBody(name='body'),
}

/**
 * @param request BatchBindDeviceToEdgeInstanceWithDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchBindDeviceToEdgeInstanceWithDriverResponse
 */
async function batchBindDeviceToEdgeInstanceWithDriverWithOptions(request: BatchBindDeviceToEdgeInstanceWithDriverRequest, runtime: Util.RuntimeOptions): BatchBindDeviceToEdgeInstanceWithDriverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotIds)) {
    query['IotIds'] = request.iotIds;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchBindDeviceToEdgeInstanceWithDriver',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchBindDeviceToEdgeInstanceWithDriverRequest
 * @return BatchBindDeviceToEdgeInstanceWithDriverResponse
 */
async function batchBindDeviceToEdgeInstanceWithDriver(request: BatchBindDeviceToEdgeInstanceWithDriverRequest): BatchBindDeviceToEdgeInstanceWithDriverResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchBindDeviceToEdgeInstanceWithDriverWithOptions(request, runtime);
}

model BatchBindDevicesIntoProjectRequest {
  devices?: [ 
    {
      deviceName?: string(name='DeviceName', description='This parameter is required.'),
      productKey?: string(name='ProductKey', description='This parameter is required.'),
    }
  ](name='Devices', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model BatchBindDevicesIntoProjectResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchBindDevicesIntoProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchBindDevicesIntoProjectResponseBody(name='body'),
}

/**
 * @param request BatchBindDevicesIntoProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchBindDevicesIntoProjectResponse
 */
async function batchBindDevicesIntoProjectWithOptions(request: BatchBindDevicesIntoProjectRequest, runtime: Util.RuntimeOptions): BatchBindDevicesIntoProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.devices)) {
    body['Devices'] = request.devices;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchBindDevicesIntoProject',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchBindDevicesIntoProjectRequest
 * @return BatchBindDevicesIntoProjectResponse
 */
async function batchBindDevicesIntoProject(request: BatchBindDevicesIntoProjectRequest): BatchBindDevicesIntoProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchBindDevicesIntoProjectWithOptions(request, runtime);
}

model BatchBindProductsIntoProjectRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKeys?: [ string ](name='ProductKeys', description='This parameter is required.'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model BatchBindProductsIntoProjectResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchBindProductsIntoProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchBindProductsIntoProjectResponseBody(name='body'),
}

/**
 * @param request BatchBindProductsIntoProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchBindProductsIntoProjectResponse
 */
async function batchBindProductsIntoProjectWithOptions(request: BatchBindProductsIntoProjectRequest, runtime: Util.RuntimeOptions): BatchBindProductsIntoProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKeys)) {
    body['ProductKeys'] = request.productKeys;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchBindProductsIntoProject',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchBindProductsIntoProjectRequest
 * @return BatchBindProductsIntoProjectResponse
 */
async function batchBindProductsIntoProject(request: BatchBindProductsIntoProjectRequest): BatchBindProductsIntoProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchBindProductsIntoProjectWithOptions(request, runtime);
}

model BatchCheckDeviceNamesRequest {
  deviceName?: [ string ](name='DeviceName'),
  deviceNameList?: [ 
    {
      deviceName?: string(name='DeviceName'),
      deviceNickname?: string(name='DeviceNickname'),
    }
  ](name='DeviceNameList'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BatchCheckDeviceNamesResponseBody = {
  code?: string(name='Code'),
  data?: {
    applyId?: long(name='ApplyId'),
    invalidDetailList?: {
      invalidDetailList?: [ 
      {
        deviceName?: string(name='DeviceName'),
        errorMsg?: string(name='ErrorMsg'),
        nickName?: string(name='NickName'),
      }
    ](name='InvalidDetailList')
    }(name='InvalidDetailList'),
    invalidDeviceNameList?: {
      invalidDeviceName?: [ string ](name='InvalidDeviceName')
    }(name='InvalidDeviceNameList'),
    invalidDeviceNicknameList?: {
      invalidDeviceNickname?: [ string ](name='InvalidDeviceNickname')
    }(name='InvalidDeviceNicknameList'),
    repeatedDeviceNameList?: {
      repeatDevieNameList?: [ string ](name='RepeatDevieNameList')
    }(name='RepeatedDeviceNameList'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchCheckDeviceNamesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCheckDeviceNamesResponseBody(name='body'),
}

/**
 * @param request BatchCheckDeviceNamesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCheckDeviceNamesResponse
 */
async function batchCheckDeviceNamesWithOptions(request: BatchCheckDeviceNamesRequest, runtime: Util.RuntimeOptions): BatchCheckDeviceNamesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceNameList)) {
    body['DeviceNameList'] = request.deviceNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCheckDeviceNames',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchCheckDeviceNamesRequest
 * @return BatchCheckDeviceNamesResponse
 */
async function batchCheckDeviceNames(request: BatchCheckDeviceNamesRequest): BatchCheckDeviceNamesResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCheckDeviceNamesWithOptions(request, runtime);
}

model BatchCheckImportDeviceRequest {
  deviceList?: [ 
    {
      deviceName?: string(name='DeviceName', description='This parameter is required.'),
      deviceSecret?: string(name='DeviceSecret', description='This parameter is required.'),
      sn?: string(name='Sn'),
    }
  ](name='DeviceList', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BatchCheckImportDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    invalidDetailList?: [ 
      {
        deviceName?: string(name='DeviceName'),
        deviceSecret?: string(name='DeviceSecret'),
        errorMsg?: string(name='ErrorMsg'),
        sn?: string(name='Sn'),
      }
    ](name='InvalidDetailList'),
    invalidDeviceNameList?: [ string ](name='InvalidDeviceNameList'),
    invalidDeviceSecretList?: [ string ](name='InvalidDeviceSecretList'),
    invalidSnList?: [ string ](name='InvalidSnList'),
    repeatedDeviceNameList?: [ string ](name='RepeatedDeviceNameList'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchCheckImportDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCheckImportDeviceResponseBody(name='body'),
}

/**
 * @param request BatchCheckImportDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCheckImportDeviceResponse
 */
async function batchCheckImportDeviceWithOptions(request: BatchCheckImportDeviceRequest, runtime: Util.RuntimeOptions): BatchCheckImportDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceList)) {
    body['DeviceList'] = request.deviceList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCheckImportDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchCheckImportDeviceRequest
 * @return BatchCheckImportDeviceResponse
 */
async function batchCheckImportDevice(request: BatchCheckImportDeviceRequest): BatchCheckImportDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCheckImportDeviceWithOptions(request, runtime);
}

model BatchCheckVehicleDeviceRequest {
  deviceList?: [ 
    {
      deviceId?: string(name='DeviceId'),
      deviceModel?: string(name='DeviceModel'),
      deviceName?: string(name='DeviceName'),
      deviceSecret?: string(name='DeviceSecret'),
      manufacturer?: string(name='Manufacturer'),
    }
  ](name='DeviceList', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BatchCheckVehicleDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    invalidDetailList?: [ 
      {
        deviceId?: string(name='DeviceId'),
        deviceModel?: string(name='DeviceModel'),
        deviceName?: string(name='DeviceName'),
        errorMsg?: string(name='ErrorMsg'),
        manufacturer?: string(name='Manufacturer'),
      }
    ](name='InvalidDetailList'),
    invalidDeviceIdList?: [ string ](name='InvalidDeviceIdList'),
    invalidDeviceModelList?: [ string ](name='InvalidDeviceModelList'),
    invalidDeviceNameList?: [ string ](name='InvalidDeviceNameList'),
    invalidManufacturerList?: [ string ](name='InvalidManufacturerList'),
    repeatedDeviceIdList?: [ string ](name='RepeatedDeviceIdList'),
    repeatedDeviceNameList?: [ string ](name='RepeatedDeviceNameList'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchCheckVehicleDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCheckVehicleDeviceResponseBody(name='body'),
}

/**
 * @param request BatchCheckVehicleDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCheckVehicleDeviceResponse
 */
async function batchCheckVehicleDeviceWithOptions(request: BatchCheckVehicleDeviceRequest, runtime: Util.RuntimeOptions): BatchCheckVehicleDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceList)) {
    body['DeviceList'] = request.deviceList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCheckVehicleDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchCheckVehicleDeviceRequest
 * @return BatchCheckVehicleDeviceResponse
 */
async function batchCheckVehicleDevice(request: BatchCheckVehicleDeviceRequest): BatchCheckVehicleDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCheckVehicleDeviceWithOptions(request, runtime);
}

model BatchClearEdgeInstanceDeviceConfigRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotIds?: [ string ](name='IotIds', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchClearEdgeInstanceDeviceConfigResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchClearEdgeInstanceDeviceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchClearEdgeInstanceDeviceConfigResponseBody(name='body'),
}

/**
 * @param request BatchClearEdgeInstanceDeviceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchClearEdgeInstanceDeviceConfigResponse
 */
async function batchClearEdgeInstanceDeviceConfigWithOptions(request: BatchClearEdgeInstanceDeviceConfigRequest, runtime: Util.RuntimeOptions): BatchClearEdgeInstanceDeviceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotIds)) {
    query['IotIds'] = request.iotIds;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchClearEdgeInstanceDeviceConfig',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchClearEdgeInstanceDeviceConfigRequest
 * @return BatchClearEdgeInstanceDeviceConfigResponse
 */
async function batchClearEdgeInstanceDeviceConfig(request: BatchClearEdgeInstanceDeviceConfigRequest): BatchClearEdgeInstanceDeviceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchClearEdgeInstanceDeviceConfigWithOptions(request, runtime);
}

model BatchCreateSoundCodeLabelRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
  total?: int32(name='Total', description='This parameter is required.'),
}

model BatchCreateSoundCodeLabelResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchCreateSoundCodeLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateSoundCodeLabelResponseBody(name='body'),
}

/**
 * @param request BatchCreateSoundCodeLabelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCreateSoundCodeLabelResponse
 */
async function batchCreateSoundCodeLabelWithOptions(request: BatchCreateSoundCodeLabelRequest, runtime: Util.RuntimeOptions): BatchCreateSoundCodeLabelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  if (!Util.isUnset(request.total)) {
    body['Total'] = request.total;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateSoundCodeLabel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchCreateSoundCodeLabelRequest
 * @return BatchCreateSoundCodeLabelResponse
 */
async function batchCreateSoundCodeLabel(request: BatchCreateSoundCodeLabelRequest): BatchCreateSoundCodeLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCreateSoundCodeLabelWithOptions(request, runtime);
}

model BatchCreateSoundCodeLabelWithLabelsRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  labels?: [ string ](name='Labels', description='This parameter is required.'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
}

model BatchCreateSoundCodeLabelWithLabelsResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchCreateSoundCodeLabelWithLabelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateSoundCodeLabelWithLabelsResponseBody(name='body'),
}

/**
 * @param request BatchCreateSoundCodeLabelWithLabelsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCreateSoundCodeLabelWithLabelsResponse
 */
async function batchCreateSoundCodeLabelWithLabelsWithOptions(request: BatchCreateSoundCodeLabelWithLabelsRequest, runtime: Util.RuntimeOptions): BatchCreateSoundCodeLabelWithLabelsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateSoundCodeLabelWithLabels',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchCreateSoundCodeLabelWithLabelsRequest
 * @return BatchCreateSoundCodeLabelWithLabelsResponse
 */
async function batchCreateSoundCodeLabelWithLabels(request: BatchCreateSoundCodeLabelWithLabelsRequest): BatchCreateSoundCodeLabelWithLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCreateSoundCodeLabelWithLabelsWithOptions(request, runtime);
}

model BatchDeleteDeviceGroupRelationsRequest {
  device?: [ 
    {
      deviceName?: string(name='DeviceName', description='This parameter is required.'),
      productKey?: string(name='ProductKey', description='This parameter is required.'),
    }
  ](name='Device'),
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchDeleteDeviceGroupRelationsResponseBody = {
  alreadyRelatedGroupDeviceCount?: int32(name='AlreadyRelatedGroupDeviceCount'),
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  successDeviceCount?: int32(name='SuccessDeviceCount'),
  validDeviceCount?: int32(name='ValidDeviceCount'),
}

model BatchDeleteDeviceGroupRelationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteDeviceGroupRelationsResponseBody(name='body'),
}

/**
 * @param request BatchDeleteDeviceGroupRelationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteDeviceGroupRelationsResponse
 */
async function batchDeleteDeviceGroupRelationsWithOptions(request: BatchDeleteDeviceGroupRelationsRequest, runtime: Util.RuntimeOptions): BatchDeleteDeviceGroupRelationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.device)) {
    query['Device'] = request.device;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteDeviceGroupRelations',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchDeleteDeviceGroupRelationsRequest
 * @return BatchDeleteDeviceGroupRelationsResponse
 */
async function batchDeleteDeviceGroupRelations(request: BatchDeleteDeviceGroupRelationsRequest): BatchDeleteDeviceGroupRelationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteDeviceGroupRelationsWithOptions(request, runtime);
}

model BatchDeleteEdgeInstanceChannelRequest {
  channelIds?: [ string ](name='ChannelIds', description='This parameter is required.'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchDeleteEdgeInstanceChannelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchDeleteEdgeInstanceChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteEdgeInstanceChannelResponseBody(name='body'),
}

/**
 * @param request BatchDeleteEdgeInstanceChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteEdgeInstanceChannelResponse
 */
async function batchDeleteEdgeInstanceChannelWithOptions(request: BatchDeleteEdgeInstanceChannelRequest, runtime: Util.RuntimeOptions): BatchDeleteEdgeInstanceChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelIds)) {
    query['ChannelIds'] = request.channelIds;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteEdgeInstanceChannel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchDeleteEdgeInstanceChannelRequest
 * @return BatchDeleteEdgeInstanceChannelResponse
 */
async function batchDeleteEdgeInstanceChannel(request: BatchDeleteEdgeInstanceChannelRequest): BatchDeleteEdgeInstanceChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteEdgeInstanceChannelWithOptions(request, runtime);
}

model BatchGetDeviceBindStatusRequest {
  iotIds?: [ string ](name='IotIds', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchGetDeviceBindStatusResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      bindStatus?: int32(name='BindStatus'),
      instanceId?: string(name='InstanceId'),
      iotId?: string(name='IotId'),
    }
  ](name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetDeviceBindStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetDeviceBindStatusResponseBody(name='body'),
}

/**
 * @param request BatchGetDeviceBindStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetDeviceBindStatusResponse
 */
async function batchGetDeviceBindStatusWithOptions(request: BatchGetDeviceBindStatusRequest, runtime: Util.RuntimeOptions): BatchGetDeviceBindStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotIds)) {
    query['IotIds'] = request.iotIds;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetDeviceBindStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchGetDeviceBindStatusRequest
 * @return BatchGetDeviceBindStatusResponse
 */
async function batchGetDeviceBindStatus(request: BatchGetDeviceBindStatusRequest): BatchGetDeviceBindStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetDeviceBindStatusWithOptions(request, runtime);
}

model BatchGetDeviceStateRequest {
  deviceName?: [ string ](name='DeviceName'),
  iotId?: [ string ](name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model BatchGetDeviceStateResponseBody = {
  code?: string(name='Code'),
  deviceStatusList?: {
    deviceStatus?: [ 
    {
      asAddress?: string(name='AsAddress'),
      deviceId?: string(name='DeviceId'),
      deviceName?: string(name='DeviceName'),
      iotId?: string(name='IotId'),
      lastOnlineTime?: string(name='LastOnlineTime'),
      status?: string(name='Status'),
      timestamp?: long(name='Timestamp'),
    }
  ](name='DeviceStatus')
  }(name='DeviceStatusList'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetDeviceStateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetDeviceStateResponseBody(name='body'),
}

/**
 * @param request BatchGetDeviceStateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetDeviceStateResponse
 */
async function batchGetDeviceStateWithOptions(request: BatchGetDeviceStateRequest, runtime: Util.RuntimeOptions): BatchGetDeviceStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetDeviceState',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchGetDeviceStateRequest
 * @return BatchGetDeviceStateResponse
 */
async function batchGetDeviceState(request: BatchGetDeviceStateRequest): BatchGetDeviceStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetDeviceStateWithOptions(request, runtime);
}

model BatchGetEdgeDriverRequest {
  driverIds?: [ string ](name='DriverIds', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchGetEdgeDriverResponseBody = {
  code?: string(name='Code'),
  driverList?: [ 
    {
      cpuArch?: string(name='CpuArch'),
      driverId?: string(name='DriverId'),
      driverName?: string(name='DriverName'),
      driverProtocol?: string(name='DriverProtocol'),
      gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
      gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
      isBuiltIn?: boolean(name='IsBuiltIn'),
      runtime?: string(name='Runtime'),
      type?: int32(name='Type'),
    }
  ](name='DriverList'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetEdgeDriverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetEdgeDriverResponseBody(name='body'),
}

/**
 * @param request BatchGetEdgeDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetEdgeDriverResponse
 */
async function batchGetEdgeDriverWithOptions(request: BatchGetEdgeDriverRequest, runtime: Util.RuntimeOptions): BatchGetEdgeDriverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverIds)) {
    query['DriverIds'] = request.driverIds;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetEdgeDriver',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchGetEdgeDriverRequest
 * @return BatchGetEdgeDriverResponse
 */
async function batchGetEdgeDriver(request: BatchGetEdgeDriverRequest): BatchGetEdgeDriverResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetEdgeDriverWithOptions(request, runtime);
}

model BatchGetEdgeInstanceChannelRequest {
  channelIds?: [ string ](name='ChannelIds', description='This parameter is required.'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchGetEdgeInstanceChannelResponseBody = {
  code?: string(name='Code'),
  data?: {
    channel?: [ 
    {
      channelId?: string(name='ChannelId'),
      channelName?: string(name='ChannelName'),
      configList?: {
        config?: [ 
        {
          configId?: string(name='ConfigId'),
          content?: string(name='Content'),
          format?: string(name='Format'),
          key?: string(name='Key'),
        }
      ](name='Config')
      }(name='ConfigList'),
    }
  ](name='Channel')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetEdgeInstanceChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetEdgeInstanceChannelResponseBody(name='body'),
}

/**
 * @param request BatchGetEdgeInstanceChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetEdgeInstanceChannelResponse
 */
async function batchGetEdgeInstanceChannelWithOptions(request: BatchGetEdgeInstanceChannelRequest, runtime: Util.RuntimeOptions): BatchGetEdgeInstanceChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelIds)) {
    query['ChannelIds'] = request.channelIds;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetEdgeInstanceChannel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchGetEdgeInstanceChannelRequest
 * @return BatchGetEdgeInstanceChannelResponse
 */
async function batchGetEdgeInstanceChannel(request: BatchGetEdgeInstanceChannelRequest): BatchGetEdgeInstanceChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetEdgeInstanceChannelWithOptions(request, runtime);
}

model BatchGetEdgeInstanceDeviceChannelRequest {
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotIds?: [ string ](name='IotIds', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchGetEdgeInstanceDeviceChannelResponseBody = {
  code?: string(name='Code'),
  deviceChannelList?: [ 
    {
      channelId?: string(name='ChannelId'),
      channelName?: string(name='ChannelName'),
      iotId?: string(name='IotId'),
    }
  ](name='DeviceChannelList'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetEdgeInstanceDeviceChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetEdgeInstanceDeviceChannelResponseBody(name='body'),
}

/**
 * @param request BatchGetEdgeInstanceDeviceChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetEdgeInstanceDeviceChannelResponse
 */
async function batchGetEdgeInstanceDeviceChannelWithOptions(request: BatchGetEdgeInstanceDeviceChannelRequest, runtime: Util.RuntimeOptions): BatchGetEdgeInstanceDeviceChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotIds)) {
    query['IotIds'] = request.iotIds;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetEdgeInstanceDeviceChannel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchGetEdgeInstanceDeviceChannelRequest
 * @return BatchGetEdgeInstanceDeviceChannelResponse
 */
async function batchGetEdgeInstanceDeviceChannel(request: BatchGetEdgeInstanceDeviceChannelRequest): BatchGetEdgeInstanceDeviceChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetEdgeInstanceDeviceChannelWithOptions(request, runtime);
}

model BatchGetEdgeInstanceDeviceConfigRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotIds?: [ string ](name='IotIds', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchGetEdgeInstanceDeviceConfigResponseBody = {
  code?: string(name='Code'),
  deviceConfigList?: [ 
    {
      config?: {
        content?: string(name='Content'),
        format?: string(name='Format'),
      }(name='Config'),
      iotId?: string(name='IotId'),
    }
  ](name='DeviceConfigList'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetEdgeInstanceDeviceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetEdgeInstanceDeviceConfigResponseBody(name='body'),
}

/**
 * @param request BatchGetEdgeInstanceDeviceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetEdgeInstanceDeviceConfigResponse
 */
async function batchGetEdgeInstanceDeviceConfigWithOptions(request: BatchGetEdgeInstanceDeviceConfigRequest, runtime: Util.RuntimeOptions): BatchGetEdgeInstanceDeviceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotIds)) {
    query['IotIds'] = request.iotIds;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetEdgeInstanceDeviceConfig',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchGetEdgeInstanceDeviceConfigRequest
 * @return BatchGetEdgeInstanceDeviceConfigResponse
 */
async function batchGetEdgeInstanceDeviceConfig(request: BatchGetEdgeInstanceDeviceConfigRequest): BatchGetEdgeInstanceDeviceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetEdgeInstanceDeviceConfigWithOptions(request, runtime);
}

model BatchGetEdgeInstanceDeviceDriverRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotIds?: [ string ](name='IotIds', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchGetEdgeInstanceDeviceDriverResponseBody = {
  code?: string(name='Code'),
  deviceDriverList?: [ 
    {
      driverId?: string(name='DriverId'),
      iotId?: string(name='IotId'),
    }
  ](name='DeviceDriverList'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetEdgeInstanceDeviceDriverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetEdgeInstanceDeviceDriverResponseBody(name='body'),
}

/**
 * @param request BatchGetEdgeInstanceDeviceDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetEdgeInstanceDeviceDriverResponse
 */
async function batchGetEdgeInstanceDeviceDriverWithOptions(request: BatchGetEdgeInstanceDeviceDriverRequest, runtime: Util.RuntimeOptions): BatchGetEdgeInstanceDeviceDriverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotIds)) {
    query['IotIds'] = request.iotIds;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetEdgeInstanceDeviceDriver',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchGetEdgeInstanceDeviceDriverRequest
 * @return BatchGetEdgeInstanceDeviceDriverResponse
 */
async function batchGetEdgeInstanceDeviceDriver(request: BatchGetEdgeInstanceDeviceDriverRequest): BatchGetEdgeInstanceDeviceDriverResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetEdgeInstanceDeviceDriverWithOptions(request, runtime);
}

model BatchGetEdgeInstanceDriverConfigsRequest {
  driverIds?: [ string ](name='DriverIds', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchGetEdgeInstanceDriverConfigsResponseBody = {
  code?: string(name='Code'),
  driverConfigList?: [ 
    {
      configList?: [ 
        {
          configId?: string(name='ConfigId'),
          content?: string(name='Content'),
          format?: string(name='Format'),
          key?: string(name='Key'),
        }
      ](name='ConfigList'),
      driverId?: string(name='DriverId'),
    }
  ](name='DriverConfigList'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGetEdgeInstanceDriverConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetEdgeInstanceDriverConfigsResponseBody(name='body'),
}

/**
 * @param request BatchGetEdgeInstanceDriverConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetEdgeInstanceDriverConfigsResponse
 */
async function batchGetEdgeInstanceDriverConfigsWithOptions(request: BatchGetEdgeInstanceDriverConfigsRequest, runtime: Util.RuntimeOptions): BatchGetEdgeInstanceDriverConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverIds)) {
    query['DriverIds'] = request.driverIds;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetEdgeInstanceDriverConfigs',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchGetEdgeInstanceDriverConfigsRequest
 * @return BatchGetEdgeInstanceDriverConfigsResponse
 */
async function batchGetEdgeInstanceDriverConfigs(request: BatchGetEdgeInstanceDriverConfigsRequest): BatchGetEdgeInstanceDriverConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetEdgeInstanceDriverConfigsWithOptions(request, runtime);
}

model BatchGrayMigrationDeviceRequest {
  deviceNames?: [ string ](name='DeviceNames', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BatchGrayMigrationDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    details?: {
      item?: [ 
      {
        code?: int32(name='Code'),
        deviceName?: string(name='DeviceName'),
        message?: string(name='Message'),
        status?: string(name='Status'),
      }
    ](name='item')
    }(name='Details'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchGrayMigrationDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGrayMigrationDeviceResponseBody(name='body'),
}

/**
 * @param request BatchGrayMigrationDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGrayMigrationDeviceResponse
 */
async function batchGrayMigrationDeviceWithOptions(request: BatchGrayMigrationDeviceRequest, runtime: Util.RuntimeOptions): BatchGrayMigrationDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceNames)) {
    body['DeviceNames'] = request.deviceNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGrayMigrationDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchGrayMigrationDeviceRequest
 * @return BatchGrayMigrationDeviceResponse
 */
async function batchGrayMigrationDevice(request: BatchGrayMigrationDeviceRequest): BatchGrayMigrationDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGrayMigrationDeviceWithOptions(request, runtime);
}

model BatchImportDeviceRequest {
  deviceList?: [ 
    {
      deviceName?: string(name='DeviceName', description='This parameter is required.'),
      deviceSecret?: string(name='DeviceSecret', description='This parameter is required.'),
      sn?: string(name='Sn'),
    }
  ](name='DeviceList', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BatchImportDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    applyId?: long(name='ApplyId'),
    invalidDetailList?: {
      invalidDetailList?: [ 
      {
        deviceName?: string(name='DeviceName'),
        deviceSecret?: string(name='DeviceSecret'),
        errorMsg?: string(name='ErrorMsg'),
        sn?: string(name='Sn'),
      }
    ](name='InvalidDetailList')
    }(name='InvalidDetailList'),
    invalidDeviceNameList?: {
      invalidDeviceName?: [ string ](name='invalidDeviceName')
    }(name='InvalidDeviceNameList'),
    invalidDeviceSecretList?: {
      invalidDeviceSecret?: [ string ](name='invalidDeviceSecret')
    }(name='InvalidDeviceSecretList'),
    invalidSnList?: {
      invalidSn?: [ string ](name='invalidSn')
    }(name='InvalidSnList'),
    repeatedDeviceNameList?: {
      repeatedDeviceName?: [ string ](name='repeatedDeviceName')
    }(name='RepeatedDeviceNameList'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchImportDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchImportDeviceResponseBody(name='body'),
}

/**
 * @param request BatchImportDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchImportDeviceResponse
 */
async function batchImportDeviceWithOptions(request: BatchImportDeviceRequest, runtime: Util.RuntimeOptions): BatchImportDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceList)) {
    body['DeviceList'] = request.deviceList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchImportDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchImportDeviceRequest
 * @return BatchImportDeviceResponse
 */
async function batchImportDevice(request: BatchImportDeviceRequest): BatchImportDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchImportDeviceWithOptions(request, runtime);
}

model BatchImportVehicleDeviceRequest {
  deviceList?: [ 
    {
      deviceId?: string(name='DeviceId'),
      deviceModel?: string(name='DeviceModel'),
      deviceName?: string(name='DeviceName'),
      deviceSecret?: string(name='DeviceSecret'),
      manufacturer?: string(name='Manufacturer'),
    }
  ](name='DeviceList', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BatchImportVehicleDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    applyId?: long(name='ApplyId'),
    invalidDetailList?: {
      invalidDetailList?: [ 
      {
        deviceId?: string(name='DeviceId'),
        deviceModel?: string(name='DeviceModel'),
        deviceName?: string(name='DeviceName'),
        errorMsg?: string(name='ErrorMsg'),
        manufacturer?: string(name='Manufacturer'),
      }
    ](name='InvalidDetailList')
    }(name='InvalidDetailList'),
    invalidDeviceIdList?: {
      invalidDeviceIdList?: [ string ](name='invalidDeviceIdList')
    }(name='InvalidDeviceIdList'),
    invalidDeviceModelList?: {
      invalidDeviceModelList?: [ string ](name='invalidDeviceModelList')
    }(name='InvalidDeviceModelList'),
    invalidDeviceNameList?: {
      invalidDeviceNameList?: [ string ](name='InvalidDeviceNameList')
    }(name='InvalidDeviceNameList'),
    invalidManufacturerList?: {
      invalidManufacturerList?: [ string ](name='invalidManufacturerList')
    }(name='InvalidManufacturerList'),
    repeatedDeviceIdList?: {
      repeatedDeviceIdList?: [ string ](name='repeatedDeviceIdList')
    }(name='RepeatedDeviceIdList'),
    repeatedDeviceNameList?: {
      repeatedDeviceNameList?: [ string ](name='RepeatedDeviceNameList')
    }(name='RepeatedDeviceNameList'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchImportVehicleDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchImportVehicleDeviceResponseBody(name='body'),
}

/**
 * @param request BatchImportVehicleDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchImportVehicleDeviceResponse
 */
async function batchImportVehicleDeviceWithOptions(request: BatchImportVehicleDeviceRequest, runtime: Util.RuntimeOptions): BatchImportVehicleDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceList)) {
    body['DeviceList'] = request.deviceList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchImportVehicleDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchImportVehicleDeviceRequest
 * @return BatchImportVehicleDeviceResponse
 */
async function batchImportVehicleDevice(request: BatchImportVehicleDeviceRequest): BatchImportVehicleDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchImportVehicleDeviceWithOptions(request, runtime);
}

model BatchPubRequest {
  contentType?: string(name='ContentType'),
  correlationData?: string(name='CorrelationData'),
  deviceName?: [ string ](name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  messageContent?: string(name='MessageContent', description='This parameter is required.'),
  messageExpiryInterval?: long(name='MessageExpiryInterval'),
  payloadFormatIndicator?: int32(name='PayloadFormatIndicator'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  qos?: int32(name='Qos'),
  responseTopicTemplateName?: string(name='ResponseTopicTemplateName'),
  retained?: boolean(name='Retained'),
  topicShortName?: string(name='TopicShortName'),
  topicTemplateName?: string(name='TopicTemplateName'),
  userProp?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='UserProp'),
}

model BatchPubResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchPubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchPubResponseBody(name='body'),
}

/**
 * @param request BatchPubRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchPubResponse
 */
async function batchPubWithOptions(request: BatchPubRequest, runtime: Util.RuntimeOptions): BatchPubResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contentType)) {
    query['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.correlationData)) {
    query['CorrelationData'] = request.correlationData;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.messageExpiryInterval)) {
    query['MessageExpiryInterval'] = request.messageExpiryInterval;
  }
  if (!Util.isUnset(request.payloadFormatIndicator)) {
    query['PayloadFormatIndicator'] = request.payloadFormatIndicator;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.qos)) {
    query['Qos'] = request.qos;
  }
  if (!Util.isUnset(request.responseTopicTemplateName)) {
    query['ResponseTopicTemplateName'] = request.responseTopicTemplateName;
  }
  if (!Util.isUnset(request.retained)) {
    query['Retained'] = request.retained;
  }
  if (!Util.isUnset(request.topicShortName)) {
    query['TopicShortName'] = request.topicShortName;
  }
  if (!Util.isUnset(request.topicTemplateName)) {
    query['TopicTemplateName'] = request.topicTemplateName;
  }
  if (!Util.isUnset(request.userProp)) {
    query['UserProp'] = request.userProp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.messageContent)) {
    body['MessageContent'] = request.messageContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchPub',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchPubRequest
 * @return BatchPubResponse
 */
async function batchPub(request: BatchPubRequest): BatchPubResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchPubWithOptions(request, runtime);
}

model BatchQueryDeviceDetailRequest {
  deviceName?: [ string ](name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BatchQueryDeviceDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    data?: [ 
    {
      deviceName?: string(name='DeviceName'),
      deviceSecret?: string(name='DeviceSecret'),
      firmwareVersion?: string(name='FirmwareVersion'),
      gmtActive?: string(name='GmtActive'),
      gmtCreate?: string(name='GmtCreate'),
      iotId?: string(name='IotId'),
      nickname?: string(name='Nickname'),
      nodeType?: int32(name='NodeType'),
      productKey?: string(name='ProductKey'),
      productName?: string(name='ProductName'),
      region?: string(name='Region'),
      status?: string(name='Status'),
      utcActive?: string(name='UtcActive'),
      utcCreate?: string(name='UtcCreate'),
    }
  ](name='Data')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchQueryDeviceDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchQueryDeviceDetailResponseBody(name='body'),
}

/**
 * @param request BatchQueryDeviceDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchQueryDeviceDetailResponse
 */
async function batchQueryDeviceDetailWithOptions(request: BatchQueryDeviceDetailRequest, runtime: Util.RuntimeOptions): BatchQueryDeviceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchQueryDeviceDetail',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchQueryDeviceDetailRequest
 * @return BatchQueryDeviceDetailResponse
 */
async function batchQueryDeviceDetail(request: BatchQueryDeviceDetailRequest): BatchQueryDeviceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchQueryDeviceDetailWithOptions(request, runtime);
}

model BatchRegisterDeviceRequest {
  count?: int32(name='Count', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BatchRegisterDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    applyId?: long(name='ApplyId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchRegisterDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchRegisterDeviceResponseBody(name='body'),
}

/**
 * @param request BatchRegisterDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchRegisterDeviceResponse
 */
async function batchRegisterDeviceWithOptions(request: BatchRegisterDeviceRequest, runtime: Util.RuntimeOptions): BatchRegisterDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.count)) {
    query['Count'] = request.count;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchRegisterDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchRegisterDeviceRequest
 * @return BatchRegisterDeviceResponse
 */
async function batchRegisterDevice(request: BatchRegisterDeviceRequest): BatchRegisterDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchRegisterDeviceWithOptions(request, runtime);
}

model BatchRegisterDeviceWithApplyIdRequest {
  applyId?: long(name='ApplyId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BatchRegisterDeviceWithApplyIdResponseBody = {
  code?: string(name='Code'),
  data?: {
    applyId?: long(name='ApplyId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchRegisterDeviceWithApplyIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchRegisterDeviceWithApplyIdResponseBody(name='body'),
}

/**
 * @param request BatchRegisterDeviceWithApplyIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchRegisterDeviceWithApplyIdResponse
 */
async function batchRegisterDeviceWithApplyIdWithOptions(request: BatchRegisterDeviceWithApplyIdRequest, runtime: Util.RuntimeOptions): BatchRegisterDeviceWithApplyIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyId)) {
    query['ApplyId'] = request.applyId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchRegisterDeviceWithApplyId',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchRegisterDeviceWithApplyIdRequest
 * @return BatchRegisterDeviceWithApplyIdResponse
 */
async function batchRegisterDeviceWithApplyId(request: BatchRegisterDeviceWithApplyIdRequest): BatchRegisterDeviceWithApplyIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchRegisterDeviceWithApplyIdWithOptions(request, runtime);
}

model BatchSetEdgeInstanceDeviceChannelRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotIds?: [ string ](name='IotIds', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchSetEdgeInstanceDeviceChannelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchSetEdgeInstanceDeviceChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchSetEdgeInstanceDeviceChannelResponseBody(name='body'),
}

/**
 * @param request BatchSetEdgeInstanceDeviceChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSetEdgeInstanceDeviceChannelResponse
 */
async function batchSetEdgeInstanceDeviceChannelWithOptions(request: BatchSetEdgeInstanceDeviceChannelRequest, runtime: Util.RuntimeOptions): BatchSetEdgeInstanceDeviceChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotIds)) {
    query['IotIds'] = request.iotIds;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchSetEdgeInstanceDeviceChannel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchSetEdgeInstanceDeviceChannelRequest
 * @return BatchSetEdgeInstanceDeviceChannelResponse
 */
async function batchSetEdgeInstanceDeviceChannel(request: BatchSetEdgeInstanceDeviceChannelRequest): BatchSetEdgeInstanceDeviceChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSetEdgeInstanceDeviceChannelWithOptions(request, runtime);
}

model BatchSetEdgeInstanceDeviceConfigRequest {
  deviceConfigs?: [ 
    {
      content?: string(name='Content', description='This parameter is required.'),
      iotId?: string(name='IotId', description='This parameter is required.'),
    }
  ](name='DeviceConfigs', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchSetEdgeInstanceDeviceConfigResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchSetEdgeInstanceDeviceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchSetEdgeInstanceDeviceConfigResponseBody(name='body'),
}

/**
 * @param request BatchSetEdgeInstanceDeviceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSetEdgeInstanceDeviceConfigResponse
 */
async function batchSetEdgeInstanceDeviceConfigWithOptions(request: BatchSetEdgeInstanceDeviceConfigRequest, runtime: Util.RuntimeOptions): BatchSetEdgeInstanceDeviceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceConfigs)) {
    query['DeviceConfigs'] = request.deviceConfigs;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchSetEdgeInstanceDeviceConfig',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchSetEdgeInstanceDeviceConfigRequest
 * @return BatchSetEdgeInstanceDeviceConfigResponse
 */
async function batchSetEdgeInstanceDeviceConfig(request: BatchSetEdgeInstanceDeviceConfigRequest): BatchSetEdgeInstanceDeviceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSetEdgeInstanceDeviceConfigWithOptions(request, runtime);
}

model BatchUnbindDeviceFromEdgeInstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotIds?: [ string ](name='IotIds', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchUnbindDeviceFromEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchUnbindDeviceFromEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUnbindDeviceFromEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request BatchUnbindDeviceFromEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUnbindDeviceFromEdgeInstanceResponse
 */
async function batchUnbindDeviceFromEdgeInstanceWithOptions(request: BatchUnbindDeviceFromEdgeInstanceRequest, runtime: Util.RuntimeOptions): BatchUnbindDeviceFromEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotIds)) {
    query['IotIds'] = request.iotIds;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchUnbindDeviceFromEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchUnbindDeviceFromEdgeInstanceRequest
 * @return BatchUnbindDeviceFromEdgeInstanceResponse
 */
async function batchUnbindDeviceFromEdgeInstance(request: BatchUnbindDeviceFromEdgeInstanceRequest): BatchUnbindDeviceFromEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchUnbindDeviceFromEdgeInstanceWithOptions(request, runtime);
}

model BatchUnbindProjectDevicesRequest {
  devices?: [ 
    {
      deviceName?: string(name='DeviceName', description='This parameter is required.'),
      productKey?: string(name='ProductKey', description='This parameter is required.'),
    }
  ](name='Devices', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model BatchUnbindProjectDevicesResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchUnbindProjectDevicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUnbindProjectDevicesResponseBody(name='body'),
}

/**
 * @param request BatchUnbindProjectDevicesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUnbindProjectDevicesResponse
 */
async function batchUnbindProjectDevicesWithOptions(request: BatchUnbindProjectDevicesRequest, runtime: Util.RuntimeOptions): BatchUnbindProjectDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.devices)) {
    body['Devices'] = request.devices;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUnbindProjectDevices',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchUnbindProjectDevicesRequest
 * @return BatchUnbindProjectDevicesResponse
 */
async function batchUnbindProjectDevices(request: BatchUnbindProjectDevicesRequest): BatchUnbindProjectDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchUnbindProjectDevicesWithOptions(request, runtime);
}

model BatchUnbindProjectProductsRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKeys?: [ string ](name='ProductKeys', description='This parameter is required.'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model BatchUnbindProjectProductsResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchUnbindProjectProductsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUnbindProjectProductsResponseBody(name='body'),
}

/**
 * @param request BatchUnbindProjectProductsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUnbindProjectProductsResponse
 */
async function batchUnbindProjectProductsWithOptions(request: BatchUnbindProjectProductsRequest, runtime: Util.RuntimeOptions): BatchUnbindProjectProductsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKeys)) {
    body['ProductKeys'] = request.productKeys;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchUnbindProjectProducts',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchUnbindProjectProductsRequest
 * @return BatchUnbindProjectProductsResponse
 */
async function batchUnbindProjectProducts(request: BatchUnbindProjectProductsRequest): BatchUnbindProjectProductsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchUnbindProjectProductsWithOptions(request, runtime);
}

model BatchUpdateDeviceNicknameRequest {
  deviceNicknameInfo?: [ 
    {
      deviceName?: string(name='DeviceName'),
      iotId?: string(name='IotId'),
      nickname?: string(name='Nickname'),
      productKey?: string(name='ProductKey'),
    }
  ](name='DeviceNicknameInfo', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BatchUpdateDeviceNicknameResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchUpdateDeviceNicknameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchUpdateDeviceNicknameResponseBody(name='body'),
}

/**
 * @param request BatchUpdateDeviceNicknameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdateDeviceNicknameResponse
 */
async function batchUpdateDeviceNicknameWithOptions(request: BatchUpdateDeviceNicknameRequest, runtime: Util.RuntimeOptions): BatchUpdateDeviceNicknameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceNicknameInfo)) {
    query['DeviceNicknameInfo'] = request.deviceNicknameInfo;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdateDeviceNickname',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BatchUpdateDeviceNicknameRequest
 * @return BatchUpdateDeviceNicknameResponse
 */
async function batchUpdateDeviceNickname(request: BatchUpdateDeviceNicknameRequest): BatchUpdateDeviceNicknameResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchUpdateDeviceNicknameWithOptions(request, runtime);
}

model BindApplicationToEdgeInstanceRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.'),
  applicationVersion?: string(name='ApplicationVersion', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model BindApplicationToEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindApplicationToEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindApplicationToEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request BindApplicationToEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindApplicationToEdgeInstanceResponse
 */
async function bindApplicationToEdgeInstanceWithOptions(request: BindApplicationToEdgeInstanceRequest, runtime: Util.RuntimeOptions): BindApplicationToEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.applicationVersion)) {
    query['ApplicationVersion'] = request.applicationVersion;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindApplicationToEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindApplicationToEdgeInstanceRequest
 * @return BindApplicationToEdgeInstanceResponse
 */
async function bindApplicationToEdgeInstance(request: BindApplicationToEdgeInstanceRequest): BindApplicationToEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindApplicationToEdgeInstanceWithOptions(request, runtime);
}

model BindDriverToEdgeInstanceRequest {
  driverId?: string(name='DriverId', description='This parameter is required.'),
  driverVersion?: string(name='DriverVersion'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  orderId?: string(name='OrderId'),
}

model BindDriverToEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindDriverToEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindDriverToEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request BindDriverToEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindDriverToEdgeInstanceResponse
 */
async function bindDriverToEdgeInstanceWithOptions(request: BindDriverToEdgeInstanceRequest, runtime: Util.RuntimeOptions): BindDriverToEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.driverVersion)) {
    query['DriverVersion'] = request.driverVersion;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindDriverToEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindDriverToEdgeInstanceRequest
 * @return BindDriverToEdgeInstanceResponse
 */
async function bindDriverToEdgeInstance(request: BindDriverToEdgeInstanceRequest): BindDriverToEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindDriverToEdgeInstanceWithOptions(request, runtime);
}

model BindGatewayToEdgeInstanceRequest {
  deviceName?: string(name='DeviceName'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model BindGatewayToEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindGatewayToEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindGatewayToEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request BindGatewayToEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindGatewayToEdgeInstanceResponse
 */
async function bindGatewayToEdgeInstanceWithOptions(request: BindGatewayToEdgeInstanceRequest, runtime: Util.RuntimeOptions): BindGatewayToEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindGatewayToEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindGatewayToEdgeInstanceRequest
 * @return BindGatewayToEdgeInstanceResponse
 */
async function bindGatewayToEdgeInstance(request: BindGatewayToEdgeInstanceRequest): BindGatewayToEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindGatewayToEdgeInstanceWithOptions(request, runtime);
}

model BindLicenseDeviceRequest {
  deviceNameList?: [ string ](name='DeviceNameList'),
  iotIdList?: [ string ](name='IotIdList'),
  iotInstanceId?: string(name='IotInstanceId'),
  licenseCode?: string(name='LicenseCode', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BindLicenseDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    checkProgressId?: string(name='CheckProgressId'),
    failSum?: long(name='FailSum'),
    progress?: int32(name='Progress'),
    resultCsvFile?: string(name='ResultCsvFile'),
    successSum?: long(name='SuccessSum'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindLicenseDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindLicenseDeviceResponseBody(name='body'),
}

/**
 * @param request BindLicenseDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindLicenseDeviceResponse
 */
async function bindLicenseDeviceWithOptions(request: BindLicenseDeviceRequest, runtime: Util.RuntimeOptions): BindLicenseDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.licenseCode)) {
    query['LicenseCode'] = request.licenseCode;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceNameList)) {
    body['DeviceNameList'] = request.deviceNameList;
  }
  if (!Util.isUnset(request.iotIdList)) {
    body['IotIdList'] = request.iotIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindLicenseDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindLicenseDeviceRequest
 * @return BindLicenseDeviceResponse
 */
async function bindLicenseDevice(request: BindLicenseDeviceRequest): BindLicenseDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindLicenseDeviceWithOptions(request, runtime);
}

model BindLicenseProductRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  licenseCode?: string(name='LicenseCode', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model BindLicenseProductResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindLicenseProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindLicenseProductResponseBody(name='body'),
}

/**
 * @param request BindLicenseProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindLicenseProductResponse
 */
async function bindLicenseProductWithOptions(request: BindLicenseProductRequest, runtime: Util.RuntimeOptions): BindLicenseProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.licenseCode)) {
    query['LicenseCode'] = request.licenseCode;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindLicenseProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindLicenseProductRequest
 * @return BindLicenseProductResponse
 */
async function bindLicenseProduct(request: BindLicenseProductRequest): BindLicenseProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindLicenseProductWithOptions(request, runtime);
}

model BindRoleToEdgeInstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  roleArn?: string(name='RoleArn', description='This parameter is required.'),
  roleName?: string(name='RoleName', description='This parameter is required.'),
}

model BindRoleToEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindRoleToEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindRoleToEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request BindRoleToEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindRoleToEdgeInstanceResponse
 */
async function bindRoleToEdgeInstanceWithOptions(request: BindRoleToEdgeInstanceRequest, runtime: Util.RuntimeOptions): BindRoleToEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.roleArn)) {
    query['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindRoleToEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindRoleToEdgeInstanceRequest
 * @return BindRoleToEdgeInstanceResponse
 */
async function bindRoleToEdgeInstance(request: BindRoleToEdgeInstanceRequest): BindRoleToEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindRoleToEdgeInstanceWithOptions(request, runtime);
}

model BindSceneRuleToEdgeInstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
}

model BindSceneRuleToEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindSceneRuleToEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindSceneRuleToEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request BindSceneRuleToEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindSceneRuleToEdgeInstanceResponse
 */
async function bindSceneRuleToEdgeInstanceWithOptions(request: BindSceneRuleToEdgeInstanceRequest, runtime: Util.RuntimeOptions): BindSceneRuleToEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindSceneRuleToEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request BindSceneRuleToEdgeInstanceRequest
 * @return BindSceneRuleToEdgeInstanceResponse
 */
async function bindSceneRuleToEdgeInstance(request: BindSceneRuleToEdgeInstanceRequest): BindSceneRuleToEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindSceneRuleToEdgeInstanceWithOptions(request, runtime);
}

model CancelJobRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model CancelJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelJobResponseBody(name='body'),
}

/**
 * @param request CancelJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelJobResponse
 */
async function cancelJobWithOptions(request: CancelJobRequest, runtime: Util.RuntimeOptions): CancelJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CancelJobRequest
 * @return CancelJobResponse
 */
async function cancelJob(request: CancelJobRequest): CancelJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelJobWithOptions(request, runtime);
}

model CancelOTAStrategyByJobRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model CancelOTAStrategyByJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelOTAStrategyByJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelOTAStrategyByJobResponseBody(name='body'),
}

/**
 * @param request CancelOTAStrategyByJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelOTAStrategyByJobResponse
 */
async function cancelOTAStrategyByJobWithOptions(request: CancelOTAStrategyByJobRequest, runtime: Util.RuntimeOptions): CancelOTAStrategyByJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelOTAStrategyByJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CancelOTAStrategyByJobRequest
 * @return CancelOTAStrategyByJobResponse
 */
async function cancelOTAStrategyByJob(request: CancelOTAStrategyByJobRequest): CancelOTAStrategyByJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOTAStrategyByJobWithOptions(request, runtime);
}

model CancelOTATaskByDeviceRequest {
  deviceName?: [ string ](name='DeviceName', description='This parameter is required.'),
  firmwareId?: string(name='FirmwareId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model CancelOTATaskByDeviceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelOTATaskByDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelOTATaskByDeviceResponseBody(name='body'),
}

/**
 * @param request CancelOTATaskByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelOTATaskByDeviceResponse
 */
async function cancelOTATaskByDeviceWithOptions(request: CancelOTATaskByDeviceRequest, runtime: Util.RuntimeOptions): CancelOTATaskByDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.firmwareId)) {
    query['FirmwareId'] = request.firmwareId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelOTATaskByDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CancelOTATaskByDeviceRequest
 * @return CancelOTATaskByDeviceResponse
 */
async function cancelOTATaskByDevice(request: CancelOTATaskByDeviceRequest): CancelOTATaskByDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOTATaskByDeviceWithOptions(request, runtime);
}

model CancelOTATaskByJobRequest {
  cancelInProgressTask?: boolean(name='CancelInProgressTask'),
  cancelNotifiedTask?: boolean(name='CancelNotifiedTask'),
  cancelQueuedTask?: boolean(name='CancelQueuedTask'),
  cancelScheduledTask?: boolean(name='CancelScheduledTask'),
  cancelUnconfirmedTask?: boolean(name='CancelUnconfirmedTask'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model CancelOTATaskByJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelOTATaskByJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelOTATaskByJobResponseBody(name='body'),
}

/**
 * @param request CancelOTATaskByJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelOTATaskByJobResponse
 */
async function cancelOTATaskByJobWithOptions(request: CancelOTATaskByJobRequest, runtime: Util.RuntimeOptions): CancelOTATaskByJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cancelInProgressTask)) {
    query['CancelInProgressTask'] = request.cancelInProgressTask;
  }
  if (!Util.isUnset(request.cancelNotifiedTask)) {
    query['CancelNotifiedTask'] = request.cancelNotifiedTask;
  }
  if (!Util.isUnset(request.cancelQueuedTask)) {
    query['CancelQueuedTask'] = request.cancelQueuedTask;
  }
  if (!Util.isUnset(request.cancelScheduledTask)) {
    query['CancelScheduledTask'] = request.cancelScheduledTask;
  }
  if (!Util.isUnset(request.cancelUnconfirmedTask)) {
    query['CancelUnconfirmedTask'] = request.cancelUnconfirmedTask;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelOTATaskByJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CancelOTATaskByJobRequest
 * @return CancelOTATaskByJobResponse
 */
async function cancelOTATaskByJob(request: CancelOTATaskByJobRequest): CancelOTATaskByJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOTATaskByJobWithOptions(request, runtime);
}

model CancelReleaseProductRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model CancelReleaseProductResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelReleaseProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelReleaseProductResponseBody(name='body'),
}

/**
 * @param request CancelReleaseProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelReleaseProductResponse
 */
async function cancelReleaseProductWithOptions(request: CancelReleaseProductRequest, runtime: Util.RuntimeOptions): CancelReleaseProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelReleaseProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CancelReleaseProductRequest
 * @return CancelReleaseProductResponse
 */
async function cancelReleaseProduct(request: CancelReleaseProductRequest): CancelReleaseProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelReleaseProductWithOptions(request, runtime);
}

model CheckBindLicenseDeviceProgressRequest {
  checkProgressId?: string(name='CheckProgressId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  licenseCode?: string(name='LicenseCode', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model CheckBindLicenseDeviceProgressResponseBody = {
  code?: string(name='Code'),
  data?: {
    failSum?: long(name='FailSum'),
    progress?: int32(name='Progress'),
    resultCsvFile?: string(name='ResultCsvFile'),
    successSum?: long(name='SuccessSum'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckBindLicenseDeviceProgressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckBindLicenseDeviceProgressResponseBody(name='body'),
}

/**
 * @param request CheckBindLicenseDeviceProgressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckBindLicenseDeviceProgressResponse
 */
async function checkBindLicenseDeviceProgressWithOptions(request: CheckBindLicenseDeviceProgressRequest, runtime: Util.RuntimeOptions): CheckBindLicenseDeviceProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkProgressId)) {
    query['CheckProgressId'] = request.checkProgressId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.licenseCode)) {
    query['LicenseCode'] = request.licenseCode;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckBindLicenseDeviceProgress',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CheckBindLicenseDeviceProgressRequest
 * @return CheckBindLicenseDeviceProgressResponse
 */
async function checkBindLicenseDeviceProgress(request: CheckBindLicenseDeviceProgressRequest): CheckBindLicenseDeviceProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkBindLicenseDeviceProgressWithOptions(request, runtime);
}

model ClearDeviceDesiredPropertyRequest {
  deviceName?: string(name='DeviceName'),
  identifies?: [ string ](name='Identifies'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model ClearDeviceDesiredPropertyResponseBody = {
  code?: string(name='Code'),
  data?: {
    versions?: string(name='Versions'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ClearDeviceDesiredPropertyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ClearDeviceDesiredPropertyResponseBody(name='body'),
}

/**
 * @param request ClearDeviceDesiredPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ClearDeviceDesiredPropertyResponse
 */
async function clearDeviceDesiredPropertyWithOptions(request: ClearDeviceDesiredPropertyRequest, runtime: Util.RuntimeOptions): ClearDeviceDesiredPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.identifies)) {
    body['Identifies'] = request.identifies;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ClearDeviceDesiredProperty',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ClearDeviceDesiredPropertyRequest
 * @return ClearDeviceDesiredPropertyResponse
 */
async function clearDeviceDesiredProperty(request: ClearDeviceDesiredPropertyRequest): ClearDeviceDesiredPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return clearDeviceDesiredPropertyWithOptions(request, runtime);
}

model ClearEdgeInstanceDriverConfigsRequest {
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model ClearEdgeInstanceDriverConfigsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ClearEdgeInstanceDriverConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ClearEdgeInstanceDriverConfigsResponseBody(name='body'),
}

/**
 * @param request ClearEdgeInstanceDriverConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ClearEdgeInstanceDriverConfigsResponse
 */
async function clearEdgeInstanceDriverConfigsWithOptions(request: ClearEdgeInstanceDriverConfigsRequest, runtime: Util.RuntimeOptions): ClearEdgeInstanceDriverConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ClearEdgeInstanceDriverConfigs',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ClearEdgeInstanceDriverConfigsRequest
 * @return ClearEdgeInstanceDriverConfigsResponse
 */
async function clearEdgeInstanceDriverConfigs(request: ClearEdgeInstanceDriverConfigsRequest): ClearEdgeInstanceDriverConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return clearEdgeInstanceDriverConfigsWithOptions(request, runtime);
}

model CloseDeviceTunnelRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  tunnelId?: string(name='TunnelId', description='This parameter is required.'),
}

model CloseDeviceTunnelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloseDeviceTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseDeviceTunnelResponseBody(name='body'),
}

/**
 * @param request CloseDeviceTunnelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseDeviceTunnelResponse
 */
async function closeDeviceTunnelWithOptions(request: CloseDeviceTunnelRequest, runtime: Util.RuntimeOptions): CloseDeviceTunnelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.tunnelId)) {
    query['TunnelId'] = request.tunnelId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseDeviceTunnel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CloseDeviceTunnelRequest
 * @return CloseDeviceTunnelResponse
 */
async function closeDeviceTunnel(request: CloseDeviceTunnelRequest): CloseDeviceTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeDeviceTunnelWithOptions(request, runtime);
}

model CloseEdgeInstanceDeploymentRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model CloseEdgeInstanceDeploymentResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloseEdgeInstanceDeploymentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseEdgeInstanceDeploymentResponseBody(name='body'),
}

/**
 * @param request CloseEdgeInstanceDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseEdgeInstanceDeploymentResponse
 */
async function closeEdgeInstanceDeploymentWithOptions(request: CloseEdgeInstanceDeploymentRequest, runtime: Util.RuntimeOptions): CloseEdgeInstanceDeploymentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseEdgeInstanceDeployment',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CloseEdgeInstanceDeploymentRequest
 * @return CloseEdgeInstanceDeploymentResponse
 */
async function closeEdgeInstanceDeployment(request: CloseEdgeInstanceDeploymentRequest): CloseEdgeInstanceDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeEdgeInstanceDeploymentWithOptions(request, runtime);
}

model ConfirmOTATaskRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  taskId?: [ string ](name='TaskId', description='This parameter is required.'),
}

model ConfirmOTATaskResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmOTATaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfirmOTATaskResponseBody(name='body'),
}

/**
 * @param request ConfirmOTATaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfirmOTATaskResponse
 */
async function confirmOTATaskWithOptions(request: ConfirmOTATaskRequest, runtime: Util.RuntimeOptions): ConfirmOTATaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmOTATask',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ConfirmOTATaskRequest
 * @return ConfirmOTATaskResponse
 */
async function confirmOTATask(request: ConfirmOTATaskRequest): ConfirmOTATaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmOTATaskWithOptions(request, runtime);
}

model CopyThingModelRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sourceModelVersion?: string(name='SourceModelVersion'),
  sourceProductKey?: string(name='SourceProductKey', description='This parameter is required.'),
  targetProductKey?: string(name='TargetProductKey', description='This parameter is required.'),
}

model CopyThingModelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CopyThingModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyThingModelResponseBody(name='body'),
}

/**
 * @param request CopyThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyThingModelResponse
 */
async function copyThingModelWithOptions(request: CopyThingModelRequest, runtime: Util.RuntimeOptions): CopyThingModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sourceModelVersion)) {
    query['SourceModelVersion'] = request.sourceModelVersion;
  }
  if (!Util.isUnset(request.sourceProductKey)) {
    query['SourceProductKey'] = request.sourceProductKey;
  }
  if (!Util.isUnset(request.targetProductKey)) {
    query['TargetProductKey'] = request.targetProductKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyThingModel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CopyThingModelRequest
 * @return CopyThingModelResponse
 */
async function copyThingModel(request: CopyThingModelRequest): CopyThingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyThingModelWithOptions(request, runtime);
}

model CopyThingModelAsyncRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  sourceModelVersion?: string(name='SourceModelVersion'),
  sourceProductKey?: string(name='SourceProductKey', description='This parameter is required.'),
  targetProductKey?: string(name='TargetProductKey', description='This parameter is required.'),
}

model CopyThingModelAsyncResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CopyThingModelAsyncResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyThingModelAsyncResponseBody(name='body'),
}

/**
 * @param request CopyThingModelAsyncRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyThingModelAsyncResponse
 */
async function copyThingModelAsyncWithOptions(request: CopyThingModelAsyncRequest, runtime: Util.RuntimeOptions): CopyThingModelAsyncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.sourceModelVersion)) {
    query['SourceModelVersion'] = request.sourceModelVersion;
  }
  if (!Util.isUnset(request.sourceProductKey)) {
    query['SourceProductKey'] = request.sourceProductKey;
  }
  if (!Util.isUnset(request.targetProductKey)) {
    query['TargetProductKey'] = request.targetProductKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyThingModelAsync',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CopyThingModelAsyncRequest
 * @return CopyThingModelAsyncResponse
 */
async function copyThingModelAsync(request: CopyThingModelAsyncRequest): CopyThingModelAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyThingModelAsyncWithOptions(request, runtime);
}

model CountSpeechBroadcastHourRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  queryDateTimeHour?: string(name='QueryDateTimeHour', description='This parameter is required.'),
  shareTaskCode?: string(name='ShareTaskCode', description='This parameter is required.'),
}

model CountSpeechBroadcastHourResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CountSpeechBroadcastHourResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CountSpeechBroadcastHourResponseBody(name='body'),
}

/**
 * @param request CountSpeechBroadcastHourRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CountSpeechBroadcastHourResponse
 */
async function countSpeechBroadcastHourWithOptions(request: CountSpeechBroadcastHourRequest, runtime: Util.RuntimeOptions): CountSpeechBroadcastHourResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.queryDateTimeHour)) {
    query['QueryDateTimeHour'] = request.queryDateTimeHour;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.shareTaskCode)) {
    body['ShareTaskCode'] = request.shareTaskCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CountSpeechBroadcastHour',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CountSpeechBroadcastHourRequest
 * @return CountSpeechBroadcastHourResponse
 */
async function countSpeechBroadcastHour(request: CountSpeechBroadcastHourRequest): CountSpeechBroadcastHourResponse {
  var runtime = new Util.RuntimeOptions{};
  return countSpeechBroadcastHourWithOptions(request, runtime);
}

model CreateConsumerGroupRequest {
  groupName?: string(name='GroupName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model CreateConsumerGroupResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  groupId?: string(name='GroupId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConsumerGroupResponseBody(name='body'),
}

/**
 * @param request CreateConsumerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsumerGroupResponse
 */
async function createConsumerGroupWithOptions(request: CreateConsumerGroupRequest, runtime: Util.RuntimeOptions): CreateConsumerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsumerGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateConsumerGroupRequest
 * @return CreateConsumerGroupResponse
 */
async function createConsumerGroup(request: CreateConsumerGroupRequest): CreateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConsumerGroupWithOptions(request, runtime);
}

model CreateConsumerGroupSubscribeRelationRequest {
  consumerGroupId?: string(name='ConsumerGroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model CreateConsumerGroupSubscribeRelationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateConsumerGroupSubscribeRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateConsumerGroupSubscribeRelationResponseBody(name='body'),
}

/**
 * @param request CreateConsumerGroupSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsumerGroupSubscribeRelationResponse
 */
async function createConsumerGroupSubscribeRelationWithOptions(request: CreateConsumerGroupSubscribeRelationRequest, runtime: Util.RuntimeOptions): CreateConsumerGroupSubscribeRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consumerGroupId)) {
    query['ConsumerGroupId'] = request.consumerGroupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateConsumerGroupSubscribeRelation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateConsumerGroupSubscribeRelationRequest
 * @return CreateConsumerGroupSubscribeRelationResponse
 */
async function createConsumerGroupSubscribeRelation(request: CreateConsumerGroupSubscribeRelationRequest): CreateConsumerGroupSubscribeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConsumerGroupSubscribeRelationWithOptions(request, runtime);
}

model CreateDataAPIServiceRequest {
  apiPath?: string(name='ApiPath', description='This parameter is required.'),
  desc?: string(name='Desc'),
  displayName?: string(name='DisplayName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  originSql?: string(name='OriginSql', description='This parameter is required.'),
  requestParam?: [ 
    {
      desc?: string(name='Desc'),
      example?: string(name='Example'),
      name?: string(name='Name'),
      required?: boolean(name='Required'),
      type?: string(name='Type'),
    }
  ](name='RequestParam'),
  responseParam?: [ 
    {
      desc?: string(name='Desc'),
      example?: string(name='Example'),
      name?: string(name='Name'),
      required?: boolean(name='Required'),
      type?: string(name='Type'),
    }
  ](name='ResponseParam'),
  templateSql?: string(name='TemplateSql', description='This parameter is required.'),
}

model CreateDataAPIServiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    apiSrn?: string(name='ApiSrn'),
    createTime?: long(name='CreateTime'),
    lastUpdateTime?: long(name='LastUpdateTime'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataAPIServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataAPIServiceResponseBody(name='body'),
}

/**
 * @param request CreateDataAPIServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataAPIServiceResponse
 */
async function createDataAPIServiceWithOptions(request: CreateDataAPIServiceRequest, runtime: Util.RuntimeOptions): CreateDataAPIServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiPath)) {
    body['ApiPath'] = request.apiPath;
  }
  if (!Util.isUnset(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.displayName)) {
    body['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.originSql)) {
    body['OriginSql'] = request.originSql;
  }
  if (!Util.isUnset(request.requestParam)) {
    body['RequestParam'] = request.requestParam;
  }
  if (!Util.isUnset(request.responseParam)) {
    body['ResponseParam'] = request.responseParam;
  }
  if (!Util.isUnset(request.templateSql)) {
    body['TemplateSql'] = request.templateSql;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataAPIService',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDataAPIServiceRequest
 * @return CreateDataAPIServiceResponse
 */
async function createDataAPIService(request: CreateDataAPIServiceRequest): CreateDataAPIServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataAPIServiceWithOptions(request, runtime);
}

model CreateDataSourceItemRequest {
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  scopeType?: string(name='ScopeType'),
  topic?: string(name='Topic', description='This parameter is required.'),
}

model CreateDataSourceItemResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataSourceItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataSourceItemResponseBody(name='body'),
}

/**
 * @param request CreateDataSourceItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataSourceItemResponse
 */
async function createDataSourceItemWithOptions(request: CreateDataSourceItemRequest, runtime: Util.RuntimeOptions): CreateDataSourceItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.scopeType)) {
    query['ScopeType'] = request.scopeType;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataSourceItem',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDataSourceItemRequest
 * @return CreateDataSourceItemResponse
 */
async function createDataSourceItem(request: CreateDataSourceItemRequest): CreateDataSourceItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataSourceItemWithOptions(request, runtime);
}

model CreateDestinationRequest {
  configuration?: string(name='Configuration', description='This parameter is required.'),
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name', description='This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateDestinationResponseBody = {
  code?: string(name='Code'),
  destination?: {
    configuration?: string(name='Configuration'),
    destinationId?: long(name='DestinationId'),
    isFailover?: boolean(name='IsFailover'),
    name?: string(name='Name'),
    type?: string(name='Type'),
    utcCreated?: string(name='UtcCreated'),
  }(name='Destination'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDestinationResponseBody(name='body'),
}

/**
 * @param request CreateDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDestinationResponse
 */
async function createDestinationWithOptions(request: CreateDestinationRequest, runtime: Util.RuntimeOptions): CreateDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configuration)) {
    query['Configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDestination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDestinationRequest
 * @return CreateDestinationResponse
 */
async function createDestination(request: CreateDestinationRequest): CreateDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDestinationWithOptions(request, runtime);
}

model CreateDeviceDistributeJobRequest {
  deviceName?: [ string ](name='DeviceName', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  sourceInstanceId?: string(name='SourceInstanceId', description='This parameter is required.'),
  strategy?: int32(name='Strategy', description='This parameter is required.'),
  targetAliyunId?: string(name='TargetAliyunId'),
  targetInstanceConfig?: [ 
    {
      targetInstanceId?: string(name='TargetInstanceId', description='This parameter is required.'),
    }
  ](name='TargetInstanceConfig', description='This parameter is required.'),
  targetUid?: string(name='TargetUid'),
}

model CreateDeviceDistributeJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDeviceDistributeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDeviceDistributeJobResponseBody(name='body'),
}

/**
 * @param request CreateDeviceDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDeviceDistributeJobResponse
 */
async function createDeviceDistributeJobWithOptions(request: CreateDeviceDistributeJobRequest, runtime: Util.RuntimeOptions): CreateDeviceDistributeJobResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.sourceInstanceId)) {
    body['SourceInstanceId'] = request.sourceInstanceId;
  }
  if (!Util.isUnset(request.strategy)) {
    body['Strategy'] = request.strategy;
  }
  if (!Util.isUnset(request.targetAliyunId)) {
    body['TargetAliyunId'] = request.targetAliyunId;
  }
  if (!Util.isUnset(request.targetInstanceConfig)) {
    body['TargetInstanceConfig'] = request.targetInstanceConfig;
  }
  if (!Util.isUnset(request.targetUid)) {
    body['TargetUid'] = request.targetUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeviceDistributeJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDeviceDistributeJobRequest
 * @return CreateDeviceDistributeJobResponse
 */
async function createDeviceDistributeJob(request: CreateDeviceDistributeJobRequest): CreateDeviceDistributeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceDistributeJobWithOptions(request, runtime);
}

model CreateDeviceDynamicGroupRequest {
  dynamicGroupExpression?: string(name='DynamicGroupExpression', description='This parameter is required.'),
  groupDesc?: string(name='GroupDesc'),
  groupName?: string(name='GroupName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
}

model CreateDeviceDynamicGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    dynamicGroupExpression?: string(name='DynamicGroupExpression'),
    groupDesc?: string(name='GroupDesc'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    utcCreate?: string(name='UtcCreate'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDeviceDynamicGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDeviceDynamicGroupResponseBody(name='body'),
}

/**
 * @param request CreateDeviceDynamicGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDeviceDynamicGroupResponse
 */
async function createDeviceDynamicGroupWithOptions(request: CreateDeviceDynamicGroupRequest, runtime: Util.RuntimeOptions): CreateDeviceDynamicGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dynamicGroupExpression)) {
    query['DynamicGroupExpression'] = request.dynamicGroupExpression;
  }
  if (!Util.isUnset(request.groupDesc)) {
    query['GroupDesc'] = request.groupDesc;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeviceDynamicGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDeviceDynamicGroupRequest
 * @return CreateDeviceDynamicGroupResponse
 */
async function createDeviceDynamicGroup(request: CreateDeviceDynamicGroupRequest): CreateDeviceDynamicGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceDynamicGroupWithOptions(request, runtime);
}

model CreateDeviceGroupRequest {
  groupDesc?: string(name='GroupDesc'),
  groupName?: string(name='GroupName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  superGroupId?: string(name='SuperGroupId'),
}

model CreateDeviceGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    groupDesc?: string(name='GroupDesc'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    utcCreate?: string(name='UtcCreate'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDeviceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDeviceGroupResponseBody(name='body'),
}

/**
 * @param request CreateDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDeviceGroupResponse
 */
async function createDeviceGroupWithOptions(request: CreateDeviceGroupRequest, runtime: Util.RuntimeOptions): CreateDeviceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupDesc)) {
    query['GroupDesc'] = request.groupDesc;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.superGroupId)) {
    query['SuperGroupId'] = request.superGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeviceGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDeviceGroupRequest
 * @return CreateDeviceGroupResponse
 */
async function createDeviceGroup(request: CreateDeviceGroupRequest): CreateDeviceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceGroupWithOptions(request, runtime);
}

model CreateDeviceTunnelRequest {
  description?: string(name='Description'),
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  udi?: string(name='Udi'),
}

model CreateDeviceTunnelResponseBody = {
  code?: string(name='Code'),
  data?: {
    sourceAccessToken?: string(name='SourceAccessToken'),
    sourceURI?: string(name='SourceURI'),
    tunnelId?: string(name='TunnelId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDeviceTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDeviceTunnelResponseBody(name='body'),
}

/**
 * @param request CreateDeviceTunnelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDeviceTunnelResponse
 */
async function createDeviceTunnelWithOptions(request: CreateDeviceTunnelRequest, runtime: Util.RuntimeOptions): CreateDeviceTunnelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.udi)) {
    query['Udi'] = request.udi;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeviceTunnel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDeviceTunnelRequest
 * @return CreateDeviceTunnelResponse
 */
async function createDeviceTunnel(request: CreateDeviceTunnelRequest): CreateDeviceTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceTunnelWithOptions(request, runtime);
}

model CreateDownloadDataJobRequest {
  downloadDataType?: string(name='DownloadDataType', description='This parameter is required.'),
  endTime?: long(name='EndTime'),
  fileConfig?: map[string]any(name='FileConfig'),
  iotInstanceId?: string(name='IotInstanceId'),
  startTime?: long(name='StartTime'),
  tableName?: string(name='TableName', description='This parameter is required.'),
}

model CreateDownloadDataJobShrinkRequest {
  downloadDataType?: string(name='DownloadDataType', description='This parameter is required.'),
  endTime?: long(name='EndTime'),
  fileConfigShrink?: string(name='FileConfig'),
  iotInstanceId?: string(name='IotInstanceId'),
  startTime?: long(name='StartTime'),
  tableName?: string(name='TableName', description='This parameter is required.'),
}

model CreateDownloadDataJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    asyncExecute?: boolean(name='AsyncExecute'),
    csvFileName?: string(name='CsvFileName'),
    csvUrl?: string(name='CsvUrl'),
    longJobId?: string(name='LongJobId'),
    status?: int32(name='Status'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDownloadDataJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDownloadDataJobResponseBody(name='body'),
}

/**
 * @param tmpReq CreateDownloadDataJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDownloadDataJobResponse
 */
async function createDownloadDataJobWithOptions(tmpReq: CreateDownloadDataJobRequest, runtime: Util.RuntimeOptions): CreateDownloadDataJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDownloadDataJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fileConfig)) {
    request.fileConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fileConfig, 'FileConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.downloadDataType)) {
    query['DownloadDataType'] = request.downloadDataType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.fileConfigShrink)) {
    query['FileConfig'] = request.fileConfigShrink;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDownloadDataJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateDownloadDataJobRequest
 * @return CreateDownloadDataJobResponse
 */
async function createDownloadDataJob(request: CreateDownloadDataJobRequest): CreateDownloadDataJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDownloadDataJobWithOptions(request, runtime);
}

model CreateEdgeDriverRequest {
  cpuArch?: string(name='CpuArch'),
  driverName?: string(name='DriverName', description='This parameter is required.'),
  driverProtocol?: string(name='DriverProtocol', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  isBuiltIn?: boolean(name='IsBuiltIn'),
  runtime?: string(name='Runtime', description='This parameter is required.'),
}

model CreateEdgeDriverResponseBody = {
  code?: string(name='Code'),
  driverId?: string(name='DriverId'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEdgeDriverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeDriverResponseBody(name='body'),
}

/**
 * @param request CreateEdgeDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeDriverResponse
 */
async function createEdgeDriverWithOptions(request: CreateEdgeDriverRequest, runtime: Util.RuntimeOptions): CreateEdgeDriverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cpuArch)) {
    query['CpuArch'] = request.cpuArch;
  }
  if (!Util.isUnset(request.driverName)) {
    query['DriverName'] = request.driverName;
  }
  if (!Util.isUnset(request.driverProtocol)) {
    query['DriverProtocol'] = request.driverProtocol;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.isBuiltIn)) {
    query['IsBuiltIn'] = request.isBuiltIn;
  }
  if (!Util.isUnset(request.runtime)) {
    query['Runtime'] = request.runtime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEdgeDriver',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEdgeDriverRequest
 * @return CreateEdgeDriverResponse
 */
async function createEdgeDriver(request: CreateEdgeDriverRequest): CreateEdgeDriverResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEdgeDriverWithOptions(request, runtime);
}

model CreateEdgeDriverVersionRequest {
  argument?: string(name='Argument'),
  configCheckRule?: string(name='ConfigCheckRule'),
  containerConfig?: string(name='ContainerConfig'),
  description?: string(name='Description'),
  driverConfig?: string(name='DriverConfig'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  driverVersion?: string(name='DriverVersion', description='This parameter is required.'),
  edgeVersion?: string(name='EdgeVersion', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  sourceConfig?: string(name='SourceConfig'),
}

model CreateEdgeDriverVersionResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEdgeDriverVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeDriverVersionResponseBody(name='body'),
}

/**
 * @param request CreateEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeDriverVersionResponse
 */
async function createEdgeDriverVersionWithOptions(request: CreateEdgeDriverVersionRequest, runtime: Util.RuntimeOptions): CreateEdgeDriverVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.argument)) {
    query['Argument'] = request.argument;
  }
  if (!Util.isUnset(request.configCheckRule)) {
    query['ConfigCheckRule'] = request.configCheckRule;
  }
  if (!Util.isUnset(request.containerConfig)) {
    query['ContainerConfig'] = request.containerConfig;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.driverConfig)) {
    query['DriverConfig'] = request.driverConfig;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.driverVersion)) {
    query['DriverVersion'] = request.driverVersion;
  }
  if (!Util.isUnset(request.edgeVersion)) {
    query['EdgeVersion'] = request.edgeVersion;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.sourceConfig)) {
    query['SourceConfig'] = request.sourceConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEdgeDriverVersion',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEdgeDriverVersionRequest
 * @return CreateEdgeDriverVersionResponse
 */
async function createEdgeDriverVersion(request: CreateEdgeDriverVersionRequest): CreateEdgeDriverVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEdgeDriverVersionWithOptions(request, runtime);
}

model CreateEdgeInstanceRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name', description='This parameter is required.'),
  spec?: int32(name='Spec'),
  tags?: string(name='Tags'),
}

model CreateEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request CreateEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeInstanceResponse
 */
async function createEdgeInstanceWithOptions(request: CreateEdgeInstanceRequest, runtime: Util.RuntimeOptions): CreateEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEdgeInstanceRequest
 * @return CreateEdgeInstanceResponse
 */
async function createEdgeInstance(request: CreateEdgeInstanceRequest): CreateEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEdgeInstanceWithOptions(request, runtime);
}

model CreateEdgeInstanceChannelRequest {
  channelName?: string(name='ChannelName', description='This parameter is required.'),
  configs?: [ 
    {
      content?: string(name='Content', description='This parameter is required.'),
      format?: string(name='Format', description='This parameter is required.'),
      key?: string(name='Key'),
    }
  ](name='Configs', description='This parameter is required.'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model CreateEdgeInstanceChannelResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEdgeInstanceChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeInstanceChannelResponseBody(name='body'),
}

/**
 * @param request CreateEdgeInstanceChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeInstanceChannelResponse
 */
async function createEdgeInstanceChannelWithOptions(request: CreateEdgeInstanceChannelRequest, runtime: Util.RuntimeOptions): CreateEdgeInstanceChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelName)) {
    query['ChannelName'] = request.channelName;
  }
  if (!Util.isUnset(request.configs)) {
    query['Configs'] = request.configs;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEdgeInstanceChannel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEdgeInstanceChannelRequest
 * @return CreateEdgeInstanceChannelResponse
 */
async function createEdgeInstanceChannel(request: CreateEdgeInstanceChannelRequest): CreateEdgeInstanceChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEdgeInstanceChannelWithOptions(request, runtime);
}

model CreateEdgeInstanceDeploymentRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateEdgeInstanceDeploymentResponseBody = {
  code?: string(name='Code'),
  deploymentId?: string(name='DeploymentId'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEdgeInstanceDeploymentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeInstanceDeploymentResponseBody(name='body'),
}

/**
 * @param request CreateEdgeInstanceDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeInstanceDeploymentResponse
 */
async function createEdgeInstanceDeploymentWithOptions(request: CreateEdgeInstanceDeploymentRequest, runtime: Util.RuntimeOptions): CreateEdgeInstanceDeploymentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEdgeInstanceDeployment',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEdgeInstanceDeploymentRequest
 * @return CreateEdgeInstanceDeploymentResponse
 */
async function createEdgeInstanceDeployment(request: CreateEdgeInstanceDeploymentRequest): CreateEdgeInstanceDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEdgeInstanceDeploymentWithOptions(request, runtime);
}

model CreateEdgeInstanceMessageRoutingRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name'),
  sourceData?: string(name='SourceData'),
  sourceType?: string(name='SourceType', description='This parameter is required.'),
  targetData?: string(name='TargetData'),
  targetIotHubQos?: int32(name='TargetIotHubQos'),
  targetType?: string(name='TargetType', description='This parameter is required.'),
  topicFilter?: string(name='TopicFilter'),
}

model CreateEdgeInstanceMessageRoutingResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  routeId?: long(name='RouteId'),
  success?: boolean(name='Success'),
}

model CreateEdgeInstanceMessageRoutingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeInstanceMessageRoutingResponseBody(name='body'),
}

/**
 * @param request CreateEdgeInstanceMessageRoutingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeInstanceMessageRoutingResponse
 */
async function createEdgeInstanceMessageRoutingWithOptions(request: CreateEdgeInstanceMessageRoutingRequest, runtime: Util.RuntimeOptions): CreateEdgeInstanceMessageRoutingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.sourceData)) {
    query['SourceData'] = request.sourceData;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.targetData)) {
    query['TargetData'] = request.targetData;
  }
  if (!Util.isUnset(request.targetIotHubQos)) {
    query['TargetIotHubQos'] = request.targetIotHubQos;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.topicFilter)) {
    query['TopicFilter'] = request.topicFilter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEdgeInstanceMessageRouting',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEdgeInstanceMessageRoutingRequest
 * @return CreateEdgeInstanceMessageRoutingResponse
 */
async function createEdgeInstanceMessageRouting(request: CreateEdgeInstanceMessageRoutingRequest): CreateEdgeInstanceMessageRoutingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEdgeInstanceMessageRoutingWithOptions(request, runtime);
}

model CreateEdgeOssPreSignedAddressRequest {
  fileName?: string(name='FileName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  iotInstanceId?: string(name='IotInstanceId'),
  resourceId?: string(name='ResourceId', description='This parameter is required.'),
  resourceVersion?: string(name='ResourceVersion', description='This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateEdgeOssPreSignedAddressResponseBody = {
  code?: string(name='Code'),
  data?: {
    ossAddress?: string(name='OssAddress'),
    ossPreSignedAddress?: string(name='OssPreSignedAddress'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateEdgeOssPreSignedAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeOssPreSignedAddressResponseBody(name='body'),
}

/**
 * @param request CreateEdgeOssPreSignedAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeOssPreSignedAddressResponse
 */
async function createEdgeOssPreSignedAddressWithOptions(request: CreateEdgeOssPreSignedAddressRequest, runtime: Util.RuntimeOptions): CreateEdgeOssPreSignedAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceVersion)) {
    query['ResourceVersion'] = request.resourceVersion;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEdgeOssPreSignedAddress',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateEdgeOssPreSignedAddressRequest
 * @return CreateEdgeOssPreSignedAddressResponse
 */
async function createEdgeOssPreSignedAddress(request: CreateEdgeOssPreSignedAddressRequest): CreateEdgeOssPreSignedAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEdgeOssPreSignedAddressWithOptions(request, runtime);
}

model CreateJobRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobDocument?: string(name='JobDocument', description='This parameter is required.'),
  jobFile?: map[string]any(name='JobFile'),
  jobName?: string(name='JobName', description='This parameter is required.'),
  rolloutConfig?: map[string]any(name='RolloutConfig'),
  scheduledTime?: long(name='ScheduledTime'),
  targetConfig?: map[string]any(name='TargetConfig', description='This parameter is required.'),
  timeoutConfig?: map[string]any(name='TimeoutConfig'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateJobShrinkRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobDocument?: string(name='JobDocument', description='This parameter is required.'),
  jobFileShrink?: string(name='JobFile'),
  jobName?: string(name='JobName', description='This parameter is required.'),
  rolloutConfigShrink?: string(name='RolloutConfig'),
  scheduledTime?: long(name='ScheduledTime'),
  targetConfigShrink?: string(name='TargetConfig', description='This parameter is required.'),
  timeoutConfigShrink?: string(name='TimeoutConfig'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateJobResponseBody(name='body'),
}

/**
 * @param tmpReq CreateJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateJobResponse
 */
async function createJobWithOptions(tmpReq: CreateJobRequest, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.jobFile)) {
    request.jobFileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobFile, 'JobFile', 'json');
  }
  if (!Util.isUnset(tmpReq.rolloutConfig)) {
    request.rolloutConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rolloutConfig, 'RolloutConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.targetConfig)) {
    request.targetConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targetConfig, 'TargetConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.timeoutConfig)) {
    request.timeoutConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.timeoutConfig, 'TimeoutConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobDocument)) {
    query['JobDocument'] = request.jobDocument;
  }
  if (!Util.isUnset(request.jobFileShrink)) {
    query['JobFile'] = request.jobFileShrink;
  }
  if (!Util.isUnset(request.jobName)) {
    query['JobName'] = request.jobName;
  }
  if (!Util.isUnset(request.rolloutConfigShrink)) {
    query['RolloutConfig'] = request.rolloutConfigShrink;
  }
  if (!Util.isUnset(request.scheduledTime)) {
    query['ScheduledTime'] = request.scheduledTime;
  }
  if (!Util.isUnset(request.targetConfigShrink)) {
    query['TargetConfig'] = request.targetConfigShrink;
  }
  if (!Util.isUnset(request.timeoutConfigShrink)) {
    query['TimeoutConfig'] = request.timeoutConfigShrink;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateJobRequest
 * @return CreateJobResponse
 */
async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobWithOptions(request, runtime);
}

model CreateLoRaNodesTaskRequest {
  deviceInfo?: [ 
    {
      devEui?: string(name='DevEui'),
      pinCode?: string(name='PinCode'),
    }
  ](name='DeviceInfo', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model CreateLoRaNodesTaskResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model CreateLoRaNodesTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLoRaNodesTaskResponseBody(name='body'),
}

/**
 * @param request CreateLoRaNodesTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLoRaNodesTaskResponse
 */
async function createLoRaNodesTaskWithOptions(request: CreateLoRaNodesTaskRequest, runtime: Util.RuntimeOptions): CreateLoRaNodesTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceInfo)) {
    query['DeviceInfo'] = request.deviceInfo;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoRaNodesTask',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateLoRaNodesTaskRequest
 * @return CreateLoRaNodesTaskResponse
 */
async function createLoRaNodesTask(request: CreateLoRaNodesTaskRequest): CreateLoRaNodesTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoRaNodesTaskWithOptions(request, runtime);
}

model CreateOTADynamicUpgradeJobRequest {
  downloadProtocol?: string(name='DownloadProtocol'),
  dynamicMode?: int32(name='DynamicMode'),
  firmwareId?: string(name='FirmwareId', description='This parameter is required.'),
  groupId?: string(name='GroupId'),
  groupType?: string(name='GroupType'),
  iotInstanceId?: string(name='IotInstanceId'),
  maximumPerMinute?: int32(name='MaximumPerMinute'),
  multiModuleMode?: boolean(name='MultiModuleMode'),
  needConfirm?: boolean(name='NeedConfirm'),
  needPush?: boolean(name='NeedPush'),
  overwriteMode?: int32(name='OverwriteMode'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  retryCount?: int32(name='RetryCount'),
  retryInterval?: int32(name='RetryInterval'),
  srcVersion?: [ string ](name='SrcVersion'),
  tag?: [ 
    {
      key?: string(name='Key', description='This parameter is required.'),
      value?: string(name='Value', description='This parameter is required.'),
    }
  ](name='Tag'),
  timeoutInMinutes?: int32(name='TimeoutInMinutes'),
}

model CreateOTADynamicUpgradeJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    utcCreate?: string(name='UtcCreate'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOTADynamicUpgradeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOTADynamicUpgradeJobResponseBody(name='body'),
}

/**
 * @param request CreateOTADynamicUpgradeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTADynamicUpgradeJobResponse
 */
async function createOTADynamicUpgradeJobWithOptions(request: CreateOTADynamicUpgradeJobRequest, runtime: Util.RuntimeOptions): CreateOTADynamicUpgradeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.downloadProtocol)) {
    query['DownloadProtocol'] = request.downloadProtocol;
  }
  if (!Util.isUnset(request.dynamicMode)) {
    query['DynamicMode'] = request.dynamicMode;
  }
  if (!Util.isUnset(request.firmwareId)) {
    query['FirmwareId'] = request.firmwareId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupType)) {
    query['GroupType'] = request.groupType;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.maximumPerMinute)) {
    query['MaximumPerMinute'] = request.maximumPerMinute;
  }
  if (!Util.isUnset(request.multiModuleMode)) {
    query['MultiModuleMode'] = request.multiModuleMode;
  }
  if (!Util.isUnset(request.needConfirm)) {
    query['NeedConfirm'] = request.needConfirm;
  }
  if (!Util.isUnset(request.needPush)) {
    query['NeedPush'] = request.needPush;
  }
  if (!Util.isUnset(request.overwriteMode)) {
    query['OverwriteMode'] = request.overwriteMode;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.retryCount)) {
    query['RetryCount'] = request.retryCount;
  }
  if (!Util.isUnset(request.retryInterval)) {
    query['RetryInterval'] = request.retryInterval;
  }
  if (!Util.isUnset(request.srcVersion)) {
    query['SrcVersion'] = request.srcVersion;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.timeoutInMinutes)) {
    query['TimeoutInMinutes'] = request.timeoutInMinutes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOTADynamicUpgradeJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOTADynamicUpgradeJobRequest
 * @return CreateOTADynamicUpgradeJobResponse
 */
async function createOTADynamicUpgradeJob(request: CreateOTADynamicUpgradeJobRequest): CreateOTADynamicUpgradeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOTADynamicUpgradeJobWithOptions(request, runtime);
}

model CreateOTAFirmwareRequest {
  destVersion?: string(name='DestVersion', description='This parameter is required.'),
  firmwareDesc?: string(name='FirmwareDesc'),
  firmwareName?: string(name='FirmwareName', description='This parameter is required.'),
  firmwareSign?: string(name='FirmwareSign'),
  firmwareSize?: int32(name='FirmwareSize'),
  firmwareUrl?: string(name='FirmwareUrl'),
  iotInstanceId?: string(name='IotInstanceId'),
  moduleName?: string(name='ModuleName'),
  multiFiles?: [ 
    {
      fileMd5?: string(name='FileMd5'),
      name?: string(name='Name'),
      signValue?: string(name='SignValue'),
      size?: int32(name='Size'),
      url?: string(name='Url'),
    }
  ](name='MultiFiles'),
  needToVerify?: boolean(name='NeedToVerify'),
  productKey?: string(name='ProductKey'),
  signMethod?: string(name='SignMethod'),
  srcVersion?: string(name='SrcVersion'),
  type?: int32(name='Type'),
  udi?: string(name='Udi'),
}

model CreateOTAFirmwareResponseBody = {
  code?: string(name='Code'),
  data?: {
    firmwareId?: string(name='FirmwareId'),
    utcCreate?: string(name='UtcCreate'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOTAFirmwareResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOTAFirmwareResponseBody(name='body'),
}

/**
 * @param request CreateOTAFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTAFirmwareResponse
 */
async function createOTAFirmwareWithOptions(request: CreateOTAFirmwareRequest, runtime: Util.RuntimeOptions): CreateOTAFirmwareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destVersion)) {
    query['DestVersion'] = request.destVersion;
  }
  if (!Util.isUnset(request.firmwareDesc)) {
    query['FirmwareDesc'] = request.firmwareDesc;
  }
  if (!Util.isUnset(request.firmwareName)) {
    query['FirmwareName'] = request.firmwareName;
  }
  if (!Util.isUnset(request.firmwareSign)) {
    query['FirmwareSign'] = request.firmwareSign;
  }
  if (!Util.isUnset(request.firmwareSize)) {
    query['FirmwareSize'] = request.firmwareSize;
  }
  if (!Util.isUnset(request.firmwareUrl)) {
    query['FirmwareUrl'] = request.firmwareUrl;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.multiFiles)) {
    query['MultiFiles'] = request.multiFiles;
  }
  if (!Util.isUnset(request.needToVerify)) {
    query['NeedToVerify'] = request.needToVerify;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.signMethod)) {
    query['SignMethod'] = request.signMethod;
  }
  if (!Util.isUnset(request.srcVersion)) {
    query['SrcVersion'] = request.srcVersion;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.udi)) {
    query['Udi'] = request.udi;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOTAFirmware',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOTAFirmwareRequest
 * @return CreateOTAFirmwareResponse
 */
async function createOTAFirmware(request: CreateOTAFirmwareRequest): CreateOTAFirmwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOTAFirmwareWithOptions(request, runtime);
}

model CreateOTAModuleRequest {
  aliasName?: string(name='AliasName'),
  desc?: string(name='Desc'),
  iotInstanceId?: string(name='IotInstanceId'),
  moduleName?: string(name='ModuleName', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model CreateOTAModuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOTAModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOTAModuleResponseBody(name='body'),
}

/**
 * @param request CreateOTAModuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTAModuleResponse
 */
async function createOTAModuleWithOptions(request: CreateOTAModuleRequest, runtime: Util.RuntimeOptions): CreateOTAModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOTAModule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOTAModuleRequest
 * @return CreateOTAModuleResponse
 */
async function createOTAModule(request: CreateOTAModuleRequest): CreateOTAModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOTAModuleWithOptions(request, runtime);
}

model CreateOTAStaticUpgradeJobRequest {
  dnListFileUrl?: string(name='DnListFileUrl'),
  downloadProtocol?: string(name='DownloadProtocol'),
  firmwareId?: string(name='FirmwareId', description='This parameter is required.'),
  grayPercent?: string(name='GrayPercent'),
  groupId?: string(name='GroupId'),
  groupType?: string(name='GroupType'),
  iotInstanceId?: string(name='IotInstanceId'),
  maximumPerMinute?: int32(name='MaximumPerMinute'),
  multiModuleMode?: boolean(name='MultiModuleMode'),
  needConfirm?: boolean(name='NeedConfirm'),
  needPush?: boolean(name='NeedPush'),
  overwriteMode?: int32(name='OverwriteMode'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  retryCount?: int32(name='RetryCount'),
  retryInterval?: int32(name='RetryInterval'),
  scheduleFinishTime?: long(name='ScheduleFinishTime'),
  scheduleTime?: long(name='ScheduleTime'),
  srcVersion?: [ string ](name='SrcVersion'),
  tag?: [ 
    {
      key?: string(name='Key', description='This parameter is required.'),
      value?: string(name='Value', description='This parameter is required.'),
    }
  ](name='Tag'),
  targetDeviceName?: [ string ](name='TargetDeviceName'),
  targetSelection?: string(name='TargetSelection', description='This parameter is required.'),
  timeoutInMinutes?: int32(name='TimeoutInMinutes'),
}

model CreateOTAStaticUpgradeJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    utcCreate?: string(name='UtcCreate'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOTAStaticUpgradeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOTAStaticUpgradeJobResponseBody(name='body'),
}

/**
 * @param request CreateOTAStaticUpgradeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTAStaticUpgradeJobResponse
 */
async function createOTAStaticUpgradeJobWithOptions(request: CreateOTAStaticUpgradeJobRequest, runtime: Util.RuntimeOptions): CreateOTAStaticUpgradeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dnListFileUrl)) {
    query['DnListFileUrl'] = request.dnListFileUrl;
  }
  if (!Util.isUnset(request.downloadProtocol)) {
    query['DownloadProtocol'] = request.downloadProtocol;
  }
  if (!Util.isUnset(request.firmwareId)) {
    query['FirmwareId'] = request.firmwareId;
  }
  if (!Util.isUnset(request.grayPercent)) {
    query['GrayPercent'] = request.grayPercent;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupType)) {
    query['GroupType'] = request.groupType;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.maximumPerMinute)) {
    query['MaximumPerMinute'] = request.maximumPerMinute;
  }
  if (!Util.isUnset(request.multiModuleMode)) {
    query['MultiModuleMode'] = request.multiModuleMode;
  }
  if (!Util.isUnset(request.needConfirm)) {
    query['NeedConfirm'] = request.needConfirm;
  }
  if (!Util.isUnset(request.needPush)) {
    query['NeedPush'] = request.needPush;
  }
  if (!Util.isUnset(request.overwriteMode)) {
    query['OverwriteMode'] = request.overwriteMode;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.retryCount)) {
    query['RetryCount'] = request.retryCount;
  }
  if (!Util.isUnset(request.retryInterval)) {
    query['RetryInterval'] = request.retryInterval;
  }
  if (!Util.isUnset(request.scheduleFinishTime)) {
    query['ScheduleFinishTime'] = request.scheduleFinishTime;
  }
  if (!Util.isUnset(request.scheduleTime)) {
    query['ScheduleTime'] = request.scheduleTime;
  }
  if (!Util.isUnset(request.srcVersion)) {
    query['SrcVersion'] = request.srcVersion;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.targetDeviceName)) {
    query['TargetDeviceName'] = request.targetDeviceName;
  }
  if (!Util.isUnset(request.targetSelection)) {
    query['TargetSelection'] = request.targetSelection;
  }
  if (!Util.isUnset(request.timeoutInMinutes)) {
    query['TimeoutInMinutes'] = request.timeoutInMinutes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOTAStaticUpgradeJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOTAStaticUpgradeJobRequest
 * @return CreateOTAStaticUpgradeJobResponse
 */
async function createOTAStaticUpgradeJob(request: CreateOTAStaticUpgradeJobRequest): CreateOTAStaticUpgradeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOTAStaticUpgradeJobWithOptions(request, runtime);
}

model CreateOTAVerifyJobRequest {
  downloadProtocol?: string(name='DownloadProtocol'),
  firmwareId?: string(name='FirmwareId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  needConfirm?: boolean(name='NeedConfirm'),
  needPush?: boolean(name='NeedPush'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  tag?: [ 
    {
      key?: string(name='Key', description='This parameter is required.'),
      value?: string(name='Value', description='This parameter is required.'),
    }
  ](name='Tag'),
  targetDeviceName?: [ string ](name='TargetDeviceName', description='This parameter is required.'),
  timeoutInMinutes?: int32(name='TimeoutInMinutes'),
}

model CreateOTAVerifyJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    utcCreate?: string(name='UtcCreate'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOTAVerifyJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOTAVerifyJobResponseBody(name='body'),
}

/**
 * @param request CreateOTAVerifyJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTAVerifyJobResponse
 */
async function createOTAVerifyJobWithOptions(request: CreateOTAVerifyJobRequest, runtime: Util.RuntimeOptions): CreateOTAVerifyJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.downloadProtocol)) {
    query['DownloadProtocol'] = request.downloadProtocol;
  }
  if (!Util.isUnset(request.firmwareId)) {
    query['FirmwareId'] = request.firmwareId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.needConfirm)) {
    query['NeedConfirm'] = request.needConfirm;
  }
  if (!Util.isUnset(request.needPush)) {
    query['NeedPush'] = request.needPush;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.targetDeviceName)) {
    query['TargetDeviceName'] = request.targetDeviceName;
  }
  if (!Util.isUnset(request.timeoutInMinutes)) {
    query['TimeoutInMinutes'] = request.timeoutInMinutes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOTAVerifyJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOTAVerifyJobRequest
 * @return CreateOTAVerifyJobResponse
 */
async function createOTAVerifyJob(request: CreateOTAVerifyJobRequest): CreateOTAVerifyJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOTAVerifyJobWithOptions(request, runtime);
}

model CreateParserRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name', description='This parameter is required.'),
}

model CreateParserResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  parserId?: long(name='ParserId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateParserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateParserResponseBody(name='body'),
}

/**
 * @param request CreateParserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateParserResponse
 */
async function createParserWithOptions(request: CreateParserRequest, runtime: Util.RuntimeOptions): CreateParserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateParser',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateParserRequest
 * @return CreateParserResponse
 */
async function createParser(request: CreateParserRequest): CreateParserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createParserWithOptions(request, runtime);
}

model CreateParserDataSourceRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name', description='This parameter is required.'),
}

model CreateParserDataSourceResponseBody = {
  code?: string(name='Code'),
  dataSource?: {
    dataSourceId?: long(name='DataSourceId'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    utcCreated?: string(name='UtcCreated'),
  }(name='DataSource'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateParserDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateParserDataSourceResponseBody(name='body'),
}

/**
 * @param request CreateParserDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateParserDataSourceResponse
 */
async function createParserDataSourceWithOptions(request: CreateParserDataSourceRequest, runtime: Util.RuntimeOptions): CreateParserDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateParserDataSource',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateParserDataSourceRequest
 * @return CreateParserDataSourceResponse
 */
async function createParserDataSource(request: CreateParserDataSourceRequest): CreateParserDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createParserDataSourceWithOptions(request, runtime);
}

model CreateProductRequest {
  aliyunCommodityCode?: string(name='AliyunCommodityCode'),
  authType?: string(name='AuthType'),
  categoryKey?: string(name='CategoryKey'),
  dataFormat?: int32(name='DataFormat'),
  description?: string(name='Description'),
  id2?: boolean(name='Id2'),
  iotInstanceId?: string(name='IotInstanceId'),
  joinPermissionId?: string(name='JoinPermissionId'),
  netType?: string(name='NetType'),
  nodeType?: int32(name='NodeType', description='This parameter is required.'),
  productName?: string(name='ProductName', description='This parameter is required.'),
  protocolType?: string(name='ProtocolType'),
  publishAuto?: boolean(name='PublishAuto'),
  resourceGroupId?: string(name='ResourceGroupId'),
  validateType?: int32(name='ValidateType'),
}

model CreateProductResponseBody = {
  code?: string(name='Code'),
  data?: {
    aliyunCommodityCode?: string(name='AliyunCommodityCode'),
    authType?: string(name='AuthType'),
    dataFormat?: int32(name='DataFormat'),
    description?: string(name='Description'),
    id2?: boolean(name='Id2'),
    nodeType?: int32(name='NodeType'),
    productKey?: string(name='ProductKey'),
    productName?: string(name='ProductName'),
    productSecret?: string(name='ProductSecret'),
    protocolType?: string(name='ProtocolType'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  productKey?: string(name='ProductKey'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProductResponseBody(name='body'),
}

/**
 * @param request CreateProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProductResponse
 */
async function createProductWithOptions(request: CreateProductRequest, runtime: Util.RuntimeOptions): CreateProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunCommodityCode)) {
    query['AliyunCommodityCode'] = request.aliyunCommodityCode;
  }
  if (!Util.isUnset(request.authType)) {
    query['AuthType'] = request.authType;
  }
  if (!Util.isUnset(request.categoryKey)) {
    query['CategoryKey'] = request.categoryKey;
  }
  if (!Util.isUnset(request.dataFormat)) {
    query['DataFormat'] = request.dataFormat;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.id2)) {
    query['Id2'] = request.id2;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.joinPermissionId)) {
    query['JoinPermissionId'] = request.joinPermissionId;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.productName)) {
    query['ProductName'] = request.productName;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.publishAuto)) {
    query['PublishAuto'] = request.publishAuto;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.validateType)) {
    query['ValidateType'] = request.validateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateProductRequest
 * @return CreateProductResponse
 */
async function createProduct(request: CreateProductRequest): CreateProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProductWithOptions(request, runtime);
}

model CreateProductDistributeJobRequest {
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  sourceInstanceId?: string(name='SourceInstanceId', description='This parameter is required.'),
  targetAliyunId?: string(name='TargetAliyunId'),
  targetInstanceId?: string(name='TargetInstanceId', description='This parameter is required.'),
  targetUid?: string(name='TargetUid'),
}

model CreateProductDistributeJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateProductDistributeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProductDistributeJobResponseBody(name='body'),
}

/**
 * @param request CreateProductDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProductDistributeJobResponse
 */
async function createProductDistributeJobWithOptions(request: CreateProductDistributeJobRequest, runtime: Util.RuntimeOptions): CreateProductDistributeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.sourceInstanceId)) {
    query['SourceInstanceId'] = request.sourceInstanceId;
  }
  if (!Util.isUnset(request.targetAliyunId)) {
    query['TargetAliyunId'] = request.targetAliyunId;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetUid)) {
    query['TargetUid'] = request.targetUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProductDistributeJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateProductDistributeJobRequest
 * @return CreateProductDistributeJobResponse
 */
async function createProductDistributeJob(request: CreateProductDistributeJobRequest): CreateProductDistributeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProductDistributeJobWithOptions(request, runtime);
}

model CreateProductTagsRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  productTag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='ProductTag', description='This parameter is required.'),
}

model CreateProductTagsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  invalidProductTags?: {
    productTag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='ProductTag')
  }(name='InvalidProductTags'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateProductTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProductTagsResponseBody(name='body'),
}

/**
 * @param request CreateProductTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProductTagsResponse
 */
async function createProductTagsWithOptions(request: CreateProductTagsRequest, runtime: Util.RuntimeOptions): CreateProductTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.productTag)) {
    query['ProductTag'] = request.productTag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProductTags',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateProductTagsRequest
 * @return CreateProductTagsResponse
 */
async function createProductTags(request: CreateProductTagsRequest): CreateProductTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProductTagsWithOptions(request, runtime);
}

model CreateProductTopicRequest {
  codec?: string(name='Codec'),
  desc?: string(name='Desc'),
  enableProxySubscribe?: boolean(name='EnableProxySubscribe'),
  iotInstanceId?: string(name='IotInstanceId'),
  operation?: string(name='Operation', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  topicShortName?: string(name='TopicShortName', description='This parameter is required.'),
}

model CreateProductTopicResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  topicId?: long(name='TopicId'),
}

model CreateProductTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProductTopicResponseBody(name='body'),
}

/**
 * @param request CreateProductTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProductTopicResponse
 */
async function createProductTopicWithOptions(request: CreateProductTopicRequest, runtime: Util.RuntimeOptions): CreateProductTopicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.codec)) {
    query['Codec'] = request.codec;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.enableProxySubscribe)) {
    query['EnableProxySubscribe'] = request.enableProxySubscribe;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.topicShortName)) {
    query['TopicShortName'] = request.topicShortName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProductTopic',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateProductTopicRequest
 * @return CreateProductTopicResponse
 */
async function createProductTopic(request: CreateProductTopicRequest): CreateProductTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProductTopicWithOptions(request, runtime);
}

model CreateRuleRequest {
  dataType?: string(name='DataType'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ruleDesc?: string(name='RuleDesc'),
  select?: string(name='Select'),
  shortTopic?: string(name='ShortTopic'),
  topic?: string(name='Topic'),
  topicType?: int32(name='TopicType'),
  where?: string(name='Where'),
}

model CreateRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  ruleId?: long(name='RuleId'),
  success?: boolean(name='Success'),
}

model CreateRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRuleResponseBody(name='body'),
}

/**
 * @param request CreateRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRuleResponse
 */
async function createRuleWithOptions(request: CreateRuleRequest, runtime: Util.RuntimeOptions): CreateRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataType)) {
    query['DataType'] = request.dataType;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ruleDesc)) {
    query['RuleDesc'] = request.ruleDesc;
  }
  if (!Util.isUnset(request.select)) {
    query['Select'] = request.select;
  }
  if (!Util.isUnset(request.shortTopic)) {
    query['ShortTopic'] = request.shortTopic;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  if (!Util.isUnset(request.topicType)) {
    query['TopicType'] = request.topicType;
  }
  if (!Util.isUnset(request.where)) {
    query['Where'] = request.where;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateRuleRequest
 * @return CreateRuleResponse
 */
async function createRule(request: CreateRuleRequest): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleWithOptions(request, runtime);
}

model CreateRuleActionRequest {
  configuration?: string(name='Configuration', description='This parameter is required.'),
  errorActionFlag?: boolean(name='ErrorActionFlag'),
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model CreateRuleActionResponseBody = {
  actionId?: long(name='ActionId'),
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateRuleActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRuleActionResponseBody(name='body'),
}

/**
 * @param request CreateRuleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRuleActionResponse
 */
async function createRuleActionWithOptions(request: CreateRuleActionRequest, runtime: Util.RuntimeOptions): CreateRuleActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configuration)) {
    query['Configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.errorActionFlag)) {
    query['ErrorActionFlag'] = request.errorActionFlag;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRuleAction',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateRuleActionRequest
 * @return CreateRuleActionResponse
 */
async function createRuleAction(request: CreateRuleActionRequest): CreateRuleActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleActionWithOptions(request, runtime);
}

model CreateSceneRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleContent?: string(name='RuleContent'),
  ruleDescription?: string(name='RuleDescription'),
  ruleName?: string(name='RuleName', description='This parameter is required.'),
}

model CreateSceneRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  ruleId?: string(name='RuleId'),
  success?: boolean(name='Success'),
}

model CreateSceneRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSceneRuleResponseBody(name='body'),
}

/**
 * @param request CreateSceneRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSceneRuleResponse
 */
async function createSceneRuleWithOptions(request: CreateSceneRuleRequest, runtime: Util.RuntimeOptions): CreateSceneRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleContent)) {
    query['RuleContent'] = request.ruleContent;
  }
  if (!Util.isUnset(request.ruleDescription)) {
    query['RuleDescription'] = request.ruleDescription;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSceneRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSceneRuleRequest
 * @return CreateSceneRuleResponse
 */
async function createSceneRule(request: CreateSceneRuleRequest): CreateSceneRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSceneRuleWithOptions(request, runtime);
}

model CreateSchedulePeriodRequest {
  description?: string(name='Description', description='This parameter is required.'),
  endTime?: string(name='EndTime', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
  soundCodeContent?: string(name='SoundCodeContent', description='This parameter is required.'),
  startTime?: string(name='StartTime', description='This parameter is required.'),
}

model CreateSchedulePeriodResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSchedulePeriodResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSchedulePeriodResponseBody(name='body'),
}

/**
 * @param request CreateSchedulePeriodRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSchedulePeriodResponse
 */
async function createSchedulePeriodWithOptions(request: CreateSchedulePeriodRequest, runtime: Util.RuntimeOptions): CreateSchedulePeriodResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  if (!Util.isUnset(request.soundCodeContent)) {
    body['SoundCodeContent'] = request.soundCodeContent;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSchedulePeriod',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSchedulePeriodRequest
 * @return CreateSchedulePeriodResponse
 */
async function createSchedulePeriod(request: CreateSchedulePeriodRequest): CreateSchedulePeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSchedulePeriodWithOptions(request, runtime);
}

model CreateSharePromotionActivityRequest {
  endTime?: long(name='EndTime'),
  iotInstanceId?: string(name='IotInstanceId'),
  sharePromotionActivityName?: string(name='SharePromotionActivityName', description='This parameter is required.'),
  startTime?: long(name='StartTime'),
}

model CreateSharePromotionActivityResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSharePromotionActivityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSharePromotionActivityResponseBody(name='body'),
}

/**
 * @param request CreateSharePromotionActivityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSharePromotionActivityResponse
 */
async function createSharePromotionActivityWithOptions(request: CreateSharePromotionActivityRequest, runtime: Util.RuntimeOptions): CreateSharePromotionActivityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.sharePromotionActivityName)) {
    body['SharePromotionActivityName'] = request.sharePromotionActivityName;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSharePromotionActivity',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSharePromotionActivityRequest
 * @return CreateSharePromotionActivityResponse
 */
async function createSharePromotionActivity(request: CreateSharePromotionActivityRequest): CreateSharePromotionActivityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSharePromotionActivityWithOptions(request, runtime);
}

model CreateSharePromotionSpeechModelRequest {
  audioFormat?: string(name='AudioFormat', description='This parameter is required.'),
  bizCode?: string(name='BizCode', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  sharePromotionActivityId?: string(name='SharePromotionActivityId', description='This parameter is required.'),
  shareTaskCode?: string(name='ShareTaskCode', description='This parameter is required.'),
  speechModelType?: string(name='SpeechModelType', description='This parameter is required.'),
  speechRate?: int32(name='SpeechRate'),
  text?: string(name='Text', description='This parameter is required.'),
  voice?: string(name='Voice', description='This parameter is required.'),
  volume?: int32(name='Volume'),
}

model CreateSharePromotionSpeechModelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSharePromotionSpeechModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSharePromotionSpeechModelResponseBody(name='body'),
}

/**
 * @param request CreateSharePromotionSpeechModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSharePromotionSpeechModelResponse
 */
async function createSharePromotionSpeechModelWithOptions(request: CreateSharePromotionSpeechModelRequest, runtime: Util.RuntimeOptions): CreateSharePromotionSpeechModelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioFormat)) {
    body['AudioFormat'] = request.audioFormat;
  }
  if (!Util.isUnset(request.bizCode)) {
    body['BizCode'] = request.bizCode;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.sharePromotionActivityId)) {
    body['SharePromotionActivityId'] = request.sharePromotionActivityId;
  }
  if (!Util.isUnset(request.shareTaskCode)) {
    body['ShareTaskCode'] = request.shareTaskCode;
  }
  if (!Util.isUnset(request.speechModelType)) {
    body['SpeechModelType'] = request.speechModelType;
  }
  if (!Util.isUnset(request.speechRate)) {
    body['SpeechRate'] = request.speechRate;
  }
  if (!Util.isUnset(request.text)) {
    body['Text'] = request.text;
  }
  if (!Util.isUnset(request.voice)) {
    body['Voice'] = request.voice;
  }
  if (!Util.isUnset(request.volume)) {
    body['Volume'] = request.volume;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSharePromotionSpeechModel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSharePromotionSpeechModelRequest
 * @return CreateSharePromotionSpeechModelResponse
 */
async function createSharePromotionSpeechModel(request: CreateSharePromotionSpeechModelRequest): CreateSharePromotionSpeechModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSharePromotionSpeechModelWithOptions(request, runtime);
}

model CreateSoundCodeRequest {
  duration?: int32(name='Duration', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name'),
  openType?: string(name='OpenType'),
  soundCodeContent?: string(name='SoundCodeContent', description='This parameter is required.'),
}

model CreateSoundCodeResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSoundCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSoundCodeResponseBody(name='body'),
}

/**
 * @param request CreateSoundCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSoundCodeResponse
 */
async function createSoundCodeWithOptions(request: CreateSoundCodeRequest, runtime: Util.RuntimeOptions): CreateSoundCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.duration)) {
    body['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.openType)) {
    body['OpenType'] = request.openType;
  }
  if (!Util.isUnset(request.soundCodeContent)) {
    body['SoundCodeContent'] = request.soundCodeContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSoundCode',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSoundCodeRequest
 * @return CreateSoundCodeResponse
 */
async function createSoundCode(request: CreateSoundCodeRequest): CreateSoundCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSoundCodeWithOptions(request, runtime);
}

model CreateSoundCodeLabelRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  label?: string(name='Label', description='This parameter is required.'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
}

model CreateSoundCodeLabelResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSoundCodeLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSoundCodeLabelResponseBody(name='body'),
}

/**
 * @param request CreateSoundCodeLabelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSoundCodeLabelResponse
 */
async function createSoundCodeLabelWithOptions(request: CreateSoundCodeLabelRequest, runtime: Util.RuntimeOptions): CreateSoundCodeLabelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.label)) {
    body['Label'] = request.label;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSoundCodeLabel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSoundCodeLabelRequest
 * @return CreateSoundCodeLabelResponse
 */
async function createSoundCodeLabel(request: CreateSoundCodeLabelRequest): CreateSoundCodeLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSoundCodeLabelWithOptions(request, runtime);
}

model CreateSoundCodeScheduleRequest {
  description?: string(name='Description'),
  endDate?: string(name='EndDate', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name', description='This parameter is required.'),
  openType?: string(name='OpenType'),
  startDate?: string(name='StartDate', description='This parameter is required.'),
}

model CreateSoundCodeScheduleResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSoundCodeScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSoundCodeScheduleResponseBody(name='body'),
}

/**
 * @param request CreateSoundCodeScheduleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSoundCodeScheduleResponse
 */
async function createSoundCodeScheduleWithOptions(request: CreateSoundCodeScheduleRequest, runtime: Util.RuntimeOptions): CreateSoundCodeScheduleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.openType)) {
    body['OpenType'] = request.openType;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSoundCodeSchedule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSoundCodeScheduleRequest
 * @return CreateSoundCodeScheduleResponse
 */
async function createSoundCodeSchedule(request: CreateSoundCodeScheduleRequest): CreateSoundCodeScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSoundCodeScheduleWithOptions(request, runtime);
}

model CreateSpeechRequest {
  audioFormat?: string(name='AudioFormat'),
  bizCode?: string(name='BizCode'),
  enableSoundCode?: boolean(name='EnableSoundCode'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
  soundCodeConfig?: map[string]any(name='SoundCodeConfig'),
  speechRate?: int32(name='SpeechRate'),
  speechType?: string(name='SpeechType'),
  text?: string(name='Text'),
  voice?: string(name='Voice', description='This parameter is required.'),
  volume?: int32(name='Volume'),
}

model CreateSpeechShrinkRequest {
  audioFormat?: string(name='AudioFormat'),
  bizCode?: string(name='BizCode'),
  enableSoundCode?: boolean(name='EnableSoundCode'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
  soundCodeConfigShrink?: string(name='SoundCodeConfig'),
  speechRate?: int32(name='SpeechRate'),
  speechType?: string(name='SpeechType'),
  text?: string(name='Text'),
  voice?: string(name='Voice', description='This parameter is required.'),
  volume?: int32(name='Volume'),
}

model CreateSpeechResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSpeechResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSpeechResponseBody(name='body'),
}

/**
 * @param tmpReq CreateSpeechRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSpeechResponse
 */
async function createSpeechWithOptions(tmpReq: CreateSpeechRequest, runtime: Util.RuntimeOptions): CreateSpeechResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSpeechShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.soundCodeConfig)) {
    request.soundCodeConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.soundCodeConfig, 'SoundCodeConfig', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioFormat)) {
    body['AudioFormat'] = request.audioFormat;
  }
  if (!Util.isUnset(request.bizCode)) {
    body['BizCode'] = request.bizCode;
  }
  if (!Util.isUnset(request.enableSoundCode)) {
    body['EnableSoundCode'] = request.enableSoundCode;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectCode)) {
    body['ProjectCode'] = request.projectCode;
  }
  if (!Util.isUnset(request.soundCodeConfigShrink)) {
    body['SoundCodeConfig'] = request.soundCodeConfigShrink;
  }
  if (!Util.isUnset(request.speechRate)) {
    body['SpeechRate'] = request.speechRate;
  }
  if (!Util.isUnset(request.speechType)) {
    body['SpeechType'] = request.speechType;
  }
  if (!Util.isUnset(request.text)) {
    body['Text'] = request.text;
  }
  if (!Util.isUnset(request.voice)) {
    body['Voice'] = request.voice;
  }
  if (!Util.isUnset(request.volume)) {
    body['Volume'] = request.volume;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSpeech',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSpeechRequest
 * @return CreateSpeechResponse
 */
async function createSpeech(request: CreateSpeechRequest): CreateSpeechResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSpeechWithOptions(request, runtime);
}

model CreateStudioAppDomainOpenRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  host?: string(name='Host', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
  protocol?: string(name='Protocol', description='This parameter is required.'),
}

model CreateStudioAppDomainOpenResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    host?: string(name='Host'),
    id?: int32(name='Id'),
    isBeian?: string(name='IsBeian'),
    projectId?: string(name='ProjectId'),
    protocol?: string(name='Protocol'),
    tenantId?: string(name='TenantId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateStudioAppDomainOpenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateStudioAppDomainOpenResponseBody(name='body'),
}

/**
 * @param request CreateStudioAppDomainOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateStudioAppDomainOpenResponse
 */
async function createStudioAppDomainOpenWithOptions(request: CreateStudioAppDomainOpenRequest, runtime: Util.RuntimeOptions): CreateStudioAppDomainOpenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.host)) {
    body['Host'] = request.host;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.protocol)) {
    body['Protocol'] = request.protocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateStudioAppDomainOpen',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateStudioAppDomainOpenRequest
 * @return CreateStudioAppDomainOpenResponse
 */
async function createStudioAppDomainOpen(request: CreateStudioAppDomainOpenRequest): CreateStudioAppDomainOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStudioAppDomainOpenWithOptions(request, runtime);
}

model CreateSubscribeRelationRequest {
  consumerGroupIds?: [ string ](name='ConsumerGroupIds'),
  deviceDataFlag?: boolean(name='DeviceDataFlag'),
  deviceLifeCycleFlag?: boolean(name='DeviceLifeCycleFlag'),
  deviceStatusChangeFlag?: boolean(name='DeviceStatusChangeFlag'),
  deviceTagFlag?: boolean(name='DeviceTagFlag'),
  deviceTopoLifeCycleFlag?: boolean(name='DeviceTopoLifeCycleFlag'),
  foundDeviceListFlag?: boolean(name='FoundDeviceListFlag'),
  iotInstanceId?: string(name='IotInstanceId'),
  mnsConfiguration?: string(name='MnsConfiguration'),
  otaEventFlag?: boolean(name='OtaEventFlag'),
  otaJobFlag?: boolean(name='OtaJobFlag'),
  otaVersionFlag?: boolean(name='OtaVersionFlag'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  subscribeFlags?: string(name='SubscribeFlags'),
  thingHistoryFlag?: boolean(name='ThingHistoryFlag'),
  type?: string(name='Type'),
}

model CreateSubscribeRelationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSubscribeRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSubscribeRelationResponseBody(name='body'),
}

/**
 * @param request CreateSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSubscribeRelationResponse
 */
async function createSubscribeRelationWithOptions(request: CreateSubscribeRelationRequest, runtime: Util.RuntimeOptions): CreateSubscribeRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consumerGroupIds)) {
    query['ConsumerGroupIds'] = request.consumerGroupIds;
  }
  if (!Util.isUnset(request.deviceDataFlag)) {
    query['DeviceDataFlag'] = request.deviceDataFlag;
  }
  if (!Util.isUnset(request.deviceLifeCycleFlag)) {
    query['DeviceLifeCycleFlag'] = request.deviceLifeCycleFlag;
  }
  if (!Util.isUnset(request.deviceStatusChangeFlag)) {
    query['DeviceStatusChangeFlag'] = request.deviceStatusChangeFlag;
  }
  if (!Util.isUnset(request.deviceTagFlag)) {
    query['DeviceTagFlag'] = request.deviceTagFlag;
  }
  if (!Util.isUnset(request.deviceTopoLifeCycleFlag)) {
    query['DeviceTopoLifeCycleFlag'] = request.deviceTopoLifeCycleFlag;
  }
  if (!Util.isUnset(request.foundDeviceListFlag)) {
    query['FoundDeviceListFlag'] = request.foundDeviceListFlag;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.mnsConfiguration)) {
    query['MnsConfiguration'] = request.mnsConfiguration;
  }
  if (!Util.isUnset(request.otaEventFlag)) {
    query['OtaEventFlag'] = request.otaEventFlag;
  }
  if (!Util.isUnset(request.otaJobFlag)) {
    query['OtaJobFlag'] = request.otaJobFlag;
  }
  if (!Util.isUnset(request.otaVersionFlag)) {
    query['OtaVersionFlag'] = request.otaVersionFlag;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.subscribeFlags)) {
    query['SubscribeFlags'] = request.subscribeFlags;
  }
  if (!Util.isUnset(request.thingHistoryFlag)) {
    query['ThingHistoryFlag'] = request.thingHistoryFlag;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSubscribeRelation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSubscribeRelationRequest
 * @return CreateSubscribeRelationResponse
 */
async function createSubscribeRelation(request: CreateSubscribeRelationRequest): CreateSubscribeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSubscribeRelationWithOptions(request, runtime);
}

model CreateThingModelRequest {
  functionBlockId?: string(name='FunctionBlockId'),
  functionBlockName?: string(name='FunctionBlockName'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  thingModelJson?: string(name='ThingModelJson'),
}

model CreateThingModelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateThingModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateThingModelResponseBody(name='body'),
}

/**
 * @param request CreateThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateThingModelResponse
 */
async function createThingModelWithOptions(request: CreateThingModelRequest, runtime: Util.RuntimeOptions): CreateThingModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.functionBlockName)) {
    query['FunctionBlockName'] = request.functionBlockName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.thingModelJson)) {
    query['ThingModelJson'] = request.thingModelJson;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateThingModel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateThingModelRequest
 * @return CreateThingModelResponse
 */
async function createThingModel(request: CreateThingModelRequest): CreateThingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createThingModelWithOptions(request, runtime);
}

model CreateThingScriptRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  scriptContent?: string(name='ScriptContent', description='This parameter is required.'),
  scriptType?: string(name='ScriptType', description='This parameter is required.'),
}

model CreateThingScriptResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateThingScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateThingScriptResponseBody(name='body'),
}

/**
 * @param request CreateThingScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateThingScriptResponse
 */
async function createThingScriptWithOptions(request: CreateThingScriptRequest, runtime: Util.RuntimeOptions): CreateThingScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.scriptContent)) {
    query['ScriptContent'] = request.scriptContent;
  }
  if (!Util.isUnset(request.scriptType)) {
    query['ScriptType'] = request.scriptType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateThingScript',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateThingScriptRequest
 * @return CreateThingScriptResponse
 */
async function createThingScript(request: CreateThingScriptRequest): CreateThingScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return createThingScriptWithOptions(request, runtime);
}

model CreateTopicConfigRequest {
  codec?: string(name='Codec'),
  description?: string(name='Description'),
  enableBroadcast?: boolean(name='EnableBroadcast'),
  enableProxySubscribe?: boolean(name='EnableProxySubscribe'),
  iotInstanceId?: string(name='IotInstanceId'),
  operation?: string(name='Operation', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  topicFullName?: string(name='TopicFullName', description='This parameter is required.'),
}

model CreateTopicConfigResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTopicConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTopicConfigResponseBody(name='body'),
}

/**
 * @param request CreateTopicConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTopicConfigResponse
 */
async function createTopicConfigWithOptions(request: CreateTopicConfigRequest, runtime: Util.RuntimeOptions): CreateTopicConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.codec)) {
    query['Codec'] = request.codec;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableBroadcast)) {
    query['EnableBroadcast'] = request.enableBroadcast;
  }
  if (!Util.isUnset(request.enableProxySubscribe)) {
    query['EnableProxySubscribe'] = request.enableProxySubscribe;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.topicFullName)) {
    query['TopicFullName'] = request.topicFullName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTopicConfig',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateTopicConfigRequest
 * @return CreateTopicConfigResponse
 */
async function createTopicConfig(request: CreateTopicConfigRequest): CreateTopicConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTopicConfigWithOptions(request, runtime);
}

model CreateTopicRouteTableRequest {
  dstTopic?: [ string ](name='DstTopic', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  srcTopic?: string(name='SrcTopic', description='This parameter is required.'),
}

model CreateTopicRouteTableResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  failureTopics?: {
    topic?: [  map[string]any ](name='Topic')
  }(name='FailureTopics'),
  isAllSucceed?: boolean(name='IsAllSucceed'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTopicRouteTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTopicRouteTableResponseBody(name='body'),
}

/**
 * @param request CreateTopicRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTopicRouteTableResponse
 */
async function createTopicRouteTableWithOptions(request: CreateTopicRouteTableRequest, runtime: Util.RuntimeOptions): CreateTopicRouteTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dstTopic)) {
    query['DstTopic'] = request.dstTopic;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.srcTopic)) {
    query['SrcTopic'] = request.srcTopic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTopicRouteTable',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateTopicRouteTableRequest
 * @return CreateTopicRouteTableResponse
 */
async function createTopicRouteTable(request: CreateTopicRouteTableRequest): CreateTopicRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTopicRouteTableWithOptions(request, runtime);
}

model DeleteClientIdsRequest {
  iotId?: string(name='IotId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteClientIdsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteClientIdsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClientIdsResponseBody(name='body'),
}

/**
 * @param request DeleteClientIdsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteClientIdsResponse
 */
async function deleteClientIdsWithOptions(request: DeleteClientIdsRequest, runtime: Util.RuntimeOptions): DeleteClientIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClientIds',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteClientIdsRequest
 * @return DeleteClientIdsResponse
 */
async function deleteClientIds(request: DeleteClientIdsRequest): DeleteClientIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClientIdsWithOptions(request, runtime);
}

model DeleteConsumerGroupRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteConsumerGroupResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConsumerGroupResponseBody(name='body'),
}

/**
 * @param request DeleteConsumerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConsumerGroupResponse
 */
async function deleteConsumerGroupWithOptions(request: DeleteConsumerGroupRequest, runtime: Util.RuntimeOptions): DeleteConsumerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConsumerGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteConsumerGroupRequest
 * @return DeleteConsumerGroupResponse
 */
async function deleteConsumerGroup(request: DeleteConsumerGroupRequest): DeleteConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConsumerGroupWithOptions(request, runtime);
}

model DeleteConsumerGroupSubscribeRelationRequest {
  consumerGroupId?: string(name='ConsumerGroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model DeleteConsumerGroupSubscribeRelationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteConsumerGroupSubscribeRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConsumerGroupSubscribeRelationResponseBody(name='body'),
}

/**
 * @param request DeleteConsumerGroupSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConsumerGroupSubscribeRelationResponse
 */
async function deleteConsumerGroupSubscribeRelationWithOptions(request: DeleteConsumerGroupSubscribeRelationRequest, runtime: Util.RuntimeOptions): DeleteConsumerGroupSubscribeRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consumerGroupId)) {
    query['ConsumerGroupId'] = request.consumerGroupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConsumerGroupSubscribeRelation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteConsumerGroupSubscribeRelationRequest
 * @return DeleteConsumerGroupSubscribeRelationResponse
 */
async function deleteConsumerGroupSubscribeRelation(request: DeleteConsumerGroupSubscribeRelationRequest): DeleteConsumerGroupSubscribeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConsumerGroupSubscribeRelationWithOptions(request, runtime);
}

model DeleteDataSourceItemRequest {
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  dataSourceItemId?: long(name='DataSourceItemId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteDataSourceItemResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDataSourceItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataSourceItemResponseBody(name='body'),
}

/**
 * @param request DeleteDataSourceItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDataSourceItemResponse
 */
async function deleteDataSourceItemWithOptions(request: DeleteDataSourceItemRequest, runtime: Util.RuntimeOptions): DeleteDataSourceItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.dataSourceItemId)) {
    query['DataSourceItemId'] = request.dataSourceItemId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSourceItem',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDataSourceItemRequest
 * @return DeleteDataSourceItemResponse
 */
async function deleteDataSourceItem(request: DeleteDataSourceItemRequest): DeleteDataSourceItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataSourceItemWithOptions(request, runtime);
}

model DeleteDestinationRequest {
  destinationId?: long(name='DestinationId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteDestinationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDestinationResponseBody(name='body'),
}

/**
 * @param request DeleteDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDestinationResponse
 */
async function deleteDestinationWithOptions(request: DeleteDestinationRequest, runtime: Util.RuntimeOptions): DeleteDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationId)) {
    query['DestinationId'] = request.destinationId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDestination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDestinationRequest
 * @return DeleteDestinationResponse
 */
async function deleteDestination(request: DeleteDestinationRequest): DeleteDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDestinationWithOptions(request, runtime);
}

model DeleteDeviceRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model DeleteDeviceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDeviceResponseBody(name='body'),
}

/**
 * @param request DeleteDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceResponse
 */
async function deleteDeviceWithOptions(request: DeleteDeviceRequest, runtime: Util.RuntimeOptions): DeleteDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDeviceRequest
 * @return DeleteDeviceResponse
 */
async function deleteDevice(request: DeleteDeviceRequest): DeleteDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceWithOptions(request, runtime);
}

model DeleteDeviceDistributeJobRequest {
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model DeleteDeviceDistributeJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDeviceDistributeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDeviceDistributeJobResponseBody(name='body'),
}

/**
 * @param request DeleteDeviceDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceDistributeJobResponse
 */
async function deleteDeviceDistributeJobWithOptions(request: DeleteDeviceDistributeJobRequest, runtime: Util.RuntimeOptions): DeleteDeviceDistributeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceDistributeJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDeviceDistributeJobRequest
 * @return DeleteDeviceDistributeJobResponse
 */
async function deleteDeviceDistributeJob(request: DeleteDeviceDistributeJobRequest): DeleteDeviceDistributeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceDistributeJobWithOptions(request, runtime);
}

model DeleteDeviceDynamicGroupRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
}

model DeleteDeviceDynamicGroupResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDeviceDynamicGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDeviceDynamicGroupResponseBody(name='body'),
}

/**
 * @param request DeleteDeviceDynamicGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceDynamicGroupResponse
 */
async function deleteDeviceDynamicGroupWithOptions(request: DeleteDeviceDynamicGroupRequest, runtime: Util.RuntimeOptions): DeleteDeviceDynamicGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceDynamicGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDeviceDynamicGroupRequest
 * @return DeleteDeviceDynamicGroupResponse
 */
async function deleteDeviceDynamicGroup(request: DeleteDeviceDynamicGroupRequest): DeleteDeviceDynamicGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceDynamicGroupWithOptions(request, runtime);
}

model DeleteDeviceFileRequest {
  deviceName?: string(name='DeviceName'),
  fileId?: string(name='FileId', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model DeleteDeviceFileResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDeviceFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDeviceFileResponseBody(name='body'),
}

/**
 * @param request DeleteDeviceFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceFileResponse
 */
async function deleteDeviceFileWithOptions(request: DeleteDeviceFileRequest, runtime: Util.RuntimeOptions): DeleteDeviceFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.fileId)) {
    query['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceFile',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDeviceFileRequest
 * @return DeleteDeviceFileResponse
 */
async function deleteDeviceFile(request: DeleteDeviceFileRequest): DeleteDeviceFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceFileWithOptions(request, runtime);
}

model DeleteDeviceGroupRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteDeviceGroupResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDeviceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDeviceGroupResponseBody(name='body'),
}

/**
 * @param request DeleteDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceGroupResponse
 */
async function deleteDeviceGroupWithOptions(request: DeleteDeviceGroupRequest, runtime: Util.RuntimeOptions): DeleteDeviceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDeviceGroupRequest
 * @return DeleteDeviceGroupResponse
 */
async function deleteDeviceGroup(request: DeleteDeviceGroupRequest): DeleteDeviceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceGroupWithOptions(request, runtime);
}

model DeleteDevicePropRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  propKey?: string(name='PropKey', description='This parameter is required.'),
}

model DeleteDevicePropResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDevicePropResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDevicePropResponseBody(name='body'),
}

/**
 * @param request DeleteDevicePropRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDevicePropResponse
 */
async function deleteDevicePropWithOptions(request: DeleteDevicePropRequest, runtime: Util.RuntimeOptions): DeleteDevicePropResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.propKey)) {
    query['PropKey'] = request.propKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceProp',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDevicePropRequest
 * @return DeleteDevicePropResponse
 */
async function deleteDeviceProp(request: DeleteDevicePropRequest): DeleteDevicePropResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevicePropWithOptions(request, runtime);
}

model DeleteDeviceSpeechRequest {
  deviceSpeechList?: [ 
    {
      audioFormat?: string(name='AudioFormat', description='This parameter is required.'),
      bizCode?: string(name='BizCode', description='This parameter is required.'),
    }
  ](name='DeviceSpeechList', description='This parameter is required.'),
  iotId?: string(name='IotId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteDeviceSpeechResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDeviceSpeechResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDeviceSpeechResponseBody(name='body'),
}

/**
 * @param request DeleteDeviceSpeechRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceSpeechResponse
 */
async function deleteDeviceSpeechWithOptions(request: DeleteDeviceSpeechRequest, runtime: Util.RuntimeOptions): DeleteDeviceSpeechResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSpeechList)) {
    body['DeviceSpeechList'] = request.deviceSpeechList;
  }
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceSpeech',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDeviceSpeechRequest
 * @return DeleteDeviceSpeechResponse
 */
async function deleteDeviceSpeech(request: DeleteDeviceSpeechRequest): DeleteDeviceSpeechResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceSpeechWithOptions(request, runtime);
}

model DeleteDeviceTunnelRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  tunnelId?: string(name='TunnelId', description='This parameter is required.'),
}

model DeleteDeviceTunnelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDeviceTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDeviceTunnelResponseBody(name='body'),
}

/**
 * @param request DeleteDeviceTunnelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceTunnelResponse
 */
async function deleteDeviceTunnelWithOptions(request: DeleteDeviceTunnelRequest, runtime: Util.RuntimeOptions): DeleteDeviceTunnelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.tunnelId)) {
    query['TunnelId'] = request.tunnelId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceTunnel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDeviceTunnelRequest
 * @return DeleteDeviceTunnelResponse
 */
async function deleteDeviceTunnel(request: DeleteDeviceTunnelRequest): DeleteDeviceTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceTunnelWithOptions(request, runtime);
}

model DeleteEdgeDriverRequest {
  driverId?: string(name='DriverId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteEdgeDriverResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEdgeDriverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEdgeDriverResponseBody(name='body'),
}

/**
 * @param request DeleteEdgeDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEdgeDriverResponse
 */
async function deleteEdgeDriverWithOptions(request: DeleteEdgeDriverRequest, runtime: Util.RuntimeOptions): DeleteEdgeDriverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEdgeDriver',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteEdgeDriverRequest
 * @return DeleteEdgeDriverResponse
 */
async function deleteEdgeDriver(request: DeleteEdgeDriverRequest): DeleteEdgeDriverResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEdgeDriverWithOptions(request, runtime);
}

model DeleteEdgeDriverVersionRequest {
  driverId?: string(name='DriverId', description='This parameter is required.'),
  driverVersion?: string(name='DriverVersion', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteEdgeDriverVersionResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEdgeDriverVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEdgeDriverVersionResponseBody(name='body'),
}

/**
 * @param request DeleteEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEdgeDriverVersionResponse
 */
async function deleteEdgeDriverVersionWithOptions(request: DeleteEdgeDriverVersionRequest, runtime: Util.RuntimeOptions): DeleteEdgeDriverVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.driverVersion)) {
    query['DriverVersion'] = request.driverVersion;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEdgeDriverVersion',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteEdgeDriverVersionRequest
 * @return DeleteEdgeDriverVersionResponse
 */
async function deleteEdgeDriverVersion(request: DeleteEdgeDriverVersionRequest): DeleteEdgeDriverVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEdgeDriverVersionWithOptions(request, runtime);
}

model DeleteEdgeInstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request DeleteEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEdgeInstanceResponse
 */
async function deleteEdgeInstanceWithOptions(request: DeleteEdgeInstanceRequest, runtime: Util.RuntimeOptions): DeleteEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteEdgeInstanceRequest
 * @return DeleteEdgeInstanceResponse
 */
async function deleteEdgeInstance(request: DeleteEdgeInstanceRequest): DeleteEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEdgeInstanceWithOptions(request, runtime);
}

model DeleteEdgeInstanceMessageRoutingRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  routeId?: long(name='RouteId', description='This parameter is required.'),
}

model DeleteEdgeInstanceMessageRoutingResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEdgeInstanceMessageRoutingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEdgeInstanceMessageRoutingResponseBody(name='body'),
}

/**
 * @param request DeleteEdgeInstanceMessageRoutingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEdgeInstanceMessageRoutingResponse
 */
async function deleteEdgeInstanceMessageRoutingWithOptions(request: DeleteEdgeInstanceMessageRoutingRequest, runtime: Util.RuntimeOptions): DeleteEdgeInstanceMessageRoutingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.routeId)) {
    query['RouteId'] = request.routeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEdgeInstanceMessageRouting',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteEdgeInstanceMessageRoutingRequest
 * @return DeleteEdgeInstanceMessageRoutingResponse
 */
async function deleteEdgeInstanceMessageRouting(request: DeleteEdgeInstanceMessageRoutingRequest): DeleteEdgeInstanceMessageRoutingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEdgeInstanceMessageRoutingWithOptions(request, runtime);
}

model DeleteJobRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model DeleteJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteJobResponseBody(name='body'),
}

/**
 * @param request DeleteJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteJobResponse
 */
async function deleteJobWithOptions(request: DeleteJobRequest, runtime: Util.RuntimeOptions): DeleteJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteJobRequest
 * @return DeleteJobResponse
 */
async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobWithOptions(request, runtime);
}

model DeleteOTAFirmwareRequest {
  firmwareId?: string(name='FirmwareId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteOTAFirmwareResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteOTAFirmwareResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteOTAFirmwareResponseBody(name='body'),
}

/**
 * @param request DeleteOTAFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOTAFirmwareResponse
 */
async function deleteOTAFirmwareWithOptions(request: DeleteOTAFirmwareRequest, runtime: Util.RuntimeOptions): DeleteOTAFirmwareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.firmwareId)) {
    query['FirmwareId'] = request.firmwareId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOTAFirmware',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteOTAFirmwareRequest
 * @return DeleteOTAFirmwareResponse
 */
async function deleteOTAFirmware(request: DeleteOTAFirmwareRequest): DeleteOTAFirmwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOTAFirmwareWithOptions(request, runtime);
}

model DeleteOTAModuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  moduleName?: string(name='ModuleName', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model DeleteOTAModuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteOTAModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteOTAModuleResponseBody(name='body'),
}

/**
 * @param request DeleteOTAModuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOTAModuleResponse
 */
async function deleteOTAModuleWithOptions(request: DeleteOTAModuleRequest, runtime: Util.RuntimeOptions): DeleteOTAModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOTAModule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteOTAModuleRequest
 * @return DeleteOTAModuleResponse
 */
async function deleteOTAModule(request: DeleteOTAModuleRequest): DeleteOTAModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOTAModuleWithOptions(request, runtime);
}

model DeleteParserRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model DeleteParserResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteParserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteParserResponseBody(name='body'),
}

/**
 * @param request DeleteParserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteParserResponse
 */
async function deleteParserWithOptions(request: DeleteParserRequest, runtime: Util.RuntimeOptions): DeleteParserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteParser',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteParserRequest
 * @return DeleteParserResponse
 */
async function deleteParser(request: DeleteParserRequest): DeleteParserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteParserWithOptions(request, runtime);
}

model DeleteParserDataSourceRequest {
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteParserDataSourceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteParserDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteParserDataSourceResponseBody(name='body'),
}

/**
 * @param request DeleteParserDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteParserDataSourceResponse
 */
async function deleteParserDataSourceWithOptions(request: DeleteParserDataSourceRequest, runtime: Util.RuntimeOptions): DeleteParserDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteParserDataSource',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteParserDataSourceRequest
 * @return DeleteParserDataSourceResponse
 */
async function deleteParserDataSource(request: DeleteParserDataSourceRequest): DeleteParserDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteParserDataSourceWithOptions(request, runtime);
}

model DeletePowerStationRequest {
  algorithmInstanceUid?: string(name='AlgorithmInstanceUid', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  powerStationUid?: string(name='PowerStationUid', description='This parameter is required.'),
}

model DeletePowerStationResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePowerStationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePowerStationResponseBody(name='body'),
}

/**
 * @param request DeletePowerStationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePowerStationResponse
 */
async function deletePowerStationWithOptions(request: DeletePowerStationRequest, runtime: Util.RuntimeOptions): DeletePowerStationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithmInstanceUid)) {
    query['AlgorithmInstanceUid'] = request.algorithmInstanceUid;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.powerStationUid)) {
    query['PowerStationUid'] = request.powerStationUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePowerStation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeletePowerStationRequest
 * @return DeletePowerStationResponse
 */
async function deletePowerStation(request: DeletePowerStationRequest): DeletePowerStationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePowerStationWithOptions(request, runtime);
}

model DeleteProductRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model DeleteProductResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteProductResponseBody(name='body'),
}

/**
 * @param request DeleteProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProductResponse
 */
async function deleteProductWithOptions(request: DeleteProductRequest, runtime: Util.RuntimeOptions): DeleteProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteProductRequest
 * @return DeleteProductResponse
 */
async function deleteProduct(request: DeleteProductRequest): DeleteProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProductWithOptions(request, runtime);
}

model DeleteProductTagsRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  productTagKey?: [ string ](name='ProductTagKey', description='This parameter is required.'),
}

model DeleteProductTagsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteProductTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteProductTagsResponseBody(name='body'),
}

/**
 * @param request DeleteProductTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProductTagsResponse
 */
async function deleteProductTagsWithOptions(request: DeleteProductTagsRequest, runtime: Util.RuntimeOptions): DeleteProductTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.productTagKey)) {
    query['ProductTagKey'] = request.productTagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductTags',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteProductTagsRequest
 * @return DeleteProductTagsResponse
 */
async function deleteProductTags(request: DeleteProductTagsRequest): DeleteProductTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProductTagsWithOptions(request, runtime);
}

model DeleteProductTopicRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  topicId?: string(name='TopicId', description='This parameter is required.'),
}

model DeleteProductTopicResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteProductTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteProductTopicResponseBody(name='body'),
}

/**
 * @param request DeleteProductTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProductTopicResponse
 */
async function deleteProductTopicWithOptions(request: DeleteProductTopicRequest, runtime: Util.RuntimeOptions): DeleteProductTopicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.topicId)) {
    query['TopicId'] = request.topicId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProductTopic',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteProductTopicRequest
 * @return DeleteProductTopicResponse
 */
async function deleteProductTopic(request: DeleteProductTopicRequest): DeleteProductTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProductTopicWithOptions(request, runtime);
}

model DeleteRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
}

model DeleteRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRuleResponseBody(name='body'),
}

/**
 * @param request DeleteRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRuleResponse
 */
async function deleteRuleWithOptions(request: DeleteRuleRequest, runtime: Util.RuntimeOptions): DeleteRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteRuleRequest
 * @return DeleteRuleResponse
 */
async function deleteRule(request: DeleteRuleRequest): DeleteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRuleWithOptions(request, runtime);
}

model DeleteRuleActionRequest {
  actionId?: long(name='ActionId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model DeleteRuleActionResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteRuleActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRuleActionResponseBody(name='body'),
}

/**
 * @param request DeleteRuleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRuleActionResponse
 */
async function deleteRuleActionWithOptions(request: DeleteRuleActionRequest, runtime: Util.RuntimeOptions): DeleteRuleActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionId)) {
    query['ActionId'] = request.actionId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRuleAction',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteRuleActionRequest
 * @return DeleteRuleActionResponse
 */
async function deleteRuleAction(request: DeleteRuleActionRequest): DeleteRuleActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRuleActionWithOptions(request, runtime);
}

model DeleteSceneRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
}

model DeleteSceneRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSceneRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSceneRuleResponseBody(name='body'),
}

/**
 * @param request DeleteSceneRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSceneRuleResponse
 */
async function deleteSceneRuleWithOptions(request: DeleteSceneRuleRequest, runtime: Util.RuntimeOptions): DeleteSceneRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSceneRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSceneRuleRequest
 * @return DeleteSceneRuleResponse
 */
async function deleteSceneRule(request: DeleteSceneRuleRequest): DeleteSceneRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSceneRuleWithOptions(request, runtime);
}

model DeleteSchedulePeriodRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  periodCode?: string(name='PeriodCode', description='This parameter is required.'),
}

model DeleteSchedulePeriodResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSchedulePeriodResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSchedulePeriodResponseBody(name='body'),
}

/**
 * @param request DeleteSchedulePeriodRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSchedulePeriodResponse
 */
async function deleteSchedulePeriodWithOptions(request: DeleteSchedulePeriodRequest, runtime: Util.RuntimeOptions): DeleteSchedulePeriodResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.periodCode)) {
    body['PeriodCode'] = request.periodCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSchedulePeriod',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSchedulePeriodRequest
 * @return DeleteSchedulePeriodResponse
 */
async function deleteSchedulePeriod(request: DeleteSchedulePeriodRequest): DeleteSchedulePeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSchedulePeriodWithOptions(request, runtime);
}

model DeleteShareTaskDeviceRequest {
  iotIdList?: [ string ](name='IotIdList'),
  iotInstanceId?: string(name='IotInstanceId'),
  shareTaskId?: string(name='ShareTaskId', description='This parameter is required.'),
}

model DeleteShareTaskDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    progress?: int32(name='Progress'),
    progressId?: string(name='ProgressId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteShareTaskDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteShareTaskDeviceResponseBody(name='body'),
}

/**
 * @param request DeleteShareTaskDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteShareTaskDeviceResponse
 */
async function deleteShareTaskDeviceWithOptions(request: DeleteShareTaskDeviceRequest, runtime: Util.RuntimeOptions): DeleteShareTaskDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotIdList)) {
    body['IotIdList'] = request.iotIdList;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.shareTaskId)) {
    body['ShareTaskId'] = request.shareTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteShareTaskDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteShareTaskDeviceRequest
 * @return DeleteShareTaskDeviceResponse
 */
async function deleteShareTaskDevice(request: DeleteShareTaskDeviceRequest): DeleteShareTaskDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteShareTaskDeviceWithOptions(request, runtime);
}

model DeleteSoundCodeRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  soundCode?: string(name='SoundCode', description='This parameter is required.'),
}

model DeleteSoundCodeResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSoundCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSoundCodeResponseBody(name='body'),
}

/**
 * @param request DeleteSoundCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSoundCodeResponse
 */
async function deleteSoundCodeWithOptions(request: DeleteSoundCodeRequest, runtime: Util.RuntimeOptions): DeleteSoundCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.soundCode)) {
    body['SoundCode'] = request.soundCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSoundCode',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSoundCodeRequest
 * @return DeleteSoundCodeResponse
 */
async function deleteSoundCode(request: DeleteSoundCodeRequest): DeleteSoundCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSoundCodeWithOptions(request, runtime);
}

model DeleteSoundCodeLabelRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  soundCode?: string(name='SoundCode', description='This parameter is required.'),
}

model DeleteSoundCodeLabelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSoundCodeLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSoundCodeLabelResponseBody(name='body'),
}

/**
 * @param request DeleteSoundCodeLabelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSoundCodeLabelResponse
 */
async function deleteSoundCodeLabelWithOptions(request: DeleteSoundCodeLabelRequest, runtime: Util.RuntimeOptions): DeleteSoundCodeLabelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.soundCode)) {
    body['SoundCode'] = request.soundCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSoundCodeLabel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSoundCodeLabelRequest
 * @return DeleteSoundCodeLabelResponse
 */
async function deleteSoundCodeLabel(request: DeleteSoundCodeLabelRequest): DeleteSoundCodeLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSoundCodeLabelWithOptions(request, runtime);
}

model DeleteSoundCodeScheduleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
}

model DeleteSoundCodeScheduleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSoundCodeScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSoundCodeScheduleResponseBody(name='body'),
}

/**
 * @param request DeleteSoundCodeScheduleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSoundCodeScheduleResponse
 */
async function deleteSoundCodeScheduleWithOptions(request: DeleteSoundCodeScheduleRequest, runtime: Util.RuntimeOptions): DeleteSoundCodeScheduleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSoundCodeSchedule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSoundCodeScheduleRequest
 * @return DeleteSoundCodeScheduleResponse
 */
async function deleteSoundCodeSchedule(request: DeleteSoundCodeScheduleRequest): DeleteSoundCodeScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSoundCodeScheduleWithOptions(request, runtime);
}

model DeleteSpeechRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  speechCodeList?: [ string ](name='SpeechCodeList', description='This parameter is required.'),
}

model DeleteSpeechResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSpeechResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSpeechResponseBody(name='body'),
}

/**
 * @param request DeleteSpeechRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSpeechResponse
 */
async function deleteSpeechWithOptions(request: DeleteSpeechRequest, runtime: Util.RuntimeOptions): DeleteSpeechResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.speechCodeList)) {
    body['SpeechCodeList'] = request.speechCodeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSpeech',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSpeechRequest
 * @return DeleteSpeechResponse
 */
async function deleteSpeech(request: DeleteSpeechRequest): DeleteSpeechResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSpeechWithOptions(request, runtime);
}

model DeleteStudioAppDomainOpenRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  domainId?: int32(name='DomainId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model DeleteStudioAppDomainOpenResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteStudioAppDomainOpenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteStudioAppDomainOpenResponseBody(name='body'),
}

/**
 * @param request DeleteStudioAppDomainOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteStudioAppDomainOpenResponse
 */
async function deleteStudioAppDomainOpenWithOptions(request: DeleteStudioAppDomainOpenRequest, runtime: Util.RuntimeOptions): DeleteStudioAppDomainOpenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.domainId)) {
    body['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteStudioAppDomainOpen',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteStudioAppDomainOpenRequest
 * @return DeleteStudioAppDomainOpenResponse
 */
async function deleteStudioAppDomainOpen(request: DeleteStudioAppDomainOpenRequest): DeleteStudioAppDomainOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStudioAppDomainOpenWithOptions(request, runtime);
}

model DeleteSubscribeRelationRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model DeleteSubscribeRelationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSubscribeRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSubscribeRelationResponseBody(name='body'),
}

/**
 * @param request DeleteSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSubscribeRelationResponse
 */
async function deleteSubscribeRelationWithOptions(request: DeleteSubscribeRelationRequest, runtime: Util.RuntimeOptions): DeleteSubscribeRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSubscribeRelation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSubscribeRelationRequest
 * @return DeleteSubscribeRelationResponse
 */
async function deleteSubscribeRelation(request: DeleteSubscribeRelationRequest): DeleteSubscribeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSubscribeRelationWithOptions(request, runtime);
}

model DeleteThingModelRequest {
  eventIdentifier?: [ string ](name='EventIdentifier'),
  functionBlockId?: string(name='FunctionBlockId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  propertyIdentifier?: [ string ](name='PropertyIdentifier'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serviceIdentifier?: [ string ](name='ServiceIdentifier'),
}

model DeleteThingModelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteThingModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteThingModelResponseBody(name='body'),
}

/**
 * @param request DeleteThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteThingModelResponse
 */
async function deleteThingModelWithOptions(request: DeleteThingModelRequest, runtime: Util.RuntimeOptions): DeleteThingModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventIdentifier)) {
    query['EventIdentifier'] = request.eventIdentifier;
  }
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.propertyIdentifier)) {
    query['PropertyIdentifier'] = request.propertyIdentifier;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.serviceIdentifier)) {
    query['ServiceIdentifier'] = request.serviceIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteThingModel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteThingModelRequest
 * @return DeleteThingModelResponse
 */
async function deleteThingModel(request: DeleteThingModelRequest): DeleteThingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteThingModelWithOptions(request, runtime);
}

model DeleteTopicConfigRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  topicFullName?: string(name='TopicFullName', description='This parameter is required.'),
}

model DeleteTopicConfigResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTopicConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTopicConfigResponseBody(name='body'),
}

/**
 * @param request DeleteTopicConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTopicConfigResponse
 */
async function deleteTopicConfigWithOptions(request: DeleteTopicConfigRequest, runtime: Util.RuntimeOptions): DeleteTopicConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.topicFullName)) {
    query['TopicFullName'] = request.topicFullName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTopicConfig',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteTopicConfigRequest
 * @return DeleteTopicConfigResponse
 */
async function deleteTopicConfig(request: DeleteTopicConfigRequest): DeleteTopicConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTopicConfigWithOptions(request, runtime);
}

model DeleteTopicRouteTableRequest {
  dstTopic?: [ string ](name='DstTopic', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  srcTopic?: string(name='SrcTopic', description='This parameter is required.'),
}

model DeleteTopicRouteTableResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  failureTopics?: {
    topic?: [  map[string]any ](name='Topic')
  }(name='FailureTopics'),
  isAllSucceed?: boolean(name='IsAllSucceed'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTopicRouteTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTopicRouteTableResponseBody(name='body'),
}

/**
 * @param request DeleteTopicRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTopicRouteTableResponse
 */
async function deleteTopicRouteTableWithOptions(request: DeleteTopicRouteTableRequest, runtime: Util.RuntimeOptions): DeleteTopicRouteTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dstTopic)) {
    query['DstTopic'] = request.dstTopic;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.srcTopic)) {
    query['SrcTopic'] = request.srcTopic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTopicRouteTable',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteTopicRouteTableRequest
 * @return DeleteTopicRouteTableResponse
 */
async function deleteTopicRouteTable(request: DeleteTopicRouteTableRequest): DeleteTopicRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTopicRouteTableWithOptions(request, runtime);
}

model DeleteUserDefineTableDataByPrimaryKeyRequest {
  conditions?: map[string]any(name='Conditions', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  tableIdentifier?: string(name='TableIdentifier', description='This parameter is required.'),
}

model DeleteUserDefineTableDataByPrimaryKeyShrinkRequest {
  conditionsShrink?: string(name='Conditions', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  tableIdentifier?: string(name='TableIdentifier', description='This parameter is required.'),
}

model DeleteUserDefineTableDataByPrimaryKeyResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteUserDefineTableDataByPrimaryKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUserDefineTableDataByPrimaryKeyResponseBody(name='body'),
}

/**
 * @param tmpReq DeleteUserDefineTableDataByPrimaryKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUserDefineTableDataByPrimaryKeyResponse
 */
async function deleteUserDefineTableDataByPrimaryKeyWithOptions(tmpReq: DeleteUserDefineTableDataByPrimaryKeyRequest, runtime: Util.RuntimeOptions): DeleteUserDefineTableDataByPrimaryKeyResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteUserDefineTableDataByPrimaryKeyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.conditions)) {
    request.conditionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.conditions, 'Conditions', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.conditionsShrink)) {
    query['Conditions'] = request.conditionsShrink;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.tableIdentifier)) {
    query['TableIdentifier'] = request.tableIdentifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserDefineTableDataByPrimaryKey',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteUserDefineTableDataByPrimaryKeyRequest
 * @return DeleteUserDefineTableDataByPrimaryKeyResponse
 */
async function deleteUserDefineTableDataByPrimaryKey(request: DeleteUserDefineTableDataByPrimaryKeyRequest): DeleteUserDefineTableDataByPrimaryKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserDefineTableDataByPrimaryKeyWithOptions(request, runtime);
}

model DetachDestinationRequest {
  destinationId?: long(name='DestinationId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model DetachDestinationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DetachDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DetachDestinationResponseBody(name='body'),
}

/**
 * @param request DetachDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachDestinationResponse
 */
async function detachDestinationWithOptions(request: DetachDestinationRequest, runtime: Util.RuntimeOptions): DetachDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationId)) {
    query['DestinationId'] = request.destinationId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachDestination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DetachDestinationRequest
 * @return DetachDestinationResponse
 */
async function detachDestination(request: DetachDestinationRequest): DetachDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDestinationWithOptions(request, runtime);
}

model DetachParserDataSourceRequest {
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model DetachParserDataSourceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DetachParserDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DetachParserDataSourceResponseBody(name='body'),
}

/**
 * @param request DetachParserDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachParserDataSourceResponse
 */
async function detachParserDataSourceWithOptions(request: DetachParserDataSourceRequest, runtime: Util.RuntimeOptions): DetachParserDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachParserDataSource',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DetachParserDataSourceRequest
 * @return DetachParserDataSourceResponse
 */
async function detachParserDataSource(request: DetachParserDataSourceRequest): DetachParserDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachParserDataSourceWithOptions(request, runtime);
}

model DisableDeviceTunnelRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model DisableDeviceTunnelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableDeviceTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableDeviceTunnelResponseBody(name='body'),
}

/**
 * @param request DisableDeviceTunnelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableDeviceTunnelResponse
 */
async function disableDeviceTunnelWithOptions(request: DisableDeviceTunnelRequest, runtime: Util.RuntimeOptions): DisableDeviceTunnelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableDeviceTunnel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DisableDeviceTunnelRequest
 * @return DisableDeviceTunnelResponse
 */
async function disableDeviceTunnel(request: DisableDeviceTunnelRequest): DisableDeviceTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDeviceTunnelWithOptions(request, runtime);
}

model DisableDeviceTunnelShareRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model DisableDeviceTunnelShareResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableDeviceTunnelShareResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableDeviceTunnelShareResponseBody(name='body'),
}

/**
 * @param request DisableDeviceTunnelShareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableDeviceTunnelShareResponse
 */
async function disableDeviceTunnelShareWithOptions(request: DisableDeviceTunnelShareRequest, runtime: Util.RuntimeOptions): DisableDeviceTunnelShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableDeviceTunnelShare',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DisableDeviceTunnelShareRequest
 * @return DisableDeviceTunnelShareResponse
 */
async function disableDeviceTunnelShare(request: DisableDeviceTunnelShareRequest): DisableDeviceTunnelShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDeviceTunnelShareWithOptions(request, runtime);
}

model DisableSceneRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
}

model DisableSceneRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableSceneRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableSceneRuleResponseBody(name='body'),
}

/**
 * @param request DisableSceneRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableSceneRuleResponse
 */
async function disableSceneRuleWithOptions(request: DisableSceneRuleRequest, runtime: Util.RuntimeOptions): DisableSceneRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableSceneRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DisableSceneRuleRequest
 * @return DisableSceneRuleResponse
 */
async function disableSceneRule(request: DisableSceneRuleRequest): DisableSceneRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableSceneRuleWithOptions(request, runtime);
}

model DisableThingRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model DisableThingResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableThingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableThingResponseBody(name='body'),
}

/**
 * @param request DisableThingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableThingResponse
 */
async function disableThingWithOptions(request: DisableThingRequest, runtime: Util.RuntimeOptions): DisableThingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableThing',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DisableThingRequest
 * @return DisableThingResponse
 */
async function disableThing(request: DisableThingRequest): DisableThingResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableThingWithOptions(request, runtime);
}

model EnableDeviceTunnelRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model EnableDeviceTunnelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableDeviceTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableDeviceTunnelResponseBody(name='body'),
}

/**
 * @param request EnableDeviceTunnelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableDeviceTunnelResponse
 */
async function enableDeviceTunnelWithOptions(request: EnableDeviceTunnelRequest, runtime: Util.RuntimeOptions): EnableDeviceTunnelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableDeviceTunnel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request EnableDeviceTunnelRequest
 * @return EnableDeviceTunnelResponse
 */
async function enableDeviceTunnel(request: EnableDeviceTunnelRequest): EnableDeviceTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableDeviceTunnelWithOptions(request, runtime);
}

model EnableDeviceTunnelShareRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model EnableDeviceTunnelShareResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableDeviceTunnelShareResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableDeviceTunnelShareResponseBody(name='body'),
}

/**
 * @param request EnableDeviceTunnelShareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableDeviceTunnelShareResponse
 */
async function enableDeviceTunnelShareWithOptions(request: EnableDeviceTunnelShareRequest, runtime: Util.RuntimeOptions): EnableDeviceTunnelShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableDeviceTunnelShare',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request EnableDeviceTunnelShareRequest
 * @return EnableDeviceTunnelShareResponse
 */
async function enableDeviceTunnelShare(request: EnableDeviceTunnelShareRequest): EnableDeviceTunnelShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableDeviceTunnelShareWithOptions(request, runtime);
}

model EnableSceneRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
}

model EnableSceneRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableSceneRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableSceneRuleResponseBody(name='body'),
}

/**
 * @param request EnableSceneRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableSceneRuleResponse
 */
async function enableSceneRuleWithOptions(request: EnableSceneRuleRequest, runtime: Util.RuntimeOptions): EnableSceneRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableSceneRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request EnableSceneRuleRequest
 * @return EnableSceneRuleResponse
 */
async function enableSceneRule(request: EnableSceneRuleRequest): EnableSceneRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSceneRuleWithOptions(request, runtime);
}

model EnableThingRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model EnableThingResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableThingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableThingResponseBody(name='body'),
}

/**
 * @param request EnableThingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableThingResponse
 */
async function enableThingWithOptions(request: EnableThingRequest, runtime: Util.RuntimeOptions): EnableThingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableThing',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request EnableThingRequest
 * @return EnableThingResponse
 */
async function enableThing(request: EnableThingRequest): EnableThingResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableThingWithOptions(request, runtime);
}

model GenerateDeviceNameListURLRequest {
  iotInstanceId?: string(name='IotInstanceId'),
}

model GenerateDeviceNameListURLResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    fileUrl?: string(name='FileUrl'),
    host?: string(name='Host'),
    key?: string(name='Key'),
    objectStorage?: string(name='ObjectStorage'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
    utcCreate?: string(name='UtcCreate'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateDeviceNameListURLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateDeviceNameListURLResponseBody(name='body'),
}

/**
 * @param request GenerateDeviceNameListURLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateDeviceNameListURLResponse
 */
async function generateDeviceNameListURLWithOptions(request: GenerateDeviceNameListURLRequest, runtime: Util.RuntimeOptions): GenerateDeviceNameListURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateDeviceNameListURL',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GenerateDeviceNameListURLRequest
 * @return GenerateDeviceNameListURLResponse
 */
async function generateDeviceNameListURL(request: GenerateDeviceNameListURLRequest): GenerateDeviceNameListURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateDeviceNameListURLWithOptions(request, runtime);
}

model GenerateFileUploadURLRequest {
  bizCode?: string(name='BizCode', description='This parameter is required.'),
  fileName?: string(name='FileName'),
  fileSuffix?: string(name='FileSuffix', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GenerateFileUploadURLResponseBody = {
  code?: string(name='Code'),
  data?: {
    host?: string(name='Host'),
    key?: string(name='Key'),
    objectStorage?: string(name='ObjectStorage'),
    ossAccessKeyId?: string(name='OssAccessKeyId'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateFileUploadURLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateFileUploadURLResponseBody(name='body'),
}

/**
 * @param request GenerateFileUploadURLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateFileUploadURLResponse
 */
async function generateFileUploadURLWithOptions(request: GenerateFileUploadURLRequest, runtime: Util.RuntimeOptions): GenerateFileUploadURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizCode)) {
    query['BizCode'] = request.bizCode;
  }
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileSuffix)) {
    query['FileSuffix'] = request.fileSuffix;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateFileUploadURL',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GenerateFileUploadURLRequest
 * @return GenerateFileUploadURLResponse
 */
async function generateFileUploadURL(request: GenerateFileUploadURLRequest): GenerateFileUploadURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateFileUploadURLWithOptions(request, runtime);
}

model GenerateOTAUploadURLRequest {
  fileSuffix?: string(name='FileSuffix'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GenerateOTAUploadURLResponseBody = {
  code?: string(name='Code'),
  data?: {
    firmwareUrl?: string(name='FirmwareUrl'),
    host?: string(name='Host'),
    key?: string(name='Key'),
    OSSAccessKeyId?: string(name='OSSAccessKeyId'),
    objectStorage?: string(name='ObjectStorage'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
    utcCreate?: string(name='UtcCreate'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateOTAUploadURLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateOTAUploadURLResponseBody(name='body'),
}

/**
 * @param request GenerateOTAUploadURLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateOTAUploadURLResponse
 */
async function generateOTAUploadURLWithOptions(request: GenerateOTAUploadURLRequest, runtime: Util.RuntimeOptions): GenerateOTAUploadURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileSuffix)) {
    query['FileSuffix'] = request.fileSuffix;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateOTAUploadURL',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GenerateOTAUploadURLRequest
 * @return GenerateOTAUploadURLResponse
 */
async function generateOTAUploadURL(request: GenerateOTAUploadURLRequest): GenerateOTAUploadURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateOTAUploadURLWithOptions(request, runtime);
}

model GetDataAPIServiceDetailRequest {
  apiSrn?: string(name='ApiSrn', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GetDataAPIServiceDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    apiPath?: string(name='ApiPath'),
    apiSrn?: string(name='ApiSrn'),
    createTime?: long(name='CreateTime'),
    dateFormat?: string(name='DateFormat'),
    description?: string(name='Description'),
    displayName?: string(name='DisplayName'),
    lastUpdateTime?: long(name='LastUpdateTime'),
    requestMethod?: string(name='RequestMethod'),
    requestProtocol?: string(name='RequestProtocol'),
    sqlTemplateDTO?: {
      originSql?: string(name='OriginSql'),
      requestParams?: {
        requestParams?: [ 
        {
          desc?: string(name='Desc'),
          example?: string(name='Example'),
          name?: string(name='Name'),
          required?: boolean(name='Required'),
          type?: string(name='Type'),
        }
      ](name='RequestParams')
      }(name='RequestParams'),
      responseParams?: {
        responseParams?: [ 
        {
          desc?: string(name='Desc'),
          example?: string(name='Example'),
          name?: string(name='Name'),
          required?: boolean(name='Required'),
          type?: string(name='Type'),
        }
      ](name='ResponseParams')
      }(name='ResponseParams'),
      templateSql?: string(name='TemplateSql'),
    }(name='SqlTemplateDTO'),
    status?: int32(name='Status'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataAPIServiceDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDataAPIServiceDetailResponseBody(name='body'),
}

/**
 * @param request GetDataAPIServiceDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataAPIServiceDetailResponse
 */
async function getDataAPIServiceDetailWithOptions(request: GetDataAPIServiceDetailRequest, runtime: Util.RuntimeOptions): GetDataAPIServiceDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiSrn)) {
    body['ApiSrn'] = request.apiSrn;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDataAPIServiceDetail',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDataAPIServiceDetailRequest
 * @return GetDataAPIServiceDetailResponse
 */
async function getDataAPIServiceDetail(request: GetDataAPIServiceDetailRequest): GetDataAPIServiceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataAPIServiceDetailWithOptions(request, runtime);
}

model GetDestinationRequest {
  destinationId?: long(name='DestinationId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GetDestinationResponseBody = {
  code?: string(name='Code'),
  destination?: {
    configuration?: string(name='Configuration'),
    destinationId?: string(name='DestinationId'),
    isFailover?: boolean(name='IsFailover'),
    name?: string(name='Name'),
    status?: string(name='Status'),
    type?: string(name='Type'),
    utcCreated?: string(name='UtcCreated'),
  }(name='Destination'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDestinationResponseBody(name='body'),
}

/**
 * @param request GetDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDestinationResponse
 */
async function getDestinationWithOptions(request: GetDestinationRequest, runtime: Util.RuntimeOptions): GetDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationId)) {
    query['DestinationId'] = request.destinationId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDestination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDestinationRequest
 * @return GetDestinationResponse
 */
async function getDestination(request: GetDestinationRequest): GetDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDestinationWithOptions(request, runtime);
}

model GetDeviceShadowRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model GetDeviceShadowResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  shadowMessage?: string(name='ShadowMessage'),
  success?: boolean(name='Success'),
}

model GetDeviceShadowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDeviceShadowResponseBody(name='body'),
}

/**
 * @param request GetDeviceShadowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeviceShadowResponse
 */
async function getDeviceShadowWithOptions(request: GetDeviceShadowRequest, runtime: Util.RuntimeOptions): GetDeviceShadowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceShadow',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDeviceShadowRequest
 * @return GetDeviceShadowResponse
 */
async function getDeviceShadow(request: GetDeviceShadowRequest): GetDeviceShadowResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceShadowWithOptions(request, runtime);
}

model GetDeviceStatusRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model GetDeviceStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    status?: string(name='Status'),
    timestamp?: long(name='Timestamp'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDeviceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDeviceStatusResponseBody(name='body'),
}

/**
 * @param request GetDeviceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeviceStatusResponse
 */
async function getDeviceStatusWithOptions(request: GetDeviceStatusRequest, runtime: Util.RuntimeOptions): GetDeviceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDeviceStatusRequest
 * @return GetDeviceStatusResponse
 */
async function getDeviceStatus(request: GetDeviceStatusRequest): GetDeviceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceStatusWithOptions(request, runtime);
}

model GetDeviceTunnelShareStatusRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model GetDeviceTunnelShareStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    gmtOpened?: long(name='GmtOpened'),
    isOpen?: boolean(name='IsOpen'),
    password?: string(name='Password'),
    shareId?: string(name='ShareId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDeviceTunnelShareStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDeviceTunnelShareStatusResponseBody(name='body'),
}

/**
 * @param request GetDeviceTunnelShareStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeviceTunnelShareStatusResponse
 */
async function getDeviceTunnelShareStatusWithOptions(request: GetDeviceTunnelShareStatusRequest, runtime: Util.RuntimeOptions): GetDeviceTunnelShareStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceTunnelShareStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDeviceTunnelShareStatusRequest
 * @return GetDeviceTunnelShareStatusResponse
 */
async function getDeviceTunnelShareStatus(request: GetDeviceTunnelShareStatusRequest): GetDeviceTunnelShareStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceTunnelShareStatusWithOptions(request, runtime);
}

model GetDeviceTunnelStatusRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model GetDeviceTunnelStatusResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDeviceTunnelStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDeviceTunnelStatusResponseBody(name='body'),
}

/**
 * @param request GetDeviceTunnelStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeviceTunnelStatusResponse
 */
async function getDeviceTunnelStatusWithOptions(request: GetDeviceTunnelStatusRequest, runtime: Util.RuntimeOptions): GetDeviceTunnelStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceTunnelStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDeviceTunnelStatusRequest
 * @return GetDeviceTunnelStatusResponse
 */
async function getDeviceTunnelStatus(request: GetDeviceTunnelStatusRequest): GetDeviceTunnelStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceTunnelStatusWithOptions(request, runtime);
}

model GetDownloadFileRequest {
  context?: map[string]any(name='Context'),
  iotInstanceId?: string(name='IotInstanceId'),
  longJobId?: string(name='LongJobId', description='This parameter is required.'),
}

model GetDownloadFileShrinkRequest {
  contextShrink?: string(name='Context'),
  iotInstanceId?: string(name='IotInstanceId'),
  longJobId?: string(name='LongJobId', description='This parameter is required.'),
}

model GetDownloadFileResponseBody = {
  code?: string(name='Code'),
  data?: {
    asyncExecute?: boolean(name='AsyncExecute'),
    beginTime?: long(name='BeginTime'),
    csvFileName?: string(name='CsvFileName'),
    csvUrl?: string(name='CsvUrl'),
    datasetId?: string(name='DatasetId'),
    endTime?: long(name='EndTime'),
    header?: [ 
      {
        alias?: string(name='Alias'),
        dimDateClass?: string(name='DimDateClass'),
        fieldName?: string(name='FieldName'),
        fieldType?: string(name='FieldType'),
        geoClass?: string(name='GeoClass'),
        timeClass?: string(name='TimeClass'),
        typeClass?: string(name='TypeClass'),
      }
    ](name='Header'),
    longJobId?: string(name='LongJobId'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    previewSize?: int32(name='PreviewSize'),
    querySetting?: {
      astExpr?: [ 
        {
          expr?: string(name='Expr'),
          exprType?: string(name='ExprType'),
        }
      ](name='AstExpr'),
      selectedHeaders?: [ 
        {
          alias?: string(name='Alias'),
          dimDateClass?: string(name='DimDateClass'),
          fieldName?: string(name='FieldName'),
          fieldType?: string(name='FieldType'),
          geoClass?: string(name='GeoClass'),
          timeClass?: string(name='TimeClass'),
        }
      ](name='SelectedHeaders'),
    }(name='QuerySetting'),
    result?: [  map[string]any ](name='Result'),
    resultDataInString?: string(name='ResultDataInString'),
    status?: int32(name='Status'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDownloadFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDownloadFileResponseBody(name='body'),
}

/**
 * @param tmpReq GetDownloadFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDownloadFileResponse
 */
async function getDownloadFileWithOptions(tmpReq: GetDownloadFileRequest, runtime: Util.RuntimeOptions): GetDownloadFileResponse {
  Util.validateModel(tmpReq);
  var request = new GetDownloadFileShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.context)) {
    request.contextShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.context, 'Context', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.longJobId)) {
    query['LongJobId'] = request.longJobId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.contextShrink)) {
    body['Context'] = request.contextShrink;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDownloadFile',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetDownloadFileRequest
 * @return GetDownloadFileResponse
 */
async function getDownloadFile(request: GetDownloadFileRequest): GetDownloadFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDownloadFileWithOptions(request, runtime);
}

model GetEdgeDriverVersionRequest {
  driverId?: string(name='DriverId', description='This parameter is required.'),
  driverVersion?: string(name='DriverVersion', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GetEdgeDriverVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    argument?: string(name='Argument'),
    configCheckRule?: string(name='ConfigCheckRule'),
    containerConfig?: string(name='ContainerConfig'),
    description?: string(name='Description'),
    driverConfig?: string(name='DriverConfig'),
    driverId?: string(name='DriverId'),
    driverVersion?: string(name='DriverVersion'),
    edgeVersion?: string(name='EdgeVersion'),
    gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
    gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
    sourceConfig?: string(name='SourceConfig'),
    versionState?: string(name='VersionState'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEdgeDriverVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeDriverVersionResponseBody(name='body'),
}

/**
 * @param request GetEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEdgeDriverVersionResponse
 */
async function getEdgeDriverVersionWithOptions(request: GetEdgeDriverVersionRequest, runtime: Util.RuntimeOptions): GetEdgeDriverVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.driverVersion)) {
    query['DriverVersion'] = request.driverVersion;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEdgeDriverVersion',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetEdgeDriverVersionRequest
 * @return GetEdgeDriverVersionResponse
 */
async function getEdgeDriverVersion(request: GetEdgeDriverVersionRequest): GetEdgeDriverVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEdgeDriverVersionWithOptions(request, runtime);
}

model GetEdgeInstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GetEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizEnable?: boolean(name='BizEnable'),
    gmtCreate?: string(name='GmtCreate'),
    gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
    gmtModified?: string(name='GmtModified'),
    gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
    instanceId?: string(name='InstanceId'),
    latestDeploymentStatus?: int32(name='LatestDeploymentStatus'),
    latestDeploymentType?: string(name='LatestDeploymentType'),
    name?: string(name='Name'),
    roleArn?: string(name='RoleArn'),
    roleAttachTime?: string(name='RoleAttachTime'),
    roleAttachTimestamp?: long(name='RoleAttachTimestamp'),
    roleName?: string(name='RoleName'),
    spec?: int32(name='Spec'),
    tags?: string(name='Tags'),
    type?: string(name='Type'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request GetEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEdgeInstanceResponse
 */
async function getEdgeInstanceWithOptions(request: GetEdgeInstanceRequest, runtime: Util.RuntimeOptions): GetEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetEdgeInstanceRequest
 * @return GetEdgeInstanceResponse
 */
async function getEdgeInstance(request: GetEdgeInstanceRequest): GetEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEdgeInstanceWithOptions(request, runtime);
}

model GetEdgeInstanceDeploymentRequest {
  deploymentId?: string(name='DeploymentId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GetEdgeInstanceDeploymentResponseBody = {
  code?: string(name='Code'),
  data?: {
    deploymentId?: string(name='DeploymentId'),
    description?: string(name='Description'),
    gmtCompleted?: string(name='GmtCompleted'),
    gmtCompletedTimestamp?: long(name='GmtCompletedTimestamp'),
    gmtCreate?: string(name='GmtCreate'),
    gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
    gmtModified?: string(name='GmtModified'),
    gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
    status?: int32(name='Status'),
    taskList?: [ 
      {
        gatewayId?: string(name='GatewayId'),
        gmtCompleted?: string(name='GmtCompleted'),
        gmtCompletedTimestamp?: long(name='GmtCompletedTimestamp'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
        resourceSnapshotList?: [ 
          {
            gmtCompleted?: string(name='GmtCompleted'),
            gmtCompletedTimestamp?: long(name='GmtCompletedTimestamp'),
            gmtCreate?: string(name='GmtCreate'),
            gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
            gmtModified?: string(name='GmtModified'),
            gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
            log?: string(name='Log'),
            operateType?: int32(name='OperateType'),
            resourceId?: string(name='ResourceId'),
            resourceName?: string(name='ResourceName'),
            resourceType?: string(name='ResourceType'),
            snapshotId?: string(name='SnapshotId'),
            stage?: int32(name='Stage'),
            status?: int32(name='Status'),
          }
        ](name='ResourceSnapshotList'),
        stage?: int32(name='Stage'),
        status?: int32(name='Status'),
        taskId?: string(name='TaskId'),
      }
    ](name='TaskList'),
    type?: string(name='Type'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEdgeInstanceDeploymentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeInstanceDeploymentResponseBody(name='body'),
}

/**
 * @param request GetEdgeInstanceDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEdgeInstanceDeploymentResponse
 */
async function getEdgeInstanceDeploymentWithOptions(request: GetEdgeInstanceDeploymentRequest, runtime: Util.RuntimeOptions): GetEdgeInstanceDeploymentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deploymentId)) {
    query['DeploymentId'] = request.deploymentId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEdgeInstanceDeployment',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetEdgeInstanceDeploymentRequest
 * @return GetEdgeInstanceDeploymentResponse
 */
async function getEdgeInstanceDeployment(request: GetEdgeInstanceDeploymentRequest): GetEdgeInstanceDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEdgeInstanceDeploymentWithOptions(request, runtime);
}

model GetEdgeInstanceMessageRoutingRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  routeId?: long(name='RouteId', description='This parameter is required.'),
}

model GetEdgeInstanceMessageRoutingResponseBody = {
  code?: string(name='Code'),
  data?: {
    gmtCreate?: string(name='GmtCreate'),
    gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
    gmtModified?: string(name='GmtModified'),
    gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
    name?: string(name='Name'),
    routeContext?: {
      qos?: string(name='Qos'),
      sourceApplicationName?: string(name='SourceApplicationName'),
      sourceFcFunctionName?: string(name='SourceFcFunctionName'),
      sourceFcServiceName?: string(name='SourceFcServiceName'),
      targetApplicationName?: string(name='TargetApplicationName'),
      targetFcFunctionName?: string(name='TargetFcFunctionName'),
      targetFcServiceName?: string(name='TargetFcServiceName'),
    }(name='RouteContext'),
    sourceData?: string(name='SourceData'),
    sourceType?: string(name='SourceType'),
    targetData?: string(name='TargetData'),
    targetType?: string(name='TargetType'),
    topicFilter?: string(name='TopicFilter'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEdgeInstanceMessageRoutingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeInstanceMessageRoutingResponseBody(name='body'),
}

/**
 * @param request GetEdgeInstanceMessageRoutingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEdgeInstanceMessageRoutingResponse
 */
async function getEdgeInstanceMessageRoutingWithOptions(request: GetEdgeInstanceMessageRoutingRequest, runtime: Util.RuntimeOptions): GetEdgeInstanceMessageRoutingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.routeId)) {
    query['RouteId'] = request.routeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEdgeInstanceMessageRouting',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetEdgeInstanceMessageRoutingRequest
 * @return GetEdgeInstanceMessageRoutingResponse
 */
async function getEdgeInstanceMessageRouting(request: GetEdgeInstanceMessageRoutingRequest): GetEdgeInstanceMessageRoutingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEdgeInstanceMessageRoutingWithOptions(request, runtime);
}

model GetGatewayBySubDeviceRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model GetGatewayBySubDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceName?: string(name='DeviceName'),
    deviceSecret?: string(name='DeviceSecret'),
    firmwareVersion?: string(name='FirmwareVersion'),
    gmtActive?: string(name='GmtActive'),
    gmtCreate?: string(name='GmtCreate'),
    gmtOnline?: string(name='GmtOnline'),
    ipAddress?: string(name='IpAddress'),
    nodeType?: string(name='NodeType'),
    productKey?: string(name='ProductKey'),
    productName?: string(name='ProductName'),
    status?: string(name='Status'),
    utcActive?: string(name='UtcActive'),
    utcCreate?: string(name='UtcCreate'),
    utcOnline?: string(name='UtcOnline'),
    iotId?: string(name='iotId'),
    region?: string(name='region'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetGatewayBySubDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetGatewayBySubDeviceResponseBody(name='body'),
}

/**
 * @param request GetGatewayBySubDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetGatewayBySubDeviceResponse
 */
async function getGatewayBySubDeviceWithOptions(request: GetGatewayBySubDeviceRequest, runtime: Util.RuntimeOptions): GetGatewayBySubDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGatewayBySubDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetGatewayBySubDeviceRequest
 * @return GetGatewayBySubDeviceResponse
 */
async function getGatewayBySubDevice(request: GetGatewayBySubDeviceRequest): GetGatewayBySubDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGatewayBySubDeviceWithOptions(request, runtime);
}

model GetLoraNodesTaskRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
}

model GetLoraNodesTaskResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  successCount?: long(name='SuccessCount'),
  successDevEuis?: {
    successDevEui?: [ string ](name='SuccessDevEui')
  }(name='SuccessDevEuis'),
  taskId?: string(name='TaskId'),
  taskState?: string(name='TaskState'),
  totalCount?: long(name='TotalCount'),
}

model GetLoraNodesTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLoraNodesTaskResponseBody(name='body'),
}

/**
 * @param request GetLoraNodesTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLoraNodesTaskResponse
 */
async function getLoraNodesTaskWithOptions(request: GetLoraNodesTaskRequest, runtime: Util.RuntimeOptions): GetLoraNodesTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLoraNodesTask',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetLoraNodesTaskRequest
 * @return GetLoraNodesTaskResponse
 */
async function getLoraNodesTask(request: GetLoraNodesTaskRequest): GetLoraNodesTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoraNodesTaskWithOptions(request, runtime);
}

model GetParserRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model GetParserResponseBody = {
  code?: string(name='Code'),
  data?: {
    dataSourceId?: long(name='DataSourceId'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    parserId?: long(name='ParserId'),
    script?: string(name='Script'),
    scriptDraft?: string(name='ScriptDraft'),
    status?: string(name='Status'),
    utcCreated?: string(name='UtcCreated'),
    utcModified?: string(name='UtcModified'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetParserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetParserResponseBody(name='body'),
}

/**
 * @param request GetParserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetParserResponse
 */
async function getParserWithOptions(request: GetParserRequest, runtime: Util.RuntimeOptions): GetParserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetParser',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetParserRequest
 * @return GetParserResponse
 */
async function getParser(request: GetParserRequest): GetParserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParserWithOptions(request, runtime);
}

model GetParserDataSourceRequest {
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GetParserDataSourceResponseBody = {
  code?: string(name='Code'),
  dataSource?: {
    createUserId?: long(name='CreateUserId'),
    dataSourceId?: long(name='DataSourceId'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    utcCreated?: string(name='UtcCreated'),
  }(name='DataSource'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetParserDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetParserDataSourceResponseBody(name='body'),
}

/**
 * @param request GetParserDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetParserDataSourceResponse
 */
async function getParserDataSourceWithOptions(request: GetParserDataSourceRequest, runtime: Util.RuntimeOptions): GetParserDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetParserDataSource',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetParserDataSourceRequest
 * @return GetParserDataSourceResponse
 */
async function getParserDataSource(request: GetParserDataSourceRequest): GetParserDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getParserDataSourceWithOptions(request, runtime);
}

model GetRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
}

model GetRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  ruleInfo?: {
    createUserId?: long(name='CreateUserId'),
    created?: string(name='Created'),
    dataType?: string(name='DataType'),
    id?: long(name='Id'),
    modified?: string(name='Modified'),
    name?: string(name='Name'),
    productKey?: string(name='ProductKey'),
    ruleDesc?: string(name='RuleDesc'),
    select?: string(name='Select'),
    shortTopic?: string(name='ShortTopic'),
    status?: string(name='Status'),
    topic?: string(name='Topic'),
    topicType?: int32(name='TopicType'),
    utcCreated?: string(name='UtcCreated'),
    utcModified?: string(name='UtcModified'),
    where?: string(name='Where'),
  }(name='RuleInfo'),
  success?: boolean(name='Success'),
}

model GetRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRuleResponseBody(name='body'),
}

/**
 * @param request GetRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRuleResponse
 */
async function getRuleWithOptions(request: GetRuleRequest, runtime: Util.RuntimeOptions): GetRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetRuleRequest
 * @return GetRuleResponse
 */
async function getRule(request: GetRuleRequest): GetRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleWithOptions(request, runtime);
}

model GetRuleActionRequest {
  actionId?: long(name='ActionId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GetRuleActionResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  ruleActionInfo?: {
    configuration?: string(name='Configuration'),
    errorActionFlag?: boolean(name='ErrorActionFlag'),
    id?: long(name='Id'),
    ruleId?: long(name='RuleId'),
    type?: string(name='Type'),
  }(name='RuleActionInfo'),
  success?: boolean(name='Success'),
}

model GetRuleActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRuleActionResponseBody(name='body'),
}

/**
 * @param request GetRuleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRuleActionResponse
 */
async function getRuleActionWithOptions(request: GetRuleActionRequest, runtime: Util.RuntimeOptions): GetRuleActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionId)) {
    query['ActionId'] = request.actionId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRuleAction',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetRuleActionRequest
 * @return GetRuleActionResponse
 */
async function getRuleAction(request: GetRuleActionRequest): GetRuleActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleActionWithOptions(request, runtime);
}

model GetSceneRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
}

model GetSceneRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    ruleContent?: string(name='RuleContent'),
    ruleDescription?: string(name='RuleDescription'),
    ruleName?: string(name='RuleName'),
    ruleStatus?: int32(name='RuleStatus'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSceneRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSceneRuleResponseBody(name='body'),
}

/**
 * @param request GetSceneRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSceneRuleResponse
 */
async function getSceneRuleWithOptions(request: GetSceneRuleRequest, runtime: Util.RuntimeOptions): GetSceneRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSceneRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetSceneRuleRequest
 * @return GetSceneRuleResponse
 */
async function getSceneRule(request: GetSceneRuleRequest): GetSceneRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSceneRuleWithOptions(request, runtime);
}

model GetShareSpeechModelAudioRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  shareTaskId?: string(name='ShareTaskId', description='This parameter is required.'),
  speechModelCodeList?: [ string ](name='SpeechModelCodeList', description='This parameter is required.'),
}

model GetShareSpeechModelAudioResponseBody = {
  code?: string(name='Code'),
  data?: {
    data?: [ string ](name='data')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetShareSpeechModelAudioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetShareSpeechModelAudioResponseBody(name='body'),
}

/**
 * @param request GetShareSpeechModelAudioRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetShareSpeechModelAudioResponse
 */
async function getShareSpeechModelAudioWithOptions(request: GetShareSpeechModelAudioRequest, runtime: Util.RuntimeOptions): GetShareSpeechModelAudioResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.shareTaskId)) {
    body['ShareTaskId'] = request.shareTaskId;
  }
  if (!Util.isUnset(request.speechModelCodeList)) {
    body['SpeechModelCodeList'] = request.speechModelCodeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareSpeechModelAudio',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetShareSpeechModelAudioRequest
 * @return GetShareSpeechModelAudioResponse
 */
async function getShareSpeechModelAudio(request: GetShareSpeechModelAudioRequest): GetShareSpeechModelAudioResponse {
  var runtime = new Util.RuntimeOptions{};
  return getShareSpeechModelAudioWithOptions(request, runtime);
}

model GetShareTaskByDeviceOpenRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model GetShareTaskByDeviceOpenResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetShareTaskByDeviceOpenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetShareTaskByDeviceOpenResponseBody(name='body'),
}

/**
 * @param request GetShareTaskByDeviceOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetShareTaskByDeviceOpenResponse
 */
async function getShareTaskByDeviceOpenWithOptions(request: GetShareTaskByDeviceOpenRequest, runtime: Util.RuntimeOptions): GetShareTaskByDeviceOpenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareTaskByDeviceOpen',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetShareTaskByDeviceOpenRequest
 * @return GetShareTaskByDeviceOpenResponse
 */
async function getShareTaskByDeviceOpen(request: GetShareTaskByDeviceOpenRequest): GetShareTaskByDeviceOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getShareTaskByDeviceOpenWithOptions(request, runtime);
}

model GetSoundCodeAudioRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  soundCodeList?: [ string ](name='SoundCodeList', description='This parameter is required.'),
}

model GetSoundCodeAudioResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ string ](name='Items')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSoundCodeAudioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSoundCodeAudioResponseBody(name='body'),
}

/**
 * @param request GetSoundCodeAudioRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSoundCodeAudioResponse
 */
async function getSoundCodeAudioWithOptions(request: GetSoundCodeAudioRequest, runtime: Util.RuntimeOptions): GetSoundCodeAudioResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.soundCodeList)) {
    body['SoundCodeList'] = request.soundCodeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSoundCodeAudio',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetSoundCodeAudioRequest
 * @return GetSoundCodeAudioResponse
 */
async function getSoundCodeAudio(request: GetSoundCodeAudioRequest): GetSoundCodeAudioResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSoundCodeAudioWithOptions(request, runtime);
}

model GetSoundCodeScheduleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
}

model GetSoundCodeScheduleResponseBody = {
  code?: string(name='Code'),
  data?: {
    description?: string(name='Description'),
    endDate?: string(name='EndDate'),
    endTime?: string(name='EndTime'),
    gmtCreate?: long(name='GmtCreate'),
    name?: string(name='Name'),
    openType?: string(name='OpenType'),
    scheduleCode?: string(name='ScheduleCode'),
    startDate?: string(name='StartDate'),
    startTime?: string(name='StartTime'),
    status?: string(name='Status'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSoundCodeScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSoundCodeScheduleResponseBody(name='body'),
}

/**
 * @param request GetSoundCodeScheduleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSoundCodeScheduleResponse
 */
async function getSoundCodeScheduleWithOptions(request: GetSoundCodeScheduleRequest, runtime: Util.RuntimeOptions): GetSoundCodeScheduleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSoundCodeSchedule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetSoundCodeScheduleRequest
 * @return GetSoundCodeScheduleResponse
 */
async function getSoundCodeSchedule(request: GetSoundCodeScheduleRequest): GetSoundCodeScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSoundCodeScheduleWithOptions(request, runtime);
}

model GetSpeechDeviceDetailRequest {
  iotId?: string(name='IotId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model GetSpeechDeviceDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    availableSpace?: float(name='AvailableSpace'),
    deviceName?: string(name='DeviceName'),
    iotId?: string(name='IotId'),
    productKey?: string(name='ProductKey'),
    speechListUpdateTime?: long(name='SpeechListUpdateTime'),
    status?: string(name='Status'),
    totalSpace?: float(name='TotalSpace'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSpeechDeviceDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSpeechDeviceDetailResponseBody(name='body'),
}

/**
 * @param request GetSpeechDeviceDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSpeechDeviceDetailResponse
 */
async function getSpeechDeviceDetailWithOptions(request: GetSpeechDeviceDetailRequest, runtime: Util.RuntimeOptions): GetSpeechDeviceDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSpeechDeviceDetail',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetSpeechDeviceDetailRequest
 * @return GetSpeechDeviceDetailResponse
 */
async function getSpeechDeviceDetail(request: GetSpeechDeviceDetailRequest): GetSpeechDeviceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSpeechDeviceDetailWithOptions(request, runtime);
}

model GetSpeechLicenseDeviceStatisticsRequest {
  iotInstanceId?: string(name='IotInstanceId'),
}

model GetSpeechLicenseDeviceStatisticsResponseBody = {
  code?: string(name='Code'),
  data?: {
    availableQuota?: int32(name='AvailableQuota'),
    expiredQuota?: int32(name='ExpiredQuota'),
    expiringQuota?: int32(name='ExpiringQuota'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSpeechLicenseDeviceStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSpeechLicenseDeviceStatisticsResponseBody(name='body'),
}

/**
 * @param request GetSpeechLicenseDeviceStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSpeechLicenseDeviceStatisticsResponse
 */
async function getSpeechLicenseDeviceStatisticsWithOptions(request: GetSpeechLicenseDeviceStatisticsRequest, runtime: Util.RuntimeOptions): GetSpeechLicenseDeviceStatisticsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetSpeechLicenseDeviceStatistics',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetSpeechLicenseDeviceStatisticsRequest
 * @return GetSpeechLicenseDeviceStatisticsResponse
 */
async function getSpeechLicenseDeviceStatistics(request: GetSpeechLicenseDeviceStatisticsRequest): GetSpeechLicenseDeviceStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSpeechLicenseDeviceStatisticsWithOptions(request, runtime);
}

model GetSpeechVoiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
    {
      label?: string(name='Label'),
      value?: string(name='Value'),
      voiceList?: {
        items?: [ 
        {
          label?: string(name='Label'),
          value?: string(name='Value'),
        }
      ](name='Items')
      }(name='VoiceList'),
    }
  ](name='Items')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSpeechVoiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSpeechVoiceResponseBody(name='body'),
}

/**
 * @param request GetSpeechVoiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSpeechVoiceResponse
 */
async function getSpeechVoiceWithOptions(runtime: Util.RuntimeOptions): GetSpeechVoiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetSpeechVoice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return GetSpeechVoiceResponse
 */
async function getSpeechVoice(): GetSpeechVoiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSpeechVoiceWithOptions(runtime);
}

model GetStudioAppTokenOpenRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model GetStudioAppTokenOpenResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizId?: string(name='BizId'),
    bizType?: string(name='BizType'),
    isEnable?: string(name='IsEnable'),
    token?: string(name='Token'),
    type?: string(name='Type'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetStudioAppTokenOpenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetStudioAppTokenOpenResponseBody(name='body'),
}

/**
 * @param request GetStudioAppTokenOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetStudioAppTokenOpenResponse
 */
async function getStudioAppTokenOpenWithOptions(request: GetStudioAppTokenOpenRequest, runtime: Util.RuntimeOptions): GetStudioAppTokenOpenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStudioAppTokenOpen',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetStudioAppTokenOpenRequest
 * @return GetStudioAppTokenOpenResponse
 */
async function getStudioAppTokenOpen(request: GetStudioAppTokenOpenRequest): GetStudioAppTokenOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStudioAppTokenOpenWithOptions(request, runtime);
}

model GetThingModelStatusInnerRequest {
  insId?: string(name='InsId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model GetThingModelStatusInnerResponseBody = {
  code?: int32(name='Code'),
  data?: {
    info?: string(name='Info'),
    instanceId?: string(name='InstanceId'),
    modifiedTime?: long(name='ModifiedTime'),
    outTime?: long(name='OutTime'),
    productKey?: string(name='ProductKey'),
    rbacTenantId?: string(name='RbacTenantId'),
    status?: int32(name='Status'),
  }(name='Data'),
  localizedMsg?: string(name='LocalizedMsg'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetThingModelStatusInnerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetThingModelStatusInnerResponseBody(name='body'),
}

/**
 * @param request GetThingModelStatusInnerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingModelStatusInnerResponse
 */
async function getThingModelStatusInnerWithOptions(request: GetThingModelStatusInnerRequest, runtime: Util.RuntimeOptions): GetThingModelStatusInnerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.insId)) {
    query['InsId'] = request.insId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetThingModelStatusInner',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetThingModelStatusInnerRequest
 * @return GetThingModelStatusInnerResponse
 */
async function getThingModelStatusInner(request: GetThingModelStatusInnerRequest): GetThingModelStatusInnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getThingModelStatusInnerWithOptions(request, runtime);
}

model GetThingModelTslRequest {
  functionBlockId?: string(name='FunctionBlockId'),
  iotInstanceId?: string(name='IotInstanceId'),
  modelVersion?: string(name='ModelVersion'),
  productKey?: string(name='ProductKey'),
  simple?: boolean(name='Simple'),
}

model GetThingModelTslResponseBody = {
  code?: string(name='Code'),
  data?: {
    tslStr?: string(name='TslStr'),
    tslUri?: string(name='TslUri'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetThingModelTslResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetThingModelTslResponseBody(name='body'),
}

/**
 * @param request GetThingModelTslRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingModelTslResponse
 */
async function getThingModelTslWithOptions(request: GetThingModelTslRequest, runtime: Util.RuntimeOptions): GetThingModelTslResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.modelVersion)) {
    query['ModelVersion'] = request.modelVersion;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.simple)) {
    query['Simple'] = request.simple;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetThingModelTsl',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetThingModelTslRequest
 * @return GetThingModelTslResponse
 */
async function getThingModelTsl(request: GetThingModelTslRequest): GetThingModelTslResponse {
  var runtime = new Util.RuntimeOptions{};
  return getThingModelTslWithOptions(request, runtime);
}

model GetThingModelTslPublishedRequest {
  functionBlockId?: string(name='FunctionBlockId'),
  iotInstanceId?: string(name='IotInstanceId'),
  modelVersion?: string(name='ModelVersion'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId'),
  simple?: boolean(name='Simple'),
}

model GetThingModelTslPublishedResponseBody = {
  code?: string(name='Code'),
  data?: {
    tslStr?: string(name='TslStr'),
    tslUri?: string(name='TslUri'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetThingModelTslPublishedResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetThingModelTslPublishedResponseBody(name='body'),
}

/**
 * @param request GetThingModelTslPublishedRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingModelTslPublishedResponse
 */
async function getThingModelTslPublishedWithOptions(request: GetThingModelTslPublishedRequest, runtime: Util.RuntimeOptions): GetThingModelTslPublishedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.modelVersion)) {
    query['ModelVersion'] = request.modelVersion;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.simple)) {
    query['Simple'] = request.simple;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetThingModelTslPublished',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetThingModelTslPublishedRequest
 * @return GetThingModelTslPublishedResponse
 */
async function getThingModelTslPublished(request: GetThingModelTslPublishedRequest): GetThingModelTslPublishedResponse {
  var runtime = new Util.RuntimeOptions{};
  return getThingModelTslPublishedWithOptions(request, runtime);
}

model GetThingScriptRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model GetThingScriptResponseBody = {
  code?: string(name='Code'),
  data?: {
    scriptType?: string(name='ScriptType'),
    scriptUrl?: string(name='ScriptUrl'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetThingScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetThingScriptResponseBody(name='body'),
}

/**
 * @param request GetThingScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingScriptResponse
 */
async function getThingScriptWithOptions(request: GetThingScriptRequest, runtime: Util.RuntimeOptions): GetThingScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetThingScript',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetThingScriptRequest
 * @return GetThingScriptResponse
 */
async function getThingScript(request: GetThingScriptRequest): GetThingScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return getThingScriptWithOptions(request, runtime);
}

model GetThingTemplateRequest {
  categoryKey?: string(name='CategoryKey'),
  iotInstanceId?: string(name='IotInstanceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model GetThingTemplateResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  thingModelJSON?: string(name='ThingModelJSON'),
}

model GetThingTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetThingTemplateResponseBody(name='body'),
}

/**
 * @param request GetThingTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingTemplateResponse
 */
async function getThingTemplateWithOptions(request: GetThingTemplateRequest, runtime: Util.RuntimeOptions): GetThingTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.categoryKey)) {
    query['CategoryKey'] = request.categoryKey;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetThingTemplate',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetThingTemplateRequest
 * @return GetThingTemplateResponse
 */
async function getThingTemplate(request: GetThingTemplateRequest): GetThingTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getThingTemplateWithOptions(request, runtime);
}

model GetThingTopoRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageNo?: int32(name='PageNo', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
}

model GetThingTopoResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    list?: {
      deviceInfo?: [ 
      {
        deviceName?: string(name='DeviceName'),
        iotId?: string(name='IotId'),
        productKey?: string(name='ProductKey'),
      }
    ](name='deviceInfo')
    }(name='List'),
    pageCount?: long(name='PageCount'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetThingTopoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetThingTopoResponseBody(name='body'),
}

/**
 * @param request GetThingTopoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingTopoResponse
 */
async function getThingTopoWithOptions(request: GetThingTopoRequest, runtime: Util.RuntimeOptions): GetThingTopoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetThingTopo',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetThingTopoRequest
 * @return GetThingTopoResponse
 */
async function getThingTopo(request: GetThingTopoRequest): GetThingTopoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getThingTopoWithOptions(request, runtime);
}

model GisQueryDeviceLocationRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  thingList?: [ 
    {
      deviceName?: string(name='DeviceName'),
      productKey?: string(name='ProductKey'),
    }
  ](name='ThingList', description='This parameter is required.'),
}

model GisQueryDeviceLocationResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      adcode?: long(name='Adcode'),
      city?: string(name='City'),
      coordinateSystem?: int32(name='CoordinateSystem'),
      country?: string(name='Country'),
      deviceName?: string(name='DeviceName'),
      ip?: string(name='Ip'),
      latitude?: float(name='Latitude'),
      longitude?: float(name='Longitude'),
      productKey?: string(name='ProductKey'),
      province?: string(name='Province'),
    }
  ](name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GisQueryDeviceLocationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GisQueryDeviceLocationResponseBody(name='body'),
}

/**
 * @param request GisQueryDeviceLocationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GisQueryDeviceLocationResponse
 */
async function gisQueryDeviceLocationWithOptions(request: GisQueryDeviceLocationRequest, runtime: Util.RuntimeOptions): GisQueryDeviceLocationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.thingList)) {
    query['ThingList'] = request.thingList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GisQueryDeviceLocation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GisQueryDeviceLocationRequest
 * @return GisQueryDeviceLocationResponse
 */
async function gisQueryDeviceLocation(request: GisQueryDeviceLocationRequest): GisQueryDeviceLocationResponse {
  var runtime = new Util.RuntimeOptions{};
  return gisQueryDeviceLocationWithOptions(request, runtime);
}

model GisSearchDeviceTraceRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  mapMatch?: int32(name='MapMatch', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model GisSearchDeviceTraceResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceName?: string(name='DeviceName'),
    points?: [ 
      {
        locateTime?: long(name='LocateTime'),
        location?: string(name='Location'),
      }
    ](name='Points'),
    productKey?: string(name='ProductKey'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GisSearchDeviceTraceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GisSearchDeviceTraceResponseBody(name='body'),
}

/**
 * @param request GisSearchDeviceTraceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GisSearchDeviceTraceResponse
 */
async function gisSearchDeviceTraceWithOptions(request: GisSearchDeviceTraceRequest, runtime: Util.RuntimeOptions): GisSearchDeviceTraceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.mapMatch)) {
    query['MapMatch'] = request.mapMatch;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GisSearchDeviceTrace',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GisSearchDeviceTraceRequest
 * @return GisSearchDeviceTraceResponse
 */
async function gisSearchDeviceTrace(request: GisSearchDeviceTraceRequest): GisSearchDeviceTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return gisSearchDeviceTraceWithOptions(request, runtime);
}

model ImportDTDataRequest {
  DTInstanceId?: string(name='DTInstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  items?: [ 
    {
      deviceName?: string(name='DeviceName', description='This parameter is required.'),
      params?: string(name='Params', description='This parameter is required.'),
    }
  ](name='Items', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model ImportDTDataResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportDTDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportDTDataResponseBody(name='body'),
}

/**
 * @param request ImportDTDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportDTDataResponse
 */
async function importDTDataWithOptions(request: ImportDTDataRequest, runtime: Util.RuntimeOptions): ImportDTDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DTInstanceId)) {
    query['DTInstanceId'] = request.DTInstanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.items)) {
    body['Items'] = request.items;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ImportDTData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImportDTDataRequest
 * @return ImportDTDataResponse
 */
async function importDTData(request: ImportDTDataRequest): ImportDTDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return importDTDataWithOptions(request, runtime);
}

model ImportDeviceRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  deviceSecret?: string(name='DeviceSecret', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  nickname?: string(name='Nickname'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  sn?: string(name='Sn'),
}

model ImportDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceName?: string(name='DeviceName'),
    deviceSecret?: string(name='DeviceSecret'),
    iotId?: string(name='IotId'),
    nickname?: string(name='Nickname'),
    productKey?: string(name='ProductKey'),
    sn?: string(name='Sn'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportDeviceResponseBody(name='body'),
}

/**
 * @param request ImportDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportDeviceResponse
 */
async function importDeviceWithOptions(request: ImportDeviceRequest, runtime: Util.RuntimeOptions): ImportDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceSecret)) {
    query['DeviceSecret'] = request.deviceSecret;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.nickname)) {
    query['Nickname'] = request.nickname;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.sn)) {
    query['Sn'] = request.sn;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImportDeviceRequest
 * @return ImportDeviceResponse
 */
async function importDevice(request: ImportDeviceRequest): ImportDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return importDeviceWithOptions(request, runtime);
}

model ImportThingModelTslRequest {
  functionBlockId?: string(name='FunctionBlockId'),
  functionBlockName?: string(name='FunctionBlockName'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tslStr?: string(name='TslStr'),
  tslUrl?: string(name='TslUrl'),
}

model ImportThingModelTslResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportThingModelTslResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportThingModelTslResponseBody(name='body'),
}

/**
 * @param request ImportThingModelTslRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportThingModelTslResponse
 */
async function importThingModelTslWithOptions(request: ImportThingModelTslRequest, runtime: Util.RuntimeOptions): ImportThingModelTslResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.functionBlockName)) {
    query['FunctionBlockName'] = request.functionBlockName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tslStr)) {
    query['TslStr'] = request.tslStr;
  }
  if (!Util.isUnset(request.tslUrl)) {
    query['TslUrl'] = request.tslUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportThingModelTsl',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImportThingModelTslRequest
 * @return ImportThingModelTslResponse
 */
async function importThingModelTsl(request: ImportThingModelTslRequest): ImportThingModelTslResponse {
  var runtime = new Util.RuntimeOptions{};
  return importThingModelTslWithOptions(request, runtime);
}

model InvokeDataAPIServiceRequest {
  apiSrn?: string(name='ApiSrn', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  param?: [ 
    {
      listParamType?: string(name='ListParamType'),
      listParamValue?: [ string ](name='ListParamValue'),
      paramName?: string(name='ParamName'),
      paramType?: string(name='ParamType'),
      paramValue?: string(name='ParamValue'),
    }
  ](name='Param'),
}

model InvokeDataAPIServiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    apiSrn?: string(name='ApiSrn'),
    fieldNameList?: {
      fieldNameList?: [ string ](name='FieldNameList')
    }(name='FieldNameList'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    resultList?: {
      resultList?: [  map[string]any ](name='ResultList')
    }(name='ResultList'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InvokeDataAPIServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InvokeDataAPIServiceResponseBody(name='body'),
}

/**
 * @param request InvokeDataAPIServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InvokeDataAPIServiceResponse
 */
async function invokeDataAPIServiceWithOptions(request: InvokeDataAPIServiceRequest, runtime: Util.RuntimeOptions): InvokeDataAPIServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiSrn)) {
    body['ApiSrn'] = request.apiSrn;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.param)) {
    body['Param'] = request.param;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InvokeDataAPIService',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request InvokeDataAPIServiceRequest
 * @return InvokeDataAPIServiceResponse
 */
async function invokeDataAPIService(request: InvokeDataAPIServiceRequest): InvokeDataAPIServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return invokeDataAPIServiceWithOptions(request, runtime);
}

model InvokeThingServiceRequest {
  args?: string(name='Args', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  identifier?: string(name='Identifier', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  qos?: int32(name='Qos'),
}

model InvokeThingServiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    messageId?: string(name='MessageId'),
    result?: string(name='Result'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InvokeThingServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InvokeThingServiceResponseBody(name='body'),
}

/**
 * @param request InvokeThingServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InvokeThingServiceResponse
 */
async function invokeThingServiceWithOptions(request: InvokeThingServiceRequest, runtime: Util.RuntimeOptions): InvokeThingServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.args)) {
    query['Args'] = request.args;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.qos)) {
    query['Qos'] = request.qos;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InvokeThingService',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request InvokeThingServiceRequest
 * @return InvokeThingServiceResponse
 */
async function invokeThingService(request: InvokeThingServiceRequest): InvokeThingServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return invokeThingServiceWithOptions(request, runtime);
}

model InvokeThingsServiceRequest {
  args?: string(name='Args', description='This parameter is required.'),
  deviceName?: [ string ](name='DeviceName', description='This parameter is required.'),
  identifier?: string(name='Identifier', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  qos?: int32(name='Qos'),
}

model InvokeThingsServiceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InvokeThingsServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InvokeThingsServiceResponseBody(name='body'),
}

/**
 * @param request InvokeThingsServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InvokeThingsServiceResponse
 */
async function invokeThingsServiceWithOptions(request: InvokeThingsServiceRequest, runtime: Util.RuntimeOptions): InvokeThingsServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.args)) {
    query['Args'] = request.args;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.qos)) {
    query['Qos'] = request.qos;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InvokeThingsService',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request InvokeThingsServiceRequest
 * @return InvokeThingsServiceResponse
 */
async function invokeThingsService(request: InvokeThingsServiceRequest): InvokeThingsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return invokeThingsServiceWithOptions(request, runtime);
}

model ListAnalyticsDataRequest {
  apiPath?: string(name='ApiPath', description='This parameter is required.'),
  condition?: [ 
    {
      betweenEnd?: string(name='BetweenEnd'),
      betweenStart?: string(name='BetweenStart'),
      fieldName?: string(name='FieldName', description='This parameter is required.'),
      operate?: string(name='Operate', description='This parameter is required.'),
      value?: string(name='Value'),
    }
  ](name='Condition'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  isoId?: string(name='IsoId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model ListAnalyticsDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    count?: long(name='Count'),
    hasNext?: boolean(name='HasNext'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    resultJson?: string(name='ResultJson'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAnalyticsDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAnalyticsDataResponseBody(name='body'),
}

/**
 * @param request ListAnalyticsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAnalyticsDataResponse
 */
async function listAnalyticsDataWithOptions(request: ListAnalyticsDataRequest, runtime: Util.RuntimeOptions): ListAnalyticsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiPath)) {
    query['ApiPath'] = request.apiPath;
  }
  if (!Util.isUnset(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.isoId)) {
    query['IsoId'] = request.isoId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAnalyticsData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListAnalyticsDataRequest
 * @return ListAnalyticsDataResponse
 */
async function listAnalyticsData(request: ListAnalyticsDataRequest): ListAnalyticsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAnalyticsDataWithOptions(request, runtime);
}

model ListDataSourceItemRequest {
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  page?: int32(name='Page', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  searchName?: string(name='SearchName'),
}

model ListDataSourceItemResponseBody = {
  code?: string(name='Code'),
  dataSourceItems?: {
    dataSourceItem?: [ 
    {
      dataSourceItemId?: long(name='DataSourceItemId'),
      deviceName?: string(name='DeviceName'),
      productKey?: string(name='ProductKey'),
      scopeType?: string(name='ScopeType'),
      topic?: string(name='Topic'),
    }
  ](name='dataSourceItem')
  }(name='DataSourceItems'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListDataSourceItemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataSourceItemResponseBody(name='body'),
}

/**
 * @param request ListDataSourceItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourceItemResponse
 */
async function listDataSourceItemWithOptions(request: ListDataSourceItemRequest, runtime: Util.RuntimeOptions): ListDataSourceItemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataSourceItem',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDataSourceItemRequest
 * @return ListDataSourceItemResponse
 */
async function listDataSourceItem(request: ListDataSourceItemRequest): ListDataSourceItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataSourceItemWithOptions(request, runtime);
}

model ListDestinationRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  page?: int32(name='Page', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  searchName?: string(name='SearchName'),
  types?: [ string ](name='Types'),
}

model ListDestinationResponseBody = {
  code?: string(name='Code'),
  destinations?: {
    destinations?: [ 
    {
      configuration?: string(name='Configuration'),
      description?: string(name='Description'),
      destinationId?: long(name='DestinationId'),
      isFailover?: boolean(name='IsFailover'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      utcCreated?: string(name='UtcCreated'),
    }
  ](name='destinations')
  }(name='Destinations'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDestinationResponseBody(name='body'),
}

/**
 * @param request ListDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDestinationResponse
 */
async function listDestinationWithOptions(request: ListDestinationRequest, runtime: Util.RuntimeOptions): ListDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDestination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDestinationRequest
 * @return ListDestinationResponse
 */
async function listDestination(request: ListDestinationRequest): ListDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDestinationWithOptions(request, runtime);
}

model ListDeviceDistributeJobRequest {
  currentPage?: int32(name='CurrentPage'),
  jobId?: string(name='JobId'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  status?: int32(name='Status'),
  targetUid?: string(name='TargetUid'),
}

model ListDeviceDistributeJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobInfo?: {
      items?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        jobId?: string(name='JobId'),
        productKey?: string(name='ProductKey'),
        sourceInstanceId?: string(name='SourceInstanceId'),
        sourceInstanceName?: string(name='SourceInstanceName'),
        sourceRegion?: string(name='SourceRegion'),
        sourceUid?: string(name='SourceUid'),
        status?: int32(name='Status'),
        strategy?: int32(name='Strategy'),
        targetInstanceConfigs?: {
          targetInstanceConfigs?: [ 
          {
            targetInstanceId?: string(name='TargetInstanceId'),
            targetInstanceName?: string(name='TargetInstanceName'),
            targetRegion?: string(name='TargetRegion'),
          }
        ](name='targetInstanceConfigs')
        }(name='TargetInstanceConfigs'),
        targetUid?: string(name='TargetUid'),
        total?: int32(name='Total'),
      }
    ](name='items')
    }(name='JobInfo'),
    nextToken?: string(name='NextToken'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDeviceDistributeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDeviceDistributeJobResponseBody(name='body'),
}

/**
 * @param request ListDeviceDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDeviceDistributeJobResponse
 */
async function listDeviceDistributeJobWithOptions(request: ListDeviceDistributeJobRequest, runtime: Util.RuntimeOptions): ListDeviceDistributeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.targetUid)) {
    query['TargetUid'] = request.targetUid;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceDistributeJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDeviceDistributeJobRequest
 * @return ListDeviceDistributeJobResponse
 */
async function listDeviceDistributeJob(request: ListDeviceDistributeJobRequest): ListDeviceDistributeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceDistributeJobWithOptions(request, runtime);
}

model ListDistributedDeviceRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  sourceInstanceId?: string(name='SourceInstanceId'),
  targetUid?: string(name='TargetUid'),
}

model ListDistributedDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    info?: {
      items?: [ 
      {
        deviceName?: string(name='DeviceName'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        productKey?: string(name='ProductKey'),
        sourceInstanceId?: string(name='SourceInstanceId'),
        sourceInstanceName?: string(name='SourceInstanceName'),
        sourceRegion?: string(name='SourceRegion'),
        sourceUid?: string(name='SourceUid'),
        targetAliyunId?: string(name='TargetAliyunId'),
        targetInstanceId?: string(name='TargetInstanceId'),
        targetInstanceName?: string(name='TargetInstanceName'),
        targetRegion?: string(name='TargetRegion'),
        targetUid?: string(name='TargetUid'),
      }
    ](name='items')
    }(name='Info'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDistributedDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDistributedDeviceResponseBody(name='body'),
}

/**
 * @param request ListDistributedDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDistributedDeviceResponse
 */
async function listDistributedDeviceWithOptions(request: ListDistributedDeviceRequest, runtime: Util.RuntimeOptions): ListDistributedDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.sourceInstanceId)) {
    query['SourceInstanceId'] = request.sourceInstanceId;
  }
  if (!Util.isUnset(request.targetUid)) {
    query['TargetUid'] = request.targetUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDistributedDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDistributedDeviceRequest
 * @return ListDistributedDeviceResponse
 */
async function listDistributedDevice(request: ListDistributedDeviceRequest): ListDistributedDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDistributedDeviceWithOptions(request, runtime);
}

model ListDistributedProductRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  sourceInstanceId?: string(name='SourceInstanceId'),
  targetInstanceId?: string(name='TargetInstanceId'),
  targetUid?: string(name='TargetUid'),
}

model ListDistributedProductResponseBody = {
  code?: string(name='Code'),
  data?: {
    info?: {
      items?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        productKey?: string(name='ProductKey'),
        sourceInstanceId?: string(name='SourceInstanceId'),
        sourceInstanceName?: string(name='SourceInstanceName'),
        sourceRegion?: string(name='SourceRegion'),
        sourceUid?: string(name='SourceUid'),
        targetAliyunId?: string(name='TargetAliyunId'),
        targetInstanceId?: string(name='TargetInstanceId'),
        targetInstanceName?: string(name='TargetInstanceName'),
        targetRegion?: string(name='TargetRegion'),
        targetUid?: string(name='TargetUid'),
      }
    ](name='items')
    }(name='Info'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDistributedProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDistributedProductResponseBody(name='body'),
}

/**
 * @param request ListDistributedProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDistributedProductResponse
 */
async function listDistributedProductWithOptions(request: ListDistributedProductRequest, runtime: Util.RuntimeOptions): ListDistributedProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.sourceInstanceId)) {
    query['SourceInstanceId'] = request.sourceInstanceId;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetUid)) {
    query['TargetUid'] = request.targetUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDistributedProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDistributedProductRequest
 * @return ListDistributedProductResponse
 */
async function listDistributedProduct(request: ListDistributedProductRequest): ListDistributedProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDistributedProductWithOptions(request, runtime);
}

model ListJobRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  status?: string(name='Status'),
}

model ListJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    data?: [ 
    {
      description?: string(name='Description'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      scheduledTime?: long(name='ScheduledTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      utcCreate?: string(name='UtcCreate'),
      utcModified?: string(name='UtcModified'),
    }
  ](name='data')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListJobResponseBody(name='body'),
}

/**
 * @param request ListJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListJobResponse
 */
async function listJobWithOptions(request: ListJobRequest, runtime: Util.RuntimeOptions): ListJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListJobRequest
 * @return ListJobResponse
 */
async function listJob(request: ListJobRequest): ListJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobWithOptions(request, runtime);
}

model ListOTAFirmwareRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  destVersion?: string(name='DestVersion'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
}

model ListOTAFirmwareResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  errorMessage?: string(name='ErrorMessage'),
  firmwareInfo?: {
    simpleFirmwareInfo?: [ 
    {
      destVersion?: string(name='DestVersion'),
      firmwareDesc?: string(name='FirmwareDesc'),
      firmwareId?: string(name='FirmwareId'),
      firmwareName?: string(name='FirmwareName'),
      firmwareSign?: string(name='FirmwareSign'),
      firmwareSize?: int32(name='FirmwareSize'),
      moduleName?: string(name='ModuleName'),
      productKey?: string(name='ProductKey'),
      productName?: string(name='ProductName'),
      signMethod?: string(name='SignMethod'),
      srcVersion?: string(name='SrcVersion'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      utcCreate?: string(name='UtcCreate'),
      utcModified?: string(name='UtcModified'),
    }
  ](name='SimpleFirmwareInfo')
  }(name='FirmwareInfo'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListOTAFirmwareResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOTAFirmwareResponseBody(name='body'),
}

/**
 * @param request ListOTAFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAFirmwareResponse
 */
async function listOTAFirmwareWithOptions(request: ListOTAFirmwareRequest, runtime: Util.RuntimeOptions): ListOTAFirmwareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.destVersion)) {
    query['DestVersion'] = request.destVersion;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOTAFirmware',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListOTAFirmwareRequest
 * @return ListOTAFirmwareResponse
 */
async function listOTAFirmware(request: ListOTAFirmwareRequest): ListOTAFirmwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOTAFirmwareWithOptions(request, runtime);
}

model ListOTAJobByDeviceRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  firmwareId?: string(name='FirmwareId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model ListOTAJobByDeviceResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    simpleOTAJobInfo?: [ 
    {
      firmwareId?: string(name='FirmwareId'),
      jobId?: string(name='JobId'),
      jobStatus?: string(name='JobStatus'),
      jobType?: string(name='JobType'),
      productKey?: string(name='ProductKey'),
      selectionType?: string(name='SelectionType'),
      tags?: {
        otaTagDTO?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='OtaTagDTO')
      }(name='Tags'),
      targetSelection?: string(name='TargetSelection'),
      utcCreate?: string(name='UtcCreate'),
      utcEndTime?: string(name='UtcEndTime'),
      utcModified?: string(name='UtcModified'),
      utcStartTime?: string(name='UtcStartTime'),
    }
  ](name='SimpleOTAJobInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListOTAJobByDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOTAJobByDeviceResponseBody(name='body'),
}

/**
 * @param request ListOTAJobByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAJobByDeviceResponse
 */
async function listOTAJobByDeviceWithOptions(request: ListOTAJobByDeviceRequest, runtime: Util.RuntimeOptions): ListOTAJobByDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.firmwareId)) {
    query['FirmwareId'] = request.firmwareId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOTAJobByDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListOTAJobByDeviceRequest
 * @return ListOTAJobByDeviceResponse
 */
async function listOTAJobByDevice(request: ListOTAJobByDeviceRequest): ListOTAJobByDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOTAJobByDeviceWithOptions(request, runtime);
}

model ListOTAJobByFirmwareRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  firmwareId?: string(name='FirmwareId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model ListOTAJobByFirmwareResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    simpleOTAJobInfo?: [ 
    {
      firmwareId?: string(name='FirmwareId'),
      jobId?: string(name='JobId'),
      jobStatus?: string(name='JobStatus'),
      jobType?: string(name='JobType'),
      productKey?: string(name='ProductKey'),
      selectionType?: string(name='SelectionType'),
      tags?: {
        otaTagDTO?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='OtaTagDTO')
      }(name='Tags'),
      targetSelection?: string(name='TargetSelection'),
      utcCreate?: string(name='UtcCreate'),
      utcEndTime?: string(name='UtcEndTime'),
      utcModified?: string(name='UtcModified'),
      utcStartTime?: string(name='UtcStartTime'),
    }
  ](name='SimpleOTAJobInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListOTAJobByFirmwareResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOTAJobByFirmwareResponseBody(name='body'),
}

/**
 * @param request ListOTAJobByFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAJobByFirmwareResponse
 */
async function listOTAJobByFirmwareWithOptions(request: ListOTAJobByFirmwareRequest, runtime: Util.RuntimeOptions): ListOTAJobByFirmwareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.firmwareId)) {
    query['FirmwareId'] = request.firmwareId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOTAJobByFirmware',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListOTAJobByFirmwareRequest
 * @return ListOTAJobByFirmwareResponse
 */
async function listOTAJobByFirmware(request: ListOTAJobByFirmwareRequest): ListOTAJobByFirmwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOTAJobByFirmwareWithOptions(request, runtime);
}

model ListOTAModuleByProductRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model ListOTAModuleByProductResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      aliasName?: string(name='AliasName'),
      desc?: string(name='Desc'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      moduleName?: string(name='ModuleName'),
      productKey?: string(name='ProductKey'),
    }
  ](name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListOTAModuleByProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOTAModuleByProductResponseBody(name='body'),
}

/**
 * @param request ListOTAModuleByProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAModuleByProductResponse
 */
async function listOTAModuleByProductWithOptions(request: ListOTAModuleByProductRequest, runtime: Util.RuntimeOptions): ListOTAModuleByProductResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOTAModuleByProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListOTAModuleByProductRequest
 * @return ListOTAModuleByProductResponse
 */
async function listOTAModuleByProduct(request: ListOTAModuleByProductRequest): ListOTAModuleByProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOTAModuleByProductWithOptions(request, runtime);
}

model ListOTAModuleVersionsByDeviceRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
}

model ListOTAModuleVersionsByDeviceResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    simpleOTAModuleInfo?: [ 
    {
      deviceName?: string(name='DeviceName'),
      iotId?: string(name='IotId'),
      moduleName?: string(name='ModuleName'),
      moduleVersion?: string(name='ModuleVersion'),
      productKey?: string(name='ProductKey'),
    }
  ](name='SimpleOTAModuleInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListOTAModuleVersionsByDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOTAModuleVersionsByDeviceResponseBody(name='body'),
}

/**
 * @param request ListOTAModuleVersionsByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAModuleVersionsByDeviceResponse
 */
async function listOTAModuleVersionsByDeviceWithOptions(request: ListOTAModuleVersionsByDeviceRequest, runtime: Util.RuntimeOptions): ListOTAModuleVersionsByDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOTAModuleVersionsByDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListOTAModuleVersionsByDeviceRequest
 * @return ListOTAModuleVersionsByDeviceResponse
 */
async function listOTAModuleVersionsByDevice(request: ListOTAModuleVersionsByDeviceRequest): ListOTAModuleVersionsByDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOTAModuleVersionsByDeviceWithOptions(request, runtime);
}

model ListOTATaskByJobRequest {
  currentPage?: int32(name='CurrentPage'),
  deviceNames?: [ string ](name='DeviceNames'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
  pageSize?: int32(name='PageSize'),
  taskStatus?: string(name='TaskStatus'),
}

model ListOTATaskByJobResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    simpleOTATaskInfo?: [ 
    {
      destVersion?: string(name='DestVersion'),
      deviceName?: string(name='DeviceName'),
      firmwareId?: string(name='FirmwareId'),
      iotId?: string(name='IotId'),
      jobId?: string(name='JobId'),
      productKey?: string(name='ProductKey'),
      productName?: string(name='ProductName'),
      progress?: string(name='Progress'),
      srcVersion?: string(name='SrcVersion'),
      taskDesc?: string(name='TaskDesc'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
      timeout?: string(name='Timeout'),
      utcCreate?: string(name='UtcCreate'),
      utcModified?: string(name='UtcModified'),
    }
  ](name='SimpleOTATaskInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListOTATaskByJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOTATaskByJobResponseBody(name='body'),
}

/**
 * @param request ListOTATaskByJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTATaskByJobResponse
 */
async function listOTATaskByJobWithOptions(request: ListOTATaskByJobRequest, runtime: Util.RuntimeOptions): ListOTATaskByJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.deviceNames)) {
    query['DeviceNames'] = request.deviceNames;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskStatus)) {
    query['TaskStatus'] = request.taskStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOTATaskByJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListOTATaskByJobRequest
 * @return ListOTATaskByJobResponse
 */
async function listOTATaskByJob(request: ListOTATaskByJobRequest): ListOTATaskByJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOTATaskByJobWithOptions(request, runtime);
}

model ListOTAUnfinishedTaskByDeviceRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  moduleName?: string(name='ModuleName'),
  productKey?: string(name='ProductKey'),
  taskStatus?: string(name='TaskStatus'),
  taskStatusList?: [ string ](name='TaskStatusList'),
}

model ListOTAUnfinishedTaskByDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    simpleOTATaskInfo?: [ 
    {
      destVersion?: string(name='DestVersion'),
      deviceName?: string(name='DeviceName'),
      firmwareId?: string(name='FirmwareId'),
      iotId?: string(name='IotId'),
      jobId?: string(name='JobId'),
      moduleName?: string(name='ModuleName'),
      productKey?: string(name='ProductKey'),
      productName?: string(name='ProductName'),
      srcVersion?: string(name='SrcVersion'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
      utcCreate?: string(name='UtcCreate'),
      utcModified?: string(name='UtcModified'),
    }
  ](name='SimpleOTATaskInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListOTAUnfinishedTaskByDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListOTAUnfinishedTaskByDeviceResponseBody(name='body'),
}

/**
 * @param request ListOTAUnfinishedTaskByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAUnfinishedTaskByDeviceResponse
 */
async function listOTAUnfinishedTaskByDeviceWithOptions(request: ListOTAUnfinishedTaskByDeviceRequest, runtime: Util.RuntimeOptions): ListOTAUnfinishedTaskByDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.taskStatus)) {
    query['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.taskStatusList)) {
    query['TaskStatusList'] = request.taskStatusList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOTAUnfinishedTaskByDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListOTAUnfinishedTaskByDeviceRequest
 * @return ListOTAUnfinishedTaskByDeviceResponse
 */
async function listOTAUnfinishedTaskByDevice(request: ListOTAUnfinishedTaskByDeviceRequest): ListOTAUnfinishedTaskByDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOTAUnfinishedTaskByDeviceWithOptions(request, runtime);
}

model ListParserRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  searchName?: string(name='SearchName'),
}

model ListParserResponseBody = {
  code?: string(name='Code'),
  data?: {
    parserList?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      parserId?: long(name='ParserId'),
      status?: string(name='Status'),
      utcCreated?: string(name='UtcCreated'),
      utcModified?: string(name='UtcModified'),
    }
  ](name='ParserList')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListParserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListParserResponseBody(name='body'),
}

/**
 * @param request ListParserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListParserResponse
 */
async function listParserWithOptions(request: ListParserRequest, runtime: Util.RuntimeOptions): ListParserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListParser',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListParserRequest
 * @return ListParserResponse
 */
async function listParser(request: ListParserRequest): ListParserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listParserWithOptions(request, runtime);
}

model ListParserDataSourceRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  page?: int32(name='Page', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  searchName?: string(name='SearchName'),
}

model ListParserDataSourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    dataSource?: [ 
    {
      dataSourceId?: long(name='DataSourceId'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      utcCreated?: string(name='UtcCreated'),
    }
  ](name='DataSource')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListParserDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListParserDataSourceResponseBody(name='body'),
}

/**
 * @param request ListParserDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListParserDataSourceResponse
 */
async function listParserDataSourceWithOptions(request: ListParserDataSourceRequest, runtime: Util.RuntimeOptions): ListParserDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListParserDataSource',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListParserDataSourceRequest
 * @return ListParserDataSourceResponse
 */
async function listParserDataSource(request: ListParserDataSourceRequest): ListParserDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listParserDataSourceWithOptions(request, runtime);
}

model ListParserDestinationRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  isFailover?: boolean(name='IsFailover'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model ListParserDestinationResponseBody = {
  code?: string(name='Code'),
  data?: {
    destinations?: [ 
    {
      configuration?: string(name='Configuration'),
      destinationId?: long(name='DestinationId'),
      isFailover?: boolean(name='IsFailover'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      utcCreated?: string(name='UtcCreated'),
      utcModified?: string(name='UtcModified'),
    }
  ](name='destinations')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListParserDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListParserDestinationResponseBody(name='body'),
}

/**
 * @param request ListParserDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListParserDestinationResponse
 */
async function listParserDestinationWithOptions(request: ListParserDestinationRequest, runtime: Util.RuntimeOptions): ListParserDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.isFailover)) {
    query['IsFailover'] = request.isFailover;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListParserDestination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListParserDestinationRequest
 * @return ListParserDestinationResponse
 */
async function listParserDestination(request: ListParserDestinationRequest): ListParserDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listParserDestinationWithOptions(request, runtime);
}

model ListPowerStationRequest {
  algorithmInstanceUid?: string(name='AlgorithmInstanceUid', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  pageNo?: int32(name='PageNo', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  powerStationName?: string(name='PowerStationName'),
}

model ListPowerStationResponseBody = {
  code?: string(name='Code'),
  data?: {
    dataList?: [ 
      {
        algoInstanceUid?: string(name='AlgoInstanceUid'),
        description?: string(name='Description'),
        name?: string(name='Name'),
        powerStationUid?: string(name='PowerStationUid'),
        ratedPower?: int32(name='RatedPower'),
      }
    ](name='DataList'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListPowerStationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPowerStationResponseBody(name='body'),
}

/**
 * @param request ListPowerStationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPowerStationResponse
 */
async function listPowerStationWithOptions(request: ListPowerStationRequest, runtime: Util.RuntimeOptions): ListPowerStationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithmInstanceUid)) {
    query['AlgorithmInstanceUid'] = request.algorithmInstanceUid;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.powerStationName)) {
    query['PowerStationName'] = request.powerStationName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPowerStation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListPowerStationRequest
 * @return ListPowerStationResponse
 */
async function listPowerStation(request: ListPowerStationRequest): ListPowerStationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPowerStationWithOptions(request, runtime);
}

model ListProductByTagsRequest {
  currentPage?: int32(name='CurrentPage'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
  productTag?: [ 
    {
      tagKey?: string(name='TagKey', description='This parameter is required.'),
      tagValue?: string(name='TagValue'),
    }
  ](name='ProductTag', description='This parameter is required.'),
}

model ListProductByTagsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  productInfos?: {
    productInfo?: [ 
    {
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      nodeType?: int32(name='NodeType'),
      productKey?: string(name='ProductKey'),
      productName?: string(name='ProductName'),
    }
  ](name='ProductInfo')
  }(name='ProductInfos'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListProductByTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProductByTagsResponseBody(name='body'),
}

/**
 * @param request ListProductByTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProductByTagsResponse
 */
async function listProductByTagsWithOptions(request: ListProductByTagsRequest, runtime: Util.RuntimeOptions): ListProductByTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productTag)) {
    query['ProductTag'] = request.productTag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductByTags',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListProductByTagsRequest
 * @return ListProductByTagsResponse
 */
async function listProductByTags(request: ListProductByTagsRequest): ListProductByTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductByTagsWithOptions(request, runtime);
}

model ListProductTagsRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model ListProductTagsResponseBody = {
  code?: string(name='Code'),
  data?: {
    productTag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='ProductTag')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListProductTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProductTagsResponseBody(name='body'),
}

/**
 * @param request ListProductTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProductTagsResponse
 */
async function listProductTagsWithOptions(request: ListProductTagsRequest, runtime: Util.RuntimeOptions): ListProductTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductTags',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListProductTagsRequest
 * @return ListProductTagsResponse
 */
async function listProductTags(request: ListProductTagsRequest): ListProductTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductTagsWithOptions(request, runtime);
}

model ListRuleRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    ruleInfo?: [ 
    {
      createUserId?: long(name='CreateUserId'),
      created?: string(name='Created'),
      dataType?: string(name='DataType'),
      id?: long(name='Id'),
      modified?: string(name='Modified'),
      name?: string(name='Name'),
      productKey?: string(name='ProductKey'),
      ruleDesc?: string(name='RuleDesc'),
      select?: string(name='Select'),
      shortTopic?: string(name='ShortTopic'),
      status?: string(name='Status'),
      topic?: string(name='Topic'),
      utcCreated?: string(name='UtcCreated'),
      utcModified?: string(name='UtcModified'),
      where?: string(name='Where'),
    }
  ](name='RuleInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRuleResponseBody(name='body'),
}

/**
 * @param request ListRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRuleResponse
 */
async function listRuleWithOptions(request: ListRuleRequest, runtime: Util.RuntimeOptions): ListRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListRuleRequest
 * @return ListRuleResponse
 */
async function listRule(request: ListRuleRequest): ListRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRuleWithOptions(request, runtime);
}

model ListRuleActionsRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
}

model ListRuleActionsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  ruleActionList?: {
    ruleActionInfo?: [ 
    {
      configuration?: string(name='Configuration'),
      errorActionFlag?: boolean(name='ErrorActionFlag'),
      id?: long(name='Id'),
      ruleId?: long(name='RuleId'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='RuleActionInfo')
  }(name='RuleActionList'),
  success?: boolean(name='Success'),
}

model ListRuleActionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRuleActionsResponseBody(name='body'),
}

/**
 * @param request ListRuleActionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRuleActionsResponse
 */
async function listRuleActionsWithOptions(request: ListRuleActionsRequest, runtime: Util.RuntimeOptions): ListRuleActionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRuleActions',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListRuleActionsRequest
 * @return ListRuleActionsResponse
 */
async function listRuleActions(request: ListRuleActionsRequest): ListRuleActionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRuleActionsWithOptions(request, runtime);
}

model ListTaskRequest {
  device?: map[string]any(name='Device'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId'),
  limit?: int32(name='Limit', description='This parameter is required.'),
  nextToken?: string(name='NextToken'),
  status?: string(name='Status'),
}

model ListTaskShrinkRequest {
  deviceShrink?: string(name='Device'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId'),
  limit?: int32(name='Limit', description='This parameter is required.'),
  nextToken?: string(name='NextToken'),
  status?: string(name='Status'),
}

model ListTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    data?: [ 
    {
      deviceName?: string(name='DeviceName'),
      iotId?: string(name='IotId'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      productKey?: string(name='ProductKey'),
      progress?: string(name='Progress'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
      utcModified?: string(name='UtcModified'),
      utcQueueTime?: string(name='UtcQueueTime'),
    }
  ](name='data')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTaskResponseBody(name='body'),
}

/**
 * @param tmpReq ListTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTaskResponse
 */
async function listTaskWithOptions(tmpReq: ListTaskRequest, runtime: Util.RuntimeOptions): ListTaskResponse {
  Util.validateModel(tmpReq);
  var request = new ListTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.device)) {
    request.deviceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.device, 'Device', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.deviceShrink)) {
    query['Device'] = request.deviceShrink;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTask',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListTaskRequest
 * @return ListTaskResponse
 */
async function listTask(request: ListTaskRequest): ListTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskWithOptions(request, runtime);
}

model ListThingModelVersionRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model ListThingModelVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    modelVersions?: [ 
      {
        description?: string(name='Description'),
        gmtCreate?: long(name='GmtCreate'),
        modelVersion?: string(name='ModelVersion'),
      }
    ](name='ModelVersions'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListThingModelVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListThingModelVersionResponseBody(name='body'),
}

/**
 * @param request ListThingModelVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListThingModelVersionResponse
 */
async function listThingModelVersionWithOptions(request: ListThingModelVersionRequest, runtime: Util.RuntimeOptions): ListThingModelVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListThingModelVersion',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListThingModelVersionRequest
 * @return ListThingModelVersionResponse
 */
async function listThingModelVersion(request: ListThingModelVersionRequest): ListThingModelVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listThingModelVersionWithOptions(request, runtime);
}

model ListThingTemplatesRequest {
  iotInstanceId?: string(name='IotInstanceId'),
}

model ListThingTemplatesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      categoryKey?: string(name='CategoryKey'),
      categoryName?: string(name='CategoryName'),
    }
  ](name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListThingTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListThingTemplatesResponseBody(name='body'),
}

/**
 * @param request ListThingTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListThingTemplatesResponse
 */
async function listThingTemplatesWithOptions(request: ListThingTemplatesRequest, runtime: Util.RuntimeOptions): ListThingTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListThingTemplates',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListThingTemplatesRequest
 * @return ListThingTemplatesResponse
 */
async function listThingTemplates(request: ListThingTemplatesRequest): ListThingTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listThingTemplatesWithOptions(request, runtime);
}

model ModifyOTAFirmwareRequest {
  firmwareDesc?: string(name='FirmwareDesc'),
  firmwareId?: string(name='FirmwareId', description='This parameter is required.'),
  firmwareName?: string(name='FirmwareName'),
  firmwareUdi?: string(name='FirmwareUdi'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model ModifyOTAFirmwareResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyOTAFirmwareResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyOTAFirmwareResponseBody(name='body'),
}

/**
 * @param request ModifyOTAFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyOTAFirmwareResponse
 */
async function modifyOTAFirmwareWithOptions(request: ModifyOTAFirmwareRequest, runtime: Util.RuntimeOptions): ModifyOTAFirmwareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.firmwareDesc)) {
    query['FirmwareDesc'] = request.firmwareDesc;
  }
  if (!Util.isUnset(request.firmwareId)) {
    query['FirmwareId'] = request.firmwareId;
  }
  if (!Util.isUnset(request.firmwareName)) {
    query['FirmwareName'] = request.firmwareName;
  }
  if (!Util.isUnset(request.firmwareUdi)) {
    query['FirmwareUdi'] = request.firmwareUdi;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyOTAFirmware',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ModifyOTAFirmwareRequest
 * @return ModifyOTAFirmwareResponse
 */
async function modifyOTAFirmware(request: ModifyOTAFirmwareRequest): ModifyOTAFirmwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyOTAFirmwareWithOptions(request, runtime);
}

model ModifyPowerStationRequest {
  algorithmInstanceUid?: string(name='AlgorithmInstanceUid', description='This parameter is required.'),
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  powerStationName?: string(name='PowerStationName'),
  powerStationUid?: string(name='PowerStationUid', description='This parameter is required.'),
  ratedPower?: int32(name='RatedPower', description='This parameter is required.'),
}

model ModifyPowerStationResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyPowerStationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPowerStationResponseBody(name='body'),
}

/**
 * @param request ModifyPowerStationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPowerStationResponse
 */
async function modifyPowerStationWithOptions(request: ModifyPowerStationRequest, runtime: Util.RuntimeOptions): ModifyPowerStationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithmInstanceUid)) {
    query['AlgorithmInstanceUid'] = request.algorithmInstanceUid;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.powerStationName)) {
    query['PowerStationName'] = request.powerStationName;
  }
  if (!Util.isUnset(request.powerStationUid)) {
    query['PowerStationUid'] = request.powerStationUid;
  }
  if (!Util.isUnset(request.ratedPower)) {
    query['RatedPower'] = request.ratedPower;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPowerStation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ModifyPowerStationRequest
 * @return ModifyPowerStationResponse
 */
async function modifyPowerStation(request: ModifyPowerStationRequest): ModifyPowerStationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPowerStationWithOptions(request, runtime);
}

model NotifyAddThingTopoRequest {
  deviceListStr?: string(name='DeviceListStr'),
  gwDeviceName?: string(name='GwDeviceName'),
  gwIotId?: string(name='GwIotId'),
  gwProductKey?: string(name='GwProductKey'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model NotifyAddThingTopoResponseBody = {
  code?: string(name='Code'),
  data?: {
    messageId?: string(name='MessageId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model NotifyAddThingTopoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: NotifyAddThingTopoResponseBody(name='body'),
}

/**
 * @param request NotifyAddThingTopoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return NotifyAddThingTopoResponse
 */
async function notifyAddThingTopoWithOptions(request: NotifyAddThingTopoRequest, runtime: Util.RuntimeOptions): NotifyAddThingTopoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceListStr)) {
    query['DeviceListStr'] = request.deviceListStr;
  }
  if (!Util.isUnset(request.gwDeviceName)) {
    query['GwDeviceName'] = request.gwDeviceName;
  }
  if (!Util.isUnset(request.gwIotId)) {
    query['GwIotId'] = request.gwIotId;
  }
  if (!Util.isUnset(request.gwProductKey)) {
    query['GwProductKey'] = request.gwProductKey;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'NotifyAddThingTopo',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request NotifyAddThingTopoRequest
 * @return NotifyAddThingTopoResponse
 */
async function notifyAddThingTopo(request: NotifyAddThingTopoRequest): NotifyAddThingTopoResponse {
  var runtime = new Util.RuntimeOptions{};
  return notifyAddThingTopoWithOptions(request, runtime);
}

model OpenIotServiceRequest {
  ownerId?: long(name='OwnerId'),
}

model OpenIotServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenIotServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenIotServiceResponseBody(name='body'),
}

/**
 * @param request OpenIotServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenIotServiceResponse
 */
async function openIotServiceWithOptions(request: OpenIotServiceRequest, runtime: Util.RuntimeOptions): OpenIotServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenIotService',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request OpenIotServiceRequest
 * @return OpenIotServiceResponse
 */
async function openIotService(request: OpenIotServiceRequest): OpenIotServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openIotServiceWithOptions(request, runtime);
}

model PackageSoundCodeLabelBatchAudioRequest {
  batchCode?: string(name='BatchCode', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model PackageSoundCodeLabelBatchAudioResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PackageSoundCodeLabelBatchAudioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PackageSoundCodeLabelBatchAudioResponseBody(name='body'),
}

/**
 * @param request PackageSoundCodeLabelBatchAudioRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PackageSoundCodeLabelBatchAudioResponse
 */
async function packageSoundCodeLabelBatchAudioWithOptions(request: PackageSoundCodeLabelBatchAudioRequest, runtime: Util.RuntimeOptions): PackageSoundCodeLabelBatchAudioResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.batchCode)) {
    body['BatchCode'] = request.batchCode;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PackageSoundCodeLabelBatchAudio',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PackageSoundCodeLabelBatchAudioRequest
 * @return PackageSoundCodeLabelBatchAudioResponse
 */
async function packageSoundCodeLabelBatchAudio(request: PackageSoundCodeLabelBatchAudioRequest): PackageSoundCodeLabelBatchAudioResponse {
  var runtime = new Util.RuntimeOptions{};
  return packageSoundCodeLabelBatchAudioWithOptions(request, runtime);
}

model PageQuerySharedSpeechOpenRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey'),
  shareTaskCode?: string(name='ShareTaskCode'),
  status?: int32(name='Status'),
}

model PageQuerySharedSpeechOpenResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    resultData?: {
      data?: [ 
      {
        audioFormat?: string(name='AudioFormat'),
        bizCode?: string(name='BizCode'),
        code?: string(name='Code'),
        speechRate?: int32(name='SpeechRate'),
        status?: int32(name='Status'),
        text?: string(name='Text'),
        voice?: string(name='Voice'),
        volume?: int32(name='Volume'),
      }
    ](name='Data')
    }(name='ResultData'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PageQuerySharedSpeechOpenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PageQuerySharedSpeechOpenResponseBody(name='body'),
}

/**
 * @param request PageQuerySharedSpeechOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PageQuerySharedSpeechOpenResponse
 */
async function pageQuerySharedSpeechOpenWithOptions(request: PageQuerySharedSpeechOpenRequest, runtime: Util.RuntimeOptions): PageQuerySharedSpeechOpenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.shareTaskCode)) {
    body['ShareTaskCode'] = request.shareTaskCode;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PageQuerySharedSpeechOpen',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PageQuerySharedSpeechOpenRequest
 * @return PageQuerySharedSpeechOpenResponse
 */
async function pageQuerySharedSpeechOpen(request: PageQuerySharedSpeechOpenRequest): PageQuerySharedSpeechOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return pageQuerySharedSpeechOpenWithOptions(request, runtime);
}

model PageQuerySpeechBroadcastHourRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
  pageToken?: string(name='PageToken'),
  queryDateTimeHour?: string(name='QueryDateTimeHour', description='This parameter is required.'),
  shareTaskCode?: string(name='ShareTaskCode', description='This parameter is required.'),
}

model PageQuerySpeechBroadcastHourResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    pageToken?: string(name='PageToken'),
    resultData?: {
      data?: [ 
      {
        code?: int32(name='Code'),
        deviceName?: string(name='DeviceName'),
        msg?: string(name='Msg'),
        productKey?: string(name='ProductKey'),
        shareTaskCode?: string(name='ShareTaskCode'),
        speechId?: string(name='SpeechId'),
        speechs?: string(name='Speechs'),
        startTime?: long(name='StartTime'),
      }
    ](name='Data')
    }(name='ResultData'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PageQuerySpeechBroadcastHourResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PageQuerySpeechBroadcastHourResponseBody(name='body'),
}

/**
 * @param request PageQuerySpeechBroadcastHourRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PageQuerySpeechBroadcastHourResponse
 */
async function pageQuerySpeechBroadcastHourWithOptions(request: PageQuerySpeechBroadcastHourRequest, runtime: Util.RuntimeOptions): PageQuerySpeechBroadcastHourResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.queryDateTimeHour)) {
    query['QueryDateTimeHour'] = request.queryDateTimeHour;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pageToken)) {
    body['PageToken'] = request.pageToken;
  }
  if (!Util.isUnset(request.shareTaskCode)) {
    body['ShareTaskCode'] = request.shareTaskCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PageQuerySpeechBroadcastHour',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PageQuerySpeechBroadcastHourRequest
 * @return PageQuerySpeechBroadcastHourResponse
 */
async function pageQuerySpeechBroadcastHour(request: PageQuerySpeechBroadcastHourRequest): PageQuerySpeechBroadcastHourResponse {
  var runtime = new Util.RuntimeOptions{};
  return pageQuerySpeechBroadcastHourWithOptions(request, runtime);
}

model PrintByTemplateRequest {
  deviceName?: string(name='DeviceName'),
  historyPrintTopic?: boolean(name='HistoryPrintTopic'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  paramsJsonString?: string(name='ParamsJsonString'),
  productKey?: string(name='ProductKey'),
  templateBizCode?: string(name='TemplateBizCode', description='This parameter is required.'),
}

model PrintByTemplateResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceErrorCode?: string(name='DeviceErrorCode'),
    deviceErrorMessage?: string(name='DeviceErrorMessage'),
    id?: string(name='Id'),
    maxRetryCount?: int32(name='MaxRetryCount'),
    retryCount?: int32(name='RetryCount'),
    success?: boolean(name='Success'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PrintByTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PrintByTemplateResponseBody(name='body'),
}

/**
 * @param request PrintByTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PrintByTemplateResponse
 */
async function printByTemplateWithOptions(request: PrintByTemplateRequest, runtime: Util.RuntimeOptions): PrintByTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.historyPrintTopic)) {
    body['HistoryPrintTopic'] = request.historyPrintTopic;
  }
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.paramsJsonString)) {
    body['ParamsJsonString'] = request.paramsJsonString;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.templateBizCode)) {
    body['TemplateBizCode'] = request.templateBizCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PrintByTemplate',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PrintByTemplateRequest
 * @return PrintByTemplateResponse
 */
async function printByTemplate(request: PrintByTemplateRequest): PrintByTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return printByTemplateWithOptions(request, runtime);
}

model PubRequest {
  contentType?: string(name='ContentType'),
  correlationData?: string(name='CorrelationData'),
  deviceName?: string(name='DeviceName'),
  iotInstanceId?: string(name='IotInstanceId'),
  messageContent?: string(name='MessageContent', description='This parameter is required.'),
  messageExpiryInterval?: long(name='MessageExpiryInterval'),
  payloadFormatIndicator?: int32(name='PayloadFormatIndicator'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  qos?: int32(name='Qos'),
  responseTopic?: string(name='ResponseTopic'),
  retained?: boolean(name='Retained'),
  topicAlias?: int32(name='TopicAlias'),
  topicFullName?: string(name='TopicFullName', description='This parameter is required.'),
  userProp?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='UserProp'),
}

model PubResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  messageId?: string(name='MessageId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PubResponseBody(name='body'),
}

/**
 * @param request PubRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PubResponse
 */
async function pubWithOptions(request: PubRequest, runtime: Util.RuntimeOptions): PubResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contentType)) {
    query['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.correlationData)) {
    query['CorrelationData'] = request.correlationData;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.messageExpiryInterval)) {
    query['MessageExpiryInterval'] = request.messageExpiryInterval;
  }
  if (!Util.isUnset(request.payloadFormatIndicator)) {
    query['PayloadFormatIndicator'] = request.payloadFormatIndicator;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.qos)) {
    query['Qos'] = request.qos;
  }
  if (!Util.isUnset(request.responseTopic)) {
    query['ResponseTopic'] = request.responseTopic;
  }
  if (!Util.isUnset(request.retained)) {
    query['Retained'] = request.retained;
  }
  if (!Util.isUnset(request.topicAlias)) {
    query['TopicAlias'] = request.topicAlias;
  }
  if (!Util.isUnset(request.topicFullName)) {
    query['TopicFullName'] = request.topicFullName;
  }
  if (!Util.isUnset(request.userProp)) {
    query['UserProp'] = request.userProp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.messageContent)) {
    body['MessageContent'] = request.messageContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Pub',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PubRequest
 * @return PubResponse
 */
async function pub(request: PubRequest): PubResponse {
  var runtime = new Util.RuntimeOptions{};
  return pubWithOptions(request, runtime);
}

model PubBroadcastRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  messageContent?: string(name='MessageContent', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  topicFullName?: string(name='TopicFullName'),
}

model PubBroadcastResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  messageId?: long(name='MessageId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PubBroadcastResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PubBroadcastResponseBody(name='body'),
}

/**
 * @param request PubBroadcastRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PubBroadcastResponse
 */
async function pubBroadcastWithOptions(request: PubBroadcastRequest, runtime: Util.RuntimeOptions): PubBroadcastResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.messageContent)) {
    query['MessageContent'] = request.messageContent;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.topicFullName)) {
    query['TopicFullName'] = request.topicFullName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PubBroadcast',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PubBroadcastRequest
 * @return PubBroadcastResponse
 */
async function pubBroadcast(request: PubBroadcastRequest): PubBroadcastResponse {
  var runtime = new Util.RuntimeOptions{};
  return pubBroadcastWithOptions(request, runtime);
}

model PublishScriptRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model PublishScriptResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  syntaxErrorMsg?: string(name='SyntaxErrorMsg'),
}

model PublishScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishScriptResponseBody(name='body'),
}

/**
 * @param request PublishScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishScriptResponse
 */
async function publishScriptWithOptions(request: PublishScriptRequest, runtime: Util.RuntimeOptions): PublishScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishScript',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PublishScriptRequest
 * @return PublishScriptResponse
 */
async function publishScript(request: PublishScriptRequest): PublishScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishScriptWithOptions(request, runtime);
}

model PublishStudioAppRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model PublishStudioAppResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PublishStudioAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishStudioAppResponseBody(name='body'),
}

/**
 * @param request PublishStudioAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishStudioAppResponse
 */
async function publishStudioAppWithOptions(request: PublishStudioAppRequest, runtime: Util.RuntimeOptions): PublishStudioAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishStudioApp',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PublishStudioAppRequest
 * @return PublishStudioAppResponse
 */
async function publishStudioApp(request: PublishStudioAppRequest): PublishStudioAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishStudioAppWithOptions(request, runtime);
}

model PublishThingModelRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  modelVersion?: string(name='ModelVersion'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model PublishThingModelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PublishThingModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishThingModelResponseBody(name='body'),
}

/**
 * @param request PublishThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishThingModelResponse
 */
async function publishThingModelWithOptions(request: PublishThingModelRequest, runtime: Util.RuntimeOptions): PublishThingModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.modelVersion)) {
    query['ModelVersion'] = request.modelVersion;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishThingModel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PublishThingModelRequest
 * @return PublishThingModelResponse
 */
async function publishThingModel(request: PublishThingModelRequest): PublishThingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishThingModelWithOptions(request, runtime);
}

model PublishThingModelAsyncRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  thingModelVersion?: string(name='ThingModelVersion'),
}

model PublishThingModelAsyncResponseBody = {
  code?: int32(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PublishThingModelAsyncResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishThingModelAsyncResponseBody(name='body'),
}

/**
 * @param request PublishThingModelAsyncRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishThingModelAsyncResponse
 */
async function publishThingModelAsyncWithOptions(request: PublishThingModelAsyncRequest, runtime: Util.RuntimeOptions): PublishThingModelAsyncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.thingModelVersion)) {
    query['ThingModelVersion'] = request.thingModelVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishThingModelAsync',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PublishThingModelAsyncRequest
 * @return PublishThingModelAsyncResponse
 */
async function publishThingModelAsync(request: PublishThingModelAsyncRequest): PublishThingModelAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishThingModelAsyncWithOptions(request, runtime);
}

model PublishThingModelAsyncInnerRequest {
  insId?: string(name='InsId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model PublishThingModelAsyncInnerResponseBody = {
  code?: int32(name='Code'),
  localizedMsg?: string(name='LocalizedMsg'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PublishThingModelAsyncInnerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishThingModelAsyncInnerResponseBody(name='body'),
}

/**
 * @param request PublishThingModelAsyncInnerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishThingModelAsyncInnerResponse
 */
async function publishThingModelAsyncInnerWithOptions(request: PublishThingModelAsyncInnerRequest, runtime: Util.RuntimeOptions): PublishThingModelAsyncInnerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.insId)) {
    query['InsId'] = request.insId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishThingModelAsyncInner',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PublishThingModelAsyncInnerRequest
 * @return PublishThingModelAsyncInnerResponse
 */
async function publishThingModelAsyncInner(request: PublishThingModelAsyncInnerRequest): PublishThingModelAsyncInnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishThingModelAsyncInnerWithOptions(request, runtime);
}

model PushSpeechRequest {
  deviceName?: string(name='DeviceName'),
  groupId?: string(name='GroupId'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
  pushMode?: string(name='PushMode', description='This parameter is required.'),
  speechCodeList?: [ string ](name='SpeechCodeList', description='This parameter is required.'),
}

model PushSpeechResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PushSpeechResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushSpeechResponseBody(name='body'),
}

/**
 * @param request PushSpeechRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushSpeechResponse
 */
async function pushSpeechWithOptions(request: PushSpeechRequest, runtime: Util.RuntimeOptions): PushSpeechResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.projectCode)) {
    body['ProjectCode'] = request.projectCode;
  }
  if (!Util.isUnset(request.pushMode)) {
    body['PushMode'] = request.pushMode;
  }
  if (!Util.isUnset(request.speechCodeList)) {
    body['SpeechCodeList'] = request.speechCodeList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PushSpeech',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushSpeechRequest
 * @return PushSpeechResponse
 */
async function pushSpeech(request: PushSpeechRequest): PushSpeechResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushSpeechWithOptions(request, runtime);
}

model QueryBatchRegisterDeviceStatusRequest {
  applyId?: long(name='ApplyId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryBatchRegisterDeviceStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    invalidDetailList?: {
      invalidDetailList?: [ 
      {
        deviceName?: string(name='DeviceName'),
        errorMsg?: string(name='ErrorMsg'),
        nickName?: string(name='NickName'),
      }
    ](name='invalidDetailList')
    }(name='InvalidDetailList'),
    invalidList?: {
      name?: [ string ](name='Name')
    }(name='InvalidList'),
    status?: string(name='Status'),
    validList?: {
      name?: [ string ](name='Name')
    }(name='ValidList'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryBatchRegisterDeviceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryBatchRegisterDeviceStatusResponseBody(name='body'),
}

/**
 * @param request QueryBatchRegisterDeviceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryBatchRegisterDeviceStatusResponse
 */
async function queryBatchRegisterDeviceStatusWithOptions(request: QueryBatchRegisterDeviceStatusRequest, runtime: Util.RuntimeOptions): QueryBatchRegisterDeviceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyId)) {
    query['ApplyId'] = request.applyId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryBatchRegisterDeviceStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryBatchRegisterDeviceStatusRequest
 * @return QueryBatchRegisterDeviceStatusResponse
 */
async function queryBatchRegisterDeviceStatus(request: QueryBatchRegisterDeviceStatusRequest): QueryBatchRegisterDeviceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBatchRegisterDeviceStatusWithOptions(request, runtime);
}

model QueryCertUrlByApplyIdRequest {
  applyId?: long(name='ApplyId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QueryCertUrlByApplyIdResponseBody = {
  certUrl?: string(name='CertUrl'),
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryCertUrlByApplyIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryCertUrlByApplyIdResponseBody(name='body'),
}

/**
 * @param request QueryCertUrlByApplyIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryCertUrlByApplyIdResponse
 */
async function queryCertUrlByApplyIdWithOptions(request: QueryCertUrlByApplyIdRequest, runtime: Util.RuntimeOptions): QueryCertUrlByApplyIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyId)) {
    query['ApplyId'] = request.applyId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCertUrlByApplyId',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryCertUrlByApplyIdRequest
 * @return QueryCertUrlByApplyIdResponse
 */
async function queryCertUrlByApplyId(request: QueryCertUrlByApplyIdRequest): QueryCertUrlByApplyIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCertUrlByApplyIdWithOptions(request, runtime);
}

model QueryClientIdsRequest {
  iotId?: string(name='IotId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QueryClientIdsResponseBody = {
  code?: string(name='Code'),
  data?: {
    dynamicRegClientIds?: [ 
      {
        clientId?: string(name='ClientId'),
        createTime?: long(name='CreateTime'),
      }
    ](name='DynamicRegClientIds'),
    iotId?: string(name='IotId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryClientIdsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryClientIdsResponseBody(name='body'),
}

/**
 * @param request QueryClientIdsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryClientIdsResponse
 */
async function queryClientIdsWithOptions(request: QueryClientIdsRequest, runtime: Util.RuntimeOptions): QueryClientIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryClientIds',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryClientIdsRequest
 * @return QueryClientIdsResponse
 */
async function queryClientIds(request: QueryClientIdsRequest): QueryClientIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryClientIdsWithOptions(request, runtime);
}

model QueryConsumerGroupByGroupIdRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QueryConsumerGroupByGroupIdResponseBody = {
  code?: string(name='Code'),
  data?: {
    createTime?: string(name='CreateTime'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryConsumerGroupByGroupIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryConsumerGroupByGroupIdResponseBody(name='body'),
}

/**
 * @param request QueryConsumerGroupByGroupIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryConsumerGroupByGroupIdResponse
 */
async function queryConsumerGroupByGroupIdWithOptions(request: QueryConsumerGroupByGroupIdRequest, runtime: Util.RuntimeOptions): QueryConsumerGroupByGroupIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryConsumerGroupByGroupId',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryConsumerGroupByGroupIdRequest
 * @return QueryConsumerGroupByGroupIdResponse
 */
async function queryConsumerGroupByGroupId(request: QueryConsumerGroupByGroupIdRequest): QueryConsumerGroupByGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryConsumerGroupByGroupIdWithOptions(request, runtime);
}

model QueryConsumerGroupListRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  fuzzy?: boolean(name='Fuzzy'),
  groupName?: string(name='GroupName'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  subBizCode?: string(name='SubBizCode'),
  type?: string(name='Type'),
}

model QueryConsumerGroupListResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    consumerGroupDTO?: [ 
    {
      createTime?: string(name='CreateTime'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
    }
  ](name='ConsumerGroupDTO')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryConsumerGroupListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryConsumerGroupListResponseBody(name='body'),
}

/**
 * @param request QueryConsumerGroupListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryConsumerGroupListResponse
 */
async function queryConsumerGroupListWithOptions(request: QueryConsumerGroupListRequest, runtime: Util.RuntimeOptions): QueryConsumerGroupListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fuzzy)) {
    query['Fuzzy'] = request.fuzzy;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.subBizCode)) {
    query['SubBizCode'] = request.subBizCode;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryConsumerGroupList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryConsumerGroupListRequest
 * @return QueryConsumerGroupListResponse
 */
async function queryConsumerGroupList(request: QueryConsumerGroupListRequest): QueryConsumerGroupListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryConsumerGroupListWithOptions(request, runtime);
}

model QueryConsumerGroupStatusRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QueryConsumerGroupStatusResponseBody = {
  accumulatedConsumeCountPerMinute?: int32(name='AccumulatedConsumeCountPerMinute'),
  accumulationCount?: int32(name='AccumulationCount'),
  clientConnectionStatusList?: {
    consumerGroupClientConnectionInfo?: [ 
    {
      accumulatedConsumeCountPerMinute?: int32(name='AccumulatedConsumeCountPerMinute'),
      clientId?: string(name='ClientId'),
      clientIpPort?: string(name='ClientIpPort'),
      onlineTime?: long(name='OnlineTime'),
      realTimeConsumeCountPerMinute?: int32(name='RealTimeConsumeCountPerMinute'),
    }
  ](name='ConsumerGroupClientConnectionInfo')
  }(name='ClientConnectionStatusList'),
  code?: string(name='Code'),
  consumerSpeed?: int32(name='ConsumerSpeed'),
  errorMessage?: string(name='ErrorMessage'),
  lastConsumerTime?: string(name='LastConsumerTime'),
  realTimeConsumeCountPerMinute?: int32(name='RealTimeConsumeCountPerMinute'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryConsumerGroupStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryConsumerGroupStatusResponseBody(name='body'),
}

/**
 * @param request QueryConsumerGroupStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryConsumerGroupStatusResponse
 */
async function queryConsumerGroupStatusWithOptions(request: QueryConsumerGroupStatusRequest, runtime: Util.RuntimeOptions): QueryConsumerGroupStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryConsumerGroupStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryConsumerGroupStatusRequest
 * @return QueryConsumerGroupStatusResponse
 */
async function queryConsumerGroupStatus(request: QueryConsumerGroupStatusRequest): QueryConsumerGroupStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryConsumerGroupStatusWithOptions(request, runtime);
}

model QueryCustomTimelineTableStatusRequest {
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  tableName?: string(name='TableName', description='This parameter is required.'),
}

model QueryCustomTimelineTableStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    count?: long(name='Count'),
    hasNext?: boolean(name='HasNext'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    resultJson?: string(name='ResultJson'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryCustomTimelineTableStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryCustomTimelineTableStatusResponseBody(name='body'),
}

/**
 * @param request QueryCustomTimelineTableStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryCustomTimelineTableStatusResponse
 */
async function queryCustomTimelineTableStatusWithOptions(request: QueryCustomTimelineTableStatusRequest, runtime: Util.RuntimeOptions): QueryCustomTimelineTableStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCustomTimelineTableStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryCustomTimelineTableStatusRequest
 * @return QueryCustomTimelineTableStatusResponse
 */
async function queryCustomTimelineTableStatus(request: QueryCustomTimelineTableStatusRequest): QueryCustomTimelineTableStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCustomTimelineTableStatusWithOptions(request, runtime);
}

model QueryDetailSceneRuleLogRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  endTime?: int32(name='EndTime', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
  startTime?: int32(name='StartTime', description='This parameter is required.'),
  traceId?: string(name='TraceId', description='This parameter is required.'),
}

model QueryDetailSceneRuleLogResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    logList?: [ 
      {
        code?: string(name='Code'),
        message?: string(name='Message'),
        pkDn?: string(name='PkDn'),
      }
    ](name='LogList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDetailSceneRuleLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDetailSceneRuleLogResponseBody(name='body'),
}

/**
 * @param request QueryDetailSceneRuleLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDetailSceneRuleLogResponse
 */
async function queryDetailSceneRuleLogWithOptions(request: QueryDetailSceneRuleLogRequest, runtime: Util.RuntimeOptions): QueryDetailSceneRuleLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.traceId)) {
    query['TraceId'] = request.traceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDetailSceneRuleLog',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDetailSceneRuleLogRequest
 * @return QueryDetailSceneRuleLogResponse
 */
async function queryDetailSceneRuleLog(request: QueryDetailSceneRuleLogRequest): QueryDetailSceneRuleLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDetailSceneRuleLogWithOptions(request, runtime);
}

model QueryDeviceRequest {
  currentPage?: int32(name='CurrentPage'),
  iotInstanceId?: string(name='IotInstanceId'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceInfo?: [ 
    {
      deviceId?: string(name='DeviceId'),
      deviceName?: string(name='DeviceName'),
      deviceSecret?: string(name='DeviceSecret'),
      deviceStatus?: string(name='DeviceStatus'),
      deviceType?: string(name='DeviceType'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      iotId?: string(name='IotId'),
      nickname?: string(name='Nickname'),
      productKey?: string(name='ProductKey'),
      utcCreate?: string(name='UtcCreate'),
      utcModified?: string(name='UtcModified'),
    }
  ](name='DeviceInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  nextToken?: string(name='NextToken'),
  page?: int32(name='Page'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceResponseBody(name='body'),
}

/**
 * @param request QueryDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceResponse
 */
async function queryDeviceWithOptions(request: QueryDeviceRequest, runtime: Util.RuntimeOptions): QueryDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceRequest
 * @return QueryDeviceResponse
 */
async function queryDevice(request: QueryDeviceRequest): QueryDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceWithOptions(request, runtime);
}

model QueryDeviceBySQLRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  SQL?: string(name='SQL', description='This parameter is required.'),
}

model QueryDeviceBySQLResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      activeTime?: string(name='ActiveTime'),
      deviceName?: string(name='DeviceName'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      groups?: [ 
        {
          groupId?: string(name='GroupId'),
        }
      ](name='Groups'),
      iotId?: string(name='IotId'),
      nickname?: string(name='Nickname'),
      OTAModules?: [ 
        {
          firmwareVersion?: string(name='FirmwareVersion'),
          moduleName?: string(name='ModuleName'),
        }
      ](name='OTAModules'),
      productKey?: string(name='ProductKey'),
      status?: string(name='Status'),
      tags?: [ 
        {
          tagName?: string(name='TagName'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tags'),
    }
  ](name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model QueryDeviceBySQLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceBySQLResponseBody(name='body'),
}

/**
 * @param request QueryDeviceBySQLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceBySQLResponse
 */
async function queryDeviceBySQLWithOptions(request: QueryDeviceBySQLRequest, runtime: Util.RuntimeOptions): QueryDeviceBySQLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.SQL)) {
    query['SQL'] = request.SQL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceBySQL',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceBySQLRequest
 * @return QueryDeviceBySQLResponse
 */
async function queryDeviceBySQL(request: QueryDeviceBySQLRequest): QueryDeviceBySQLResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceBySQLWithOptions(request, runtime);
}

model QueryDeviceByStatusRequest {
  currentPage?: int32(name='CurrentPage'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey'),
  resourceGroupId?: string(name='ResourceGroupId'),
  status?: int32(name='Status', description='This parameter is required.'),
}

model QueryDeviceByStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    simpleDeviceInfo?: [ 
    {
      deviceName?: string(name='DeviceName'),
      deviceSecret?: string(name='DeviceSecret'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      iotId?: string(name='IotId'),
      nickname?: string(name='Nickname'),
      productKey?: string(name='ProductKey'),
      status?: string(name='Status'),
      utcCreate?: string(name='UtcCreate'),
      utcModified?: string(name='UtcModified'),
    }
  ](name='SimpleDeviceInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryDeviceByStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceByStatusResponseBody(name='body'),
}

/**
 * @param request QueryDeviceByStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceByStatusResponse
 */
async function queryDeviceByStatusWithOptions(request: QueryDeviceByStatusRequest, runtime: Util.RuntimeOptions): QueryDeviceByStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceByStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceByStatusRequest
 * @return QueryDeviceByStatusResponse
 */
async function queryDeviceByStatus(request: QueryDeviceByStatusRequest): QueryDeviceByStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceByStatusWithOptions(request, runtime);
}

model QueryDeviceByTagsRequest {
  currentPage?: int32(name='CurrentPage'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
  tag?: [ 
    {
      tagKey?: string(name='TagKey', description='This parameter is required.'),
      tagValue?: string(name='TagValue', description='This parameter is required.'),
    }
  ](name='Tag'),
}

model QueryDeviceByTagsResponseBody = {
  code?: string(name='Code'),
  data?: {
    simpleDeviceInfo?: [ 
    {
      deviceName?: string(name='DeviceName'),
      iotId?: string(name='IotId'),
      productKey?: string(name='ProductKey'),
      productName?: string(name='ProductName'),
    }
  ](name='SimpleDeviceInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryDeviceByTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceByTagsResponseBody(name='body'),
}

/**
 * @param request QueryDeviceByTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceByTagsResponse
 */
async function queryDeviceByTagsWithOptions(request: QueryDeviceByTagsRequest, runtime: Util.RuntimeOptions): QueryDeviceByTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceByTags',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceByTagsRequest
 * @return QueryDeviceByTagsResponse
 */
async function queryDeviceByTags(request: QueryDeviceByTagsRequest): QueryDeviceByTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceByTagsWithOptions(request, runtime);
}

model QueryDeviceCertRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryDeviceCertResponseBody = {
  code?: string(name='Code'),
  deviceCertInfo?: {
    certSN?: string(name='CertSN'),
    certificate?: string(name='Certificate'),
    privateKey?: string(name='PrivateKey'),
    status?: int32(name='Status'),
  }(name='DeviceCertInfo'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceCertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceCertResponseBody(name='body'),
}

/**
 * @param request QueryDeviceCertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceCertResponse
 */
async function queryDeviceCertWithOptions(request: QueryDeviceCertRequest, runtime: Util.RuntimeOptions): QueryDeviceCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceCert',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceCertRequest
 * @return QueryDeviceCertResponse
 */
async function queryDeviceCert(request: QueryDeviceCertRequest): QueryDeviceCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceCertWithOptions(request, runtime);
}

model QueryDeviceDesiredPropertyRequest {
  deviceName?: string(name='DeviceName'),
  functionBlockId?: string(name='FunctionBlockId'),
  identifier?: [ string ](name='Identifier'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model QueryDeviceDesiredPropertyResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      desiredPropertyInfo?: [ 
      {
        dataType?: string(name='DataType'),
        identifier?: string(name='Identifier'),
        name?: string(name='Name'),
        time?: string(name='Time'),
        unit?: string(name='Unit'),
        value?: string(name='Value'),
        version?: long(name='Version'),
      }
    ](name='DesiredPropertyInfo')
    }(name='List'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceDesiredPropertyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceDesiredPropertyResponseBody(name='body'),
}

/**
 * @param request QueryDeviceDesiredPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceDesiredPropertyResponse
 */
async function queryDeviceDesiredPropertyWithOptions(request: QueryDeviceDesiredPropertyRequest, runtime: Util.RuntimeOptions): QueryDeviceDesiredPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceDesiredProperty',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceDesiredPropertyRequest
 * @return QueryDeviceDesiredPropertyResponse
 */
async function queryDeviceDesiredProperty(request: QueryDeviceDesiredPropertyRequest): QueryDeviceDesiredPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceDesiredPropertyWithOptions(request, runtime);
}

model QueryDeviceDetailRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model QueryDeviceDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceName?: string(name='DeviceName'),
    deviceSecret?: string(name='DeviceSecret'),
    firmwareVersion?: string(name='FirmwareVersion'),
    gmtActive?: string(name='GmtActive'),
    gmtCreate?: string(name='GmtCreate'),
    gmtOnline?: string(name='GmtOnline'),
    gmtTimestamp?: string(name='GmtTimestamp'),
    iotId?: string(name='IotId'),
    ipAddress?: string(name='IpAddress'),
    nickname?: string(name='Nickname'),
    nodeType?: int32(name='NodeType'),
    owner?: boolean(name='Owner'),
    productKey?: string(name='ProductKey'),
    productName?: string(name='ProductName'),
    region?: string(name='Region'),
    status?: string(name='Status'),
    utcActive?: string(name='UtcActive'),
    utcCreate?: string(name='UtcCreate'),
    utcOnline?: string(name='UtcOnline'),
    utcTimestamp?: string(name='UtcTimestamp'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceDetailResponseBody(name='body'),
}

/**
 * @param request QueryDeviceDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceDetailResponse
 */
async function queryDeviceDetailWithOptions(request: QueryDeviceDetailRequest, runtime: Util.RuntimeOptions): QueryDeviceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceDetail',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceDetailRequest
 * @return QueryDeviceDetailResponse
 */
async function queryDeviceDetail(request: QueryDeviceDetailRequest): QueryDeviceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceDetailWithOptions(request, runtime);
}

model QueryDeviceDistributeDetailRequest {
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model QueryDeviceDistributeDetailResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  file?: string(name='File'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceDistributeDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceDistributeDetailResponseBody(name='body'),
}

/**
 * @param request QueryDeviceDistributeDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceDistributeDetailResponse
 */
async function queryDeviceDistributeDetailWithOptions(request: QueryDeviceDistributeDetailRequest, runtime: Util.RuntimeOptions): QueryDeviceDistributeDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceDistributeDetail',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceDistributeDetailRequest
 * @return QueryDeviceDistributeDetailResponse
 */
async function queryDeviceDistributeDetail(request: QueryDeviceDistributeDetailRequest): QueryDeviceDistributeDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceDistributeDetailWithOptions(request, runtime);
}

model QueryDeviceDistributeJobRequest {
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model QueryDeviceDistributeJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    gmtCreate?: long(name='GmtCreate'),
    jobId?: string(name='JobId'),
    productKey?: string(name='ProductKey'),
    sourceInstanceId?: string(name='SourceInstanceId'),
    sourceUid?: string(name='SourceUid'),
    status?: int32(name='Status'),
    strategy?: int32(name='Strategy'),
    targetInstanceConfigs?: {
      targetInstanceConfigs?: [ 
      {
        targetInstanceId?: string(name='TargetInstanceId'),
      }
    ](name='targetInstanceConfigs')
    }(name='TargetInstanceConfigs'),
    targetUid?: string(name='TargetUid'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceDistributeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceDistributeJobResponseBody(name='body'),
}

/**
 * @param request QueryDeviceDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceDistributeJobResponse
 */
async function queryDeviceDistributeJobWithOptions(request: QueryDeviceDistributeJobRequest, runtime: Util.RuntimeOptions): QueryDeviceDistributeJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceDistributeJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceDistributeJobRequest
 * @return QueryDeviceDistributeJobResponse
 */
async function queryDeviceDistributeJob(request: QueryDeviceDistributeJobRequest): QueryDeviceDistributeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceDistributeJobWithOptions(request, runtime);
}

model QueryDeviceEventDataRequest {
  asc?: int32(name='Asc'),
  deviceName?: string(name='DeviceName'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  eventType?: string(name='EventType'),
  identifier?: string(name='Identifier'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model QueryDeviceEventDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      eventInfo?: [ 
      {
        eventType?: string(name='EventType'),
        identifier?: string(name='Identifier'),
        name?: string(name='Name'),
        outputData?: string(name='OutputData'),
        time?: string(name='Time'),
      }
    ](name='EventInfo')
    }(name='List'),
    nextTime?: long(name='NextTime'),
    nextValid?: boolean(name='NextValid'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceEventDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceEventDataResponseBody(name='body'),
}

/**
 * @param request QueryDeviceEventDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceEventDataResponse
 */
async function queryDeviceEventDataWithOptions(request: QueryDeviceEventDataRequest, runtime: Util.RuntimeOptions): QueryDeviceEventDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceEventData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceEventDataRequest
 * @return QueryDeviceEventDataResponse
 */
async function queryDeviceEventData(request: QueryDeviceEventDataRequest): QueryDeviceEventDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceEventDataWithOptions(request, runtime);
}

model QueryDeviceFileRequest {
  deviceName?: string(name='DeviceName'),
  fileId?: string(name='FileId', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model QueryDeviceFileResponseBody = {
  code?: string(name='Code'),
  data?: {
    downloadUrl?: string(name='DownloadUrl'),
    fileId?: string(name='FileId'),
    name?: string(name='Name'),
    size?: string(name='Size'),
    utcCreatedOn?: string(name='UtcCreatedOn'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceFileResponseBody(name='body'),
}

/**
 * @param request QueryDeviceFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceFileResponse
 */
async function queryDeviceFileWithOptions(request: QueryDeviceFileRequest, runtime: Util.RuntimeOptions): QueryDeviceFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.fileId)) {
    query['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceFile',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceFileRequest
 * @return QueryDeviceFileResponse
 */
async function queryDeviceFile(request: QueryDeviceFileRequest): QueryDeviceFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceFileWithOptions(request, runtime);
}

model QueryDeviceFileListRequest {
  currentPage?: int32(name='CurrentPage'),
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey'),
}

model QueryDeviceFileListResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    fileSummary?: [ 
    {
      fileId?: string(name='FileId'),
      name?: string(name='Name'),
      size?: string(name='Size'),
      utcCreatedOn?: string(name='UtcCreatedOn'),
    }
  ](name='FileSummary')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryDeviceFileListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceFileListResponseBody(name='body'),
}

/**
 * @param request QueryDeviceFileListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceFileListResponse
 */
async function queryDeviceFileListWithOptions(request: QueryDeviceFileListRequest, runtime: Util.RuntimeOptions): QueryDeviceFileListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceFileList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceFileListRequest
 * @return QueryDeviceFileListResponse
 */
async function queryDeviceFileList(request: QueryDeviceFileListRequest): QueryDeviceFileListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceFileListWithOptions(request, runtime);
}

model QueryDeviceGroupByDeviceRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryDeviceGroupByDeviceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  groupInfos?: {
    groupInfo?: [ 
    {
      groupDesc?: string(name='GroupDesc'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      utcCreate?: string(name='UtcCreate'),
    }
  ](name='GroupInfo')
  }(name='GroupInfos'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceGroupByDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceGroupByDeviceResponseBody(name='body'),
}

/**
 * @param request QueryDeviceGroupByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupByDeviceResponse
 */
async function queryDeviceGroupByDeviceWithOptions(request: QueryDeviceGroupByDeviceRequest, runtime: Util.RuntimeOptions): QueryDeviceGroupByDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceGroupByDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceGroupByDeviceRequest
 * @return QueryDeviceGroupByDeviceResponse
 */
async function queryDeviceGroupByDevice(request: QueryDeviceGroupByDeviceRequest): QueryDeviceGroupByDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceGroupByDeviceWithOptions(request, runtime);
}

model QueryDeviceGroupByTagsRequest {
  currentPage?: int32(name='CurrentPage'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
  tag?: [ 
    {
      tagKey?: string(name='TagKey', description='This parameter is required.'),
      tagValue?: string(name='TagValue', description='This parameter is required.'),
    }
  ](name='Tag'),
}

model QueryDeviceGroupByTagsResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceGroup?: [ 
    {
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
    }
  ](name='DeviceGroup')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryDeviceGroupByTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceGroupByTagsResponseBody(name='body'),
}

/**
 * @param request QueryDeviceGroupByTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupByTagsResponse
 */
async function queryDeviceGroupByTagsWithOptions(request: QueryDeviceGroupByTagsRequest, runtime: Util.RuntimeOptions): QueryDeviceGroupByTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceGroupByTags',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceGroupByTagsRequest
 * @return QueryDeviceGroupByTagsResponse
 */
async function queryDeviceGroupByTags(request: QueryDeviceGroupByTagsRequest): QueryDeviceGroupByTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceGroupByTagsWithOptions(request, runtime);
}

model QueryDeviceGroupInfoRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  groupType?: string(name='GroupType'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QueryDeviceGroupInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceActive?: int32(name='DeviceActive'),
    deviceCount?: int32(name='DeviceCount'),
    deviceOnline?: int32(name='DeviceOnline'),
    dynamicGroupExpression?: string(name='DynamicGroupExpression'),
    groupDesc?: string(name='GroupDesc'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    utcCreate?: string(name='UtcCreate'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceGroupInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceGroupInfoResponseBody(name='body'),
}

/**
 * @param request QueryDeviceGroupInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupInfoResponse
 */
async function queryDeviceGroupInfoWithOptions(request: QueryDeviceGroupInfoRequest, runtime: Util.RuntimeOptions): QueryDeviceGroupInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupType)) {
    query['GroupType'] = request.groupType;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceGroupInfo',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceGroupInfoRequest
 * @return QueryDeviceGroupInfoResponse
 */
async function queryDeviceGroupInfo(request: QueryDeviceGroupInfoRequest): QueryDeviceGroupInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceGroupInfoWithOptions(request, runtime);
}

model QueryDeviceGroupListRequest {
  currentPage?: int32(name='CurrentPage'),
  groupName?: string(name='GroupName'),
  groupTypes?: [ string ](name='GroupTypes'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
  superGroupId?: string(name='SuperGroupId'),
}

model QueryDeviceGroupListResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    groupInfo?: [ 
    {
      groupDesc?: string(name='GroupDesc'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      groupType?: string(name='GroupType'),
      utcCreate?: string(name='UtcCreate'),
    }
  ](name='GroupInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryDeviceGroupListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceGroupListResponseBody(name='body'),
}

/**
 * @param request QueryDeviceGroupListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupListResponse
 */
async function queryDeviceGroupListWithOptions(request: QueryDeviceGroupListRequest, runtime: Util.RuntimeOptions): QueryDeviceGroupListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.groupTypes)) {
    query['GroupTypes'] = request.groupTypes;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.superGroupId)) {
    query['SuperGroupId'] = request.superGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceGroupList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceGroupListRequest
 * @return QueryDeviceGroupListResponse
 */
async function queryDeviceGroupList(request: QueryDeviceGroupListRequest): QueryDeviceGroupListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceGroupListWithOptions(request, runtime);
}

model QueryDeviceGroupTagListRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  groupType?: string(name='GroupType'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QueryDeviceGroupTagListResponseBody = {
  code?: string(name='Code'),
  data?: {
    groupTagInfo?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='GroupTagInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceGroupTagListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceGroupTagListResponseBody(name='body'),
}

/**
 * @param request QueryDeviceGroupTagListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupTagListResponse
 */
async function queryDeviceGroupTagListWithOptions(request: QueryDeviceGroupTagListRequest, runtime: Util.RuntimeOptions): QueryDeviceGroupTagListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupType)) {
    query['GroupType'] = request.groupType;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceGroupTagList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceGroupTagListRequest
 * @return QueryDeviceGroupTagListResponse
 */
async function queryDeviceGroupTagList(request: QueryDeviceGroupTagListRequest): QueryDeviceGroupTagListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceGroupTagListWithOptions(request, runtime);
}

model QueryDeviceInfoRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model QueryDeviceInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceName?: string(name='DeviceName'),
    deviceSecret?: string(name='DeviceSecret'),
    iotId?: string(name='IotId'),
    nickname?: string(name='Nickname'),
    productKey?: string(name='ProductKey'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceInfoResponseBody(name='body'),
}

/**
 * @param request QueryDeviceInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceInfoResponse
 */
async function queryDeviceInfoWithOptions(request: QueryDeviceInfoRequest, runtime: Util.RuntimeOptions): QueryDeviceInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceInfo',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceInfoRequest
 * @return QueryDeviceInfoResponse
 */
async function queryDeviceInfo(request: QueryDeviceInfoRequest): QueryDeviceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceInfoWithOptions(request, runtime);
}

model QueryDeviceListByDeviceGroupRequest {
  currentPage?: int32(name='CurrentPage'),
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
}

model QueryDeviceListByDeviceGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    simpleDeviceInfo?: [ 
    {
      deviceName?: string(name='DeviceName'),
      iotId?: string(name='IotId'),
      productKey?: string(name='ProductKey'),
      productName?: string(name='ProductName'),
    }
  ](name='SimpleDeviceInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryDeviceListByDeviceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceListByDeviceGroupResponseBody(name='body'),
}

/**
 * @param request QueryDeviceListByDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceListByDeviceGroupResponse
 */
async function queryDeviceListByDeviceGroupWithOptions(request: QueryDeviceListByDeviceGroupRequest, runtime: Util.RuntimeOptions): QueryDeviceListByDeviceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceListByDeviceGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceListByDeviceGroupRequest
 * @return QueryDeviceListByDeviceGroupResponse
 */
async function queryDeviceListByDeviceGroup(request: QueryDeviceListByDeviceGroupRequest): QueryDeviceListByDeviceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceListByDeviceGroupWithOptions(request, runtime);
}

model QueryDeviceOriginalEventDataRequest {
  asc?: int32(name='Asc', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  identifier?: string(name='Identifier', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model QueryDeviceOriginalEventDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      eventInfo?: [ 
      {
        eventType?: string(name='EventType'),
        identifier?: string(name='Identifier'),
        name?: string(name='Name'),
        outputData?: string(name='OutputData'),
        time?: string(name='Time'),
      }
    ](name='EventInfo')
    }(name='List'),
    nextPageToken?: string(name='NextPageToken'),
    nextValid?: boolean(name='NextValid'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceOriginalEventDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceOriginalEventDataResponseBody(name='body'),
}

/**
 * @param request QueryDeviceOriginalEventDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceOriginalEventDataResponse
 */
async function queryDeviceOriginalEventDataWithOptions(request: QueryDeviceOriginalEventDataRequest, runtime: Util.RuntimeOptions): QueryDeviceOriginalEventDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceOriginalEventData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceOriginalEventDataRequest
 * @return QueryDeviceOriginalEventDataResponse
 */
async function queryDeviceOriginalEventData(request: QueryDeviceOriginalEventDataRequest): QueryDeviceOriginalEventDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceOriginalEventDataWithOptions(request, runtime);
}

model QueryDeviceOriginalPropertyDataRequest {
  asc?: int32(name='Asc', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  identifier?: string(name='Identifier', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model QueryDeviceOriginalPropertyDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      propertyInfo?: [ 
      {
        time?: string(name='Time'),
        value?: string(name='Value'),
      }
    ](name='PropertyInfo')
    }(name='List'),
    nextValid?: boolean(name='NextValid'),
    nextPageToken?: string(name='nextPageToken'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceOriginalPropertyDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceOriginalPropertyDataResponseBody(name='body'),
}

/**
 * @param request QueryDeviceOriginalPropertyDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceOriginalPropertyDataResponse
 */
async function queryDeviceOriginalPropertyDataWithOptions(request: QueryDeviceOriginalPropertyDataRequest, runtime: Util.RuntimeOptions): QueryDeviceOriginalPropertyDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceOriginalPropertyData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceOriginalPropertyDataRequest
 * @return QueryDeviceOriginalPropertyDataResponse
 */
async function queryDeviceOriginalPropertyData(request: QueryDeviceOriginalPropertyDataRequest): QueryDeviceOriginalPropertyDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceOriginalPropertyDataWithOptions(request, runtime);
}

model QueryDeviceOriginalPropertyStatusRequest {
  asc?: int32(name='Asc', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
}

model QueryDeviceOriginalPropertyStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      propertyStatusDataInfo?: [ 
      {
        identifier?: string(name='Identifier'),
        time?: long(name='Time'),
        value?: string(name='Value'),
      }
    ](name='PropertyStatusDataInfo')
    }(name='List'),
    nextPageToken?: string(name='NextPageToken'),
    nextValid?: boolean(name='NextValid'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceOriginalPropertyStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceOriginalPropertyStatusResponseBody(name='body'),
}

/**
 * @param request QueryDeviceOriginalPropertyStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceOriginalPropertyStatusResponse
 */
async function queryDeviceOriginalPropertyStatusWithOptions(request: QueryDeviceOriginalPropertyStatusRequest, runtime: Util.RuntimeOptions): QueryDeviceOriginalPropertyStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceOriginalPropertyStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceOriginalPropertyStatusRequest
 * @return QueryDeviceOriginalPropertyStatusResponse
 */
async function queryDeviceOriginalPropertyStatus(request: QueryDeviceOriginalPropertyStatusRequest): QueryDeviceOriginalPropertyStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceOriginalPropertyStatusWithOptions(request, runtime);
}

model QueryDeviceOriginalServiceDataRequest {
  asc?: int32(name='Asc', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  identifier?: string(name='Identifier', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model QueryDeviceOriginalServiceDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      serviceInfo?: [ 
      {
        identifier?: string(name='Identifier'),
        inputData?: string(name='InputData'),
        name?: string(name='Name'),
        outputData?: string(name='OutputData'),
        time?: string(name='Time'),
      }
    ](name='ServiceInfo')
    }(name='List'),
    nextPageToken?: string(name='NextPageToken'),
    nextValid?: boolean(name='NextValid'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceOriginalServiceDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceOriginalServiceDataResponseBody(name='body'),
}

/**
 * @param request QueryDeviceOriginalServiceDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceOriginalServiceDataResponse
 */
async function queryDeviceOriginalServiceDataWithOptions(request: QueryDeviceOriginalServiceDataRequest, runtime: Util.RuntimeOptions): QueryDeviceOriginalServiceDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceOriginalServiceData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceOriginalServiceDataRequest
 * @return QueryDeviceOriginalServiceDataResponse
 */
async function queryDeviceOriginalServiceData(request: QueryDeviceOriginalServiceDataRequest): QueryDeviceOriginalServiceDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceOriginalServiceDataWithOptions(request, runtime);
}

model QueryDevicePropRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model QueryDevicePropResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  props?: string(name='Props'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDevicePropResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDevicePropResponseBody(name='body'),
}

/**
 * @param request QueryDevicePropRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicePropResponse
 */
async function queryDevicePropWithOptions(request: QueryDevicePropRequest, runtime: Util.RuntimeOptions): QueryDevicePropResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceProp',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDevicePropRequest
 * @return QueryDevicePropResponse
 */
async function queryDeviceProp(request: QueryDevicePropRequest): QueryDevicePropResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDevicePropWithOptions(request, runtime);
}

model QueryDevicePropertiesDataRequest {
  asc?: int32(name='Asc', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  identifier?: [ string ](name='Identifier', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model QueryDevicePropertiesDataResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  nextTime?: long(name='NextTime'),
  nextValid?: boolean(name='NextValid'),
  propertyDataInfos?: {
    propertyDataInfo?: [ 
    {
      identifier?: string(name='Identifier'),
      list?: {
        propertyInfo?: [ 
        {
          time?: long(name='Time'),
          value?: string(name='Value'),
        }
      ](name='PropertyInfo')
      }(name='List'),
    }
  ](name='PropertyDataInfo')
  }(name='PropertyDataInfos'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDevicePropertiesDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDevicePropertiesDataResponseBody(name='body'),
}

/**
 * @param request QueryDevicePropertiesDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicePropertiesDataResponse
 */
async function queryDevicePropertiesDataWithOptions(request: QueryDevicePropertiesDataRequest, runtime: Util.RuntimeOptions): QueryDevicePropertiesDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDevicePropertiesData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDevicePropertiesDataRequest
 * @return QueryDevicePropertiesDataResponse
 */
async function queryDevicePropertiesData(request: QueryDevicePropertiesDataRequest): QueryDevicePropertiesDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDevicePropertiesDataWithOptions(request, runtime);
}

model QueryDevicePropertyDataRequest {
  asc?: int32(name='Asc', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  identifier?: string(name='Identifier', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model QueryDevicePropertyDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      propertyInfo?: [ 
      {
        time?: string(name='Time'),
        value?: string(name='Value'),
      }
    ](name='PropertyInfo')
    }(name='List'),
    nextTime?: long(name='NextTime'),
    nextValid?: boolean(name='NextValid'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDevicePropertyDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDevicePropertyDataResponseBody(name='body'),
}

/**
 * @param request QueryDevicePropertyDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicePropertyDataResponse
 */
async function queryDevicePropertyDataWithOptions(request: QueryDevicePropertyDataRequest, runtime: Util.RuntimeOptions): QueryDevicePropertyDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDevicePropertyData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDevicePropertyDataRequest
 * @return QueryDevicePropertyDataResponse
 */
async function queryDevicePropertyData(request: QueryDevicePropertyDataRequest): QueryDevicePropertyDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDevicePropertyDataWithOptions(request, runtime);
}

model QueryDevicePropertyStatusRequest {
  deviceName?: string(name='DeviceName'),
  functionBlockId?: string(name='FunctionBlockId'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model QueryDevicePropertyStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      propertyStatusInfo?: [ 
      {
        dataType?: string(name='DataType'),
        identifier?: string(name='Identifier'),
        name?: string(name='Name'),
        time?: string(name='Time'),
        unit?: string(name='Unit'),
        value?: string(name='Value'),
      }
    ](name='PropertyStatusInfo')
    }(name='List'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDevicePropertyStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDevicePropertyStatusResponseBody(name='body'),
}

/**
 * @param request QueryDevicePropertyStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicePropertyStatusResponse
 */
async function queryDevicePropertyStatusWithOptions(request: QueryDevicePropertyStatusRequest, runtime: Util.RuntimeOptions): QueryDevicePropertyStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDevicePropertyStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDevicePropertyStatusRequest
 * @return QueryDevicePropertyStatusResponse
 */
async function queryDevicePropertyStatus(request: QueryDevicePropertyStatusRequest): QueryDevicePropertyStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDevicePropertyStatusWithOptions(request, runtime);
}

model QueryDeviceProvisioningRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryDeviceProvisioningResponseBody = {
  code?: string(name='Code'),
  data?: {
    aliyunUid?: string(name='AliyunUid'),
    deviceName?: string(name='DeviceName'),
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    productKey?: string(name='ProductKey'),
    sourceIotInstanceId?: string(name='SourceIotInstanceId'),
    sourceRegion?: string(name='SourceRegion'),
    targetIotInstanceId?: string(name='TargetIotInstanceId'),
    targetRegion?: string(name='TargetRegion'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceProvisioningResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceProvisioningResponseBody(name='body'),
}

/**
 * @param request QueryDeviceProvisioningRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceProvisioningResponse
 */
async function queryDeviceProvisioningWithOptions(request: QueryDeviceProvisioningRequest, runtime: Util.RuntimeOptions): QueryDeviceProvisioningResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceProvisioning',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceProvisioningRequest
 * @return QueryDeviceProvisioningResponse
 */
async function queryDeviceProvisioning(request: QueryDeviceProvisioningRequest): QueryDeviceProvisioningResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceProvisioningWithOptions(request, runtime);
}

model QueryDeviceServiceDataRequest {
  asc?: int32(name='Asc'),
  deviceName?: string(name='DeviceName'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  identifier?: string(name='Identifier'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
}

model QueryDeviceServiceDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      serviceInfo?: [ 
      {
        identifier?: string(name='Identifier'),
        inputData?: string(name='InputData'),
        name?: string(name='Name'),
        outputData?: string(name='OutputData'),
        time?: string(name='Time'),
      }
    ](name='ServiceInfo')
    }(name='List'),
    nextTime?: long(name='NextTime'),
    nextValid?: boolean(name='NextValid'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceServiceDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceServiceDataResponseBody(name='body'),
}

/**
 * @param request QueryDeviceServiceDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceServiceDataResponse
 */
async function queryDeviceServiceDataWithOptions(request: QueryDeviceServiceDataRequest, runtime: Util.RuntimeOptions): QueryDeviceServiceDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceServiceData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceServiceDataRequest
 * @return QueryDeviceServiceDataResponse
 */
async function queryDeviceServiceData(request: QueryDeviceServiceDataRequest): QueryDeviceServiceDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceServiceDataWithOptions(request, runtime);
}

model QueryDeviceSpeechRequest {
  iotId?: string(name='IotId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
}

model QueryDeviceSpeechResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        audioFormat?: string(name='AudioFormat'),
        bizCode?: string(name='BizCode'),
        size?: float(name='Size'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceSpeechResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceSpeechResponseBody(name='body'),
}

/**
 * @param request QueryDeviceSpeechRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceSpeechResponse
 */
async function queryDeviceSpeechWithOptions(request: QueryDeviceSpeechRequest, runtime: Util.RuntimeOptions): QueryDeviceSpeechResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceSpeech',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceSpeechRequest
 * @return QueryDeviceSpeechResponse
 */
async function queryDeviceSpeech(request: QueryDeviceSpeechRequest): QueryDeviceSpeechResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceSpeechWithOptions(request, runtime);
}

model QueryDeviceStatisticsRequest {
  groupId?: string(name='GroupId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model QueryDeviceStatisticsResponseBody = {
  code?: string(name='Code'),
  data?: {
    activeCount?: long(name='activeCount'),
    deviceCount?: long(name='deviceCount'),
    onlineCount?: long(name='onlineCount'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceStatisticsResponseBody(name='body'),
}

/**
 * @param request QueryDeviceStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceStatisticsResponse
 */
async function queryDeviceStatisticsWithOptions(request: QueryDeviceStatisticsRequest, runtime: Util.RuntimeOptions): QueryDeviceStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceStatistics',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceStatisticsRequest
 * @return QueryDeviceStatisticsResponse
 */
async function queryDeviceStatistics(request: QueryDeviceStatisticsRequest): QueryDeviceStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceStatisticsWithOptions(request, runtime);
}

model QueryDeviceSubTopicRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryDeviceSubTopicResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  topicList?: [ 
    {
      timestamp?: long(name='Timestamp'),
      topicName?: string(name='TopicName'),
    }
  ](name='TopicList'),
}

model QueryDeviceSubTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceSubTopicResponseBody(name='body'),
}

/**
 * @param request QueryDeviceSubTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceSubTopicResponse
 */
async function queryDeviceSubTopicWithOptions(request: QueryDeviceSubTopicRequest, runtime: Util.RuntimeOptions): QueryDeviceSubTopicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceSubTopic',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceSubTopicRequest
 * @return QueryDeviceSubTopicResponse
 */
async function queryDeviceSubTopic(request: QueryDeviceSubTopicRequest): QueryDeviceSubTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceSubTopicWithOptions(request, runtime);
}

model QueryDeviceTunnelRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  tunnelId?: string(name='TunnelId', description='This parameter is required.'),
}

model QueryDeviceTunnelResponseBody = {
  code?: string(name='Code'),
  data?: {
    description?: string(name='Description'),
    deviceConnState?: string(name='DeviceConnState'),
    deviceName?: string(name='DeviceName'),
    iotId?: string(name='IotId'),
    productKey?: string(name='ProductKey'),
    productName?: string(name='ProductName'),
    sourceConnState?: string(name='SourceConnState'),
    tunnelId?: string(name='TunnelId'),
    tunnelState?: string(name='TunnelState'),
    udi?: string(name='Udi'),
    utcClosed?: string(name='UtcClosed'),
    utcCreated?: string(name='UtcCreated'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDeviceTunnelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDeviceTunnelResponseBody(name='body'),
}

/**
 * @param request QueryDeviceTunnelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceTunnelResponse
 */
async function queryDeviceTunnelWithOptions(request: QueryDeviceTunnelRequest, runtime: Util.RuntimeOptions): QueryDeviceTunnelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.tunnelId)) {
    query['TunnelId'] = request.tunnelId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDeviceTunnel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDeviceTunnelRequest
 * @return QueryDeviceTunnelResponse
 */
async function queryDeviceTunnel(request: QueryDeviceTunnelRequest): QueryDeviceTunnelResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDeviceTunnelWithOptions(request, runtime);
}

model QueryDevicesHotStorageDataRequest {
  asc?: int32(name='Asc', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  identifier?: string(name='Identifier', description='This parameter is required.'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  userTopic?: string(name='UserTopic', description='This parameter is required.'),
}

model QueryDevicesHotStorageDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      propertyInfo?: [ 
      {
        time?: string(name='Time'),
        value?: string(name='Value'),
      }
    ](name='PropertyInfo')
    }(name='List'),
    nextValid?: boolean(name='NextValid'),
    nextPageToken?: string(name='nextPageToken'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDevicesHotStorageDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDevicesHotStorageDataResponseBody(name='body'),
}

/**
 * @param request QueryDevicesHotStorageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicesHotStorageDataResponse
 */
async function queryDevicesHotStorageDataWithOptions(request: QueryDevicesHotStorageDataRequest, runtime: Util.RuntimeOptions): QueryDevicesHotStorageDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.userTopic)) {
    query['UserTopic'] = request.userTopic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDevicesHotStorageData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDevicesHotStorageDataRequest
 * @return QueryDevicesHotStorageDataResponse
 */
async function queryDevicesHotStorageData(request: QueryDevicesHotStorageDataRequest): QueryDevicesHotStorageDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDevicesHotStorageDataWithOptions(request, runtime);
}

model QueryDevicesHotStorageDataStatusRequest {
  asc?: int32(name='Asc', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  userTopic?: string(name='UserTopic', description='This parameter is required.'),
}

model QueryDevicesHotStorageDataStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      propertyStatusDataInfo?: [ 
      {
        identifier?: string(name='Identifier'),
        time?: long(name='Time'),
        value?: string(name='Value'),
      }
    ](name='PropertyStatusDataInfo')
    }(name='List'),
    nextPageToken?: string(name='NextPageToken'),
    nextValid?: boolean(name='NextValid'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDevicesHotStorageDataStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDevicesHotStorageDataStatusResponseBody(name='body'),
}

/**
 * @param request QueryDevicesHotStorageDataStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicesHotStorageDataStatusResponse
 */
async function queryDevicesHotStorageDataStatusWithOptions(request: QueryDevicesHotStorageDataStatusRequest, runtime: Util.RuntimeOptions): QueryDevicesHotStorageDataStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asc)) {
    query['Asc'] = request.asc;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.nextPageToken)) {
    query['NextPageToken'] = request.nextPageToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.userTopic)) {
    query['UserTopic'] = request.userTopic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDevicesHotStorageDataStatus',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDevicesHotStorageDataStatusRequest
 * @return QueryDevicesHotStorageDataStatusResponse
 */
async function queryDevicesHotStorageDataStatus(request: QueryDevicesHotStorageDataStatusRequest): QueryDevicesHotStorageDataStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDevicesHotStorageDataStatusWithOptions(request, runtime);
}

model QueryDynamicGroupDevicesRequest {
  currentPage?: int32(name='CurrentPage'),
  deviceName?: string(name='DeviceName'),
  fuzzyName?: boolean(name='FuzzyName'),
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey'),
  status?: string(name='Status'),
}

model QueryDynamicGroupDevicesResponseBody = {
  code?: string(name='Code'),
  data?: {
    simpleDeviceInfo?: [ 
    {
      activeTime?: string(name='ActiveTime'),
      categoryKey?: string(name='CategoryKey'),
      deviceName?: string(name='DeviceName'),
      iotId?: string(name='IotId'),
      lastOnlineTime?: string(name='LastOnlineTime'),
      nickname?: string(name='Nickname'),
      nodeType?: int32(name='NodeType'),
      productKey?: string(name='ProductKey'),
      productName?: string(name='ProductName'),
      status?: string(name='Status'),
      utcActiveTime?: string(name='UtcActiveTime'),
      utcLastOnlineTime?: string(name='UtcLastOnlineTime'),
    }
  ](name='SimpleDeviceInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  nextToken?: string(name='NextToken'),
  page?: int32(name='Page'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryDynamicGroupDevicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryDynamicGroupDevicesResponseBody(name='body'),
}

/**
 * @param request QueryDynamicGroupDevicesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDynamicGroupDevicesResponse
 */
async function queryDynamicGroupDevicesWithOptions(request: QueryDynamicGroupDevicesRequest, runtime: Util.RuntimeOptions): QueryDynamicGroupDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.fuzzyName)) {
    query['FuzzyName'] = request.fuzzyName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDynamicGroupDevices',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryDynamicGroupDevicesRequest
 * @return QueryDynamicGroupDevicesResponse
 */
async function queryDynamicGroupDevices(request: QueryDynamicGroupDevicesRequest): QueryDynamicGroupDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDynamicGroupDevicesWithOptions(request, runtime);
}

model QueryEdgeDriverRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  driverName?: string(name='DriverName'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  type?: int32(name='Type', description='This parameter is required.'),
}

model QueryEdgeDriverResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    driverList?: [ 
      {
        cpuArch?: string(name='CpuArch'),
        driverId?: string(name='DriverId'),
        driverName?: string(name='DriverName'),
        driverProtocol?: string(name='DriverProtocol'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
        isApply?: boolean(name='IsApply'),
        isBuiltIn?: boolean(name='IsBuiltIn'),
        runtime?: string(name='Runtime'),
        type?: int32(name='Type'),
      }
    ](name='DriverList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeDriverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeDriverResponseBody(name='body'),
}

/**
 * @param request QueryEdgeDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeDriverResponse
 */
async function queryEdgeDriverWithOptions(request: QueryEdgeDriverRequest, runtime: Util.RuntimeOptions): QueryEdgeDriverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.driverName)) {
    query['DriverName'] = request.driverName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeDriver',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeDriverRequest
 * @return QueryEdgeDriverResponse
 */
async function queryEdgeDriver(request: QueryEdgeDriverRequest): QueryEdgeDriverResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeDriverWithOptions(request, runtime);
}

model QueryEdgeDriverVersionRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  driverVersion?: string(name='DriverVersion'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  versionState?: int32(name='VersionState'),
}

model QueryEdgeDriverVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    driverVersionList?: [ 
      {
        argument?: string(name='Argument'),
        configCheckRule?: string(name='ConfigCheckRule'),
        containerConfig?: string(name='ContainerConfig'),
        description?: string(name='Description'),
        driverConfig?: string(name='DriverConfig'),
        driverId?: string(name='DriverId'),
        driverVersion?: string(name='DriverVersion'),
        edgeVersion?: string(name='EdgeVersion'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
        sourceConfig?: string(name='SourceConfig'),
        versionState?: string(name='VersionState'),
      }
    ](name='DriverVersionList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeDriverVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeDriverVersionResponseBody(name='body'),
}

/**
 * @param request QueryEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeDriverVersionResponse
 */
async function queryEdgeDriverVersionWithOptions(request: QueryEdgeDriverVersionRequest, runtime: Util.RuntimeOptions): QueryEdgeDriverVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.driverVersion)) {
    query['DriverVersion'] = request.driverVersion;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.versionState)) {
    query['VersionState'] = request.versionState;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeDriverVersion',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeDriverVersionRequest
 * @return QueryEdgeDriverVersionResponse
 */
async function queryEdgeDriverVersion(request: QueryEdgeDriverVersionRequest): QueryEdgeDriverVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeDriverVersionWithOptions(request, runtime);
}

model QueryEdgeInstanceRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model QueryEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    instanceList?: [ 
      {
        bizEnable?: boolean(name='BizEnable'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
        instanceId?: string(name='InstanceId'),
        latestDeploymentStatus?: int32(name='LatestDeploymentStatus'),
        latestDeploymentType?: string(name='LatestDeploymentType'),
        name?: string(name='Name'),
        roleArn?: string(name='RoleArn'),
        roleAttachTime?: string(name='RoleAttachTime'),
        roleAttachTimestamp?: long(name='RoleAttachTimestamp'),
        roleName?: string(name='RoleName'),
        spec?: int32(name='Spec'),
        tags?: string(name='Tags'),
        type?: int32(name='Type'),
      }
    ](name='InstanceList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request QueryEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceResponse
 */
async function queryEdgeInstanceWithOptions(request: QueryEdgeInstanceRequest, runtime: Util.RuntimeOptions): QueryEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeInstanceRequest
 * @return QueryEdgeInstanceResponse
 */
async function queryEdgeInstance(request: QueryEdgeInstanceRequest): QueryEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeInstanceWithOptions(request, runtime);
}

model QueryEdgeInstanceChannelRequest {
  channelName?: string(name='ChannelName'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model QueryEdgeInstanceChannelResponseBody = {
  code?: string(name='Code'),
  data?: {
    channelList?: {
      channel?: [ 
      {
        channelId?: string(name='ChannelId'),
        channelName?: string(name='ChannelName'),
        configList?: {
          config?: [ 
          {
            configId?: string(name='ConfigId'),
            content?: string(name='Content'),
            format?: string(name='Format'),
            key?: string(name='Key'),
          }
        ](name='Config')
        }(name='ConfigList'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
      }
    ](name='Channel')
    }(name='ChannelList'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeInstanceChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeInstanceChannelResponseBody(name='body'),
}

/**
 * @param request QueryEdgeInstanceChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceChannelResponse
 */
async function queryEdgeInstanceChannelWithOptions(request: QueryEdgeInstanceChannelRequest, runtime: Util.RuntimeOptions): QueryEdgeInstanceChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelName)) {
    query['ChannelName'] = request.channelName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeInstanceChannel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeInstanceChannelRequest
 * @return QueryEdgeInstanceChannelResponse
 */
async function queryEdgeInstanceChannel(request: QueryEdgeInstanceChannelRequest): QueryEdgeInstanceChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeInstanceChannelWithOptions(request, runtime);
}

model QueryEdgeInstanceDeviceRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model QueryEdgeInstanceDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    deviceList?: [ 
      {
        deviceName?: string(name='DeviceName'),
        driverId?: string(name='DriverId'),
        iotId?: string(name='IotId'),
        productKey?: string(name='ProductKey'),
      }
    ](name='DeviceList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeInstanceDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeInstanceDeviceResponseBody(name='body'),
}

/**
 * @param request QueryEdgeInstanceDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceDeviceResponse
 */
async function queryEdgeInstanceDeviceWithOptions(request: QueryEdgeInstanceDeviceRequest, runtime: Util.RuntimeOptions): QueryEdgeInstanceDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeInstanceDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeInstanceDeviceRequest
 * @return QueryEdgeInstanceDeviceResponse
 */
async function queryEdgeInstanceDevice(request: QueryEdgeInstanceDeviceRequest): QueryEdgeInstanceDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeInstanceDeviceWithOptions(request, runtime);
}

model QueryEdgeInstanceDeviceByDriverRequest {
  channelId?: string(name='ChannelId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model QueryEdgeInstanceDeviceByDriverResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    deviceList?: [ 
      {
        iotId?: string(name='IotId'),
      }
    ](name='DeviceList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeInstanceDeviceByDriverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeInstanceDeviceByDriverResponseBody(name='body'),
}

/**
 * @param request QueryEdgeInstanceDeviceByDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceDeviceByDriverResponse
 */
async function queryEdgeInstanceDeviceByDriverWithOptions(request: QueryEdgeInstanceDeviceByDriverRequest, runtime: Util.RuntimeOptions): QueryEdgeInstanceDeviceByDriverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeInstanceDeviceByDriver',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeInstanceDeviceByDriverRequest
 * @return QueryEdgeInstanceDeviceByDriverResponse
 */
async function queryEdgeInstanceDeviceByDriver(request: QueryEdgeInstanceDeviceByDriverRequest): QueryEdgeInstanceDeviceByDriverResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeInstanceDeviceByDriverWithOptions(request, runtime);
}

model QueryEdgeInstanceDriverRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model QueryEdgeInstanceDriverResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    driverList?: [ 
      {
        driverId?: string(name='DriverId'),
        driverVersion?: string(name='DriverVersion'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        orderId?: string(name='OrderId'),
      }
    ](name='DriverList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeInstanceDriverResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeInstanceDriverResponseBody(name='body'),
}

/**
 * @param request QueryEdgeInstanceDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceDriverResponse
 */
async function queryEdgeInstanceDriverWithOptions(request: QueryEdgeInstanceDriverRequest, runtime: Util.RuntimeOptions): QueryEdgeInstanceDriverResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeInstanceDriver',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeInstanceDriverRequest
 * @return QueryEdgeInstanceDriverResponse
 */
async function queryEdgeInstanceDriver(request: QueryEdgeInstanceDriverRequest): QueryEdgeInstanceDriverResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeInstanceDriverWithOptions(request, runtime);
}

model QueryEdgeInstanceGatewayRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QueryEdgeInstanceGatewayResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  gatewayList?: [ 
    {
      deviceName?: string(name='DeviceName'),
      edgeVersion?: string(name='EdgeVersion'),
      iotId?: string(name='IotId'),
      productKey?: string(name='ProductKey'),
    }
  ](name='GatewayList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeInstanceGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeInstanceGatewayResponseBody(name='body'),
}

/**
 * @param request QueryEdgeInstanceGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceGatewayResponse
 */
async function queryEdgeInstanceGatewayWithOptions(request: QueryEdgeInstanceGatewayRequest, runtime: Util.RuntimeOptions): QueryEdgeInstanceGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeInstanceGateway',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeInstanceGatewayRequest
 * @return QueryEdgeInstanceGatewayResponse
 */
async function queryEdgeInstanceGateway(request: QueryEdgeInstanceGatewayRequest): QueryEdgeInstanceGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeInstanceGatewayWithOptions(request, runtime);
}

model QueryEdgeInstanceHistoricDeploymentRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  startTime?: long(name='StartTime'),
}

model QueryEdgeInstanceHistoricDeploymentResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    deploymentList?: [ 
      {
        deploymentId?: string(name='DeploymentId'),
        description?: string(name='Description'),
        gmtCompleted?: string(name='GmtCompleted'),
        gmtCompletedTimestamp?: long(name='GmtCompletedTimestamp'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
        status?: int32(name='Status'),
        type?: string(name='Type'),
      }
    ](name='DeploymentList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeInstanceHistoricDeploymentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeInstanceHistoricDeploymentResponseBody(name='body'),
}

/**
 * @param request QueryEdgeInstanceHistoricDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceHistoricDeploymentResponse
 */
async function queryEdgeInstanceHistoricDeploymentWithOptions(request: QueryEdgeInstanceHistoricDeploymentRequest, runtime: Util.RuntimeOptions): QueryEdgeInstanceHistoricDeploymentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeInstanceHistoricDeployment',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeInstanceHistoricDeploymentRequest
 * @return QueryEdgeInstanceHistoricDeploymentResponse
 */
async function queryEdgeInstanceHistoricDeployment(request: QueryEdgeInstanceHistoricDeploymentRequest): QueryEdgeInstanceHistoricDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeInstanceHistoricDeploymentWithOptions(request, runtime);
}

model QueryEdgeInstanceMessageRoutingRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model QueryEdgeInstanceMessageRoutingResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    messageRouteList?: {
      messageRoute?: [ 
      {
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateTimestamp?: long(name='GmtCreateTimestamp'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedTimestamp?: long(name='GmtModifiedTimestamp'),
        name?: string(name='Name'),
        routeContext?: {
          qos?: string(name='Qos'),
          sourceApplicationName?: string(name='SourceApplicationName'),
          sourceFcFunctionName?: string(name='SourceFcFunctionName'),
          sourceFcServiceName?: string(name='SourceFcServiceName'),
          targetApplicationName?: string(name='TargetApplicationName'),
          targetFcFunctionName?: string(name='TargetFcFunctionName'),
          targetFcServiceName?: string(name='TargetFcServiceName'),
        }(name='RouteContext'),
        routeId?: int32(name='RouteId'),
        sourceData?: string(name='SourceData'),
        sourceType?: string(name='SourceType'),
        targetData?: string(name='TargetData'),
        targetType?: string(name='TargetType'),
        topicFilter?: string(name='TopicFilter'),
      }
    ](name='MessageRoute')
    }(name='MessageRouteList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeInstanceMessageRoutingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeInstanceMessageRoutingResponseBody(name='body'),
}

/**
 * @param request QueryEdgeInstanceMessageRoutingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceMessageRoutingResponse
 */
async function queryEdgeInstanceMessageRoutingWithOptions(request: QueryEdgeInstanceMessageRoutingRequest, runtime: Util.RuntimeOptions): QueryEdgeInstanceMessageRoutingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeInstanceMessageRouting',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeInstanceMessageRoutingRequest
 * @return QueryEdgeInstanceMessageRoutingResponse
 */
async function queryEdgeInstanceMessageRouting(request: QueryEdgeInstanceMessageRoutingRequest): QueryEdgeInstanceMessageRoutingResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeInstanceMessageRoutingWithOptions(request, runtime);
}

model QueryEdgeInstanceSceneRuleRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model QueryEdgeInstanceSceneRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    ruleList?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        isExisted?: int32(name='IsExisted'),
        ruleId?: string(name='RuleId'),
        ruleName?: string(name='RuleName'),
        status?: int32(name='Status'),
      }
    ](name='RuleList'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEdgeInstanceSceneRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryEdgeInstanceSceneRuleResponseBody(name='body'),
}

/**
 * @param request QueryEdgeInstanceSceneRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceSceneRuleResponse
 */
async function queryEdgeInstanceSceneRuleWithOptions(request: QueryEdgeInstanceSceneRuleRequest, runtime: Util.RuntimeOptions): QueryEdgeInstanceSceneRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEdgeInstanceSceneRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryEdgeInstanceSceneRuleRequest
 * @return QueryEdgeInstanceSceneRuleResponse
 */
async function queryEdgeInstanceSceneRule(request: QueryEdgeInstanceSceneRuleRequest): QueryEdgeInstanceSceneRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEdgeInstanceSceneRuleWithOptions(request, runtime);
}

model QueryImportedDeviceByApplyIdRequest {
  applyId?: long(name='ApplyId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageNo?: int32(name='PageNo', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model QueryImportedDeviceByApplyIdResponseBody = {
  code?: string(name='Code'),
  deviceList?: {
    device?: [ 
    {
      deviceName?: string(name='DeviceName'),
      deviceSecret?: string(name='DeviceSecret'),
      productKey?: string(name='ProductKey'),
      sn?: string(name='Sn'),
    }
  ](name='device')
  }(name='DeviceList'),
  errorMessage?: string(name='ErrorMessage'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalPage?: int32(name='TotalPage'),
}

model QueryImportedDeviceByApplyIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryImportedDeviceByApplyIdResponseBody(name='body'),
}

/**
 * @param request QueryImportedDeviceByApplyIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryImportedDeviceByApplyIdResponse
 */
async function queryImportedDeviceByApplyIdWithOptions(request: QueryImportedDeviceByApplyIdRequest, runtime: Util.RuntimeOptions): QueryImportedDeviceByApplyIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyId)) {
    query['ApplyId'] = request.applyId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryImportedDeviceByApplyId',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryImportedDeviceByApplyIdRequest
 * @return QueryImportedDeviceByApplyIdResponse
 */
async function queryImportedDeviceByApplyId(request: QueryImportedDeviceByApplyIdRequest): QueryImportedDeviceByApplyIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryImportedDeviceByApplyIdWithOptions(request, runtime);
}

model QueryJobRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model QueryJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    description?: string(name='Description'),
    jobDocument?: string(name='JobDocument'),
    jobFile?: {
      fileUrl?: string(name='FileUrl'),
      sign?: string(name='Sign'),
      signMethod?: string(name='SignMethod'),
    }(name='JobFile'),
    jobId?: string(name='JobId'),
    jobName?: string(name='JobName'),
    rolloutConfig?: {
      maximumPerMinute?: int32(name='MaximumPerMinute'),
      messageQoS?: string(name='MessageQoS'),
    }(name='RolloutConfig'),
    scheduledTime?: long(name='ScheduledTime'),
    status?: string(name='Status'),
    targetConfig?: {
      targetDevices?: {
        targetDevices?: [ 
        {
          deviceName?: string(name='DeviceName'),
          productKey?: string(name='ProductKey'),
        }
      ](name='targetDevices')
      }(name='TargetDevices'),
      targetGroup?: string(name='TargetGroup'),
      targetProduct?: string(name='TargetProduct'),
      targetType?: string(name='TargetType'),
    }(name='TargetConfig'),
    timeoutConfig?: {
      inProgressTimeoutInMinutes?: int32(name='InProgressTimeoutInMinutes'),
    }(name='TimeoutConfig'),
    type?: string(name='Type'),
    utcCreate?: string(name='UtcCreate'),
    utcModified?: string(name='UtcModified'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryJobResponseBody(name='body'),
}

/**
 * @param request QueryJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryJobResponse
 */
async function queryJobWithOptions(request: QueryJobRequest, runtime: Util.RuntimeOptions): QueryJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryJobRequest
 * @return QueryJobResponse
 */
async function queryJob(request: QueryJobRequest): QueryJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJobWithOptions(request, runtime);
}

model QueryJobStatisticsRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model QueryJobStatisticsResponseBody = {
  code?: string(name='Code'),
  data?: {
    cancelled?: int32(name='Cancelled'),
    failed?: int32(name='Failed'),
    inProgress?: int32(name='InProgress'),
    queued?: int32(name='Queued'),
    rejected?: int32(name='Rejected'),
    sent?: int32(name='Sent'),
    succeeded?: int32(name='Succeeded'),
    timeOut?: int32(name='TimeOut'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryJobStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryJobStatisticsResponseBody(name='body'),
}

/**
 * @param request QueryJobStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryJobStatisticsResponse
 */
async function queryJobStatisticsWithOptions(request: QueryJobStatisticsRequest, runtime: Util.RuntimeOptions): QueryJobStatisticsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryJobStatistics',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryJobStatisticsRequest
 * @return QueryJobStatisticsResponse
 */
async function queryJobStatistics(request: QueryJobStatisticsRequest): QueryJobStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJobStatisticsWithOptions(request, runtime);
}

model QueryLicenseDeviceListRequest {
  endTime?: long(name='EndTime'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  licenseCode?: string(name='LicenseCode'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey'),
  startTime?: long(name='StartTime'),
}

model QueryLicenseDeviceListResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceList?: {
      item?: [ 
      {
        deviceName?: string(name='DeviceName'),
        expiryTime?: long(name='ExpiryTime'),
        gmtCreate?: long(name='GmtCreate'),
        iotId?: string(name='IotId'),
        licenseCode?: string(name='LicenseCode'),
        productKey?: string(name='ProductKey'),
        productName?: string(name='ProductName'),
      }
    ](name='item')
    }(name='DeviceList'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryLicenseDeviceListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryLicenseDeviceListResponseBody(name='body'),
}

/**
 * @param request QueryLicenseDeviceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryLicenseDeviceListResponse
 */
async function queryLicenseDeviceListWithOptions(request: QueryLicenseDeviceListRequest, runtime: Util.RuntimeOptions): QueryLicenseDeviceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.licenseCode)) {
    query['LicenseCode'] = request.licenseCode;
  }
  if (!Util.isUnset(request.pageId)) {
    query['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryLicenseDeviceList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryLicenseDeviceListRequest
 * @return QueryLicenseDeviceListResponse
 */
async function queryLicenseDeviceList(request: QueryLicenseDeviceListRequest): QueryLicenseDeviceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryLicenseDeviceListWithOptions(request, runtime);
}

model QueryLoRaJoinPermissionsRequest {
  iotInstanceId?: string(name='IotInstanceId'),
}

model QueryLoRaJoinPermissionsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  joinPermissions?: {
    joinPermission?: [ 
    {
      classMode?: string(name='ClassMode'),
      enabled?: boolean(name='Enabled'),
      joinPermissionId?: string(name='JoinPermissionId'),
      joinPermissionName?: string(name='JoinPermissionName'),
      joinPermissionType?: string(name='JoinPermissionType'),
      ownerAliyunPk?: string(name='OwnerAliyunPk'),
    }
  ](name='JoinPermission')
  }(name='JoinPermissions'),
  productKey?: string(name='ProductKey'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryLoRaJoinPermissionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryLoRaJoinPermissionsResponseBody(name='body'),
}

/**
 * @param request QueryLoRaJoinPermissionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryLoRaJoinPermissionsResponse
 */
async function queryLoRaJoinPermissionsWithOptions(request: QueryLoRaJoinPermissionsRequest, runtime: Util.RuntimeOptions): QueryLoRaJoinPermissionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryLoRaJoinPermissions',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryLoRaJoinPermissionsRequest
 * @return QueryLoRaJoinPermissionsResponse
 */
async function queryLoRaJoinPermissions(request: QueryLoRaJoinPermissionsRequest): QueryLoRaJoinPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryLoRaJoinPermissionsWithOptions(request, runtime);
}

model QueryMessageInfoRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  uniMsgId?: string(name='UniMsgId', description='This parameter is required.'),
}

model QueryMessageInfoResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  message?: {
    generateTime?: long(name='GenerateTime'),
    messageContent?: string(name='MessageContent'),
    mqttProperties?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='MqttProperties'),
    topicFullName?: string(name='TopicFullName'),
    transformedMessageContent?: string(name='TransformedMessageContent'),
    transformedTopicFullName?: string(name='TransformedTopicFullName'),
    uniMsgId?: string(name='UniMsgId'),
    userProperties?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='UserProperties'),
  }(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMessageInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMessageInfoResponseBody(name='body'),
}

/**
 * @param request QueryMessageInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMessageInfoResponse
 */
async function queryMessageInfoWithOptions(request: QueryMessageInfoRequest, runtime: Util.RuntimeOptions): QueryMessageInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.uniMsgId)) {
    query['UniMsgId'] = request.uniMsgId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMessageInfo',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMessageInfoRequest
 * @return QueryMessageInfoResponse
 */
async function queryMessageInfo(request: QueryMessageInfoRequest): QueryMessageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMessageInfoWithOptions(request, runtime);
}

model QueryOTAFirmwareRequest {
  firmwareId?: string(name='FirmwareId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QueryOTAFirmwareResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  firmwareInfo?: {
    destVersion?: string(name='DestVersion'),
    firmwareDesc?: string(name='FirmwareDesc'),
    firmwareId?: string(name='FirmwareId'),
    firmwareName?: string(name='FirmwareName'),
    firmwareSign?: string(name='FirmwareSign'),
    firmwareSize?: int32(name='FirmwareSize'),
    firmwareUrl?: string(name='FirmwareUrl'),
    moduleName?: string(name='ModuleName'),
    multiFiles?: [ 
      {
        fileMd5?: string(name='FileMd5'),
        name?: string(name='Name'),
        signValue?: string(name='SignValue'),
        size?: int32(name='Size'),
        url?: string(name='Url'),
      }
    ](name='MultiFiles'),
    productKey?: string(name='ProductKey'),
    productName?: string(name='ProductName'),
    signMethod?: string(name='SignMethod'),
    srcVersion?: string(name='SrcVersion'),
    status?: int32(name='Status'),
    type?: int32(name='Type'),
    udi?: string(name='Udi'),
    utcCreate?: string(name='UtcCreate'),
    utcModified?: string(name='UtcModified'),
    verifyProgress?: int32(name='VerifyProgress'),
  }(name='FirmwareInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryOTAFirmwareResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryOTAFirmwareResponseBody(name='body'),
}

/**
 * @param request QueryOTAFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryOTAFirmwareResponse
 */
async function queryOTAFirmwareWithOptions(request: QueryOTAFirmwareRequest, runtime: Util.RuntimeOptions): QueryOTAFirmwareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.firmwareId)) {
    query['FirmwareId'] = request.firmwareId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOTAFirmware',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryOTAFirmwareRequest
 * @return QueryOTAFirmwareResponse
 */
async function queryOTAFirmware(request: QueryOTAFirmwareRequest): QueryOTAFirmwareResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOTAFirmwareWithOptions(request, runtime);
}

model QueryOTAJobRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model QueryOTAJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    destVersion?: string(name='DestVersion'),
    downloadProtocol?: string(name='DownloadProtocol'),
    dynamicMode?: int32(name='DynamicMode'),
    firmwareId?: string(name='FirmwareId'),
    grayPercent?: string(name='GrayPercent'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    jobDesc?: string(name='JobDesc'),
    jobId?: string(name='JobId'),
    jobStatus?: string(name='JobStatus'),
    jobType?: string(name='JobType'),
    maximumPerMinute?: int32(name='MaximumPerMinute'),
    multiModuleMode?: boolean(name='MultiModuleMode'),
    name?: string(name='Name'),
    needConfirm?: boolean(name='NeedConfirm'),
    needPush?: boolean(name='NeedPush'),
    overwriteMode?: int32(name='OverwriteMode'),
    productKey?: string(name='ProductKey'),
    retryCount?: int32(name='RetryCount'),
    retryInterval?: int32(name='RetryInterval'),
    selectionType?: string(name='SelectionType'),
    srcVersions?: {
      srcVersion?: [ string ](name='SrcVersion')
    }(name='SrcVersions'),
    tags?: {
      otaTagDTO?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='OtaTagDTO')
    }(name='Tags'),
    targetSelection?: string(name='TargetSelection'),
    timeoutInMinutes?: int32(name='TimeoutInMinutes'),
    utcCreate?: string(name='UtcCreate'),
    utcEndTime?: string(name='UtcEndTime'),
    utcModified?: string(name='UtcModified'),
    utcScheduleFinishTime?: string(name='UtcScheduleFinishTime'),
    utcScheduleTime?: string(name='UtcScheduleTime'),
    utcStartTime?: string(name='UtcStartTime'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryOTAJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryOTAJobResponseBody(name='body'),
}

/**
 * @param request QueryOTAJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryOTAJobResponse
 */
async function queryOTAJobWithOptions(request: QueryOTAJobRequest, runtime: Util.RuntimeOptions): QueryOTAJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOTAJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryOTAJobRequest
 * @return QueryOTAJobResponse
 */
async function queryOTAJob(request: QueryOTAJobRequest): QueryOTAJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOTAJobWithOptions(request, runtime);
}

model QueryPageByApplyIdRequest {
  applyId?: long(name='ApplyId', description='This parameter is required.'),
  currentPage?: int32(name='CurrentPage'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize'),
}

model QueryPageByApplyIdResponseBody = {
  applyDeviceList?: {
    applyDeviceInfo?: [ 
    {
      deviceId?: string(name='DeviceId'),
      deviceName?: string(name='DeviceName'),
      deviceSecret?: string(name='DeviceSecret'),
      iotId?: string(name='IotId'),
    }
  ](name='ApplyDeviceInfo')
  }(name='ApplyDeviceList'),
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  page?: int32(name='Page'),
  pageCount?: int32(name='PageCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryPageByApplyIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPageByApplyIdResponseBody(name='body'),
}

/**
 * @param request QueryPageByApplyIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPageByApplyIdResponse
 */
async function queryPageByApplyIdWithOptions(request: QueryPageByApplyIdRequest, runtime: Util.RuntimeOptions): QueryPageByApplyIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyId)) {
    query['ApplyId'] = request.applyId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPageByApplyId',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryPageByApplyIdRequest
 * @return QueryPageByApplyIdResponse
 */
async function queryPageByApplyId(request: QueryPageByApplyIdRequest): QueryPageByApplyIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPageByApplyIdWithOptions(request, runtime);
}

model QueryProductRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryProductResponseBody = {
  code?: string(name='Code'),
  data?: {
    aliyunCommodityCode?: string(name='AliyunCommodityCode'),
    authType?: string(name='AuthType'),
    categoryKey?: string(name='CategoryKey'),
    categoryName?: string(name='CategoryName'),
    dataFormat?: int32(name='DataFormat'),
    description?: string(name='Description'),
    deviceCount?: int32(name='DeviceCount'),
    gmtCreate?: long(name='GmtCreate'),
    id2?: boolean(name='Id2'),
    netType?: int32(name='NetType'),
    nodeType?: int32(name='NodeType'),
    owner?: boolean(name='Owner'),
    productKey?: string(name='ProductKey'),
    productName?: string(name='ProductName'),
    productSecret?: string(name='ProductSecret'),
    productStatus?: string(name='ProductStatus'),
    protocolType?: string(name='ProtocolType'),
    validateType?: int32(name='ValidateType'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryProductResponseBody(name='body'),
}

/**
 * @param request QueryProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProductResponse
 */
async function queryProductWithOptions(request: QueryProductRequest, runtime: Util.RuntimeOptions): QueryProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryProductRequest
 * @return QueryProductResponse
 */
async function queryProduct(request: QueryProductRequest): QueryProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProductWithOptions(request, runtime);
}

model QueryProductCertInfoRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryProductCertInfoResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  productCertInfo?: {
    issueModel?: int32(name='IssueModel'),
  }(name='ProductCertInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryProductCertInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryProductCertInfoResponseBody(name='body'),
}

/**
 * @param request QueryProductCertInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProductCertInfoResponse
 */
async function queryProductCertInfoWithOptions(request: QueryProductCertInfoRequest, runtime: Util.RuntimeOptions): QueryProductCertInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProductCertInfo',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryProductCertInfoRequest
 * @return QueryProductCertInfoResponse
 */
async function queryProductCertInfo(request: QueryProductCertInfoRequest): QueryProductCertInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProductCertInfoWithOptions(request, runtime);
}

model QueryProductListRequest {
  aliyunCommodityCode?: string(name='AliyunCommodityCode'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model QueryProductListResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    list?: {
      productInfo?: [ 
      {
        authType?: string(name='AuthType'),
        dataFormat?: int32(name='DataFormat'),
        description?: string(name='Description'),
        deviceCount?: int32(name='DeviceCount'),
        gmtCreate?: long(name='GmtCreate'),
        nodeType?: int32(name='NodeType'),
        productKey?: string(name='ProductKey'),
        productName?: string(name='ProductName'),
      }
    ](name='ProductInfo')
    }(name='List'),
    pageCount?: int32(name='PageCount'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryProductListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryProductListResponseBody(name='body'),
}

/**
 * @param request QueryProductListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProductListResponse
 */
async function queryProductListWithOptions(request: QueryProductListRequest, runtime: Util.RuntimeOptions): QueryProductListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunCommodityCode)) {
    query['AliyunCommodityCode'] = request.aliyunCommodityCode;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProductList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryProductListRequest
 * @return QueryProductListResponse
 */
async function queryProductList(request: QueryProductListRequest): QueryProductListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProductListWithOptions(request, runtime);
}

model QueryProductTopicRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryProductTopicResponseBody = {
  code?: string(name='Code'),
  data?: {
    productTopicInfo?: [ 
    {
      codec?: string(name='Codec'),
      desc?: string(name='Desc'),
      enableProxySubscribe?: boolean(name='EnableProxySubscribe'),
      id?: string(name='Id'),
      operation?: string(name='Operation'),
      productKey?: string(name='ProductKey'),
      topicShortName?: string(name='TopicShortName'),
    }
  ](name='ProductTopicInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryProductTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryProductTopicResponseBody(name='body'),
}

/**
 * @param request QueryProductTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProductTopicResponse
 */
async function queryProductTopicWithOptions(request: QueryProductTopicRequest, runtime: Util.RuntimeOptions): QueryProductTopicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProductTopic',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryProductTopicRequest
 * @return QueryProductTopicResponse
 */
async function queryProductTopic(request: QueryProductTopicRequest): QueryProductTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProductTopicWithOptions(request, runtime);
}

model QueryProjectShareDeviceListRequest {
  deviceName?: string(name='DeviceName'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryProjectShareDeviceListResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceList?: {
      items?: [ 
      {
        deviceName?: string(name='DeviceName'),
        iotId?: string(name='IotId'),
        productKey?: string(name='ProductKey'),
        sharable?: long(name='Sharable'),
      }
    ](name='items')
    }(name='DeviceList'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryProjectShareDeviceListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryProjectShareDeviceListResponseBody(name='body'),
}

/**
 * @param request QueryProjectShareDeviceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProjectShareDeviceListResponse
 */
async function queryProjectShareDeviceListWithOptions(request: QueryProjectShareDeviceListRequest, runtime: Util.RuntimeOptions): QueryProjectShareDeviceListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryProjectShareDeviceList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryProjectShareDeviceListRequest
 * @return QueryProjectShareDeviceListResponse
 */
async function queryProjectShareDeviceList(request: QueryProjectShareDeviceListRequest): QueryProjectShareDeviceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProjectShareDeviceListWithOptions(request, runtime);
}

model QuerySceneRuleRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  ruleName?: string(name='RuleName'),
}

model QuerySceneRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    ruleList?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        ruleDescription?: string(name='RuleDescription'),
        ruleId?: string(name='RuleId'),
        ruleName?: string(name='RuleName'),
        ruleStatus?: int32(name='RuleStatus'),
      }
    ](name='RuleList'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySceneRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySceneRuleResponseBody(name='body'),
}

/**
 * @param request QuerySceneRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySceneRuleResponse
 */
async function querySceneRuleWithOptions(request: QuerySceneRuleRequest, runtime: Util.RuntimeOptions): QuerySceneRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySceneRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySceneRuleRequest
 * @return QuerySceneRuleResponse
 */
async function querySceneRule(request: QuerySceneRuleRequest): QuerySceneRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySceneRuleWithOptions(request, runtime);
}

model QuerySchedulePeriodListRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
}

model QuerySchedulePeriodListResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        description?: string(name='Description'),
        endTime?: string(name='EndTime'),
        periodCode?: string(name='PeriodCode'),
        soundCodeContent?: string(name='SoundCodeContent'),
        startTime?: string(name='StartTime'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySchedulePeriodListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySchedulePeriodListResponseBody(name='body'),
}

/**
 * @param request QuerySchedulePeriodListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySchedulePeriodListResponse
 */
async function querySchedulePeriodListWithOptions(request: QuerySchedulePeriodListRequest, runtime: Util.RuntimeOptions): QuerySchedulePeriodListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySchedulePeriodList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySchedulePeriodListRequest
 * @return QuerySchedulePeriodListResponse
 */
async function querySchedulePeriodList(request: QuerySchedulePeriodListRequest): QuerySchedulePeriodListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySchedulePeriodListWithOptions(request, runtime);
}

model QueryShareProductNameByProductKeyRequest {
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  shareTaskCode?: string(name='ShareTaskCode', description='This parameter is required.'),
}

model QueryShareProductNameByProductKeyResponseBody = {
  code?: string(name='Code'),
  data?: {
    productName?: string(name='ProductName'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryShareProductNameByProductKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryShareProductNameByProductKeyResponseBody(name='body'),
}

/**
 * @param request QueryShareProductNameByProductKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryShareProductNameByProductKeyResponse
 */
async function queryShareProductNameByProductKeyWithOptions(request: QueryShareProductNameByProductKeyRequest, runtime: Util.RuntimeOptions): QueryShareProductNameByProductKeyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.shareTaskCode)) {
    body['ShareTaskCode'] = request.shareTaskCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryShareProductNameByProductKey',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryShareProductNameByProductKeyRequest
 * @return QueryShareProductNameByProductKeyResponse
 */
async function queryShareProductNameByProductKey(request: QueryShareProductNameByProductKeyRequest): QueryShareProductNameByProductKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryShareProductNameByProductKeyWithOptions(request, runtime);
}

model QuerySharePromotionActivityAuditResultRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  sharePromotionActivityId?: string(name='SharePromotionActivityId', description='This parameter is required.'),
  shareTaskCode?: string(name='ShareTaskCode', description='This parameter is required.'),
}

model QuerySharePromotionActivityAuditResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    auditResult?: int32(name='AuditResult'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySharePromotionActivityAuditResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySharePromotionActivityAuditResultResponseBody(name='body'),
}

/**
 * @param request QuerySharePromotionActivityAuditResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySharePromotionActivityAuditResultResponse
 */
async function querySharePromotionActivityAuditResultWithOptions(request: QuerySharePromotionActivityAuditResultRequest, runtime: Util.RuntimeOptions): QuerySharePromotionActivityAuditResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.sharePromotionActivityId)) {
    body['SharePromotionActivityId'] = request.sharePromotionActivityId;
  }
  if (!Util.isUnset(request.shareTaskCode)) {
    body['ShareTaskCode'] = request.shareTaskCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySharePromotionActivityAuditResult',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySharePromotionActivityAuditResultRequest
 * @return QuerySharePromotionActivityAuditResultResponse
 */
async function querySharePromotionActivityAuditResult(request: QuerySharePromotionActivityAuditResultRequest): QuerySharePromotionActivityAuditResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySharePromotionActivityAuditResultWithOptions(request, runtime);
}

model QueryShareTaskDeviceListRequest {
  deviceName?: string(name='DeviceName'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  shareTaskId?: string(name='ShareTaskId', description='This parameter is required.'),
}

model QueryShareTaskDeviceListResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceList?: {
      items?: [ 
      {
        deviceName?: string(name='DeviceName'),
        gmtAdded?: long(name='GmtAdded'),
        iotId?: string(name='IotId'),
        productKey?: string(name='ProductKey'),
      }
    ](name='items')
    }(name='DeviceList'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryShareTaskDeviceListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryShareTaskDeviceListResponseBody(name='body'),
}

/**
 * @param request QueryShareTaskDeviceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryShareTaskDeviceListResponse
 */
async function queryShareTaskDeviceListWithOptions(request: QueryShareTaskDeviceListRequest, runtime: Util.RuntimeOptions): QueryShareTaskDeviceListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.shareTaskId)) {
    body['ShareTaskId'] = request.shareTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryShareTaskDeviceList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryShareTaskDeviceListRequest
 * @return QueryShareTaskDeviceListResponse
 */
async function queryShareTaskDeviceList(request: QueryShareTaskDeviceListRequest): QueryShareTaskDeviceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryShareTaskDeviceListWithOptions(request, runtime);
}

model QuerySolutionDeviceGroupPageRequest {
  fuzzyGroupName?: string(name='FuzzyGroupName'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
}

model QuerySolutionDeviceGroupPageResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      itemName?: [ 
      {
        deviceCount?: long(name='DeviceCount'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        groupDesc?: string(name='GroupDesc'),
        groupId?: string(name='GroupId'),
        groupName?: string(name='GroupName'),
      }
    ](name='itemName')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySolutionDeviceGroupPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySolutionDeviceGroupPageResponseBody(name='body'),
}

/**
 * @param request QuerySolutionDeviceGroupPageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySolutionDeviceGroupPageResponse
 */
async function querySolutionDeviceGroupPageWithOptions(request: QuerySolutionDeviceGroupPageRequest, runtime: Util.RuntimeOptions): QuerySolutionDeviceGroupPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fuzzyGroupName)) {
    query['FuzzyGroupName'] = request.fuzzyGroupName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    query['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectCode)) {
    query['ProjectCode'] = request.projectCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySolutionDeviceGroupPage',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySolutionDeviceGroupPageRequest
 * @return QuerySolutionDeviceGroupPageResponse
 */
async function querySolutionDeviceGroupPage(request: QuerySolutionDeviceGroupPageRequest): QuerySolutionDeviceGroupPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySolutionDeviceGroupPageWithOptions(request, runtime);
}

model QuerySoundCodeLabelBatchFailedResultRequest {
  batchCode?: string(name='BatchCode', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QuerySoundCodeLabelBatchFailedResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
    {
      errorMessage?: string(name='ErrorMessage'),
      label?: string(name='Label'),
      resultCode?: string(name='ResultCode'),
    }
  ](name='Items')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySoundCodeLabelBatchFailedResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySoundCodeLabelBatchFailedResultResponseBody(name='body'),
}

/**
 * @param request QuerySoundCodeLabelBatchFailedResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySoundCodeLabelBatchFailedResultResponse
 */
async function querySoundCodeLabelBatchFailedResultWithOptions(request: QuerySoundCodeLabelBatchFailedResultRequest, runtime: Util.RuntimeOptions): QuerySoundCodeLabelBatchFailedResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.batchCode)) {
    body['BatchCode'] = request.batchCode;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySoundCodeLabelBatchFailedResult',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySoundCodeLabelBatchFailedResultRequest
 * @return QuerySoundCodeLabelBatchFailedResultResponse
 */
async function querySoundCodeLabelBatchFailedResult(request: QuerySoundCodeLabelBatchFailedResultRequest): QuerySoundCodeLabelBatchFailedResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySoundCodeLabelBatchFailedResultWithOptions(request, runtime);
}

model QuerySoundCodeLabelBatchListRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
}

model QuerySoundCodeLabelBatchListResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        batchCode?: string(name='BatchCode'),
        description?: string(name='Description'),
        gmtCreate?: long(name='GmtCreate'),
        status?: string(name='Status'),
        successNum?: int32(name='SuccessNum'),
        total?: int32(name='Total'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySoundCodeLabelBatchListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySoundCodeLabelBatchListResponseBody(name='body'),
}

/**
 * @param request QuerySoundCodeLabelBatchListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySoundCodeLabelBatchListResponse
 */
async function querySoundCodeLabelBatchListWithOptions(request: QuerySoundCodeLabelBatchListRequest, runtime: Util.RuntimeOptions): QuerySoundCodeLabelBatchListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySoundCodeLabelBatchList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySoundCodeLabelBatchListRequest
 * @return QuerySoundCodeLabelBatchListResponse
 */
async function querySoundCodeLabelBatchList(request: QuerySoundCodeLabelBatchListRequest): QuerySoundCodeLabelBatchListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySoundCodeLabelBatchListWithOptions(request, runtime);
}

model QuerySoundCodeLabelListRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
}

model QuerySoundCodeLabelListResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        label?: string(name='Label'),
        soundCode?: string(name='SoundCode'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySoundCodeLabelListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySoundCodeLabelListResponseBody(name='body'),
}

/**
 * @param request QuerySoundCodeLabelListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySoundCodeLabelListResponse
 */
async function querySoundCodeLabelListWithOptions(request: QuerySoundCodeLabelListRequest, runtime: Util.RuntimeOptions): QuerySoundCodeLabelListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySoundCodeLabelList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySoundCodeLabelListRequest
 * @return QuerySoundCodeLabelListResponse
 */
async function querySoundCodeLabelList(request: QuerySoundCodeLabelListRequest): QuerySoundCodeLabelListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySoundCodeLabelListWithOptions(request, runtime);
}

model QuerySoundCodeListRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
}

model QuerySoundCodeListResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        duration?: int32(name='Duration'),
        gmtCreate?: long(name='GmtCreate'),
        name?: string(name='Name'),
        openType?: string(name='OpenType'),
        soundCode?: string(name='SoundCode'),
        soundCodeContent?: string(name='SoundCodeContent'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySoundCodeListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySoundCodeListResponseBody(name='body'),
}

/**
 * @param request QuerySoundCodeListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySoundCodeListResponse
 */
async function querySoundCodeListWithOptions(request: QuerySoundCodeListRequest, runtime: Util.RuntimeOptions): QuerySoundCodeListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySoundCodeList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySoundCodeListRequest
 * @return QuerySoundCodeListResponse
 */
async function querySoundCodeList(request: QuerySoundCodeListRequest): QuerySoundCodeListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySoundCodeListWithOptions(request, runtime);
}

model QuerySoundCodeScheduleListRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
}

model QuerySoundCodeScheduleListResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        description?: string(name='Description'),
        endDate?: string(name='EndDate'),
        endTime?: string(name='EndTime'),
        gmtCreate?: long(name='GmtCreate'),
        name?: string(name='Name'),
        openType?: string(name='OpenType'),
        scheduleCode?: string(name='ScheduleCode'),
        startDate?: string(name='StartDate'),
        startTime?: string(name='StartTime'),
        status?: string(name='Status'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySoundCodeScheduleListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySoundCodeScheduleListResponseBody(name='body'),
}

/**
 * @param request QuerySoundCodeScheduleListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySoundCodeScheduleListResponse
 */
async function querySoundCodeScheduleListWithOptions(request: QuerySoundCodeScheduleListRequest, runtime: Util.RuntimeOptions): QuerySoundCodeScheduleListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySoundCodeScheduleList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySoundCodeScheduleListRequest
 * @return QuerySoundCodeScheduleListResponse
 */
async function querySoundCodeScheduleList(request: QuerySoundCodeScheduleListRequest): QuerySoundCodeScheduleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySoundCodeScheduleListWithOptions(request, runtime);
}

model QuerySpeechRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  speechCode?: string(name='SpeechCode', description='This parameter is required.'),
}

model QuerySpeechResponseBody = {
  code?: string(name='Code'),
  data?: {
    audioFormat?: string(name='AudioFormat'),
    bizCode?: string(name='BizCode'),
    enableSoundCode?: boolean(name='EnableSoundCode'),
    soundCodeConfig?: {
      additionalDuration?: int32(name='AdditionalDuration'),
      soundCodeContent?: string(name='SoundCodeContent'),
    }(name='SoundCodeConfig'),
    speechCode?: string(name='SpeechCode'),
    speechRate?: int32(name='SpeechRate'),
    speechType?: string(name='SpeechType'),
    text?: string(name='Text'),
    voice?: string(name='Voice'),
    volume?: int32(name='Volume'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySpeechResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySpeechResponseBody(name='body'),
}

/**
 * @param request QuerySpeechRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySpeechResponse
 */
async function querySpeechWithOptions(request: QuerySpeechRequest, runtime: Util.RuntimeOptions): QuerySpeechResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.speechCode)) {
    body['SpeechCode'] = request.speechCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpeech',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySpeechRequest
 * @return QuerySpeechResponse
 */
async function querySpeech(request: QuerySpeechRequest): QuerySpeechResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpeechWithOptions(request, runtime);
}

model QuerySpeechDeviceRequest {
  availableSpace?: string(name='AvailableSpace'),
  availableSpaceScope?: string(name='AvailableSpaceScope'),
  deviceName?: string(name='DeviceName'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
}

model QuerySpeechDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        availableSpace?: float(name='AvailableSpace'),
        deviceName?: string(name='DeviceName'),
        iotId?: string(name='IotId'),
        productKey?: string(name='ProductKey'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySpeechDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySpeechDeviceResponseBody(name='body'),
}

/**
 * @param request QuerySpeechDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySpeechDeviceResponse
 */
async function querySpeechDeviceWithOptions(request: QuerySpeechDeviceRequest, runtime: Util.RuntimeOptions): QuerySpeechDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.availableSpace)) {
    body['AvailableSpace'] = request.availableSpace;
  }
  if (!Util.isUnset(request.availableSpaceScope)) {
    body['AvailableSpaceScope'] = request.availableSpaceScope;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectCode)) {
    body['ProjectCode'] = request.projectCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpeechDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySpeechDeviceRequest
 * @return QuerySpeechDeviceResponse
 */
async function querySpeechDevice(request: QuerySpeechDeviceRequest): QuerySpeechDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpeechDeviceWithOptions(request, runtime);
}

model QuerySpeechLicenseAvailableQuotaRequest {
  iotInstanceId?: string(name='IotInstanceId'),
}

model QuerySpeechLicenseAvailableQuotaResponseBody = {
  code?: string(name='Code'),
  data?: long(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySpeechLicenseAvailableQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySpeechLicenseAvailableQuotaResponseBody(name='body'),
}

/**
 * @param request QuerySpeechLicenseAvailableQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySpeechLicenseAvailableQuotaResponse
 */
async function querySpeechLicenseAvailableQuotaWithOptions(request: QuerySpeechLicenseAvailableQuotaRequest, runtime: Util.RuntimeOptions): QuerySpeechLicenseAvailableQuotaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpeechLicenseAvailableQuota',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySpeechLicenseAvailableQuotaRequest
 * @return QuerySpeechLicenseAvailableQuotaResponse
 */
async function querySpeechLicenseAvailableQuota(request: QuerySpeechLicenseAvailableQuotaRequest): QuerySpeechLicenseAvailableQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpeechLicenseAvailableQuotaWithOptions(request, runtime);
}

model QuerySpeechLicenseDeviceListRequest {
  checkGroupId?: string(name='CheckGroupId'),
  deviceName?: string(name='DeviceName'),
  iotInstanceId?: string(name='IotInstanceId'),
  licenseStatusList?: [ string ](name='LicenseStatusList'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  productKey?: string(name='ProductKey'),
}

model QuerySpeechLicenseDeviceListResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceList?: {
      item?: [ 
      {
        deviceName?: string(name='DeviceName'),
        deviceStatus?: string(name='DeviceStatus'),
        expiryTime?: long(name='ExpiryTime'),
        inSpecifiedGroup?: boolean(name='InSpecifiedGroup'),
        iotId?: string(name='IotId'),
        licenseStatus?: string(name='LicenseStatus'),
        productKey?: string(name='ProductKey'),
        productName?: string(name='ProductName'),
      }
    ](name='item')
    }(name='DeviceList'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySpeechLicenseDeviceListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySpeechLicenseDeviceListResponseBody(name='body'),
}

/**
 * @param request QuerySpeechLicenseDeviceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySpeechLicenseDeviceListResponse
 */
async function querySpeechLicenseDeviceListWithOptions(request: QuerySpeechLicenseDeviceListRequest, runtime: Util.RuntimeOptions): QuerySpeechLicenseDeviceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    query['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkGroupId)) {
    body['CheckGroupId'] = request.checkGroupId;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.licenseStatusList)) {
    body['LicenseStatusList'] = request.licenseStatusList;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpeechLicenseDeviceList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySpeechLicenseDeviceListRequest
 * @return QuerySpeechLicenseDeviceListResponse
 */
async function querySpeechLicenseDeviceList(request: QuerySpeechLicenseDeviceListRequest): QuerySpeechLicenseDeviceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpeechLicenseDeviceListWithOptions(request, runtime);
}

model QuerySpeechListRequest {
  audioFormat?: string(name='AudioFormat'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
}

model QuerySpeechListResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        audioFormat?: string(name='AudioFormat'),
        bizCode?: string(name='BizCode'),
        speechCode?: string(name='SpeechCode'),
        speechList?: {
          items?: [ 
          {
            bizCode?: string(name='BizCode'),
            speechCode?: string(name='SpeechCode'),
            text?: string(name='Text'),
            voice?: string(name='Voice'),
          }
        ](name='Items')
        }(name='SpeechList'),
        speechType?: string(name='SpeechType'),
        text?: string(name='Text'),
        voice?: string(name='Voice'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySpeechListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySpeechListResponseBody(name='body'),
}

/**
 * @param request QuerySpeechListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySpeechListResponse
 */
async function querySpeechListWithOptions(request: QuerySpeechListRequest, runtime: Util.RuntimeOptions): QuerySpeechListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioFormat)) {
    body['AudioFormat'] = request.audioFormat;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectCode)) {
    body['ProjectCode'] = request.projectCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpeechList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySpeechListRequest
 * @return QuerySpeechListResponse
 */
async function querySpeechList(request: QuerySpeechListRequest): QuerySpeechListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpeechListWithOptions(request, runtime);
}

model QuerySpeechPushJobRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobCode?: string(name='JobCode'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
  pushMode?: string(name='PushMode'),
  statusList?: [ string ](name='StatusList'),
}

model QuerySpeechPushJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        code?: string(name='Code'),
        createdTime?: long(name='CreatedTime'),
        deviceName?: string(name='DeviceName'),
        expiredTime?: long(name='ExpiredTime'),
        failDeviceNum?: int32(name='FailDeviceNum'),
        groupId?: string(name='GroupId'),
        groupName?: string(name='GroupName'),
        iotId?: string(name='IotId'),
        productKey?: string(name='ProductKey'),
        pushMode?: string(name='PushMode'),
        runningDeviceNum?: int32(name='RunningDeviceNum'),
        speechNum?: int32(name='SpeechNum'),
        speechStatus?: boolean(name='SpeechStatus'),
        status?: string(name='Status'),
        successDeviceNum?: int32(name='SuccessDeviceNum'),
        totalDeviceNum?: int32(name='TotalDeviceNum'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySpeechPushJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySpeechPushJobResponseBody(name='body'),
}

/**
 * @param request QuerySpeechPushJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySpeechPushJobResponse
 */
async function querySpeechPushJobWithOptions(request: QuerySpeechPushJobRequest, runtime: Util.RuntimeOptions): QuerySpeechPushJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobCode)) {
    query['JobCode'] = request.jobCode;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectCode)) {
    body['ProjectCode'] = request.projectCode;
  }
  if (!Util.isUnset(request.pushMode)) {
    body['PushMode'] = request.pushMode;
  }
  if (!Util.isUnset(request.statusList)) {
    body['StatusList'] = request.statusList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpeechPushJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySpeechPushJobRequest
 * @return QuerySpeechPushJobResponse
 */
async function querySpeechPushJob(request: QuerySpeechPushJobRequest): QuerySpeechPushJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpeechPushJobWithOptions(request, runtime);
}

model QuerySpeechPushJobDeviceRequest {
  deviceName?: string(name='DeviceName'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobCode?: string(name='JobCode', description='This parameter is required.'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model QuerySpeechPushJobDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        deviceName?: string(name='DeviceName'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        gmtModified?: long(name='GmtModified'),
        status?: string(name='Status'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySpeechPushJobDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySpeechPushJobDeviceResponseBody(name='body'),
}

/**
 * @param request QuerySpeechPushJobDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySpeechPushJobDeviceResponse
 */
async function querySpeechPushJobDeviceWithOptions(request: QuerySpeechPushJobDeviceRequest, runtime: Util.RuntimeOptions): QuerySpeechPushJobDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobCode)) {
    body['JobCode'] = request.jobCode;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpeechPushJobDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySpeechPushJobDeviceRequest
 * @return QuerySpeechPushJobDeviceResponse
 */
async function querySpeechPushJobDevice(request: QuerySpeechPushJobDeviceRequest): QuerySpeechPushJobDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpeechPushJobDeviceWithOptions(request, runtime);
}

model QuerySpeechPushJobSpeechRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobCode?: string(name='JobCode', description='This parameter is required.'),
  pageId?: int32(name='PageId'),
  pageSize?: int32(name='PageSize'),
}

model QuerySpeechPushJobSpeechResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      items?: [ 
      {
        bizCode?: string(name='BizCode'),
        speechList?: {
          items?: [ 
          {
            bizCode?: string(name='BizCode'),
            text?: string(name='Text'),
            voice?: string(name='Voice'),
          }
        ](name='Items')
        }(name='SpeechList'),
        speechType?: string(name='SpeechType'),
        text?: string(name='Text'),
        voice?: string(name='Voice'),
      }
    ](name='Items')
    }(name='List'),
    pageId?: int32(name='PageId'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySpeechPushJobSpeechResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySpeechPushJobSpeechResponseBody(name='body'),
}

/**
 * @param request QuerySpeechPushJobSpeechRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySpeechPushJobSpeechResponse
 */
async function querySpeechPushJobSpeechWithOptions(request: QuerySpeechPushJobSpeechRequest, runtime: Util.RuntimeOptions): QuerySpeechPushJobSpeechResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobCode)) {
    body['JobCode'] = request.jobCode;
  }
  if (!Util.isUnset(request.pageId)) {
    body['PageId'] = request.pageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpeechPushJobSpeech',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySpeechPushJobSpeechRequest
 * @return QuerySpeechPushJobSpeechResponse
 */
async function querySpeechPushJobSpeech(request: QuerySpeechPushJobSpeechRequest): QuerySpeechPushJobSpeechResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpeechPushJobSpeechWithOptions(request, runtime);
}

model QueryStudioAppDomainListOpenRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model QueryStudioAppDomainListOpenResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      domainInfo?: [ 
      {
        appId?: string(name='AppId'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        host?: string(name='Host'),
        id?: int32(name='Id'),
        isBeian?: string(name='IsBeian'),
        projectId?: string(name='ProjectId'),
        protocol?: string(name='Protocol'),
        tenantId?: string(name='TenantId'),
      }
    ](name='DomainInfo')
    }(name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryStudioAppDomainListOpenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryStudioAppDomainListOpenResponseBody(name='body'),
}

/**
 * @param request QueryStudioAppDomainListOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryStudioAppDomainListOpenResponse
 */
async function queryStudioAppDomainListOpenWithOptions(request: QueryStudioAppDomainListOpenRequest, runtime: Util.RuntimeOptions): QueryStudioAppDomainListOpenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryStudioAppDomainListOpen',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryStudioAppDomainListOpenRequest
 * @return QueryStudioAppDomainListOpenResponse
 */
async function queryStudioAppDomainListOpen(request: QueryStudioAppDomainListOpenRequest): QueryStudioAppDomainListOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryStudioAppDomainListOpenWithOptions(request, runtime);
}

model QueryStudioAppListRequest {
  fuzzyName?: string(name='FuzzyName'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
  types?: [ string ](name='Types', description='This parameter is required.'),
}

model QueryStudioAppListResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      appInfo?: [ 
      {
        appId?: string(name='AppId'),
        appKey?: string(name='AppKey'),
        appSecret?: string(name='AppSecret'),
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        gmtRelease?: string(name='GmtRelease'),
        name?: string(name='Name'),
        projectId?: string(name='ProjectId'),
        type?: string(name='Type'),
      }
    ](name='AppInfo')
    }(name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryStudioAppListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryStudioAppListResponseBody(name='body'),
}

/**
 * @param request QueryStudioAppListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryStudioAppListResponse
 */
async function queryStudioAppListWithOptions(request: QueryStudioAppListRequest, runtime: Util.RuntimeOptions): QueryStudioAppListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fuzzyName)) {
    body['FuzzyName'] = request.fuzzyName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    body['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.types)) {
    body['Types'] = request.types;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryStudioAppList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryStudioAppListRequest
 * @return QueryStudioAppListResponse
 */
async function queryStudioAppList(request: QueryStudioAppListRequest): QueryStudioAppListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryStudioAppListWithOptions(request, runtime);
}

model QueryStudioAppPageListOpenRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  isRelease?: boolean(name='IsRelease'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model QueryStudioAppPageListOpenResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      pageInfo?: [ 
      {
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: int32(name='Id'),
        isHidden?: int32(name='IsHidden'),
        isHome?: int32(name='IsHome'),
        isLoginPage?: int32(name='IsLoginPage'),
        name?: string(name='Name'),
        pageId?: string(name='PageId'),
        path?: string(name='Path'),
      }
    ](name='PageInfo')
    }(name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryStudioAppPageListOpenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryStudioAppPageListOpenResponseBody(name='body'),
}

/**
 * @param request QueryStudioAppPageListOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryStudioAppPageListOpenResponse
 */
async function queryStudioAppPageListOpenWithOptions(request: QueryStudioAppPageListOpenRequest, runtime: Util.RuntimeOptions): QueryStudioAppPageListOpenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.isRelease)) {
    body['IsRelease'] = request.isRelease;
  }
  if (!Util.isUnset(request.pageNo)) {
    body['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryStudioAppPageListOpen',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryStudioAppPageListOpenRequest
 * @return QueryStudioAppPageListOpenResponse
 */
async function queryStudioAppPageListOpen(request: QueryStudioAppPageListOpenRequest): QueryStudioAppPageListOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryStudioAppPageListOpenWithOptions(request, runtime);
}

model QueryStudioProjectListRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model QueryStudioProjectListResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      projectInfo?: [ 
      {
        description?: string(name='Description'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModified?: long(name='GmtModified'),
        name?: string(name='Name'),
        projectId?: string(name='ProjectId'),
      }
    ](name='ProjectInfo')
    }(name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryStudioProjectListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryStudioProjectListResponseBody(name='body'),
}

/**
 * @param request QueryStudioProjectListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryStudioProjectListResponse
 */
async function queryStudioProjectListWithOptions(request: QueryStudioProjectListRequest, runtime: Util.RuntimeOptions): QueryStudioProjectListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNo)) {
    body['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryStudioProjectList',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryStudioProjectListRequest
 * @return QueryStudioProjectListResponse
 */
async function queryStudioProjectList(request: QueryStudioProjectListRequest): QueryStudioProjectListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryStudioProjectListWithOptions(request, runtime);
}

model QuerySubscribeRelationRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model QuerySubscribeRelationResponseBody = {
  code?: string(name='Code'),
  consumerGroupIds?: [ string ](name='ConsumerGroupIds'),
  deviceDataFlag?: boolean(name='DeviceDataFlag'),
  deviceLifeCycleFlag?: boolean(name='DeviceLifeCycleFlag'),
  deviceStatusChangeFlag?: boolean(name='DeviceStatusChangeFlag'),
  deviceTagFlag?: boolean(name='DeviceTagFlag'),
  deviceTopoLifeCycleFlag?: boolean(name='DeviceTopoLifeCycleFlag'),
  errorMessage?: string(name='ErrorMessage'),
  foundDeviceListFlag?: boolean(name='FoundDeviceListFlag'),
  mnsConfiguration?: string(name='MnsConfiguration'),
  otaEventFlag?: boolean(name='OtaEventFlag'),
  otaJobFlag?: boolean(name='OtaJobFlag'),
  otaVersionFlag?: boolean(name='OtaVersionFlag'),
  productKey?: string(name='ProductKey'),
  requestId?: string(name='RequestId'),
  subscribeFlags?: string(name='SubscribeFlags'),
  success?: boolean(name='Success'),
  thingHistoryFlag?: boolean(name='ThingHistoryFlag'),
  type?: string(name='Type'),
}

model QuerySubscribeRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySubscribeRelationResponseBody(name='body'),
}

/**
 * @param request QuerySubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySubscribeRelationResponse
 */
async function querySubscribeRelationWithOptions(request: QuerySubscribeRelationRequest, runtime: Util.RuntimeOptions): QuerySubscribeRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySubscribeRelation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySubscribeRelationRequest
 * @return QuerySubscribeRelationResponse
 */
async function querySubscribeRelation(request: QuerySubscribeRelationRequest): QuerySubscribeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySubscribeRelationWithOptions(request, runtime);
}

model QuerySummarySceneRuleLogRequest {
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  endTime?: int32(name='EndTime', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
  startTime?: int32(name='StartTime', description='This parameter is required.'),
  status?: string(name='Status', description='This parameter is required.'),
}

model QuerySummarySceneRuleLogResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    logList?: {
      logInfo?: [ 
      {
        logTime?: int32(name='LogTime'),
        result?: string(name='Result'),
        traceId?: string(name='TraceId'),
      }
    ](name='LogInfo')
    }(name='LogList'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySummarySceneRuleLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySummarySceneRuleLogResponseBody(name='body'),
}

/**
 * @param request QuerySummarySceneRuleLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySummarySceneRuleLogResponse
 */
async function querySummarySceneRuleLogWithOptions(request: QuerySummarySceneRuleLogRequest, runtime: Util.RuntimeOptions): QuerySummarySceneRuleLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySummarySceneRuleLog',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySummarySceneRuleLogRequest
 * @return QuerySummarySceneRuleLogResponse
 */
async function querySummarySceneRuleLog(request: QuerySummarySceneRuleLogRequest): QuerySummarySceneRuleLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySummarySceneRuleLogWithOptions(request, runtime);
}

model QuerySuperDeviceGroupRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model QuerySuperDeviceGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    groupInfo?: [ 
    {
      groupDesc?: string(name='GroupDesc'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
    }
  ](name='GroupInfo')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySuperDeviceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySuperDeviceGroupResponseBody(name='body'),
}

/**
 * @param request QuerySuperDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySuperDeviceGroupResponse
 */
async function querySuperDeviceGroupWithOptions(request: QuerySuperDeviceGroupRequest, runtime: Util.RuntimeOptions): QuerySuperDeviceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySuperDeviceGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QuerySuperDeviceGroupRequest
 * @return QuerySuperDeviceGroupResponse
 */
async function querySuperDeviceGroup(request: QuerySuperDeviceGroupRequest): QuerySuperDeviceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySuperDeviceGroupWithOptions(request, runtime);
}

model QueryTaskRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
}

model QueryTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceName?: string(name='DeviceName'),
    iotId?: string(name='IotId'),
    jobId?: string(name='JobId'),
    jobName?: string(name='JobName'),
    message?: string(name='Message'),
    productKey?: string(name='ProductKey'),
    progress?: string(name='Progress'),
    status?: string(name='Status'),
    statusDetail?: string(name='StatusDetail'),
    taskId?: string(name='TaskId'),
    utcModified?: string(name='UtcModified'),
    utcQueueTime?: string(name='UtcQueueTime'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTaskResponseBody(name='body'),
}

/**
 * @param request QueryTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTaskResponse
 */
async function queryTaskWithOptions(request: QueryTaskRequest, runtime: Util.RuntimeOptions): QueryTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTask',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryTaskRequest
 * @return QueryTaskResponse
 */
async function queryTask(request: QueryTaskRequest): QueryTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskWithOptions(request, runtime);
}

model QueryThingModelRequest {
  functionBlockId?: string(name='FunctionBlockId'),
  iotInstanceId?: string(name='IotInstanceId'),
  modelVersion?: string(name='ModelVersion'),
  productKey?: string(name='ProductKey'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model QueryThingModelResponseBody = {
  code?: string(name='Code'),
  data?: {
    thingModelJson?: string(name='ThingModelJson'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  productKey?: string(name='ProductKey'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryThingModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryThingModelResponseBody(name='body'),
}

/**
 * @param request QueryThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryThingModelResponse
 */
async function queryThingModelWithOptions(request: QueryThingModelRequest, runtime: Util.RuntimeOptions): QueryThingModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.modelVersion)) {
    query['ModelVersion'] = request.modelVersion;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryThingModel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryThingModelRequest
 * @return QueryThingModelResponse
 */
async function queryThingModel(request: QueryThingModelRequest): QueryThingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryThingModelWithOptions(request, runtime);
}

model QueryThingModelExtendConfigRequest {
  functionBlockId?: string(name='FunctionBlockId'),
  iotInstanceId?: string(name='IotInstanceId'),
  modelVersion?: string(name='ModelVersion'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model QueryThingModelExtendConfigResponseBody = {
  code?: string(name='Code'),
  data?: {
    configuration?: string(name='Configuration'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryThingModelExtendConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryThingModelExtendConfigResponseBody(name='body'),
}

/**
 * @param request QueryThingModelExtendConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryThingModelExtendConfigResponse
 */
async function queryThingModelExtendConfigWithOptions(request: QueryThingModelExtendConfigRequest, runtime: Util.RuntimeOptions): QueryThingModelExtendConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.modelVersion)) {
    query['ModelVersion'] = request.modelVersion;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryThingModelExtendConfig',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryThingModelExtendConfigRequest
 * @return QueryThingModelExtendConfigResponse
 */
async function queryThingModelExtendConfig(request: QueryThingModelExtendConfigRequest): QueryThingModelExtendConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryThingModelExtendConfigWithOptions(request, runtime);
}

model QueryThingModelExtendConfigPublishedRequest {
  functionBlockId?: string(name='FunctionBlockId'),
  iotInstanceId?: string(name='IotInstanceId'),
  modelVersion?: string(name='ModelVersion'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryThingModelExtendConfigPublishedResponseBody = {
  code?: string(name='Code'),
  data?: {
    configuration?: string(name='Configuration'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryThingModelExtendConfigPublishedResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryThingModelExtendConfigPublishedResponseBody(name='body'),
}

/**
 * @param request QueryThingModelExtendConfigPublishedRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryThingModelExtendConfigPublishedResponse
 */
async function queryThingModelExtendConfigPublishedWithOptions(request: QueryThingModelExtendConfigPublishedRequest, runtime: Util.RuntimeOptions): QueryThingModelExtendConfigPublishedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.modelVersion)) {
    query['ModelVersion'] = request.modelVersion;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryThingModelExtendConfigPublished',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryThingModelExtendConfigPublishedRequest
 * @return QueryThingModelExtendConfigPublishedResponse
 */
async function queryThingModelExtendConfigPublished(request: QueryThingModelExtendConfigPublishedRequest): QueryThingModelExtendConfigPublishedResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryThingModelExtendConfigPublishedWithOptions(request, runtime);
}

model QueryThingModelPublishedRequest {
  functionBlockId?: string(name='FunctionBlockId'),
  iotInstanceId?: string(name='IotInstanceId'),
  modelVersion?: string(name='ModelVersion'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model QueryThingModelPublishedResponseBody = {
  code?: string(name='Code'),
  data?: {
    thingModelJson?: string(name='ThingModelJson'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  productKey?: string(name='ProductKey'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryThingModelPublishedResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryThingModelPublishedResponseBody(name='body'),
}

/**
 * @param request QueryThingModelPublishedRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryThingModelPublishedResponse
 */
async function queryThingModelPublishedWithOptions(request: QueryThingModelPublishedRequest, runtime: Util.RuntimeOptions): QueryThingModelPublishedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.modelVersion)) {
    query['ModelVersion'] = request.modelVersion;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryThingModelPublished',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryThingModelPublishedRequest
 * @return QueryThingModelPublishedResponse
 */
async function queryThingModelPublished(request: QueryThingModelPublishedRequest): QueryThingModelPublishedResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryThingModelPublishedWithOptions(request, runtime);
}

model QueryTopicConfigRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model QueryTopicConfigResponseBody = {
  code?: string(name='Code'),
  data?: {
    topicConfigInfo?: [ 
    {
      codec?: string(name='Codec'),
      description?: string(name='Description'),
      enableBroadcast?: boolean(name='EnableBroadcast'),
      enableProxySubscribe?: boolean(name='EnableProxySubscribe'),
      operation?: string(name='Operation'),
      productKey?: string(name='ProductKey'),
      topicFullName?: string(name='TopicFullName'),
    }
  ](name='TopicConfigInfo')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryTopicConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTopicConfigResponseBody(name='body'),
}

/**
 * @param request QueryTopicConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTopicConfigResponse
 */
async function queryTopicConfigWithOptions(request: QueryTopicConfigRequest, runtime: Util.RuntimeOptions): QueryTopicConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTopicConfig',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryTopicConfigRequest
 * @return QueryTopicConfigResponse
 */
async function queryTopicConfig(request: QueryTopicConfigRequest): QueryTopicConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTopicConfigWithOptions(request, runtime);
}

model QueryTopicReverseRouteTableRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  regionId?: string(name='RegionId'),
  topic?: string(name='Topic', description='This parameter is required.'),
}

model QueryTopicReverseRouteTableResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  srcTopics?: {
    topic?: [  map[string]any ](name='Topic')
  }(name='SrcTopics'),
  success?: boolean(name='Success'),
}

model QueryTopicReverseRouteTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTopicReverseRouteTableResponseBody(name='body'),
}

/**
 * @param request QueryTopicReverseRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTopicReverseRouteTableResponse
 */
async function queryTopicReverseRouteTableWithOptions(request: QueryTopicReverseRouteTableRequest, runtime: Util.RuntimeOptions): QueryTopicReverseRouteTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTopicReverseRouteTable',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryTopicReverseRouteTableRequest
 * @return QueryTopicReverseRouteTableResponse
 */
async function queryTopicReverseRouteTable(request: QueryTopicReverseRouteTableRequest): QueryTopicReverseRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTopicReverseRouteTableWithOptions(request, runtime);
}

model QueryTopicRouteTableRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  topic?: string(name='Topic', description='This parameter is required.'),
}

model QueryTopicRouteTableResponseBody = {
  code?: string(name='Code'),
  dstTopics?: {
    topic?: [  map[string]any ](name='Topic')
  }(name='DstTopics'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryTopicRouteTableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryTopicRouteTableResponseBody(name='body'),
}

/**
 * @param request QueryTopicRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTopicRouteTableResponse
 */
async function queryTopicRouteTableWithOptions(request: QueryTopicRouteTableRequest, runtime: Util.RuntimeOptions): QueryTopicRouteTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTopicRouteTable',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryTopicRouteTableRequest
 * @return QueryTopicRouteTableResponse
 */
async function queryTopicRouteTable(request: QueryTopicRouteTableRequest): QueryTopicRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTopicRouteTableWithOptions(request, runtime);
}

model QueryVehicleDeviceRequest {
  deviceName?: string(name='DeviceName'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model QueryVehicleDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    createTime?: long(name='CreateTime'),
    deviceName?: string(name='DeviceName'),
    iotId?: string(name='IotId'),
    jtProtocolDeviceData?: {
      authCode?: string(name='AuthCode'),
      city?: string(name='City'),
      deviceId?: string(name='DeviceId'),
      deviceModel?: string(name='DeviceModel'),
      manufacturer?: string(name='Manufacturer'),
      province?: string(name='Province'),
      registerTime?: string(name='RegisterTime'),
      status?: string(name='Status'),
      vehicleColour?: string(name='VehicleColour'),
      vehicleNumber?: string(name='VehicleNumber'),
    }(name='JtProtocolDeviceData'),
    modifiedTime?: long(name='ModifiedTime'),
    productKey?: string(name='ProductKey'),
    protocol?: string(name='Protocol'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryVehicleDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryVehicleDeviceResponseBody(name='body'),
}

/**
 * @param request QueryVehicleDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryVehicleDeviceResponse
 */
async function queryVehicleDeviceWithOptions(request: QueryVehicleDeviceRequest, runtime: Util.RuntimeOptions): QueryVehicleDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryVehicleDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryVehicleDeviceRequest
 * @return QueryVehicleDeviceResponse
 */
async function queryVehicleDevice(request: QueryVehicleDeviceRequest): QueryVehicleDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryVehicleDeviceWithOptions(request, runtime);
}

model RRpcRequest {
  contentType?: string(name='ContentType'),
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  requestBase64Byte?: string(name='RequestBase64Byte', description='This parameter is required.'),
  timeout?: int32(name='Timeout', description='This parameter is required.'),
  topic?: string(name='Topic'),
}

model RRpcResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  messageId?: long(name='MessageId'),
  payloadBase64Byte?: string(name='PayloadBase64Byte'),
  requestId?: string(name='RequestId'),
  rrpcCode?: string(name='RrpcCode'),
  success?: boolean(name='Success'),
}

model RRpcResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RRpcResponseBody(name='body'),
}

/**
 * @param request RRpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RRpcResponse
 */
async function rRpcWithOptions(request: RRpcRequest, runtime: Util.RuntimeOptions): RRpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contentType)) {
    query['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestBase64Byte)) {
    body['RequestBase64Byte'] = request.requestBase64Byte;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RRpc',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RRpcRequest
 * @return RRpcResponse
 */
async function rRpc(request: RRpcRequest): RRpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return rRpcWithOptions(request, runtime);
}

model ReBindLicenseDeviceRequest {
  deviceNameList?: [ string ](name='DeviceNameList', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  licenseCode?: string(name='LicenseCode', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model ReBindLicenseDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    checkProgressId?: string(name='CheckProgressId'),
    failSum?: long(name='FailSum'),
    progress?: int32(name='Progress'),
    resultCsvFile?: string(name='ResultCsvFile'),
    successSum?: long(name='SuccessSum'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReBindLicenseDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReBindLicenseDeviceResponseBody(name='body'),
}

/**
 * @param request ReBindLicenseDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReBindLicenseDeviceResponse
 */
async function reBindLicenseDeviceWithOptions(request: ReBindLicenseDeviceRequest, runtime: Util.RuntimeOptions): ReBindLicenseDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.licenseCode)) {
    query['LicenseCode'] = request.licenseCode;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceNameList)) {
    body['DeviceNameList'] = request.deviceNameList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReBindLicenseDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ReBindLicenseDeviceRequest
 * @return ReBindLicenseDeviceResponse
 */
async function reBindLicenseDevice(request: ReBindLicenseDeviceRequest): ReBindLicenseDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return reBindLicenseDeviceWithOptions(request, runtime);
}

model RefreshDeviceTunnelSharePasswordRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model RefreshDeviceTunnelSharePasswordResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  password?: string(name='Password'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefreshDeviceTunnelSharePasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshDeviceTunnelSharePasswordResponseBody(name='body'),
}

/**
 * @param request RefreshDeviceTunnelSharePasswordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshDeviceTunnelSharePasswordResponse
 */
async function refreshDeviceTunnelSharePasswordWithOptions(request: RefreshDeviceTunnelSharePasswordRequest, runtime: Util.RuntimeOptions): RefreshDeviceTunnelSharePasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshDeviceTunnelSharePassword',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RefreshDeviceTunnelSharePasswordRequest
 * @return RefreshDeviceTunnelSharePasswordResponse
 */
async function refreshDeviceTunnelSharePassword(request: RefreshDeviceTunnelSharePasswordRequest): RefreshDeviceTunnelSharePasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshDeviceTunnelSharePasswordWithOptions(request, runtime);
}

model RefreshStudioAppTokenOpenRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model RefreshStudioAppTokenOpenResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizId?: string(name='BizId'),
    bizType?: string(name='BizType'),
    isEnable?: string(name='IsEnable'),
    token?: string(name='Token'),
    type?: string(name='Type'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefreshStudioAppTokenOpenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RefreshStudioAppTokenOpenResponseBody(name='body'),
}

/**
 * @param request RefreshStudioAppTokenOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshStudioAppTokenOpenResponse
 */
async function refreshStudioAppTokenOpenWithOptions(request: RefreshStudioAppTokenOpenRequest, runtime: Util.RuntimeOptions): RefreshStudioAppTokenOpenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RefreshStudioAppTokenOpen',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RefreshStudioAppTokenOpenRequest
 * @return RefreshStudioAppTokenOpenResponse
 */
async function refreshStudioAppTokenOpen(request: RefreshStudioAppTokenOpenRequest): RefreshStudioAppTokenOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshStudioAppTokenOpenWithOptions(request, runtime);
}

model RegisterDeviceRequest {
  appKey?: string(name='AppKey'),
  devEui?: string(name='DevEui'),
  deviceName?: string(name='DeviceName'),
  iotInstanceId?: string(name='IotInstanceId'),
  joinEui?: string(name='JoinEui'),
  loraNodeType?: string(name='LoraNodeType'),
  nickname?: string(name='Nickname'),
  pinCode?: string(name='PinCode'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model RegisterDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    devEui?: string(name='DevEui'),
    deviceName?: string(name='DeviceName'),
    deviceSecret?: string(name='DeviceSecret'),
    iotId?: string(name='IotId'),
    joinEui?: string(name='JoinEui'),
    nickname?: string(name='Nickname'),
    productKey?: string(name='ProductKey'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RegisterDeviceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RegisterDeviceResponseBody(name='body'),
}

/**
 * @param request RegisterDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterDeviceResponse
 */
async function registerDeviceWithOptions(request: RegisterDeviceRequest, runtime: Util.RuntimeOptions): RegisterDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appKey)) {
    query['AppKey'] = request.appKey;
  }
  if (!Util.isUnset(request.devEui)) {
    query['DevEui'] = request.devEui;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.joinEui)) {
    query['JoinEui'] = request.joinEui;
  }
  if (!Util.isUnset(request.loraNodeType)) {
    query['LoraNodeType'] = request.loraNodeType;
  }
  if (!Util.isUnset(request.nickname)) {
    query['Nickname'] = request.nickname;
  }
  if (!Util.isUnset(request.pinCode)) {
    query['PinCode'] = request.pinCode;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterDevice',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RegisterDeviceRequest
 * @return RegisterDeviceResponse
 */
async function registerDevice(request: RegisterDeviceRequest): RegisterDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerDeviceWithOptions(request, runtime);
}

model ReleaseEdgeDriverVersionRequest {
  driverId?: string(name='DriverId', description='This parameter is required.'),
  driverVersion?: string(name='DriverVersion', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model ReleaseEdgeDriverVersionResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReleaseEdgeDriverVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseEdgeDriverVersionResponseBody(name='body'),
}

/**
 * @param request ReleaseEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseEdgeDriverVersionResponse
 */
async function releaseEdgeDriverVersionWithOptions(request: ReleaseEdgeDriverVersionRequest, runtime: Util.RuntimeOptions): ReleaseEdgeDriverVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.driverVersion)) {
    query['DriverVersion'] = request.driverVersion;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseEdgeDriverVersion',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ReleaseEdgeDriverVersionRequest
 * @return ReleaseEdgeDriverVersionResponse
 */
async function releaseEdgeDriverVersion(request: ReleaseEdgeDriverVersionRequest): ReleaseEdgeDriverVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseEdgeDriverVersionWithOptions(request, runtime);
}

model ReleaseProductRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model ReleaseProductResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReleaseProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseProductResponseBody(name='body'),
}

/**
 * @param request ReleaseProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseProductResponse
 */
async function releaseProductWithOptions(request: ReleaseProductRequest, runtime: Util.RuntimeOptions): ReleaseProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ReleaseProductRequest
 * @return ReleaseProductResponse
 */
async function releaseProduct(request: ReleaseProductRequest): ReleaseProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseProductWithOptions(request, runtime);
}

model RemoveThingTopoRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model RemoveThingTopoResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RemoveThingTopoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveThingTopoResponseBody(name='body'),
}

/**
 * @param request RemoveThingTopoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveThingTopoResponse
 */
async function removeThingTopoWithOptions(request: RemoveThingTopoRequest, runtime: Util.RuntimeOptions): RemoveThingTopoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveThingTopo',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RemoveThingTopoRequest
 * @return RemoveThingTopoResponse
 */
async function removeThingTopo(request: RemoveThingTopoRequest): RemoveThingTopoResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeThingTopoWithOptions(request, runtime);
}

model ReplaceEdgeInstanceGatewayRequest {
  currentGatewayId?: string(name='CurrentGatewayId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  newGatewayId?: string(name='NewGatewayId', description='This parameter is required.'),
}

model ReplaceEdgeInstanceGatewayResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReplaceEdgeInstanceGatewayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReplaceEdgeInstanceGatewayResponseBody(name='body'),
}

/**
 * @param request ReplaceEdgeInstanceGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReplaceEdgeInstanceGatewayResponse
 */
async function replaceEdgeInstanceGatewayWithOptions(request: ReplaceEdgeInstanceGatewayRequest, runtime: Util.RuntimeOptions): ReplaceEdgeInstanceGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentGatewayId)) {
    query['CurrentGatewayId'] = request.currentGatewayId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.newGatewayId)) {
    query['NewGatewayId'] = request.newGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReplaceEdgeInstanceGateway',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ReplaceEdgeInstanceGatewayRequest
 * @return ReplaceEdgeInstanceGatewayResponse
 */
async function replaceEdgeInstanceGateway(request: ReplaceEdgeInstanceGatewayRequest): ReplaceEdgeInstanceGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceEdgeInstanceGatewayWithOptions(request, runtime);
}

model RerunJobRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
}

model RerunJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RerunJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RerunJobResponseBody(name='body'),
}

/**
 * @param request RerunJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RerunJobResponse
 */
async function rerunJobWithOptions(request: RerunJobRequest, runtime: Util.RuntimeOptions): RerunJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RerunJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RerunJobRequest
 * @return RerunJobResponse
 */
async function rerunJob(request: RerunJobRequest): RerunJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return rerunJobWithOptions(request, runtime);
}

model ResetConsumerGroupPositionRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model ResetConsumerGroupPositionResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ResetConsumerGroupPositionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetConsumerGroupPositionResponseBody(name='body'),
}

/**
 * @param request ResetConsumerGroupPositionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetConsumerGroupPositionResponse
 */
async function resetConsumerGroupPositionWithOptions(request: ResetConsumerGroupPositionRequest, runtime: Util.RuntimeOptions): ResetConsumerGroupPositionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetConsumerGroupPosition',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetConsumerGroupPositionRequest
 * @return ResetConsumerGroupPositionResponse
 */
async function resetConsumerGroupPosition(request: ResetConsumerGroupPositionRequest): ResetConsumerGroupPositionResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetConsumerGroupPositionWithOptions(request, runtime);
}

model ResetDeviceTimelineRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model ResetDeviceTimelineResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ResetDeviceTimelineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetDeviceTimelineResponseBody(name='body'),
}

/**
 * @param request ResetDeviceTimelineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetDeviceTimelineResponse
 */
async function resetDeviceTimelineWithOptions(request: ResetDeviceTimelineRequest, runtime: Util.RuntimeOptions): ResetDeviceTimelineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetDeviceTimeline',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetDeviceTimelineRequest
 * @return ResetDeviceTimelineResponse
 */
async function resetDeviceTimeline(request: ResetDeviceTimelineRequest): ResetDeviceTimelineResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetDeviceTimelineWithOptions(request, runtime);
}

model ResetThingRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
}

model ResetThingResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ResetThingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetThingResponseBody(name='body'),
}

/**
 * @param request ResetThingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetThingResponse
 */
async function resetThingWithOptions(request: ResetThingRequest, runtime: Util.RuntimeOptions): ResetThingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetThing',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResetThingRequest
 * @return ResetThingResponse
 */
async function resetThing(request: ResetThingRequest): ResetThingResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetThingWithOptions(request, runtime);
}

model RetrySoundCodeLabelBatchRequest {
  batchCode?: string(name='BatchCode', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model RetrySoundCodeLabelBatchResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RetrySoundCodeLabelBatchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RetrySoundCodeLabelBatchResponseBody(name='body'),
}

/**
 * @param request RetrySoundCodeLabelBatchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetrySoundCodeLabelBatchResponse
 */
async function retrySoundCodeLabelBatchWithOptions(request: RetrySoundCodeLabelBatchRequest, runtime: Util.RuntimeOptions): RetrySoundCodeLabelBatchResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.batchCode)) {
    body['BatchCode'] = request.batchCode;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RetrySoundCodeLabelBatch',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RetrySoundCodeLabelBatchRequest
 * @return RetrySoundCodeLabelBatchResponse
 */
async function retrySoundCodeLabelBatch(request: RetrySoundCodeLabelBatchRequest): RetrySoundCodeLabelBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return retrySoundCodeLabelBatchWithOptions(request, runtime);
}

model ReupgradeOTATaskRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
  taskId?: [ string ](name='TaskId', description='This parameter is required.'),
}

model ReupgradeOTATaskResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReupgradeOTATaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReupgradeOTATaskResponseBody(name='body'),
}

/**
 * @param request ReupgradeOTATaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReupgradeOTATaskResponse
 */
async function reupgradeOTATaskWithOptions(request: ReupgradeOTATaskRequest, runtime: Util.RuntimeOptions): ReupgradeOTATaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReupgradeOTATask',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ReupgradeOTATaskRequest
 * @return ReupgradeOTATaskResponse
 */
async function reupgradeOTATask(request: ReupgradeOTATaskRequest): ReupgradeOTATaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return reupgradeOTATaskWithOptions(request, runtime);
}

model SaveDevicePropRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  props?: string(name='Props', description='This parameter is required.'),
}

model SaveDevicePropResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveDevicePropResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveDevicePropResponseBody(name='body'),
}

/**
 * @param request SaveDevicePropRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveDevicePropResponse
 */
async function saveDevicePropWithOptions(request: SaveDevicePropRequest, runtime: Util.RuntimeOptions): SaveDevicePropResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.props)) {
    query['Props'] = request.props;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveDeviceProp',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SaveDevicePropRequest
 * @return SaveDevicePropResponse
 */
async function saveDeviceProp(request: SaveDevicePropRequest): SaveDevicePropResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveDevicePropWithOptions(request, runtime);
}

model SaveScriptRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
  scriptDraft?: string(name='ScriptDraft', description='This parameter is required.'),
}

model SaveScriptResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveScriptResponseBody(name='body'),
}

/**
 * @param request SaveScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveScriptResponse
 */
async function saveScriptWithOptions(request: SaveScriptRequest, runtime: Util.RuntimeOptions): SaveScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  if (!Util.isUnset(request.scriptDraft)) {
    query['ScriptDraft'] = request.scriptDraft;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveScript',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SaveScriptRequest
 * @return SaveScriptResponse
 */
async function saveScript(request: SaveScriptRequest): SaveScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveScriptWithOptions(request, runtime);
}

model SetDeviceDesiredPropertyRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  items?: string(name='Items', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  versions?: string(name='Versions', description='This parameter is required.'),
}

model SetDeviceDesiredPropertyResponseBody = {
  code?: string(name='Code'),
  data?: {
    messageId?: string(name='MessageId'),
    versions?: string(name='Versions'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetDeviceDesiredPropertyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDeviceDesiredPropertyResponseBody(name='body'),
}

/**
 * @param request SetDeviceDesiredPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDeviceDesiredPropertyResponse
 */
async function setDeviceDesiredPropertyWithOptions(request: SetDeviceDesiredPropertyRequest, runtime: Util.RuntimeOptions): SetDeviceDesiredPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.items)) {
    query['Items'] = request.items;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.versions)) {
    query['Versions'] = request.versions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDeviceDesiredProperty',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetDeviceDesiredPropertyRequest
 * @return SetDeviceDesiredPropertyResponse
 */
async function setDeviceDesiredProperty(request: SetDeviceDesiredPropertyRequest): SetDeviceDesiredPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDeviceDesiredPropertyWithOptions(request, runtime);
}

model SetDeviceGroupTagsRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  groupType?: string(name='GroupType'),
  iotInstanceId?: string(name='IotInstanceId'),
  tagString?: string(name='TagString'),
}

model SetDeviceGroupTagsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetDeviceGroupTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDeviceGroupTagsResponseBody(name='body'),
}

/**
 * @param request SetDeviceGroupTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDeviceGroupTagsResponse
 */
async function setDeviceGroupTagsWithOptions(request: SetDeviceGroupTagsRequest, runtime: Util.RuntimeOptions): SetDeviceGroupTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupType)) {
    query['GroupType'] = request.groupType;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.tagString)) {
    query['TagString'] = request.tagString;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDeviceGroupTags',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetDeviceGroupTagsRequest
 * @return SetDeviceGroupTagsResponse
 */
async function setDeviceGroupTags(request: SetDeviceGroupTagsRequest): SetDeviceGroupTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDeviceGroupTagsWithOptions(request, runtime);
}

model SetDevicePropertyRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  items?: string(name='Items', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  qos?: int32(name='Qos'),
}

model SetDevicePropertyResponseBody = {
  code?: string(name='Code'),
  data?: {
    messageId?: string(name='MessageId'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetDevicePropertyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDevicePropertyResponseBody(name='body'),
}

/**
 * @param request SetDevicePropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDevicePropertyResponse
 */
async function setDevicePropertyWithOptions(request: SetDevicePropertyRequest, runtime: Util.RuntimeOptions): SetDevicePropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.items)) {
    query['Items'] = request.items;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.qos)) {
    query['Qos'] = request.qos;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDeviceProperty',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetDevicePropertyRequest
 * @return SetDevicePropertyResponse
 */
async function setDeviceProperty(request: SetDevicePropertyRequest): SetDevicePropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDevicePropertyWithOptions(request, runtime);
}

model SetDevicesPropertyRequest {
  deviceName?: [ string ](name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  items?: string(name='Items', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  qos?: int32(name='Qos'),
}

model SetDevicesPropertyResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetDevicesPropertyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDevicesPropertyResponseBody(name='body'),
}

/**
 * @param request SetDevicesPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDevicesPropertyResponse
 */
async function setDevicesPropertyWithOptions(request: SetDevicesPropertyRequest, runtime: Util.RuntimeOptions): SetDevicesPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.items)) {
    query['Items'] = request.items;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.qos)) {
    query['Qos'] = request.qos;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDevicesProperty',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetDevicesPropertyRequest
 * @return SetDevicesPropertyResponse
 */
async function setDevicesProperty(request: SetDevicesPropertyRequest): SetDevicesPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDevicesPropertyWithOptions(request, runtime);
}

model SetEdgeInstanceDriverConfigsRequest {
  configs?: [ 
    {
      content?: string(name='Content', description='This parameter is required.'),
      format?: string(name='Format', description='This parameter is required.'),
      key?: string(name='Key'),
    }
  ](name='Configs', description='This parameter is required.'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model SetEdgeInstanceDriverConfigsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetEdgeInstanceDriverConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetEdgeInstanceDriverConfigsResponseBody(name='body'),
}

/**
 * @param request SetEdgeInstanceDriverConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetEdgeInstanceDriverConfigsResponse
 */
async function setEdgeInstanceDriverConfigsWithOptions(request: SetEdgeInstanceDriverConfigsRequest, runtime: Util.RuntimeOptions): SetEdgeInstanceDriverConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configs)) {
    query['Configs'] = request.configs;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetEdgeInstanceDriverConfigs',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetEdgeInstanceDriverConfigsRequest
 * @return SetEdgeInstanceDriverConfigsResponse
 */
async function setEdgeInstanceDriverConfigs(request: SetEdgeInstanceDriverConfigsRequest): SetEdgeInstanceDriverConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setEdgeInstanceDriverConfigsWithOptions(request, runtime);
}

model SetProductCertInfoRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  issueModel?: int32(name='IssueModel', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model SetProductCertInfoResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetProductCertInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetProductCertInfoResponseBody(name='body'),
}

/**
 * @param request SetProductCertInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetProductCertInfoResponse
 */
async function setProductCertInfoWithOptions(request: SetProductCertInfoRequest, runtime: Util.RuntimeOptions): SetProductCertInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.issueModel)) {
    query['IssueModel'] = request.issueModel;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetProductCertInfo',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetProductCertInfoRequest
 * @return SetProductCertInfoResponse
 */
async function setProductCertInfo(request: SetProductCertInfoRequest): SetProductCertInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return setProductCertInfoWithOptions(request, runtime);
}

model SetStudioProjectCooperationRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  status?: string(name='Status', description='This parameter is required.'),
}

model SetStudioProjectCooperationResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetStudioProjectCooperationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetStudioProjectCooperationResponseBody(name='body'),
}

/**
 * @param request SetStudioProjectCooperationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetStudioProjectCooperationResponse
 */
async function setStudioProjectCooperationWithOptions(request: SetStudioProjectCooperationRequest, runtime: Util.RuntimeOptions): SetStudioProjectCooperationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetStudioProjectCooperation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetStudioProjectCooperationRequest
 * @return SetStudioProjectCooperationResponse
 */
async function setStudioProjectCooperation(request: SetStudioProjectCooperationRequest): SetStudioProjectCooperationResponse {
  var runtime = new Util.RuntimeOptions{};
  return setStudioProjectCooperationWithOptions(request, runtime);
}

model SetupStudioAppAuthModeOpenRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  authMode?: int32(name='AuthMode', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectId?: string(name='ProjectId', description='This parameter is required.'),
}

model SetupStudioAppAuthModeOpenResponseBody = {
  code?: string(name='Code'),
  data?: {
    authMode?: int32(name='AuthMode'),
    tokenInfo?: {
      bizId?: string(name='BizId'),
      bizType?: string(name='BizType'),
      isEnable?: string(name='IsEnable'),
      token?: string(name='Token'),
      type?: string(name='Type'),
    }(name='TokenInfo'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetupStudioAppAuthModeOpenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetupStudioAppAuthModeOpenResponseBody(name='body'),
}

/**
 * @param request SetupStudioAppAuthModeOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetupStudioAppAuthModeOpenResponse
 */
async function setupStudioAppAuthModeOpenWithOptions(request: SetupStudioAppAuthModeOpenRequest, runtime: Util.RuntimeOptions): SetupStudioAppAuthModeOpenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.authMode)) {
    body['AuthMode'] = request.authMode;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetupStudioAppAuthModeOpen',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SetupStudioAppAuthModeOpenRequest
 * @return SetupStudioAppAuthModeOpenResponse
 */
async function setupStudioAppAuthModeOpen(request: SetupStudioAppAuthModeOpenRequest): SetupStudioAppAuthModeOpenResponse {
  var runtime = new Util.RuntimeOptions{};
  return setupStudioAppAuthModeOpenWithOptions(request, runtime);
}

model ShareSpeechByCombinationRequest {
  audioFormat?: string(name='AudioFormat'),
  combinationList?: [ string ](name='CombinationList', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  speechId?: string(name='SpeechId'),
}

model ShareSpeechByCombinationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ShareSpeechByCombinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ShareSpeechByCombinationResponseBody(name='body'),
}

/**
 * @param request ShareSpeechByCombinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ShareSpeechByCombinationResponse
 */
async function shareSpeechByCombinationWithOptions(request: ShareSpeechByCombinationRequest, runtime: Util.RuntimeOptions): ShareSpeechByCombinationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioFormat)) {
    body['AudioFormat'] = request.audioFormat;
  }
  if (!Util.isUnset(request.combinationList)) {
    body['CombinationList'] = request.combinationList;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.speechId)) {
    body['SpeechId'] = request.speechId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ShareSpeechByCombination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ShareSpeechByCombinationRequest
 * @return ShareSpeechByCombinationResponse
 */
async function shareSpeechByCombination(request: ShareSpeechByCombinationRequest): ShareSpeechByCombinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return shareSpeechByCombinationWithOptions(request, runtime);
}

model SpeechByCombinationRequest {
  audioFormat?: string(name='AudioFormat'),
  combinationList?: [ string ](name='CombinationList', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  enforceFlag?: boolean(name='EnforceFlag'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  speechId?: string(name='SpeechId'),
}

model SpeechByCombinationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SpeechByCombinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SpeechByCombinationResponseBody(name='body'),
}

/**
 * @param request SpeechByCombinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SpeechByCombinationResponse
 */
async function speechByCombinationWithOptions(request: SpeechByCombinationRequest, runtime: Util.RuntimeOptions): SpeechByCombinationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioFormat)) {
    body['AudioFormat'] = request.audioFormat;
  }
  if (!Util.isUnset(request.combinationList)) {
    body['CombinationList'] = request.combinationList;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.enforceFlag)) {
    body['EnforceFlag'] = request.enforceFlag;
  }
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.speechId)) {
    body['SpeechId'] = request.speechId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SpeechByCombination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SpeechByCombinationRequest
 * @return SpeechByCombinationResponse
 */
async function speechByCombination(request: SpeechByCombinationRequest): SpeechByCombinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return speechByCombinationWithOptions(request, runtime);
}

model SpeechBySynthesisRequest {
  audioFormat?: string(name='AudioFormat', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  speechId?: string(name='SpeechId'),
  speechRate?: int32(name='SpeechRate'),
  text?: string(name='Text', description='This parameter is required.'),
  voice?: string(name='Voice', description='This parameter is required.'),
  volume?: int32(name='Volume'),
}

model SpeechBySynthesisResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SpeechBySynthesisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SpeechBySynthesisResponseBody(name='body'),
}

/**
 * @param request SpeechBySynthesisRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SpeechBySynthesisResponse
 */
async function speechBySynthesisWithOptions(request: SpeechBySynthesisRequest, runtime: Util.RuntimeOptions): SpeechBySynthesisResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioFormat)) {
    body['AudioFormat'] = request.audioFormat;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.speechId)) {
    body['SpeechId'] = request.speechId;
  }
  if (!Util.isUnset(request.speechRate)) {
    body['SpeechRate'] = request.speechRate;
  }
  if (!Util.isUnset(request.text)) {
    body['Text'] = request.text;
  }
  if (!Util.isUnset(request.voice)) {
    body['Voice'] = request.voice;
  }
  if (!Util.isUnset(request.volume)) {
    body['Volume'] = request.volume;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SpeechBySynthesis',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SpeechBySynthesisRequest
 * @return SpeechBySynthesisResponse
 */
async function speechBySynthesis(request: SpeechBySynthesisRequest): SpeechBySynthesisResponse {
  var runtime = new Util.RuntimeOptions{};
  return speechBySynthesisWithOptions(request, runtime);
}

model StartPTDetectionRequest {
  algorithmInstanceUid?: string(name='AlgorithmInstanceUid', description='This parameter is required.'),
  data?: string(name='Data', description='This parameter is required.'),
  dataCollectionTime?: long(name='DataCollectionTime', description='This parameter is required.'),
  fileName?: string(name='FileName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  powerPlantsNumber?: int32(name='PowerPlantsNumber'),
  powerStationUid?: string(name='PowerStationUid'),
  sensitivity?: int32(name='Sensitivity'),
}

model StartPTDetectionResponseBody = {
  code?: string(name='Code'),
  data?: {
    data?: string(name='Data'),
    errMsg?: string(name='ErrMsg'),
    inputData?: string(name='InputData'),
    status?: string(name='Status'),
    success?: boolean(name='Success'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartPTDetectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartPTDetectionResponseBody(name='body'),
}

/**
 * @param request StartPTDetectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartPTDetectionResponse
 */
async function startPTDetectionWithOptions(request: StartPTDetectionRequest, runtime: Util.RuntimeOptions): StartPTDetectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithmInstanceUid)) {
    query['AlgorithmInstanceUid'] = request.algorithmInstanceUid;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.dataCollectionTime)) {
    query['DataCollectionTime'] = request.dataCollectionTime;
  }
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.powerPlantsNumber)) {
    query['PowerPlantsNumber'] = request.powerPlantsNumber;
  }
  if (!Util.isUnset(request.powerStationUid)) {
    query['PowerStationUid'] = request.powerStationUid;
  }
  if (!Util.isUnset(request.sensitivity)) {
    query['Sensitivity'] = request.sensitivity;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartPTDetection',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StartPTDetectionRequest
 * @return StartPTDetectionResponse
 */
async function startPTDetection(request: StartPTDetectionRequest): StartPTDetectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return startPTDetectionWithOptions(request, runtime);
}

model StartParserRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model StartParserResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartParserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartParserResponseBody(name='body'),
}

/**
 * @param request StartParserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartParserResponse
 */
async function startParserWithOptions(request: StartParserRequest, runtime: Util.RuntimeOptions): StartParserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartParser',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StartParserRequest
 * @return StartParserResponse
 */
async function startParser(request: StartParserRequest): StartParserResponse {
  var runtime = new Util.RuntimeOptions{};
  return startParserWithOptions(request, runtime);
}

model StartRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
}

model StartRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartRuleResponseBody(name='body'),
}

/**
 * @param request StartRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartRuleResponse
 */
async function startRuleWithOptions(request: StartRuleRequest, runtime: Util.RuntimeOptions): StartRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StartRuleRequest
 * @return StartRuleResponse
 */
async function startRule(request: StartRuleRequest): StartRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return startRuleWithOptions(request, runtime);
}

model StopParserRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model StopParserResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopParserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopParserResponseBody(name='body'),
}

/**
 * @param request StopParserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopParserResponse
 */
async function stopParserWithOptions(request: StopParserRequest, runtime: Util.RuntimeOptions): StopParserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopParser',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StopParserRequest
 * @return StopParserResponse
 */
async function stopParser(request: StopParserRequest): StopParserResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopParserWithOptions(request, runtime);
}

model StopRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
}

model StopRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopRuleResponseBody(name='body'),
}

/**
 * @param request StopRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopRuleResponse
 */
async function stopRuleWithOptions(request: StopRuleRequest, runtime: Util.RuntimeOptions): StopRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StopRuleRequest
 * @return StopRuleResponse
 */
async function stopRule(request: StopRuleRequest): StopRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopRuleWithOptions(request, runtime);
}

model SubscribeTopicRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  topic?: [ string ](name='Topic', description='This parameter is required.'),
}

model SubscribeTopicResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubscribeTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubscribeTopicResponseBody(name='body'),
}

/**
 * @param request SubscribeTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubscribeTopicResponse
 */
async function subscribeTopicWithOptions(request: SubscribeTopicRequest, runtime: Util.RuntimeOptions): SubscribeTopicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubscribeTopic',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SubscribeTopicRequest
 * @return SubscribeTopicResponse
 */
async function subscribeTopic(request: SubscribeTopicRequest): SubscribeTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return subscribeTopicWithOptions(request, runtime);
}

model SyncSpeechByCombinationRequest {
  audioFormat?: string(name='AudioFormat'),
  combinationList?: [ string ](name='CombinationList', description='This parameter is required.'),
  deviceName?: string(name='DeviceName'),
  enforceFlag?: boolean(name='EnforceFlag'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey'),
  speechId?: string(name='SpeechId'),
}

model SyncSpeechByCombinationResponseBody = {
  code?: string(name='Code'),
  data?: {
    detail?: string(name='Detail'),
    deviceErrorCode?: string(name='DeviceErrorCode'),
    deviceErrorMessage?: string(name='DeviceErrorMessage'),
    id?: string(name='Id'),
    maxRetryCount?: int32(name='MaxRetryCount'),
    retryCount?: int32(name='RetryCount'),
    success?: boolean(name='Success'),
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SyncSpeechByCombinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SyncSpeechByCombinationResponseBody(name='body'),
}

/**
 * @param request SyncSpeechByCombinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SyncSpeechByCombinationResponse
 */
async function syncSpeechByCombinationWithOptions(request: SyncSpeechByCombinationRequest, runtime: Util.RuntimeOptions): SyncSpeechByCombinationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioFormat)) {
    body['AudioFormat'] = request.audioFormat;
  }
  if (!Util.isUnset(request.combinationList)) {
    body['CombinationList'] = request.combinationList;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.enforceFlag)) {
    body['EnforceFlag'] = request.enforceFlag;
  }
  if (!Util.isUnset(request.iotId)) {
    body['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    body['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.speechId)) {
    body['SpeechId'] = request.speechId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SyncSpeechByCombination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SyncSpeechByCombinationRequest
 * @return SyncSpeechByCombinationResponse
 */
async function syncSpeechByCombination(request: SyncSpeechByCombinationRequest): SyncSpeechByCombinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncSpeechByCombinationWithOptions(request, runtime);
}

model TestSpeechRequest {
  audioFormat?: string(name='AudioFormat'),
  enableSoundCode?: boolean(name='EnableSoundCode'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
  soundCodeConfig?: map[string]any(name='SoundCodeConfig'),
  speechRate?: int32(name='SpeechRate'),
  speechType?: string(name='SpeechType'),
  text?: string(name='Text'),
  voice?: string(name='Voice', description='This parameter is required.'),
  volume?: int32(name='Volume'),
}

model TestSpeechShrinkRequest {
  audioFormat?: string(name='AudioFormat'),
  enableSoundCode?: boolean(name='EnableSoundCode'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
  soundCodeConfigShrink?: string(name='SoundCodeConfig'),
  speechRate?: int32(name='SpeechRate'),
  speechType?: string(name='SpeechType'),
  text?: string(name='Text'),
  voice?: string(name='Voice', description='This parameter is required.'),
  volume?: int32(name='Volume'),
}

model TestSpeechResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ string ](name='items')
  }(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TestSpeechResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TestSpeechResponseBody(name='body'),
}

/**
 * @param tmpReq TestSpeechRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TestSpeechResponse
 */
async function testSpeechWithOptions(tmpReq: TestSpeechRequest, runtime: Util.RuntimeOptions): TestSpeechResponse {
  Util.validateModel(tmpReq);
  var request = new TestSpeechShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.soundCodeConfig)) {
    request.soundCodeConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.soundCodeConfig, 'SoundCodeConfig', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioFormat)) {
    body['AudioFormat'] = request.audioFormat;
  }
  if (!Util.isUnset(request.enableSoundCode)) {
    body['EnableSoundCode'] = request.enableSoundCode;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectCode)) {
    body['ProjectCode'] = request.projectCode;
  }
  if (!Util.isUnset(request.soundCodeConfigShrink)) {
    body['SoundCodeConfig'] = request.soundCodeConfigShrink;
  }
  if (!Util.isUnset(request.speechRate)) {
    body['SpeechRate'] = request.speechRate;
  }
  if (!Util.isUnset(request.speechType)) {
    body['SpeechType'] = request.speechType;
  }
  if (!Util.isUnset(request.text)) {
    body['Text'] = request.text;
  }
  if (!Util.isUnset(request.voice)) {
    body['Voice'] = request.voice;
  }
  if (!Util.isUnset(request.volume)) {
    body['Volume'] = request.volume;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TestSpeech',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request TestSpeechRequest
 * @return TestSpeechResponse
 */
async function testSpeech(request: TestSpeechRequest): TestSpeechResponse {
  var runtime = new Util.RuntimeOptions{};
  return testSpeechWithOptions(request, runtime);
}

model TestSwitchRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model TestSwitchResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  iotId?: string(name='IotId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TestSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TestSwitchResponseBody(name='body'),
}

/**
 * @param request TestSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TestSwitchResponse
 */
async function testSwitchWithOptions(request: TestSwitchRequest, runtime: Util.RuntimeOptions): TestSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TestSwitch',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request TestSwitchRequest
 * @return TestSwitchResponse
 */
async function testSwitch(request: TestSwitchRequest): TestSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return testSwitchWithOptions(request, runtime);
}

model TransformClientIdRequest {
  clientId?: string(name='ClientId', description='This parameter is required.'),
  iotId?: string(name='IotId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model TransformClientIdResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TransformClientIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TransformClientIdResponseBody(name='body'),
}

/**
 * @param request TransformClientIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TransformClientIdResponse
 */
async function transformClientIdWithOptions(request: TransformClientIdRequest, runtime: Util.RuntimeOptions): TransformClientIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransformClientId',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request TransformClientIdRequest
 * @return TransformClientIdResponse
 */
async function transformClientId(request: TransformClientIdRequest): TransformClientIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return transformClientIdWithOptions(request, runtime);
}

model TriggerSceneRuleRequest {
  instanceId?: string(name='InstanceId'),
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
}

model TriggerSceneRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TriggerSceneRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TriggerSceneRuleResponseBody(name='body'),
}

/**
 * @param request TriggerSceneRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TriggerSceneRuleResponse
 */
async function triggerSceneRuleWithOptions(request: TriggerSceneRuleRequest, runtime: Util.RuntimeOptions): TriggerSceneRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TriggerSceneRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request TriggerSceneRuleRequest
 * @return TriggerSceneRuleResponse
 */
async function triggerSceneRule(request: TriggerSceneRuleRequest): TriggerSceneRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return triggerSceneRuleWithOptions(request, runtime);
}

model UnbindApplicationFromEdgeInstanceRequest {
  applicationId?: string(name='ApplicationId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model UnbindApplicationFromEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindApplicationFromEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindApplicationFromEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request UnbindApplicationFromEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindApplicationFromEdgeInstanceResponse
 */
async function unbindApplicationFromEdgeInstanceWithOptions(request: UnbindApplicationFromEdgeInstanceRequest, runtime: Util.RuntimeOptions): UnbindApplicationFromEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicationId)) {
    query['ApplicationId'] = request.applicationId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindApplicationFromEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnbindApplicationFromEdgeInstanceRequest
 * @return UnbindApplicationFromEdgeInstanceResponse
 */
async function unbindApplicationFromEdgeInstance(request: UnbindApplicationFromEdgeInstanceRequest): UnbindApplicationFromEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindApplicationFromEdgeInstanceWithOptions(request, runtime);
}

model UnbindDriverFromEdgeInstanceRequest {
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model UnbindDriverFromEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindDriverFromEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindDriverFromEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request UnbindDriverFromEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindDriverFromEdgeInstanceResponse
 */
async function unbindDriverFromEdgeInstanceWithOptions(request: UnbindDriverFromEdgeInstanceRequest, runtime: Util.RuntimeOptions): UnbindDriverFromEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindDriverFromEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnbindDriverFromEdgeInstanceRequest
 * @return UnbindDriverFromEdgeInstanceResponse
 */
async function unbindDriverFromEdgeInstance(request: UnbindDriverFromEdgeInstanceRequest): UnbindDriverFromEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindDriverFromEdgeInstanceWithOptions(request, runtime);
}

model UnbindLicenseProductRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  licenseCode?: string(name='LicenseCode', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model UnbindLicenseProductResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindLicenseProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindLicenseProductResponseBody(name='body'),
}

/**
 * @param request UnbindLicenseProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindLicenseProductResponse
 */
async function unbindLicenseProductWithOptions(request: UnbindLicenseProductRequest, runtime: Util.RuntimeOptions): UnbindLicenseProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.licenseCode)) {
    query['LicenseCode'] = request.licenseCode;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindLicenseProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnbindLicenseProductRequest
 * @return UnbindLicenseProductResponse
 */
async function unbindLicenseProduct(request: UnbindLicenseProductRequest): UnbindLicenseProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindLicenseProductWithOptions(request, runtime);
}

model UnbindRoleFromEdgeInstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model UnbindRoleFromEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindRoleFromEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindRoleFromEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request UnbindRoleFromEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindRoleFromEdgeInstanceResponse
 */
async function unbindRoleFromEdgeInstanceWithOptions(request: UnbindRoleFromEdgeInstanceRequest, runtime: Util.RuntimeOptions): UnbindRoleFromEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindRoleFromEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnbindRoleFromEdgeInstanceRequest
 * @return UnbindRoleFromEdgeInstanceResponse
 */
async function unbindRoleFromEdgeInstance(request: UnbindRoleFromEdgeInstanceRequest): UnbindRoleFromEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindRoleFromEdgeInstanceWithOptions(request, runtime);
}

model UnbindSceneRuleFromEdgeInstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
}

model UnbindSceneRuleFromEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindSceneRuleFromEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindSceneRuleFromEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request UnbindSceneRuleFromEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindSceneRuleFromEdgeInstanceResponse
 */
async function unbindSceneRuleFromEdgeInstanceWithOptions(request: UnbindSceneRuleFromEdgeInstanceRequest, runtime: Util.RuntimeOptions): UnbindSceneRuleFromEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindSceneRuleFromEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnbindSceneRuleFromEdgeInstanceRequest
 * @return UnbindSceneRuleFromEdgeInstanceResponse
 */
async function unbindSceneRuleFromEdgeInstance(request: UnbindSceneRuleFromEdgeInstanceRequest): UnbindSceneRuleFromEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindSceneRuleFromEdgeInstanceWithOptions(request, runtime);
}

model UnsubscribeTopicRequest {
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  topic?: [ string ](name='Topic', description='This parameter is required.'),
}

model UnsubscribeTopicResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  failureTopics?: {
    topic?: [  map[string]any ](name='topic')
  }(name='FailureTopics'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnsubscribeTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnsubscribeTopicResponseBody(name='body'),
}

/**
 * @param request UnsubscribeTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnsubscribeTopicResponse
 */
async function unsubscribeTopicWithOptions(request: UnsubscribeTopicRequest, runtime: Util.RuntimeOptions): UnsubscribeTopicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnsubscribeTopic',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UnsubscribeTopicRequest
 * @return UnsubscribeTopicResponse
 */
async function unsubscribeTopic(request: UnsubscribeTopicRequest): UnsubscribeTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return unsubscribeTopicWithOptions(request, runtime);
}

model UpdateConsumerGroupRequest {
  groupId?: string(name='GroupId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  newGroupName?: string(name='NewGroupName', description='This parameter is required.'),
}

model UpdateConsumerGroupResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateConsumerGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateConsumerGroupResponseBody(name='body'),
}

/**
 * @param request UpdateConsumerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConsumerGroupResponse
 */
async function updateConsumerGroupWithOptions(request: UpdateConsumerGroupRequest, runtime: Util.RuntimeOptions): UpdateConsumerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.newGroupName)) {
    query['NewGroupName'] = request.newGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConsumerGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateConsumerGroupRequest
 * @return UpdateConsumerGroupResponse
 */
async function updateConsumerGroup(request: UpdateConsumerGroupRequest): UpdateConsumerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConsumerGroupWithOptions(request, runtime);
}

model UpdateDestinationRequest {
  configuration?: string(name='Configuration', description='This parameter is required.'),
  description?: string(name='Description'),
  destinationId?: long(name='DestinationId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name', description='This parameter is required.'),
  type?: string(name='Type', description='This parameter is required.'),
}

model UpdateDestinationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDestinationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDestinationResponseBody(name='body'),
}

/**
 * @param request UpdateDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDestinationResponse
 */
async function updateDestinationWithOptions(request: UpdateDestinationRequest, runtime: Util.RuntimeOptions): UpdateDestinationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configuration)) {
    query['Configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destinationId)) {
    query['DestinationId'] = request.destinationId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDestination',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateDestinationRequest
 * @return UpdateDestinationResponse
 */
async function updateDestination(request: UpdateDestinationRequest): UpdateDestinationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDestinationWithOptions(request, runtime);
}

model UpdateDeviceGroupRequest {
  groupDesc?: string(name='GroupDesc'),
  groupId?: string(name='GroupId', description='This parameter is required.'),
  groupType?: string(name='GroupType'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model UpdateDeviceGroupResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDeviceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDeviceGroupResponseBody(name='body'),
}

/**
 * @param request UpdateDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDeviceGroupResponse
 */
async function updateDeviceGroupWithOptions(request: UpdateDeviceGroupRequest, runtime: Util.RuntimeOptions): UpdateDeviceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupDesc)) {
    query['GroupDesc'] = request.groupDesc;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupType)) {
    query['GroupType'] = request.groupType;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceGroup',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateDeviceGroupRequest
 * @return UpdateDeviceGroupResponse
 */
async function updateDeviceGroup(request: UpdateDeviceGroupRequest): UpdateDeviceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceGroupWithOptions(request, runtime);
}

model UpdateDeviceShadowRequest {
  deltaUpdate?: boolean(name='DeltaUpdate'),
  deviceName?: string(name='DeviceName', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  shadowMessage?: string(name='ShadowMessage', description='This parameter is required.'),
}

model UpdateDeviceShadowResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDeviceShadowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDeviceShadowResponseBody(name='body'),
}

/**
 * @param request UpdateDeviceShadowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDeviceShadowResponse
 */
async function updateDeviceShadowWithOptions(request: UpdateDeviceShadowRequest, runtime: Util.RuntimeOptions): UpdateDeviceShadowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deltaUpdate)) {
    query['DeltaUpdate'] = request.deltaUpdate;
  }
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.shadowMessage)) {
    query['ShadowMessage'] = request.shadowMessage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceShadow',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateDeviceShadowRequest
 * @return UpdateDeviceShadowResponse
 */
async function updateDeviceShadow(request: UpdateDeviceShadowRequest): UpdateDeviceShadowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceShadowWithOptions(request, runtime);
}

model UpdateEdgeDriverVersionRequest {
  argument?: string(name='Argument'),
  configCheckRule?: string(name='ConfigCheckRule'),
  containerConfig?: string(name='ContainerConfig'),
  description?: string(name='Description'),
  driverConfig?: string(name='DriverConfig'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  driverVersion?: string(name='DriverVersion', description='This parameter is required.'),
  edgeVersion?: string(name='EdgeVersion', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  sourceConfig?: string(name='SourceConfig'),
}

model UpdateEdgeDriverVersionResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEdgeDriverVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEdgeDriverVersionResponseBody(name='body'),
}

/**
 * @param request UpdateEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEdgeDriverVersionResponse
 */
async function updateEdgeDriverVersionWithOptions(request: UpdateEdgeDriverVersionRequest, runtime: Util.RuntimeOptions): UpdateEdgeDriverVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.argument)) {
    query['Argument'] = request.argument;
  }
  if (!Util.isUnset(request.configCheckRule)) {
    query['ConfigCheckRule'] = request.configCheckRule;
  }
  if (!Util.isUnset(request.containerConfig)) {
    query['ContainerConfig'] = request.containerConfig;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.driverConfig)) {
    query['DriverConfig'] = request.driverConfig;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.driverVersion)) {
    query['DriverVersion'] = request.driverVersion;
  }
  if (!Util.isUnset(request.edgeVersion)) {
    query['EdgeVersion'] = request.edgeVersion;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.sourceConfig)) {
    query['SourceConfig'] = request.sourceConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEdgeDriverVersion',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateEdgeDriverVersionRequest
 * @return UpdateEdgeDriverVersionResponse
 */
async function updateEdgeDriverVersion(request: UpdateEdgeDriverVersionRequest): UpdateEdgeDriverVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEdgeDriverVersionWithOptions(request, runtime);
}

model UpdateEdgeInstanceRequest {
  bizEnable?: boolean(name='BizEnable'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name', description='This parameter is required.'),
  spec?: int32(name='Spec'),
  tags?: string(name='Tags'),
}

model UpdateEdgeInstanceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEdgeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEdgeInstanceResponseBody(name='body'),
}

/**
 * @param request UpdateEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEdgeInstanceResponse
 */
async function updateEdgeInstanceWithOptions(request: UpdateEdgeInstanceRequest, runtime: Util.RuntimeOptions): UpdateEdgeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizEnable)) {
    query['BizEnable'] = request.bizEnable;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEdgeInstance',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateEdgeInstanceRequest
 * @return UpdateEdgeInstanceResponse
 */
async function updateEdgeInstance(request: UpdateEdgeInstanceRequest): UpdateEdgeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEdgeInstanceWithOptions(request, runtime);
}

model UpdateEdgeInstanceChannelRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  channelName?: string(name='ChannelName', description='This parameter is required.'),
  configs?: [ 
    {
      content?: string(name='Content', description='This parameter is required.'),
      format?: string(name='Format', description='This parameter is required.'),
      key?: string(name='Key'),
    }
  ](name='Configs', description='This parameter is required.'),
  driverId?: string(name='DriverId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
}

model UpdateEdgeInstanceChannelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEdgeInstanceChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEdgeInstanceChannelResponseBody(name='body'),
}

/**
 * @param request UpdateEdgeInstanceChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEdgeInstanceChannelResponse
 */
async function updateEdgeInstanceChannelWithOptions(request: UpdateEdgeInstanceChannelRequest, runtime: Util.RuntimeOptions): UpdateEdgeInstanceChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.channelName)) {
    query['ChannelName'] = request.channelName;
  }
  if (!Util.isUnset(request.configs)) {
    query['Configs'] = request.configs;
  }
  if (!Util.isUnset(request.driverId)) {
    query['DriverId'] = request.driverId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEdgeInstanceChannel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateEdgeInstanceChannelRequest
 * @return UpdateEdgeInstanceChannelResponse
 */
async function updateEdgeInstanceChannel(request: UpdateEdgeInstanceChannelRequest): UpdateEdgeInstanceChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEdgeInstanceChannelWithOptions(request, runtime);
}

model UpdateEdgeInstanceMessageRoutingRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name'),
  routeId?: long(name='RouteId', description='This parameter is required.'),
  sourceData?: string(name='SourceData'),
  sourceType?: string(name='SourceType', description='This parameter is required.'),
  targetData?: string(name='TargetData'),
  targetIotHubQos?: int32(name='TargetIotHubQos'),
  targetType?: string(name='TargetType', description='This parameter is required.'),
  topicFilter?: string(name='TopicFilter'),
}

model UpdateEdgeInstanceMessageRoutingResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateEdgeInstanceMessageRoutingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEdgeInstanceMessageRoutingResponseBody(name='body'),
}

/**
 * @param request UpdateEdgeInstanceMessageRoutingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEdgeInstanceMessageRoutingResponse
 */
async function updateEdgeInstanceMessageRoutingWithOptions(request: UpdateEdgeInstanceMessageRoutingRequest, runtime: Util.RuntimeOptions): UpdateEdgeInstanceMessageRoutingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.routeId)) {
    query['RouteId'] = request.routeId;
  }
  if (!Util.isUnset(request.sourceData)) {
    query['SourceData'] = request.sourceData;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.targetData)) {
    query['TargetData'] = request.targetData;
  }
  if (!Util.isUnset(request.targetIotHubQos)) {
    query['TargetIotHubQos'] = request.targetIotHubQos;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.topicFilter)) {
    query['TopicFilter'] = request.topicFilter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEdgeInstanceMessageRouting',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateEdgeInstanceMessageRoutingRequest
 * @return UpdateEdgeInstanceMessageRoutingResponse
 */
async function updateEdgeInstanceMessageRouting(request: UpdateEdgeInstanceMessageRoutingRequest): UpdateEdgeInstanceMessageRoutingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEdgeInstanceMessageRoutingWithOptions(request, runtime);
}

model UpdateJobRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
  rolloutConfig?: map[string]any(name='RolloutConfig'),
  timeoutConfig?: map[string]any(name='TimeoutConfig'),
}

model UpdateJobShrinkRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
  rolloutConfigShrink?: string(name='RolloutConfig'),
  timeoutConfigShrink?: string(name='TimeoutConfig'),
}

model UpdateJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateJobResponseBody(name='body'),
}

/**
 * @param tmpReq UpdateJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateJobResponse
 */
async function updateJobWithOptions(tmpReq: UpdateJobRequest, runtime: Util.RuntimeOptions): UpdateJobResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.rolloutConfig)) {
    request.rolloutConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rolloutConfig, 'RolloutConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.timeoutConfig)) {
    request.timeoutConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.timeoutConfig, 'TimeoutConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.rolloutConfigShrink)) {
    query['RolloutConfig'] = request.rolloutConfigShrink;
  }
  if (!Util.isUnset(request.timeoutConfigShrink)) {
    query['TimeoutConfig'] = request.timeoutConfigShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateJobRequest
 * @return UpdateJobResponse
 */
async function updateJob(request: UpdateJobRequest): UpdateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJobWithOptions(request, runtime);
}

model UpdateOTAJobRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  jobId?: string(name='JobId', description='This parameter is required.'),
  maximumPerMinute?: int32(name='MaximumPerMinute', description='This parameter is required.'),
  srcVersionList?: [ string ](name='SrcVersionList'),
  tags?: [ 
    {
      key?: string(name='Key', description='This parameter is required.'),
      value?: string(name='Value', description='This parameter is required.'),
    }
  ](name='Tags'),
  targetSelection?: string(name='TargetSelection', description='This parameter is required.'),
  timeoutInMinutes?: int32(name='TimeoutInMinutes'),
  upgradeType?: string(name='UpgradeType', description='This parameter is required.'),
}

model UpdateOTAJobResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateOTAJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateOTAJobResponseBody(name='body'),
}

/**
 * @param request UpdateOTAJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOTAJobResponse
 */
async function updateOTAJobWithOptions(request: UpdateOTAJobRequest, runtime: Util.RuntimeOptions): UpdateOTAJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.maximumPerMinute)) {
    query['MaximumPerMinute'] = request.maximumPerMinute;
  }
  if (!Util.isUnset(request.srcVersionList)) {
    query['SrcVersionList'] = request.srcVersionList;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.targetSelection)) {
    query['TargetSelection'] = request.targetSelection;
  }
  if (!Util.isUnset(request.timeoutInMinutes)) {
    query['TimeoutInMinutes'] = request.timeoutInMinutes;
  }
  if (!Util.isUnset(request.upgradeType)) {
    query['UpgradeType'] = request.upgradeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOTAJob',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateOTAJobRequest
 * @return UpdateOTAJobResponse
 */
async function updateOTAJob(request: UpdateOTAJobRequest): UpdateOTAJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOTAJobWithOptions(request, runtime);
}

model UpdateOTAModuleRequest {
  aliasName?: string(name='AliasName'),
  desc?: string(name='Desc'),
  iotInstanceId?: string(name='IotInstanceId'),
  moduleName?: string(name='ModuleName', description='This parameter is required.'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
}

model UpdateOTAModuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateOTAModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateOTAModuleResponseBody(name='body'),
}

/**
 * @param request UpdateOTAModuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOTAModuleResponse
 */
async function updateOTAModuleWithOptions(request: UpdateOTAModuleRequest, runtime: Util.RuntimeOptions): UpdateOTAModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOTAModule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateOTAModuleRequest
 * @return UpdateOTAModuleResponse
 */
async function updateOTAModule(request: UpdateOTAModuleRequest): UpdateOTAModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOTAModuleWithOptions(request, runtime);
}

model UpdateParserRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name'),
  parserId?: long(name='ParserId', description='This parameter is required.'),
}

model UpdateParserResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateParserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateParserResponseBody(name='body'),
}

/**
 * @param request UpdateParserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateParserResponse
 */
async function updateParserWithOptions(request: UpdateParserRequest, runtime: Util.RuntimeOptions): UpdateParserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.parserId)) {
    query['ParserId'] = request.parserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateParser',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateParserRequest
 * @return UpdateParserResponse
 */
async function updateParser(request: UpdateParserRequest): UpdateParserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateParserWithOptions(request, runtime);
}

model UpdateParserDataSourceRequest {
  dataSourceId?: long(name='DataSourceId', description='This parameter is required.'),
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name', description='This parameter is required.'),
}

model UpdateParserDataSourceResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateParserDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateParserDataSourceResponseBody(name='body'),
}

/**
 * @param request UpdateParserDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateParserDataSourceResponse
 */
async function updateParserDataSourceWithOptions(request: UpdateParserDataSourceRequest, runtime: Util.RuntimeOptions): UpdateParserDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataSourceId)) {
    query['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateParserDataSource',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateParserDataSourceRequest
 * @return UpdateParserDataSourceResponse
 */
async function updateParserDataSource(request: UpdateParserDataSourceRequest): UpdateParserDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateParserDataSourceWithOptions(request, runtime);
}

model UpdateProductRequest {
  description?: string(name='Description'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  productName?: string(name='ProductName', description='This parameter is required.'),
}

model UpdateProductResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateProductResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateProductResponseBody(name='body'),
}

/**
 * @param request UpdateProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProductResponse
 */
async function updateProductWithOptions(request: UpdateProductRequest, runtime: Util.RuntimeOptions): UpdateProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.productName)) {
    query['ProductName'] = request.productName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProduct',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateProductRequest
 * @return UpdateProductResponse
 */
async function updateProduct(request: UpdateProductRequest): UpdateProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProductWithOptions(request, runtime);
}

model UpdateProductFilterConfigRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  propertyTimestampFilter?: boolean(name='PropertyTimestampFilter', description='This parameter is required.'),
  propertyValueFilter?: boolean(name='PropertyValueFilter', description='This parameter is required.'),
}

model UpdateProductFilterConfigResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateProductFilterConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateProductFilterConfigResponseBody(name='body'),
}

/**
 * @param request UpdateProductFilterConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProductFilterConfigResponse
 */
async function updateProductFilterConfigWithOptions(request: UpdateProductFilterConfigRequest, runtime: Util.RuntimeOptions): UpdateProductFilterConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.propertyTimestampFilter)) {
    query['PropertyTimestampFilter'] = request.propertyTimestampFilter;
  }
  if (!Util.isUnset(request.propertyValueFilter)) {
    query['PropertyValueFilter'] = request.propertyValueFilter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductFilterConfig',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateProductFilterConfigRequest
 * @return UpdateProductFilterConfigResponse
 */
async function updateProductFilterConfig(request: UpdateProductFilterConfigRequest): UpdateProductFilterConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProductFilterConfigWithOptions(request, runtime);
}

model UpdateProductTagsRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  productTag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='ProductTag', description='This parameter is required.'),
}

model UpdateProductTagsResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  invalidProductTags?: {
    productTag?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='ProductTag')
  }(name='InvalidProductTags'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateProductTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateProductTagsResponseBody(name='body'),
}

/**
 * @param request UpdateProductTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProductTagsResponse
 */
async function updateProductTagsWithOptions(request: UpdateProductTagsRequest, runtime: Util.RuntimeOptions): UpdateProductTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.productTag)) {
    query['ProductTag'] = request.productTag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductTags',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateProductTagsRequest
 * @return UpdateProductTagsResponse
 */
async function updateProductTags(request: UpdateProductTagsRequest): UpdateProductTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProductTagsWithOptions(request, runtime);
}

model UpdateProductTopicRequest {
  codec?: string(name='Codec'),
  desc?: string(name='Desc'),
  enableProxySubscribe?: boolean(name='EnableProxySubscribe'),
  iotInstanceId?: string(name='IotInstanceId'),
  operation?: string(name='Operation', description='This parameter is required.'),
  topicId?: string(name='TopicId', description='This parameter is required.'),
  topicShortName?: string(name='TopicShortName', description='This parameter is required.'),
}

model UpdateProductTopicResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateProductTopicResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateProductTopicResponseBody(name='body'),
}

/**
 * @param request UpdateProductTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProductTopicResponse
 */
async function updateProductTopicWithOptions(request: UpdateProductTopicRequest, runtime: Util.RuntimeOptions): UpdateProductTopicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.codec)) {
    query['Codec'] = request.codec;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.enableProxySubscribe)) {
    query['EnableProxySubscribe'] = request.enableProxySubscribe;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.topicId)) {
    query['TopicId'] = request.topicId;
  }
  if (!Util.isUnset(request.topicShortName)) {
    query['TopicShortName'] = request.topicShortName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProductTopic',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateProductTopicRequest
 * @return UpdateProductTopicResponse
 */
async function updateProductTopic(request: UpdateProductTopicRequest): UpdateProductTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProductTopicWithOptions(request, runtime);
}

model UpdateRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name'),
  productKey?: string(name='ProductKey'),
  ruleDesc?: string(name='RuleDesc'),
  ruleId?: long(name='RuleId', description='This parameter is required.'),
  select?: string(name='Select'),
  shortTopic?: string(name='ShortTopic'),
  topic?: string(name='Topic'),
  topicType?: int32(name='TopicType'),
  where?: string(name='Where'),
}

model UpdateRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRuleResponseBody(name='body'),
}

/**
 * @param request UpdateRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRuleResponse
 */
async function updateRuleWithOptions(request: UpdateRuleRequest, runtime: Util.RuntimeOptions): UpdateRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.ruleDesc)) {
    query['RuleDesc'] = request.ruleDesc;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.select)) {
    query['Select'] = request.select;
  }
  if (!Util.isUnset(request.shortTopic)) {
    query['ShortTopic'] = request.shortTopic;
  }
  if (!Util.isUnset(request.topic)) {
    query['Topic'] = request.topic;
  }
  if (!Util.isUnset(request.topicType)) {
    query['TopicType'] = request.topicType;
  }
  if (!Util.isUnset(request.where)) {
    query['Where'] = request.where;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateRuleRequest
 * @return UpdateRuleResponse
 */
async function updateRule(request: UpdateRuleRequest): UpdateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleWithOptions(request, runtime);
}

model UpdateRuleActionRequest {
  actionId?: long(name='ActionId', description='This parameter is required.'),
  configuration?: string(name='Configuration', description='This parameter is required.'),
  iotInstanceId?: string(name='IotInstanceId'),
  type?: string(name='Type', description='This parameter is required.'),
}

model UpdateRuleActionResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateRuleActionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRuleActionResponseBody(name='body'),
}

/**
 * @param request UpdateRuleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRuleActionResponse
 */
async function updateRuleActionWithOptions(request: UpdateRuleActionRequest, runtime: Util.RuntimeOptions): UpdateRuleActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionId)) {
    query['ActionId'] = request.actionId;
  }
  if (!Util.isUnset(request.configuration)) {
    query['Configuration'] = request.configuration;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRuleAction',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateRuleActionRequest
 * @return UpdateRuleActionResponse
 */
async function updateRuleAction(request: UpdateRuleActionRequest): UpdateRuleActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleActionWithOptions(request, runtime);
}

model UpdateSceneRuleRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  ruleContent?: string(name='RuleContent'),
  ruleDescription?: string(name='RuleDescription'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
  ruleName?: string(name='RuleName'),
}

model UpdateSceneRuleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSceneRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSceneRuleResponseBody(name='body'),
}

/**
 * @param request UpdateSceneRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSceneRuleResponse
 */
async function updateSceneRuleWithOptions(request: UpdateSceneRuleRequest, runtime: Util.RuntimeOptions): UpdateSceneRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.ruleContent)) {
    query['RuleContent'] = request.ruleContent;
  }
  if (!Util.isUnset(request.ruleDescription)) {
    query['RuleDescription'] = request.ruleDescription;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSceneRule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateSceneRuleRequest
 * @return UpdateSceneRuleResponse
 */
async function updateSceneRule(request: UpdateSceneRuleRequest): UpdateSceneRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSceneRuleWithOptions(request, runtime);
}

model UpdateSchedulePeriodRequest {
  description?: string(name='Description'),
  endTime?: string(name='EndTime'),
  iotInstanceId?: string(name='IotInstanceId'),
  periodCode?: string(name='PeriodCode', description='This parameter is required.'),
  soundCodeContent?: string(name='SoundCodeContent'),
  startTime?: string(name='StartTime'),
}

model UpdateSchedulePeriodResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSchedulePeriodResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSchedulePeriodResponseBody(name='body'),
}

/**
 * @param request UpdateSchedulePeriodRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSchedulePeriodResponse
 */
async function updateSchedulePeriodWithOptions(request: UpdateSchedulePeriodRequest, runtime: Util.RuntimeOptions): UpdateSchedulePeriodResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.periodCode)) {
    body['PeriodCode'] = request.periodCode;
  }
  if (!Util.isUnset(request.soundCodeContent)) {
    body['SoundCodeContent'] = request.soundCodeContent;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSchedulePeriod',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateSchedulePeriodRequest
 * @return UpdateSchedulePeriodResponse
 */
async function updateSchedulePeriod(request: UpdateSchedulePeriodRequest): UpdateSchedulePeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSchedulePeriodWithOptions(request, runtime);
}

model UpdateSoundCodeRequest {
  duration?: int32(name='Duration'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name'),
  soundCode?: string(name='SoundCode', description='This parameter is required.'),
  soundCodeContent?: string(name='SoundCodeContent'),
}

model UpdateSoundCodeResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSoundCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSoundCodeResponseBody(name='body'),
}

/**
 * @param request UpdateSoundCodeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSoundCodeResponse
 */
async function updateSoundCodeWithOptions(request: UpdateSoundCodeRequest, runtime: Util.RuntimeOptions): UpdateSoundCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.duration)) {
    body['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.soundCode)) {
    body['SoundCode'] = request.soundCode;
  }
  if (!Util.isUnset(request.soundCodeContent)) {
    body['SoundCodeContent'] = request.soundCodeContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSoundCode',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateSoundCodeRequest
 * @return UpdateSoundCodeResponse
 */
async function updateSoundCode(request: UpdateSoundCodeRequest): UpdateSoundCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSoundCodeWithOptions(request, runtime);
}

model UpdateSoundCodeLabelRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  label?: string(name='Label', description='This parameter is required.'),
  soundCode?: string(name='SoundCode', description='This parameter is required.'),
}

model UpdateSoundCodeLabelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSoundCodeLabelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSoundCodeLabelResponseBody(name='body'),
}

/**
 * @param request UpdateSoundCodeLabelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSoundCodeLabelResponse
 */
async function updateSoundCodeLabelWithOptions(request: UpdateSoundCodeLabelRequest, runtime: Util.RuntimeOptions): UpdateSoundCodeLabelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.label)) {
    body['Label'] = request.label;
  }
  if (!Util.isUnset(request.soundCode)) {
    body['SoundCode'] = request.soundCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSoundCodeLabel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateSoundCodeLabelRequest
 * @return UpdateSoundCodeLabelResponse
 */
async function updateSoundCodeLabel(request: UpdateSoundCodeLabelRequest): UpdateSoundCodeLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSoundCodeLabelWithOptions(request, runtime);
}

model UpdateSoundCodeScheduleRequest {
  description?: string(name='Description'),
  endDate?: string(name='EndDate'),
  endTime?: string(name='EndTime'),
  iotInstanceId?: string(name='IotInstanceId'),
  name?: string(name='Name'),
  scheduleCode?: string(name='ScheduleCode', description='This parameter is required.'),
  startDate?: string(name='StartDate'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model UpdateSoundCodeScheduleResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSoundCodeScheduleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSoundCodeScheduleResponseBody(name='body'),
}

/**
 * @param request UpdateSoundCodeScheduleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSoundCodeScheduleResponse
 */
async function updateSoundCodeScheduleWithOptions(request: UpdateSoundCodeScheduleRequest, runtime: Util.RuntimeOptions): UpdateSoundCodeScheduleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.scheduleCode)) {
    body['ScheduleCode'] = request.scheduleCode;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSoundCodeSchedule',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateSoundCodeScheduleRequest
 * @return UpdateSoundCodeScheduleResponse
 */
async function updateSoundCodeSchedule(request: UpdateSoundCodeScheduleRequest): UpdateSoundCodeScheduleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSoundCodeScheduleWithOptions(request, runtime);
}

model UpdateSpeechRequest {
  enableSoundCode?: boolean(name='EnableSoundCode'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
  soundCodeConfig?: map[string]any(name='SoundCodeConfig'),
  speechCode?: string(name='SpeechCode', description='This parameter is required.'),
  speechRate?: int32(name='SpeechRate'),
  voice?: string(name='Voice', description='This parameter is required.'),
  volume?: int32(name='Volume'),
}

model UpdateSpeechShrinkRequest {
  enableSoundCode?: boolean(name='EnableSoundCode'),
  iotInstanceId?: string(name='IotInstanceId'),
  projectCode?: string(name='ProjectCode', description='This parameter is required.'),
  soundCodeConfigShrink?: string(name='SoundCodeConfig'),
  speechCode?: string(name='SpeechCode', description='This parameter is required.'),
  speechRate?: int32(name='SpeechRate'),
  voice?: string(name='Voice', description='This parameter is required.'),
  volume?: int32(name='Volume'),
}

model UpdateSpeechResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSpeechResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSpeechResponseBody(name='body'),
}

/**
 * @param tmpReq UpdateSpeechRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSpeechResponse
 */
async function updateSpeechWithOptions(tmpReq: UpdateSpeechRequest, runtime: Util.RuntimeOptions): UpdateSpeechResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateSpeechShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.soundCodeConfig)) {
    request.soundCodeConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.soundCodeConfig, 'SoundCodeConfig', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.enableSoundCode)) {
    body['EnableSoundCode'] = request.enableSoundCode;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    body['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.projectCode)) {
    body['ProjectCode'] = request.projectCode;
  }
  if (!Util.isUnset(request.soundCodeConfigShrink)) {
    body['SoundCodeConfig'] = request.soundCodeConfigShrink;
  }
  if (!Util.isUnset(request.speechCode)) {
    body['SpeechCode'] = request.speechCode;
  }
  if (!Util.isUnset(request.speechRate)) {
    body['SpeechRate'] = request.speechRate;
  }
  if (!Util.isUnset(request.voice)) {
    body['Voice'] = request.voice;
  }
  if (!Util.isUnset(request.volume)) {
    body['Volume'] = request.volume;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSpeech',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateSpeechRequest
 * @return UpdateSpeechResponse
 */
async function updateSpeech(request: UpdateSpeechRequest): UpdateSpeechResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSpeechWithOptions(request, runtime);
}

model UpdateSubscribeRelationRequest {
  consumerGroupIds?: [ string ](name='ConsumerGroupIds'),
  deviceDataFlag?: boolean(name='DeviceDataFlag'),
  deviceLifeCycleFlag?: boolean(name='DeviceLifeCycleFlag'),
  deviceStatusChangeFlag?: boolean(name='DeviceStatusChangeFlag'),
  deviceTagFlag?: boolean(name='DeviceTagFlag'),
  deviceTopoLifeCycleFlag?: boolean(name='DeviceTopoLifeCycleFlag'),
  foundDeviceListFlag?: boolean(name='FoundDeviceListFlag'),
  iotInstanceId?: string(name='IotInstanceId'),
  mnsConfiguration?: string(name='MnsConfiguration'),
  otaEventFlag?: boolean(name='OtaEventFlag'),
  otaJobFlag?: boolean(name='OtaJobFlag'),
  otaVersionFlag?: boolean(name='OtaVersionFlag'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  subscribeFlags?: string(name='SubscribeFlags'),
  thingHistoryFlag?: boolean(name='ThingHistoryFlag'),
  type?: string(name='Type', description='This parameter is required.'),
}

model UpdateSubscribeRelationResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSubscribeRelationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSubscribeRelationResponseBody(name='body'),
}

/**
 * @param request UpdateSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSubscribeRelationResponse
 */
async function updateSubscribeRelationWithOptions(request: UpdateSubscribeRelationRequest, runtime: Util.RuntimeOptions): UpdateSubscribeRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consumerGroupIds)) {
    query['ConsumerGroupIds'] = request.consumerGroupIds;
  }
  if (!Util.isUnset(request.deviceDataFlag)) {
    query['DeviceDataFlag'] = request.deviceDataFlag;
  }
  if (!Util.isUnset(request.deviceLifeCycleFlag)) {
    query['DeviceLifeCycleFlag'] = request.deviceLifeCycleFlag;
  }
  if (!Util.isUnset(request.deviceStatusChangeFlag)) {
    query['DeviceStatusChangeFlag'] = request.deviceStatusChangeFlag;
  }
  if (!Util.isUnset(request.deviceTagFlag)) {
    query['DeviceTagFlag'] = request.deviceTagFlag;
  }
  if (!Util.isUnset(request.deviceTopoLifeCycleFlag)) {
    query['DeviceTopoLifeCycleFlag'] = request.deviceTopoLifeCycleFlag;
  }
  if (!Util.isUnset(request.foundDeviceListFlag)) {
    query['FoundDeviceListFlag'] = request.foundDeviceListFlag;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.mnsConfiguration)) {
    query['MnsConfiguration'] = request.mnsConfiguration;
  }
  if (!Util.isUnset(request.otaEventFlag)) {
    query['OtaEventFlag'] = request.otaEventFlag;
  }
  if (!Util.isUnset(request.otaJobFlag)) {
    query['OtaJobFlag'] = request.otaJobFlag;
  }
  if (!Util.isUnset(request.otaVersionFlag)) {
    query['OtaVersionFlag'] = request.otaVersionFlag;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.subscribeFlags)) {
    query['SubscribeFlags'] = request.subscribeFlags;
  }
  if (!Util.isUnset(request.thingHistoryFlag)) {
    query['ThingHistoryFlag'] = request.thingHistoryFlag;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSubscribeRelation',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateSubscribeRelationRequest
 * @return UpdateSubscribeRelationResponse
 */
async function updateSubscribeRelation(request: UpdateSubscribeRelationRequest): UpdateSubscribeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSubscribeRelationWithOptions(request, runtime);
}

model UpdateThingModelRequest {
  functionBlockId?: string(name='FunctionBlockId'),
  functionBlockName?: string(name='FunctionBlockName'),
  identifier?: string(name='Identifier'),
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  thingModelJson?: string(name='ThingModelJson'),
}

model UpdateThingModelResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateThingModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateThingModelResponseBody(name='body'),
}

/**
 * @param request UpdateThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateThingModelResponse
 */
async function updateThingModelWithOptions(request: UpdateThingModelRequest, runtime: Util.RuntimeOptions): UpdateThingModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionBlockId)) {
    query['FunctionBlockId'] = request.functionBlockId;
  }
  if (!Util.isUnset(request.functionBlockName)) {
    query['FunctionBlockName'] = request.functionBlockName;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.thingModelJson)) {
    query['ThingModelJson'] = request.thingModelJson;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateThingModel',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateThingModelRequest
 * @return UpdateThingModelResponse
 */
async function updateThingModel(request: UpdateThingModelRequest): UpdateThingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateThingModelWithOptions(request, runtime);
}

model UpdateThingScriptRequest {
  iotInstanceId?: string(name='IotInstanceId'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  scriptContent?: string(name='ScriptContent', description='This parameter is required.'),
  scriptType?: string(name='ScriptType', description='This parameter is required.'),
}

model UpdateThingScriptResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateThingScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateThingScriptResponseBody(name='body'),
}

/**
 * @param request UpdateThingScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateThingScriptResponse
 */
async function updateThingScriptWithOptions(request: UpdateThingScriptRequest, runtime: Util.RuntimeOptions): UpdateThingScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.scriptContent)) {
    query['ScriptContent'] = request.scriptContent;
  }
  if (!Util.isUnset(request.scriptType)) {
    query['ScriptType'] = request.scriptType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateThingScript',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateThingScriptRequest
 * @return UpdateThingScriptResponse
 */
async function updateThingScript(request: UpdateThingScriptRequest): UpdateThingScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateThingScriptWithOptions(request, runtime);
}

model UpdateTopicConfigRequest {
  codec?: string(name='Codec'),
  description?: string(name='Description'),
  enableBroadcast?: boolean(name='EnableBroadcast'),
  enableProxySubscribe?: boolean(name='EnableProxySubscribe'),
  iotInstanceId?: string(name='IotInstanceId'),
  operation?: string(name='Operation'),
  productKey?: string(name='ProductKey', description='This parameter is required.'),
  topicFullName?: string(name='TopicFullName', description='This parameter is required.'),
}

model UpdateTopicConfigResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateTopicConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTopicConfigResponseBody(name='body'),
}

/**
 * @param request UpdateTopicConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTopicConfigResponse
 */
async function updateTopicConfigWithOptions(request: UpdateTopicConfigRequest, runtime: Util.RuntimeOptions): UpdateTopicConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.codec)) {
    query['Codec'] = request.codec;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableBroadcast)) {
    query['EnableBroadcast'] = request.enableBroadcast;
  }
  if (!Util.isUnset(request.enableProxySubscribe)) {
    query['EnableProxySubscribe'] = request.enableProxySubscribe;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.topicFullName)) {
    query['TopicFullName'] = request.topicFullName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTopicConfig',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateTopicConfigRequest
 * @return UpdateTopicConfigResponse
 */
async function updateTopicConfig(request: UpdateTopicConfigRequest): UpdateTopicConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTopicConfigWithOptions(request, runtime);
}

model WriteDevicesHotStorageDataRequest {
  deviceName?: string(name='DeviceName'),
  iotId?: string(name='IotId'),
  iotInstanceId?: string(name='IotInstanceId', description='This parameter is required.'),
  items?: string(name='Items', description='This parameter is required.'),
  productKey?: string(name='ProductKey'),
  userTopic?: string(name='UserTopic', description='This parameter is required.'),
}

model WriteDevicesHotStorageDataResponseBody = {
  code?: string(name='Code'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model WriteDevicesHotStorageDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: WriteDevicesHotStorageDataResponseBody(name='body'),
}

/**
 * @param request WriteDevicesHotStorageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return WriteDevicesHotStorageDataResponse
 */
async function writeDevicesHotStorageDataWithOptions(request: WriteDevicesHotStorageDataRequest, runtime: Util.RuntimeOptions): WriteDevicesHotStorageDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.iotId)) {
    query['IotId'] = request.iotId;
  }
  if (!Util.isUnset(request.iotInstanceId)) {
    query['IotInstanceId'] = request.iotInstanceId;
  }
  if (!Util.isUnset(request.items)) {
    query['Items'] = request.items;
  }
  if (!Util.isUnset(request.productKey)) {
    query['ProductKey'] = request.productKey;
  }
  if (!Util.isUnset(request.userTopic)) {
    query['UserTopic'] = request.userTopic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WriteDevicesHotStorageData',
    version = '2018-01-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request WriteDevicesHotStorageDataRequest
 * @return WriteDevicesHotStorageDataResponse
 */
async function writeDevicesHotStorageData(request: WriteDevicesHotStorageDataRequest): WriteDevicesHotStorageDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return writeDevicesHotStorageDataWithOptions(request, runtime);
}

