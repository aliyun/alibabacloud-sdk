/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    cn-qingdao = 'vpc.aliyuncs.com',
    cn-beijing = 'vpc.aliyuncs.com',
    cn-hangzhou = 'vpc.aliyuncs.com',
    cn-shanghai = 'vpc.aliyuncs.com',
    cn-shenzhen = 'vpc.aliyuncs.com',
    cn-hongkong = 'vpc.aliyuncs.com',
    ap-southeast-1 = 'vpc.aliyuncs.com',
    us-east-1 = 'vpc.aliyuncs.com',
    us-west-1 = 'vpc.aliyuncs.com',
    cn-shanghai-finance-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-finance-1 = 'vpc.aliyuncs.com',
    cn-north-2-gov-1 = 'vpc.aliyuncs.com',
    ap-northeast-2-pop = 'vpc.aliyuncs.com',
    cn-beijing-finance-1 = 'vpc.aliyuncs.com',
    cn-beijing-finance-pop = 'vpc.aliyuncs.com',
    cn-beijing-gov-1 = 'vpc.aliyuncs.com',
    cn-beijing-nu16-b01 = 'vpc.aliyuncs.com',
    cn-edge-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-fujian = 'vpc.aliyuncs.com',
    cn-haidian-cm12-c01 = 'vpc.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'vpc.aliyuncs.com',
    cn-hangzhou-finance = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'vpc.aliyuncs.com',
    cn-hangzhou-test-306 = 'vpc.aliyuncs.com',
    cn-hongkong-finance-pop = 'vpc.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-qingdao-nebula = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-shanghai-et15-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-et2-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-inner = 'vpc.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-inner = 'vpc.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'vpc.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'vpc.aliyuncs.com',
    cn-wuhan = 'vpc.aliyuncs.com',
    cn-yushanfang = 'vpc.aliyuncs.com',
    cn-zhangbei = 'vpc.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'vpc.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'vpc.cn-zhangjiakou.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    eu-west-1-oxs = 'vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com',
    rus-west-1-pop = 'vpc.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('vpc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model ActivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model ActivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ActivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateRouterInterfaceResponseBody(name='body'),
}

async function activateRouterInterfaceWithOptions(request: ActivateRouterInterfaceRequest, runtime: Util.RuntimeOptions): ActivateRouterInterfaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ActivateRouterInterface', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function activateRouterInterface(request: ActivateRouterInterfaceRequest): ActivateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateRouterInterfaceWithOptions(request, runtime);
}

model ActiveFlowLogRequest {
  flowLogId?: string(name='FlowLogId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ActiveFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ActiveFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: ActiveFlowLogResponseBody(name='body'),
}

async function activeFlowLogWithOptions(request: ActiveFlowLogRequest, runtime: Util.RuntimeOptions): ActiveFlowLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ActiveFlowLog', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function activeFlowLog(request: ActiveFlowLogRequest): ActiveFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return activeFlowLogWithOptions(request, runtime);
}

model AddBgpNetworkRequest {
  clientToken?: string(name='ClientToken'),
  dstCidrBlock?: string(name='DstCidrBlock'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
  vpcId?: string(name='VpcId'),
}

model AddBgpNetworkResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddBgpNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: AddBgpNetworkResponseBody(name='body'),
}

async function addBgpNetworkWithOptions(request: AddBgpNetworkRequest, runtime: Util.RuntimeOptions): AddBgpNetworkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddBgpNetwork', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addBgpNetwork(request: AddBgpNetworkRequest): AddBgpNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBgpNetworkWithOptions(request, runtime);
}

model AddCommonBandwidthPackageIpRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  ipInstanceId?: string(name='IpInstanceId'),
  ipType?: string(name='IpType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddCommonBandwidthPackageIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCommonBandwidthPackageIpResponse = {
  headers: map[string]string(name='headers'),
  body: AddCommonBandwidthPackageIpResponseBody(name='body'),
}

async function addCommonBandwidthPackageIpWithOptions(request: AddCommonBandwidthPackageIpRequest, runtime: Util.RuntimeOptions): AddCommonBandwidthPackageIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddCommonBandwidthPackageIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addCommonBandwidthPackageIp(request: AddCommonBandwidthPackageIpRequest): AddCommonBandwidthPackageIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCommonBandwidthPackageIpWithOptions(request, runtime);
}

model AddCommonBandwidthPackageIpsRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  ipInstanceIds?: [ string ](name='IpInstanceIds'),
  ipType?: string(name='IpType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddCommonBandwidthPackageIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCommonBandwidthPackageIpsResponse = {
  headers: map[string]string(name='headers'),
  body: AddCommonBandwidthPackageIpsResponseBody(name='body'),
}

async function addCommonBandwidthPackageIpsWithOptions(request: AddCommonBandwidthPackageIpsRequest, runtime: Util.RuntimeOptions): AddCommonBandwidthPackageIpsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddCommonBandwidthPackageIps', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addCommonBandwidthPackageIps(request: AddCommonBandwidthPackageIpsRequest): AddCommonBandwidthPackageIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCommonBandwidthPackageIpsWithOptions(request, runtime);
}

model AddGlobalAccelerationInstanceIpRequest {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipInstanceId?: string(name='IpInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddGlobalAccelerationInstanceIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddGlobalAccelerationInstanceIpResponse = {
  headers: map[string]string(name='headers'),
  body: AddGlobalAccelerationInstanceIpResponseBody(name='body'),
}

async function addGlobalAccelerationInstanceIpWithOptions(request: AddGlobalAccelerationInstanceIpRequest, runtime: Util.RuntimeOptions): AddGlobalAccelerationInstanceIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddGlobalAccelerationInstanceIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addGlobalAccelerationInstanceIp(request: AddGlobalAccelerationInstanceIpRequest): AddGlobalAccelerationInstanceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

model AddIPv6TranslatorAclListEntryRequest {
  aclEntryComment?: string(name='AclEntryComment'),
  aclEntryIp?: string(name='AclEntryIp'),
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddIPv6TranslatorAclListEntryResponseBody = {
  aclEntryId?: string(name='AclEntryId'),
  requestId?: string(name='RequestId'),
}

model AddIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: AddIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function addIPv6TranslatorAclListEntryWithOptions(request: AddIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): AddIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddIPv6TranslatorAclListEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addIPv6TranslatorAclListEntry(request: AddIPv6TranslatorAclListEntryRequest): AddIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model AddSourcesToTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
  trafficMirrorSourceIds?: [ string ](name='TrafficMirrorSourceIds'),
}

model AddSourcesToTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddSourcesToTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  body: AddSourcesToTrafficMirrorSessionResponseBody(name='body'),
}

async function addSourcesToTrafficMirrorSessionWithOptions(request: AddSourcesToTrafficMirrorSessionRequest, runtime: Util.RuntimeOptions): AddSourcesToTrafficMirrorSessionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddSourcesToTrafficMirrorSession', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addSourcesToTrafficMirrorSession(request: AddSourcesToTrafficMirrorSessionRequest): AddSourcesToTrafficMirrorSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSourcesToTrafficMirrorSessionWithOptions(request, runtime);
}

model AllocateEipAddressRequest {
  activityId?: long(name='ActivityId'),
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: string(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ISP?: string(name='ISP'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  name?: string(name='Name'),
  netmode?: string(name='Netmode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionTypes?: [ string ](name='SecurityProtectionTypes'),
}

model AllocateEipAddressResponseBody = {
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model AllocateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipAddressResponseBody(name='body'),
}

async function allocateEipAddressWithOptions(request: AllocateEipAddressRequest, runtime: Util.RuntimeOptions): AllocateEipAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AllocateEipAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function allocateEipAddress(request: AllocateEipAddressRequest): AllocateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipAddressWithOptions(request, runtime);
}

model AllocateEipAddressProRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: string(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ISP?: string(name='ISP'),
  instanceChargeType?: string(name='InstanceChargeType'),
  instanceId?: string(name='InstanceId'),
  internetChargeType?: string(name='InternetChargeType'),
  ipAddress?: string(name='IpAddress'),
  netmode?: string(name='Netmode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionTypes?: [ string ](name='SecurityProtectionTypes'),
}

model AllocateEipAddressProResponseBody = {
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model AllocateEipAddressProResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipAddressProResponseBody(name='body'),
}

async function allocateEipAddressProWithOptions(request: AllocateEipAddressProRequest, runtime: Util.RuntimeOptions): AllocateEipAddressProResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AllocateEipAddressPro', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function allocateEipAddressPro(request: AllocateEipAddressProRequest): AllocateEipAddressProResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipAddressProWithOptions(request, runtime);
}

model AllocateEipSegmentAddressRequest {
  bandwidth?: string(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  eipMask?: string(name='EipMask'),
  internetChargeType?: string(name='InternetChargeType'),
  isp?: string(name='Isp'),
  netmode?: string(name='Netmode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AllocateEipSegmentAddressResponseBody = {
  eipSegmentInstanceId?: string(name='EipSegmentInstanceId'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model AllocateEipSegmentAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipSegmentAddressResponseBody(name='body'),
}

async function allocateEipSegmentAddressWithOptions(request: AllocateEipSegmentAddressRequest, runtime: Util.RuntimeOptions): AllocateEipSegmentAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AllocateEipSegmentAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function allocateEipSegmentAddress(request: AllocateEipSegmentAddressRequest): AllocateEipSegmentAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipSegmentAddressWithOptions(request, runtime);
}

model AllocateIpv6InternetBandwidthRequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  internetChargeType?: string(name='InternetChargeType'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AllocateIpv6InternetBandwidthResponseBody = {
  internetBandwidthId?: string(name='InternetBandwidthId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  requestId?: string(name='RequestId'),
}

model AllocateIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateIpv6InternetBandwidthResponseBody(name='body'),
}

async function allocateIpv6InternetBandwidthWithOptions(request: AllocateIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): AllocateIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AllocateIpv6InternetBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function allocateIpv6InternetBandwidth(request: AllocateIpv6InternetBandwidthRequest): AllocateIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateIpv6InternetBandwidthWithOptions(request, runtime);
}

model ApplyPhysicalConnectionLOARequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  companyName?: string(name='CompanyName'),
  constructionTime?: string(name='ConstructionTime'),
  instanceId?: string(name='InstanceId'),
  lineType?: string(name='LineType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  PMInfo?: [ 
    {
      PMCertificateNo?: string(name='PMCertificateNo'),
      PMCertificateType?: string(name='PMCertificateType'),
      PMContactInfo?: string(name='PMContactInfo'),
      PMGender?: string(name='PMGender'),
      PMName?: string(name='PMName'),
    }
  ](name='PMInfo'),
  peerLocation?: string(name='PeerLocation'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  si?: string(name='Si'),
}

model ApplyPhysicalConnectionLOAResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApplyPhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyPhysicalConnectionLOAResponseBody(name='body'),
}

async function applyPhysicalConnectionLOAWithOptions(request: ApplyPhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): ApplyPhysicalConnectionLOAResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ApplyPhysicalConnectionLOA', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function applyPhysicalConnectionLOA(request: ApplyPhysicalConnectionLOARequest): ApplyPhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyPhysicalConnectionLOAWithOptions(request, runtime);
}

model AssociateEipAddressRequest {
  allocationId?: string(name='AllocationId'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  instanceRegionId?: string(name='InstanceRegionId'),
  instanceType?: string(name='InstanceType'),
  mode?: string(name='Mode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AssociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateEipAddressResponseBody(name='body'),
}

async function associateEipAddressWithOptions(request: AssociateEipAddressRequest, runtime: Util.RuntimeOptions): AssociateEipAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateEipAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateEipAddress(request: AssociateEipAddressRequest): AssociateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateEipAddressWithOptions(request, runtime);
}

model AssociateGlobalAccelerationInstanceRequest {
  backendServerId?: string(name='BackendServerId'),
  backendServerRegionId?: string(name='BackendServerRegionId'),
  backendServerType?: string(name='BackendServerType'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AssociateGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function associateGlobalAccelerationInstanceWithOptions(request: AssociateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): AssociateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateGlobalAccelerationInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateGlobalAccelerationInstance(request: AssociateGlobalAccelerationInstanceRequest): AssociateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateGlobalAccelerationInstanceWithOptions(request, runtime);
}

model AssociateHaVipRequest {
  clientToken?: string(name='ClientToken'),
  haVipId?: string(name='HaVipId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AssociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateHaVipResponseBody(name='body'),
}

async function associateHaVipWithOptions(request: AssociateHaVipRequest, runtime: Util.RuntimeOptions): AssociateHaVipResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateHaVip', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateHaVip(request: AssociateHaVipRequest): AssociateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateHaVipWithOptions(request, runtime);
}

model AssociateNetworkAclRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resource'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AssociateNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateNetworkAclResponseBody(name='body'),
}

async function associateNetworkAclWithOptions(request: AssociateNetworkAclRequest, runtime: Util.RuntimeOptions): AssociateNetworkAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateNetworkAcl', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateNetworkAcl(request: AssociateNetworkAclRequest): AssociateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateNetworkAclWithOptions(request, runtime);
}

model AssociatePhysicalConnectionToVirtualBorderRouterRequest {
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  enableIpv6?: string(name='EnableIpv6'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
  vlanId?: string(name='VlanId'),
}

model AssociatePhysicalConnectionToVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociatePhysicalConnectionToVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: AssociatePhysicalConnectionToVirtualBorderRouterResponseBody(name='body'),
}

async function associatePhysicalConnectionToVirtualBorderRouterWithOptions(request: AssociatePhysicalConnectionToVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): AssociatePhysicalConnectionToVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociatePhysicalConnectionToVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associatePhysicalConnectionToVirtualBorderRouter(request: AssociatePhysicalConnectionToVirtualBorderRouterRequest): AssociatePhysicalConnectionToVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return associatePhysicalConnectionToVirtualBorderRouterWithOptions(request, runtime);
}

model AssociateRouteTableRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  vSwitchId?: string(name='VSwitchId'),
}

model AssociateRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateRouteTableResponseBody(name='body'),
}

async function associateRouteTableWithOptions(request: AssociateRouteTableRequest, runtime: Util.RuntimeOptions): AssociateRouteTableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateRouteTable', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateRouteTable(request: AssociateRouteTableRequest): AssociateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateRouteTableWithOptions(request, runtime);
}

model AssociateRouteTableWithGatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  gatewayId?: string(name='GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
}

model AssociateRouteTableWithGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateRouteTableWithGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateRouteTableWithGatewayResponseBody(name='body'),
}

async function associateRouteTableWithGatewayWithOptions(request: AssociateRouteTableWithGatewayRequest, runtime: Util.RuntimeOptions): AssociateRouteTableWithGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateRouteTableWithGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateRouteTableWithGateway(request: AssociateRouteTableWithGatewayRequest): AssociateRouteTableWithGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateRouteTableWithGatewayWithOptions(request, runtime);
}

model AssociateRouteTablesWithVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken', description='幂等参数'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求'),
  endpointId?: string(name='EndpointId', description='VPC网关实例ID'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableIds?: [ string ](name='RouteTableIds', description='路由表列表'),
}

model AssociateRouteTablesWithVpcGatewayEndpointResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AssociateRouteTablesWithVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateRouteTablesWithVpcGatewayEndpointResponseBody(name='body'),
}

async function associateRouteTablesWithVpcGatewayEndpointWithOptions(request: AssociateRouteTablesWithVpcGatewayEndpointRequest, runtime: Util.RuntimeOptions): AssociateRouteTablesWithVpcGatewayEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateRouteTablesWithVpcGatewayEndpoint', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateRouteTablesWithVpcGatewayEndpoint(request: AssociateRouteTablesWithVpcGatewayEndpointRequest): AssociateRouteTablesWithVpcGatewayEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateRouteTablesWithVpcGatewayEndpointWithOptions(request, runtime);
}

model AssociateVpcCidrBlockRequest {
  ipVersion?: string(name='IpVersion'),
  ipv6Isp?: string(name='Ipv6Isp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock'),
  vpcId?: string(name='VpcId'),
}

model AssociateVpcCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateVpcCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateVpcCidrBlockResponseBody(name='body'),
}

async function associateVpcCidrBlockWithOptions(request: AssociateVpcCidrBlockRequest, runtime: Util.RuntimeOptions): AssociateVpcCidrBlockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateVpcCidrBlock', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateVpcCidrBlock(request: AssociateVpcCidrBlockRequest): AssociateVpcCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateVpcCidrBlockWithOptions(request, runtime);
}

model AssociateVpnGatewayWithCertificateRequest {
  certificateId?: string(name='CertificateId'),
  certificateType?: string(name='CertificateType'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model AssociateVpnGatewayWithCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateVpnGatewayWithCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateVpnGatewayWithCertificateResponseBody(name='body'),
}

async function associateVpnGatewayWithCertificateWithOptions(request: AssociateVpnGatewayWithCertificateRequest, runtime: Util.RuntimeOptions): AssociateVpnGatewayWithCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateVpnGatewayWithCertificate', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateVpnGatewayWithCertificate(request: AssociateVpnGatewayWithCertificateRequest): AssociateVpnGatewayWithCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateVpnGatewayWithCertificateWithOptions(request, runtime);
}

model AttachDhcpOptionsSetToVpcRequest {
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model AttachDhcpOptionsSetToVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachDhcpOptionsSetToVpcResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDhcpOptionsSetToVpcResponseBody(name='body'),
}

async function attachDhcpOptionsSetToVpcWithOptions(request: AttachDhcpOptionsSetToVpcRequest, runtime: Util.RuntimeOptions): AttachDhcpOptionsSetToVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AttachDhcpOptionsSetToVpc', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function attachDhcpOptionsSetToVpc(request: AttachDhcpOptionsSetToVpcRequest): AttachDhcpOptionsSetToVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDhcpOptionsSetToVpcWithOptions(request, runtime);
}

model AttachVbrToVpconnRequest {
  dryRun?: boolean(name='DryRun', description='DryRun'),
  regionId?: string(name='RegionId'),
  token?: string(name='Token', description='幂等Token'),
  vbrId?: string(name='VbrId', description='待迁移的vbr'),
  vpconnId?: string(name='VpconnId', description='迁移到目标vpconn'),
}

model AttachVbrToVpconnResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  virtualPhysicalConnection?: string(name='VirtualPhysicalConnection', description='Vpconn的实例ID'),
}

model AttachVbrToVpconnResponse = {
  headers: map[string]string(name='headers'),
  body: AttachVbrToVpconnResponseBody(name='body'),
}

async function attachVbrToVpconnWithOptions(request: AttachVbrToVpconnRequest, runtime: Util.RuntimeOptions): AttachVbrToVpconnResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AttachVbrToVpconn', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function attachVbrToVpconn(request: AttachVbrToVpconnRequest): AttachVbrToVpconnResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachVbrToVpconnWithOptions(request, runtime);
}

model CancelCommonBandwidthPackageIpBandwidthRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  eipId?: string(name='EipId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelCommonBandwidthPackageIpBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCommonBandwidthPackageIpBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: CancelCommonBandwidthPackageIpBandwidthResponseBody(name='body'),
}

async function cancelCommonBandwidthPackageIpBandwidthWithOptions(request: CancelCommonBandwidthPackageIpBandwidthRequest, runtime: Util.RuntimeOptions): CancelCommonBandwidthPackageIpBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelCommonBandwidthPackageIpBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelCommonBandwidthPackageIpBandwidth(request: CancelCommonBandwidthPackageIpBandwidthRequest): CancelCommonBandwidthPackageIpBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

model CancelExpressCloudConnectionRequest {
  eccId?: string(name='EccId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelExpressCloudConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelExpressCloudConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelExpressCloudConnectionResponseBody(name='body'),
}

async function cancelExpressCloudConnectionWithOptions(request: CancelExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): CancelExpressCloudConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelExpressCloudConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelExpressCloudConnection(request: CancelExpressCloudConnectionRequest): CancelExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelExpressCloudConnectionWithOptions(request, runtime);
}

model CancelPhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelPhysicalConnectionResponseBody(name='body'),
}

async function cancelPhysicalConnectionWithOptions(request: CancelPhysicalConnectionRequest, runtime: Util.RuntimeOptions): CancelPhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelPhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelPhysicalConnection(request: CancelPhysicalConnectionRequest): CancelPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelPhysicalConnectionWithOptions(request, runtime);
}

model CompletePhysicalConnectionLOARequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  lineCode?: string(name='LineCode'),
  lineLabel?: string(name='LineLabel'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CompletePhysicalConnectionLOAResponseBody = {
  requestId?: string(name='RequestId'),
}

model CompletePhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  body: CompletePhysicalConnectionLOAResponseBody(name='body'),
}

async function completePhysicalConnectionLOAWithOptions(request: CompletePhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): CompletePhysicalConnectionLOAResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CompletePhysicalConnectionLOA', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function completePhysicalConnectionLOA(request: CompletePhysicalConnectionLOARequest): CompletePhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return completePhysicalConnectionLOAWithOptions(request, runtime);
}

model ConfirmPhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ConfirmPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfirmPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmPhysicalConnectionResponseBody(name='body'),
}

async function confirmPhysicalConnectionWithOptions(request: ConfirmPhysicalConnectionRequest, runtime: Util.RuntimeOptions): ConfirmPhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConfirmPhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function confirmPhysicalConnection(request: ConfirmPhysicalConnectionRequest): ConfirmPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmPhysicalConnectionWithOptions(request, runtime);
}

model ConnectRouterInterfaceRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model ConnectRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConnectRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ConnectRouterInterfaceResponseBody(name='body'),
}

async function connectRouterInterfaceWithOptions(request: ConnectRouterInterfaceRequest, runtime: Util.RuntimeOptions): ConnectRouterInterfaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConnectRouterInterface', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function connectRouterInterface(request: ConnectRouterInterfaceRequest): ConnectRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return connectRouterInterfaceWithOptions(request, runtime);
}

model ConvertBandwidthPackageRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ConvertBandwidthPackageResponseBody = {
  convertInstanceId?: string(name='ConvertInstanceId'),
  requestId?: string(name='RequestId'),
}

model ConvertBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertBandwidthPackageResponseBody(name='body'),
}

async function convertBandwidthPackageWithOptions(request: ConvertBandwidthPackageRequest, runtime: Util.RuntimeOptions): ConvertBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConvertBandwidthPackage', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function convertBandwidthPackage(request: ConvertBandwidthPackageRequest): ConvertBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertBandwidthPackageWithOptions(request, runtime);
}

model CopyNetworkAclEntriesRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceNetworkAclId?: string(name='SourceNetworkAclId'),
}

model CopyNetworkAclEntriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model CopyNetworkAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: CopyNetworkAclEntriesResponseBody(name='body'),
}

async function copyNetworkAclEntriesWithOptions(request: CopyNetworkAclEntriesRequest, runtime: Util.RuntimeOptions): CopyNetworkAclEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CopyNetworkAclEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function copyNetworkAclEntries(request: CopyNetworkAclEntriesRequest): CopyNetworkAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyNetworkAclEntriesWithOptions(request, runtime);
}

model CreateBgpGroupRequest {
  authKey?: string(name='AuthKey'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipVersion?: string(name='IpVersion'),
  isFakeAsn?: boolean(name='IsFakeAsn'),
  localAsn?: long(name='LocalAsn'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerAsn?: long(name='PeerAsn'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model CreateBgpGroupResponseBody = {
  bgpGroupId?: string(name='BgpGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateBgpGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBgpGroupResponseBody(name='body'),
}

async function createBgpGroupWithOptions(request: CreateBgpGroupRequest, runtime: Util.RuntimeOptions): CreateBgpGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBgpGroup', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBgpGroup(request: CreateBgpGroupRequest): CreateBgpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBgpGroupWithOptions(request, runtime);
}

model CreateBgpPeerRequest {
  bfdMultiHop?: int32(name='BfdMultiHop'),
  bgpGroupId?: string(name='BgpGroupId'),
  clientToken?: string(name='ClientToken'),
  enableBfd?: boolean(name='EnableBfd'),
  ipVersion?: string(name='IpVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerIpAddress?: string(name='PeerIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateBgpPeerResponseBody = {
  bgpPeerId?: string(name='BgpPeerId'),
  requestId?: string(name='RequestId'),
}

model CreateBgpPeerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBgpPeerResponseBody(name='body'),
}

async function createBgpPeerWithOptions(request: CreateBgpPeerRequest, runtime: Util.RuntimeOptions): CreateBgpPeerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBgpPeer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBgpPeer(request: CreateBgpPeerRequest): CreateBgpPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBgpPeerWithOptions(request, runtime);
}

model CreateCommonBandwidthPackageRequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ISP?: string(name='ISP'),
  internetChargeType?: string(name='InternetChargeType'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  ratio?: int32(name='Ratio'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionTypes?: [ string ](name='SecurityProtectionTypes'),
  zone?: string(name='Zone'),
}

model CreateCommonBandwidthPackageResponseBody = {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateCommonBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCommonBandwidthPackageResponseBody(name='body'),
}

async function createCommonBandwidthPackageWithOptions(request: CreateCommonBandwidthPackageRequest, runtime: Util.RuntimeOptions): CreateCommonBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCommonBandwidthPackage', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCommonBandwidthPackage(request: CreateCommonBandwidthPackageRequest): CreateCommonBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCommonBandwidthPackageWithOptions(request, runtime);
}

model CreateCustomerGatewayRequest {
  asn?: string(name='Asn'),
  authKey?: string(name='AuthKey'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateCustomerGatewayResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model CreateCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCustomerGatewayResponseBody(name='body'),
}

async function createCustomerGatewayWithOptions(request: CreateCustomerGatewayRequest, runtime: Util.RuntimeOptions): CreateCustomerGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCustomerGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCustomerGateway(request: CreateCustomerGatewayRequest): CreateCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomerGatewayWithOptions(request, runtime);
}

model CreateDhcpOptionsSetRequest {
  bootFileName?: string(name='BootFileName'),
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  domainName?: string(name='DomainName'),
  domainNameServers?: string(name='DomainNameServers'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TFTPServerName?: string(name='TFTPServerName'),
}

model CreateDhcpOptionsSetResponseBody = {
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  requestId?: string(name='RequestId'),
}

model CreateDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDhcpOptionsSetResponseBody(name='body'),
}

async function createDhcpOptionsSetWithOptions(request: CreateDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): CreateDhcpOptionsSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateDhcpOptionsSet', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createDhcpOptionsSet(request: CreateDhcpOptionsSetRequest): CreateDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDhcpOptionsSetWithOptions(request, runtime);
}

model CreateExpressCloudConnectionRequest {
  bandwidth?: int32(name='Bandwidth'),
  contactMail?: string(name='ContactMail'),
  contactTel?: string(name='ContactTel'),
  description?: string(name='Description'),
  IDCardNo?: string(name='IDCardNo'),
  idcSP?: string(name='IdcSP'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerCity?: string(name='PeerCity'),
  peerLocation?: string(name='PeerLocation'),
  portType?: string(name='PortType'),
  redundantEccId?: string(name='RedundantEccId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateExpressCloudConnectionResponseBody = {
  eccId?: string(name='EccId'),
  requestId?: string(name='RequestId'),
}

model CreateExpressCloudConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExpressCloudConnectionResponseBody(name='body'),
}

async function createExpressCloudConnectionWithOptions(request: CreateExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): CreateExpressCloudConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateExpressCloudConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createExpressCloudConnection(request: CreateExpressCloudConnectionRequest): CreateExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExpressCloudConnectionWithOptions(request, runtime);
}

model CreateFlowLogRequest {
  description?: string(name='Description'),
  flowLogName?: string(name='FlowLogName'),
  logStoreName?: string(name='LogStoreName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  projectName?: string(name='ProjectName'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  trafficType?: string(name='TrafficType'),
}

model CreateFlowLogResponseBody = {
  flowLogId?: string(name='FlowLogId'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowLogResponseBody(name='body'),
}

async function createFlowLogWithOptions(request: CreateFlowLogRequest, runtime: Util.RuntimeOptions): CreateFlowLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlowLog', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlowLog(request: CreateFlowLogRequest): CreateFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowLogWithOptions(request, runtime);
}

model CreateForwardEntryRequest {
  clientToken?: string(name='ClientToken'),
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  forwardEntryName?: string(name='ForwardEntryName'),
  forwardTableId?: string(name='ForwardTableId'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  portBreak?: boolean(name='PortBreak'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateForwardEntryResponseBody = {
  forwardEntryId?: string(name='ForwardEntryId'),
  requestId?: string(name='RequestId'),
}

model CreateForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardEntryResponseBody(name='body'),
}

async function createForwardEntryWithOptions(request: CreateForwardEntryRequest, runtime: Util.RuntimeOptions): CreateForwardEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateForwardEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createForwardEntry(request: CreateForwardEntryRequest): CreateForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createForwardEntryWithOptions(request, runtime);
}

model CreateFullNatEntryRequest {
  accessIp?: string(name='AccessIp', description='需要进行转发的后端IP'),
  accessPort?: string(name='AccessPort', description='需要进行端口转发的内部端口，取值范围：1~65535。'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  fullNatEntryDescription?: string(name='FullNatEntryDescription'),
  fullNatEntryName?: string(name='FullNatEntryName', description='FULLNAT规则的名称。 长度为2~128个字符，必须以大小写字母或中文开头，但不能以http://或https://开头。'),
  fullNatTableId?: string(name='FullNatTableId', description='FullNAT条目所属的FullNAT列表的ID。'),
  ipProtocol?: string(name='IpProtocol', description='协议类型，取值： • TCP：转发TCP协议的报文。 • UDP：转发UDP协议的报文。'),
  natIp?: string(name='NatIp', description='提供入方向访问的IP地址，该公网IP需要是当前VpcNat下的NatIP'),
  natIpPort?: string(name='NatIpPort', description='需要进行端口转发的外部端口，取值范围：1~65535。'),
  networkInterfaceId?: string(name='NetworkInterfaceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateFullNatEntryResponseBody = {
  fullNatEntryId?: string(name='FullNatEntryId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateFullNatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFullNatEntryResponseBody(name='body'),
}

async function createFullNatEntryWithOptions(request: CreateFullNatEntryRequest, runtime: Util.RuntimeOptions): CreateFullNatEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFullNatEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFullNatEntry(request: CreateFullNatEntryRequest): CreateFullNatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFullNatEntryWithOptions(request, runtime);
}

model CreateGlobalAccelerationInstanceRequest {
  bandwidth?: string(name='Bandwidth'),
  bandwidthType?: string(name='BandwidthType'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceLocation?: string(name='ServiceLocation'),
}

model CreateGlobalAccelerationInstanceResponseBody = {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipAddress?: string(name='IpAddress'),
  requestId?: string(name='RequestId'),
}

model CreateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function createGlobalAccelerationInstanceWithOptions(request: CreateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): CreateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateGlobalAccelerationInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createGlobalAccelerationInstance(request: CreateGlobalAccelerationInstanceRequest): CreateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalAccelerationInstanceWithOptions(request, runtime);
}

model CreateHaVipRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateHaVipResponseBody = {
  haVipId?: string(name='HaVipId'),
  ipAddress?: string(name='IpAddress'),
  requestId?: string(name='RequestId'),
}

model CreateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHaVipResponseBody(name='body'),
}

async function createHaVipWithOptions(request: CreateHaVipRequest, runtime: Util.RuntimeOptions): CreateHaVipResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateHaVip', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createHaVip(request: CreateHaVipRequest): CreateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHaVipWithOptions(request, runtime);
}

model CreateIPv6TranslatorRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  duration?: int32(name='Duration'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
}

model CreateIPv6TranslatorResponseBody = {
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
}

model CreateIPv6TranslatorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIPv6TranslatorResponseBody(name='body'),
}

async function createIPv6TranslatorWithOptions(request: CreateIPv6TranslatorRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIPv6Translator', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIPv6Translator(request: CreateIPv6TranslatorRequest): CreateIPv6TranslatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorWithOptions(request, runtime);
}

model CreateIPv6TranslatorAclListRequest {
  aclName?: string(name='AclName'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateIPv6TranslatorAclListResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId'),
}

model CreateIPv6TranslatorAclListResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIPv6TranslatorAclListResponseBody(name='body'),
}

async function createIPv6TranslatorAclListWithOptions(request: CreateIPv6TranslatorAclListRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorAclListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIPv6TranslatorAclList', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIPv6TranslatorAclList(request: CreateIPv6TranslatorAclListRequest): CreateIPv6TranslatorAclListResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorAclListWithOptions(request, runtime);
}

model CreateIPv6TranslatorEntryRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: int32(name='BackendIpv4Port'),
  entryBandwidth?: int32(name='EntryBandwidth'),
  entryDescription?: string(name='EntryDescription'),
  entryName?: string(name='EntryName'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  transProtocol?: string(name='TransProtocol'),
}

model CreateIPv6TranslatorEntryResponseBody = {
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  requestId?: string(name='RequestId'),
}

model CreateIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIPv6TranslatorEntryResponseBody(name='body'),
}

async function createIPv6TranslatorEntryWithOptions(request: CreateIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIPv6TranslatorEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIPv6TranslatorEntry(request: CreateIPv6TranslatorEntryRequest): CreateIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorEntryWithOptions(request, runtime);
}

model CreateIpsecServerRequest {
  clientIpPool?: string(name='ClientIpPool'),
  clientToken?: string(name='ClientToken'),
  dryRun?: string(name='DryRun'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipSecServerName?: string(name='IpSecServerName'),
  ipsecConfig?: string(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  psk?: string(name='Psk'),
  pskEnabled?: boolean(name='PskEnabled'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateIpsecServerResponseBody = {
  creationTime?: string(name='CreationTime'),
  ipsecServerId?: string(name='IpsecServerId'),
  ipsecServerName?: string(name='IpsecServerName'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpsecServerResponseBody(name='body'),
}

async function createIpsecServerWithOptions(request: CreateIpsecServerRequest, runtime: Util.RuntimeOptions): CreateIpsecServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIpsecServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIpsecServer(request: CreateIpsecServerRequest): CreateIpsecServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpsecServerWithOptions(request, runtime);
}

model CreateIpv4GatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
  ipv4GatewayName?: string(name='Ipv4GatewayName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model CreateIpv4GatewayResponseBody = {
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv4GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpv4GatewayResponseBody(name='body'),
}

async function createIpv4GatewayWithOptions(request: CreateIpv4GatewayRequest, runtime: Util.RuntimeOptions): CreateIpv4GatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIpv4Gateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIpv4Gateway(request: CreateIpv4GatewayRequest): CreateIpv4GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv4GatewayWithOptions(request, runtime);
}

model CreateIpv6EgressOnlyRuleRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateIpv6EgressOnlyRuleResponseBody = {
  ipv6EgressRuleId?: string(name='Ipv6EgressRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv6EgressOnlyRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpv6EgressOnlyRuleResponseBody(name='body'),
}

async function createIpv6EgressOnlyRuleWithOptions(request: CreateIpv6EgressOnlyRuleRequest, runtime: Util.RuntimeOptions): CreateIpv6EgressOnlyRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIpv6EgressOnlyRule', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIpv6EgressOnlyRule(request: CreateIpv6EgressOnlyRuleRequest): CreateIpv6EgressOnlyRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv6EgressOnlyRuleWithOptions(request, runtime);
}

model CreateIpv6GatewayRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
  vpcId?: string(name='VpcId'),
}

model CreateIpv6GatewayResponseBody = {
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv6GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpv6GatewayResponseBody(name='body'),
}

async function createIpv6GatewayWithOptions(request: CreateIpv6GatewayRequest, runtime: Util.RuntimeOptions): CreateIpv6GatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIpv6Gateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIpv6Gateway(request: CreateIpv6GatewayRequest): CreateIpv6GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv6GatewayWithOptions(request, runtime);
}

model CreateNatGatewayRequest {
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  duration?: string(name='Duration'),
  icmpReplyEnabled?: boolean(name='IcmpReplyEnabled'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  name?: string(name='Name'),
  natType?: string(name='NatType'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled'),
  spec?: string(name='Spec'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateNatGatewayResponseBody = {
  forwardTableIds?: {
    forwardTableId?: [ string ](name='ForwardTableId')
  }(name='ForwardTableIds'),
  fullNatTableIds?: {
    fullNatTableId?: [ string ](name='FullNatTableId')
  }(name='FullNatTableIds'),
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId'),
  snatTableIds?: {
    snatTableId?: [ string ](name='SnatTableId')
  }(name='SnatTableIds'),
}

model CreateNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatGatewayResponseBody(name='body'),
}

async function createNatGatewayWithOptions(request: CreateNatGatewayRequest, runtime: Util.RuntimeOptions): CreateNatGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateNatGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createNatGateway(request: CreateNatGatewayRequest): CreateNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNatGatewayWithOptions(request, runtime);
}

model CreateNatIpRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natIp?: string(name='NatIp'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpCidrId?: string(name='NatIpCidrId'),
  natIpDescription?: string(name='NatIpDescription'),
  natIpName?: string(name='NatIpName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateNatIpResponseBody = {
  natIp?: string(name='NatIp'),
  natIpId?: string(name='NatIpId'),
  requestId?: string(name='RequestId'),
}

model CreateNatIpResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatIpResponseBody(name='body'),
}

async function createNatIpWithOptions(request: CreateNatIpRequest, runtime: Util.RuntimeOptions): CreateNatIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateNatIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createNatIp(request: CreateNatIpRequest): CreateNatIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNatIpWithOptions(request, runtime);
}

model CreateNatIpCidrRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpCidrDescription?: string(name='NatIpCidrDescription'),
  natIpCidrName?: string(name='NatIpCidrName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateNatIpCidrResponseBody = {
  natIpCidrId?: string(name='NatIpCidrId'),
  requestId?: string(name='RequestId'),
}

model CreateNatIpCidrResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatIpCidrResponseBody(name='body'),
}

async function createNatIpCidrWithOptions(request: CreateNatIpCidrRequest, runtime: Util.RuntimeOptions): CreateNatIpCidrResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateNatIpCidr', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createNatIpCidr(request: CreateNatIpCidrRequest): CreateNatIpCidrResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNatIpCidrWithOptions(request, runtime);
}

model CreateNetworkAclRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  networkAclName?: string(name='NetworkAclName'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model CreateNetworkAclResponseBody = {
  networkAclAttribute?: {
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    egressAclEntries?: {
      egressAclEntry?: [ 
      {
        description?: string(name='Description'),
        destinationCidrIp?: string(name='DestinationCidrIp'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
      }
    ](name='EgressAclEntry')
    }(name='EgressAclEntries'),
    ingressAclEntries?: {
      ingressAclEntry?: [ 
      {
        description?: string(name='Description'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
        sourceCidrIp?: string(name='SourceCidrIp'),
      }
    ](name='IngressAclEntry')
    }(name='IngressAclEntries'),
    networkAclId?: string(name='NetworkAclId'),
    networkAclName?: string(name='NetworkAclName'),
    regionId?: string(name='RegionId'),
    resources?: {
      resource?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        status?: string(name='Status'),
      }
    ](name='Resource')
    }(name='Resources'),
    status?: string(name='Status'),
    vpcId?: string(name='VpcId'),
  }(name='NetworkAclAttribute'),
  networkAclId?: string(name='NetworkAclId'),
  requestId?: string(name='RequestId'),
}

model CreateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkAclResponseBody(name='body'),
}

async function createNetworkAclWithOptions(request: CreateNetworkAclRequest, runtime: Util.RuntimeOptions): CreateNetworkAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateNetworkAcl', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createNetworkAcl(request: CreateNetworkAclRequest): CreateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNetworkAclWithOptions(request, runtime);
}

model CreatePhysicalConnectionRequest {
  accessPointId?: string(name='AccessPointId'),
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  lineOperator?: string(name='LineOperator'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerLocation?: string(name='PeerLocation'),
  portType?: string(name='PortType'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  type?: string(name='Type'),
  bandwidth?: int32(name='bandwidth'),
}

model CreatePhysicalConnectionResponseBody = {
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePhysicalConnectionResponseBody(name='body'),
}

async function createPhysicalConnectionWithOptions(request: CreatePhysicalConnectionRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreatePhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createPhysicalConnection(request: CreatePhysicalConnectionRequest): CreatePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionWithOptions(request, runtime);
}

model CreatePhysicalConnectionOccupancyOrderRequest {
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  instanceChargeType?: string(name='InstanceChargeType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreatePhysicalConnectionOccupancyOrderResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionOccupancyOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePhysicalConnectionOccupancyOrderResponseBody(name='body'),
}

async function createPhysicalConnectionOccupancyOrderWithOptions(request: CreatePhysicalConnectionOccupancyOrderRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionOccupancyOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreatePhysicalConnectionOccupancyOrder', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createPhysicalConnectionOccupancyOrder(request: CreatePhysicalConnectionOccupancyOrderRequest): CreatePhysicalConnectionOccupancyOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionOccupancyOrderWithOptions(request, runtime);
}

model CreatePhysicalConnectionSetupOrderRequest {
  accessPointId?: string(name='AccessPointId'),
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  lineOperator?: string(name='LineOperator'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  portType?: string(name='PortType'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreatePhysicalConnectionSetupOrderResponseBody = {
  orderId?: string(name='OrderId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionSetupOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePhysicalConnectionSetupOrderResponseBody(name='body'),
}

async function createPhysicalConnectionSetupOrderWithOptions(request: CreatePhysicalConnectionSetupOrderRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionSetupOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreatePhysicalConnectionSetupOrder', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createPhysicalConnectionSetupOrder(request: CreatePhysicalConnectionSetupOrderRequest): CreatePhysicalConnectionSetupOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionSetupOrderWithOptions(request, runtime);
}

model CreateRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  nextHopId?: string(name='NextHopId'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
      weight?: int32(name='Weight'),
    }
  ](name='NextHopList'),
  nextHopType?: string(name='NextHopType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryName?: string(name='RouteEntryName'),
  routeTableId?: string(name='RouteTableId'),
}

model CreateRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
  routeEntryId?: string(name='RouteEntryId'),
}

model CreateRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouteEntryResponseBody(name='body'),
}

async function createRouteEntryWithOptions(request: CreateRouteEntryRequest, runtime: Util.RuntimeOptions): CreateRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRouteEntry(request: CreateRouteEntryRequest): CreateRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouteEntryWithOptions(request, runtime);
}

model CreateRouteTableRequest {
  associateType?: string(name='AssociateType'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableName?: string(name='RouteTableName'),
  vpcId?: string(name='VpcId'),
}

model CreateRouteTableResponseBody = {
  associateType?: string(name='AssociateType'),
  requestId?: string(name='RequestId'),
  routeTableId?: string(name='RouteTableId'),
}

model CreateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouteTableResponseBody(name='body'),
}

async function createRouteTableWithOptions(request: CreateRouteTableRequest, runtime: Util.RuntimeOptions): CreateRouteTableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRouteTable', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRouteTable(request: CreateRouteTableRequest): CreateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouteTableWithOptions(request, runtime);
}

model CreateRouterInterfaceRequest {
  accessPointId?: string(name='AccessPointId'),
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  instanceChargeType?: string(name='InstanceChargeType'),
  name?: string(name='Name'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
  oppositeRegionId?: string(name='OppositeRegionId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  role?: string(name='Role'),
  routerId?: string(name='RouterId'),
  routerType?: string(name='RouterType'),
  spec?: string(name='Spec'),
}

model CreateRouterInterfaceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model CreateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouterInterfaceResponseBody(name='body'),
}

async function createRouterInterfaceWithOptions(request: CreateRouterInterfaceRequest, runtime: Util.RuntimeOptions): CreateRouterInterfaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateRouterInterface', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createRouterInterface(request: CreateRouterInterfaceRequest): CreateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouterInterfaceWithOptions(request, runtime);
}

model CreateSnatEntryRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snatEntryName?: string(name='SnatEntryName'),
  snatIp?: string(name='SnatIp'),
  snatTableId?: string(name='SnatTableId'),
  sourceCIDR?: string(name='SourceCIDR'),
  sourceVSwitchId?: string(name='SourceVSwitchId'),
}

model CreateSnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
  snatEntryId?: string(name='SnatEntryId'),
}

model CreateSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnatEntryResponseBody(name='body'),
}

async function createSnatEntryWithOptions(request: CreateSnatEntryRequest, runtime: Util.RuntimeOptions): CreateSnatEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSnatEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSnatEntry(request: CreateSnatEntryRequest): CreateSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSnatEntryWithOptions(request, runtime);
}

model CreateSslVpnClientCertRequest {
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model CreateSslVpnClientCertResponseBody = {
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model CreateSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSslVpnClientCertResponseBody(name='body'),
}

async function createSslVpnClientCertWithOptions(request: CreateSslVpnClientCertRequest, runtime: Util.RuntimeOptions): CreateSslVpnClientCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSslVpnClientCert', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSslVpnClientCert(request: CreateSslVpnClientCertRequest): CreateSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSslVpnClientCertWithOptions(request, runtime);
}

model CreateSslVpnServerRequest {
  cipher?: string(name='Cipher'),
  clientIpPool?: string(name='ClientIpPool'),
  clientToken?: string(name='ClientToken'),
  compress?: boolean(name='Compress'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
  IDaaSRegionId?: string(name='IDaaSRegionId'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: int32(name='Port'),
  proto?: string(name='Proto'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateSslVpnServerResponseBody = {
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model CreateSslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSslVpnServerResponseBody(name='body'),
}

async function createSslVpnServerWithOptions(request: CreateSslVpnServerRequest, runtime: Util.RuntimeOptions): CreateSslVpnServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSslVpnServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSslVpnServer(request: CreateSslVpnServerRequest): CreateSslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSslVpnServerWithOptions(request, runtime);
}

model CreateTrafficMirrorFilterRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  egressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='EgressRules'),
  ingressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='IngressRules'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterDescription?: string(name='TrafficMirrorFilterDescription'),
  trafficMirrorFilterName?: string(name='TrafficMirrorFilterName'),
}

model CreateTrafficMirrorFilterResponseBody = {
  requestId?: string(name='RequestId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
}

model CreateTrafficMirrorFilterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTrafficMirrorFilterResponseBody(name='body'),
}

async function createTrafficMirrorFilterWithOptions(request: CreateTrafficMirrorFilterRequest, runtime: Util.RuntimeOptions): CreateTrafficMirrorFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateTrafficMirrorFilter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createTrafficMirrorFilter(request: CreateTrafficMirrorFilterRequest): CreateTrafficMirrorFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTrafficMirrorFilterWithOptions(request, runtime);
}

model CreateTrafficMirrorFilterRulesRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  egressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='EgressRules'),
  ingressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='IngressRules'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
}

model CreateTrafficMirrorFilterRulesResponseBody = {
  egressRules?: [ 
    {
      instanceId?: string(name='InstanceId'),
    }
  ](name='EgressRules'),
  ingressRules?: [ 
    {
      instanceId?: string(name='InstanceId'),
    }
  ](name='IngressRules'),
  requestId?: string(name='RequestId'),
}

model CreateTrafficMirrorFilterRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTrafficMirrorFilterRulesResponseBody(name='body'),
}

async function createTrafficMirrorFilterRulesWithOptions(request: CreateTrafficMirrorFilterRulesRequest, runtime: Util.RuntimeOptions): CreateTrafficMirrorFilterRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateTrafficMirrorFilterRules', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createTrafficMirrorFilterRules(request: CreateTrafficMirrorFilterRulesRequest): CreateTrafficMirrorFilterRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTrafficMirrorFilterRulesWithOptions(request, runtime);
}

model CreateTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  enabled?: boolean(name='Enabled'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  packetLength?: int32(name='PacketLength'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorSessionDescription?: string(name='TrafficMirrorSessionDescription'),
  trafficMirrorSessionName?: string(name='TrafficMirrorSessionName'),
  trafficMirrorSourceIds?: [ string ](name='TrafficMirrorSourceIds'),
  trafficMirrorTargetId?: string(name='TrafficMirrorTargetId'),
  trafficMirrorTargetType?: string(name='TrafficMirrorTargetType'),
  virtualNetworkId?: int32(name='VirtualNetworkId'),
}

model CreateTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
}

model CreateTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTrafficMirrorSessionResponseBody(name='body'),
}

async function createTrafficMirrorSessionWithOptions(request: CreateTrafficMirrorSessionRequest, runtime: Util.RuntimeOptions): CreateTrafficMirrorSessionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateTrafficMirrorSession', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createTrafficMirrorSession(request: CreateTrafficMirrorSessionRequest): CreateTrafficMirrorSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTrafficMirrorSessionWithOptions(request, runtime);
}

model CreateVSwitchRequest {
  cidrBlock?: string(name='CidrBlock'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipv6CidrBlock?: int32(name='Ipv6CidrBlock'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchName?: string(name='VSwitchName'),
  vpcId?: string(name='VpcId'),
  vpcIpv6CidrBlock?: string(name='VpcIpv6CidrBlock'),
  zoneId?: string(name='ZoneId'),
}

model CreateVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVSwitchResponseBody(name='body'),
}

async function createVSwitchWithOptions(request: CreateVSwitchRequest, runtime: Util.RuntimeOptions): CreateVSwitchResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVSwitch', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVSwitch(request: CreateVSwitchRequest): CreateVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVSwitchWithOptions(request, runtime);
}

model CreateVbrHaRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerVbrId?: string(name='PeerVbrId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model CreateVbrHaResponseBody = {
  requestId?: string(name='RequestId'),
  vbrHaId?: string(name='VbrHaId'),
}

model CreateVbrHaResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVbrHaResponseBody(name='body'),
}

async function createVbrHaWithOptions(request: CreateVbrHaRequest, runtime: Util.RuntimeOptions): CreateVbrHaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVbrHa', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVbrHa(request: CreateVbrHaRequest): CreateVbrHaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVbrHaWithOptions(request, runtime);
}

model CreateVirtualBorderRouterRequest {
  bandwidth?: long(name='Bandwidth'),
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  enableIpv6?: boolean(name='EnableIpv6'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrOwnerId?: long(name='VbrOwnerId'),
  vlanId?: int32(name='VlanId'),
}

model CreateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
  vbrId?: string(name='VbrId'),
}

model CreateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualBorderRouterResponseBody(name='body'),
}

async function createVirtualBorderRouterWithOptions(request: CreateVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): CreateVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVirtualBorderRouter(request: CreateVirtualBorderRouterRequest): CreateVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualBorderRouterWithOptions(request, runtime);
}

model CreateVirtualPhysicalConnectionRequest {
  description?: string(name='Description', description='Vpconn的description'),
  dryRun?: boolean(name='DryRun', description='DryRun'),
  name?: string(name='Name', description='Vpconn的name'),
  orderMode?: string(name='OrderMode', description='vpconn的支付方'),
  physicalConnectionId?: string(name='PhysicalConnectionId', description='Vpconn的主Pconn'),
  regionId?: string(name='RegionId'),
  spec?: string(name='Spec', description='vpconn规格'),
  token?: string(name='Token', description='幂等Token'),
  vlanId?: long(name='VlanId', description='vpconn的VlanID'),
  vpconnAliUid?: long(name='VpconnAliUid', description='Vpconn拥有者'),
}

model CreateVirtualPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  virtualPhysicalConnection?: string(name='VirtualPhysicalConnection', description='Vpconn的实例ID'),
}

model CreateVirtualPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualPhysicalConnectionResponseBody(name='body'),
}

async function createVirtualPhysicalConnectionWithOptions(request: CreateVirtualPhysicalConnectionRequest, runtime: Util.RuntimeOptions): CreateVirtualPhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVirtualPhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVirtualPhysicalConnection(request: CreateVirtualPhysicalConnectionRequest): CreateVirtualPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualPhysicalConnectionWithOptions(request, runtime);
}

model CreateVpcRequest {
  cidrBlock?: string(name='CidrBlock'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  enableIpv6?: boolean(name='EnableIpv6'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  ipv6Isp?: string(name='Ipv6Isp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userCidr?: string(name='UserCidr'),
  vpcName?: string(name='VpcName'),
}

model CreateVpcResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  routeTableId?: string(name='RouteTableId'),
  VRouterId?: string(name='VRouterId'),
  vpcId?: string(name='VpcId'),
}

model CreateVpcResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcResponseBody(name='body'),
}

async function createVpcWithOptions(request: CreateVpcRequest, runtime: Util.RuntimeOptions): CreateVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpc', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpc(request: CreateVpcRequest): CreateVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcWithOptions(request, runtime);
}

model CreateVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken', description='幂等参数'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求'),
  endpointDescription?: string(name='EndpointDescription', description='网关节点描述'),
  endpointName?: string(name='EndpointName', description='网关节点名称'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  policyDocument?: string(name='PolicyDocument', description='访问云服务的权限控制策略'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceName?: string(name='ServiceName', description='网关节点服务的名称'),
  vpcId?: string(name='VpcId', description='专有网络实例ID'),
}

model CreateVpcGatewayEndpointResponseBody = {
  creationTime?: string(name='CreationTime'),
  endpointId?: string(name='EndpointId'),
  endpointName?: string(name='EndpointName'),
  requestId?: string(name='RequestId', description='Id of the request'),
  serviceName?: string(name='ServiceName'),
}

model CreateVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcGatewayEndpointResponseBody(name='body'),
}

async function createVpcGatewayEndpointWithOptions(request: CreateVpcGatewayEndpointRequest, runtime: Util.RuntimeOptions): CreateVpcGatewayEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpcGatewayEndpoint', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpcGatewayEndpoint(request: CreateVpcGatewayEndpointRequest): CreateVpcGatewayEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcGatewayEndpointWithOptions(request, runtime);
}

model CreateVpconnFromVbrRequest {
  dryRun?: boolean(name='DryRun', description='DryRun'),
  orderMode?: string(name='OrderMode', description='vpconn的支付方'),
  regionId?: string(name='RegionId'),
  token?: string(name='Token', description='幂等Token'),
  vbrId?: string(name='VbrId', description='跨帐号的VBR'),
}

model CreateVpconnFromVbrResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  virtualPhysicalConnection?: string(name='VirtualPhysicalConnection', description='Vpconn的实例ID'),
}

model CreateVpconnFromVbrResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpconnFromVbrResponseBody(name='body'),
}

async function createVpconnFromVbrWithOptions(request: CreateVpconnFromVbrRequest, runtime: Util.RuntimeOptions): CreateVpconnFromVbrResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpconnFromVbr', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpconnFromVbr(request: CreateVpconnFromVbrRequest): CreateVpconnFromVbrResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpconnFromVbrWithOptions(request, runtime);
}

model CreateVpnConnectionRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  bgpConfig?: string(name='BgpConfig'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
  remoteSubnet?: string(name='RemoteSubnet'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateVpnConnectionResponseBody = {
  createTime?: long(name='CreateTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model CreateVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnConnectionResponseBody(name='body'),
}

async function createVpnConnectionWithOptions(request: CreateVpnConnectionRequest, runtime: Util.RuntimeOptions): CreateVpnConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpnConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpnConnection(request: CreateVpnConnectionRequest): CreateVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnConnectionWithOptions(request, runtime);
}

model CreateVpnGatewayRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  enableIpsec?: boolean(name='EnableIpsec'),
  enableSsl?: boolean(name='EnableSsl'),
  instanceChargeType?: string(name='InstanceChargeType'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslConnections?: int32(name='SslConnections'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  vpnType?: string(name='VpnType'),
}

model CreateVpnGatewayResponseBody = {
  name?: string(name='Name'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnGatewayResponseBody(name='body'),
}

async function createVpnGatewayWithOptions(request: CreateVpnGatewayRequest, runtime: Util.RuntimeOptions): CreateVpnGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpnGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpnGateway(request: CreateVpnGatewayRequest): CreateVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnGatewayWithOptions(request, runtime);
}

model CreateVpnPbrRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publishVpc?: boolean(name='PublishVpc'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  routeSource?: string(name='RouteSource'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model CreateVpnPbrRouteEntryResponseBody = {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  requestId?: string(name='RequestId'),
  routeDest?: string(name='RouteDest'),
  routeSource?: string(name='RouteSource'),
  state?: string(name='State'),
  vpnInstanceId?: string(name='VpnInstanceId'),
  weight?: int32(name='Weight'),
}

model CreateVpnPbrRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnPbrRouteEntryResponseBody(name='body'),
}

async function createVpnPbrRouteEntryWithOptions(request: CreateVpnPbrRouteEntryRequest, runtime: Util.RuntimeOptions): CreateVpnPbrRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpnPbrRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpnPbrRouteEntry(request: CreateVpnPbrRouteEntryRequest): CreateVpnPbrRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnPbrRouteEntryWithOptions(request, runtime);
}

model CreateVpnRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publishVpc?: boolean(name='PublishVpc'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model CreateVpnRouteEntryResponseBody = {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  requestId?: string(name='RequestId'),
  routeDest?: string(name='RouteDest'),
  state?: string(name='State'),
  vpnInstanceId?: string(name='VpnInstanceId'),
  weight?: int32(name='Weight'),
}

model CreateVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnRouteEntryResponseBody(name='body'),
}

async function createVpnRouteEntryWithOptions(request: CreateVpnRouteEntryRequest, runtime: Util.RuntimeOptions): CreateVpnRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVpnRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVpnRouteEntry(request: CreateVpnRouteEntryRequest): CreateVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnRouteEntryWithOptions(request, runtime);
}

model DeactivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model DeactivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeactivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateRouterInterfaceResponseBody(name='body'),
}

async function deactivateRouterInterfaceWithOptions(request: DeactivateRouterInterfaceRequest, runtime: Util.RuntimeOptions): DeactivateRouterInterfaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeactivateRouterInterface', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deactivateRouterInterface(request: DeactivateRouterInterfaceRequest): DeactivateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactivateRouterInterfaceWithOptions(request, runtime);
}

model DeactiveFlowLogRequest {
  flowLogId?: string(name='FlowLogId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeactiveFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeactiveFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: DeactiveFlowLogResponseBody(name='body'),
}

async function deactiveFlowLogWithOptions(request: DeactiveFlowLogRequest, runtime: Util.RuntimeOptions): DeactiveFlowLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeactiveFlowLog', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deactiveFlowLog(request: DeactiveFlowLogRequest): DeactiveFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactiveFlowLogWithOptions(request, runtime);
}

model DeleteBgpGroupRequest {
  bgpGroupId?: string(name='BgpGroupId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteBgpGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBgpGroupResponseBody(name='body'),
}

async function deleteBgpGroupWithOptions(request: DeleteBgpGroupRequest, runtime: Util.RuntimeOptions): DeleteBgpGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBgpGroup', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBgpGroup(request: DeleteBgpGroupRequest): DeleteBgpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpGroupWithOptions(request, runtime);
}

model DeleteBgpNetworkRequest {
  clientToken?: string(name='ClientToken'),
  dstCidrBlock?: string(name='DstCidrBlock'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model DeleteBgpNetworkResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBgpNetworkResponseBody(name='body'),
}

async function deleteBgpNetworkWithOptions(request: DeleteBgpNetworkRequest, runtime: Util.RuntimeOptions): DeleteBgpNetworkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBgpNetwork', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBgpNetwork(request: DeleteBgpNetworkRequest): DeleteBgpNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpNetworkWithOptions(request, runtime);
}

model DeleteBgpPeerRequest {
  bgpPeerId?: string(name='BgpPeerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteBgpPeerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpPeerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBgpPeerResponseBody(name='body'),
}

async function deleteBgpPeerWithOptions(request: DeleteBgpPeerRequest, runtime: Util.RuntimeOptions): DeleteBgpPeerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBgpPeer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBgpPeer(request: DeleteBgpPeerRequest): DeleteBgpPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpPeerWithOptions(request, runtime);
}

model DeleteCommonBandwidthPackageRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  force?: string(name='Force'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteCommonBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCommonBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCommonBandwidthPackageResponseBody(name='body'),
}

async function deleteCommonBandwidthPackageWithOptions(request: DeleteCommonBandwidthPackageRequest, runtime: Util.RuntimeOptions): DeleteCommonBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCommonBandwidthPackage', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCommonBandwidthPackage(request: DeleteCommonBandwidthPackageRequest): DeleteCommonBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCommonBandwidthPackageWithOptions(request, runtime);
}

model DeleteCustomerGatewayRequest {
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteCustomerGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCustomerGatewayResponseBody(name='body'),
}

async function deleteCustomerGatewayWithOptions(request: DeleteCustomerGatewayRequest, runtime: Util.RuntimeOptions): DeleteCustomerGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCustomerGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCustomerGateway(request: DeleteCustomerGatewayRequest): DeleteCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomerGatewayWithOptions(request, runtime);
}

model DeleteDhcpOptionsSetRequest {
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDhcpOptionsSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDhcpOptionsSetResponseBody(name='body'),
}

async function deleteDhcpOptionsSetWithOptions(request: DeleteDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): DeleteDhcpOptionsSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteDhcpOptionsSet', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteDhcpOptionsSet(request: DeleteDhcpOptionsSetRequest): DeleteDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDhcpOptionsSetWithOptions(request, runtime);
}

model DeleteExpressCloudConnectionRequest {
  eccId?: string(name='EccId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteExpressCloudConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExpressCloudConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExpressCloudConnectionResponseBody(name='body'),
}

async function deleteExpressCloudConnectionWithOptions(request: DeleteExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): DeleteExpressCloudConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExpressCloudConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExpressCloudConnection(request: DeleteExpressCloudConnectionRequest): DeleteExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExpressCloudConnectionWithOptions(request, runtime);
}

model DeleteExpressConnectRequest {
  clientToken?: string(name='ClientToken'),
  force?: boolean(name='Force'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model DeleteExpressConnectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExpressConnectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExpressConnectResponseBody(name='body'),
}

async function deleteExpressConnectWithOptions(request: DeleteExpressConnectRequest, runtime: Util.RuntimeOptions): DeleteExpressConnectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExpressConnect', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExpressConnect(request: DeleteExpressConnectRequest): DeleteExpressConnectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExpressConnectWithOptions(request, runtime);
}

model DeleteFlowLogRequest {
  flowLogId?: string(name='FlowLogId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowLogResponseBody(name='body'),
}

async function deleteFlowLogWithOptions(request: DeleteFlowLogRequest, runtime: Util.RuntimeOptions): DeleteFlowLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFlowLog', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFlowLog(request: DeleteFlowLogRequest): DeleteFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowLogWithOptions(request, runtime);
}

model DeleteForwardEntryRequest {
  clientToken?: string(name='ClientToken'),
  forwardEntryId?: string(name='ForwardEntryId'),
  forwardTableId?: string(name='ForwardTableId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardEntryResponseBody(name='body'),
}

async function deleteForwardEntryWithOptions(request: DeleteForwardEntryRequest, runtime: Util.RuntimeOptions): DeleteForwardEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteForwardEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteForwardEntry(request: DeleteForwardEntryRequest): DeleteForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteForwardEntryWithOptions(request, runtime);
}

model DeleteFullNatEntryRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  fullNatEntryId?: string(name='FullNatEntryId', description='要修改的DNAT条目的ID。'),
  fullNatTableId?: string(name='FullNatTableId', description='FullNAT条目所属的FullNAT列表的ID。'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteFullNatEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteFullNatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFullNatEntryResponseBody(name='body'),
}

async function deleteFullNatEntryWithOptions(request: DeleteFullNatEntryRequest, runtime: Util.RuntimeOptions): DeleteFullNatEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFullNatEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFullNatEntry(request: DeleteFullNatEntryRequest): DeleteFullNatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFullNatEntryWithOptions(request, runtime);
}

model DeleteGlobalAccelerationInstanceRequest {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGlobalAccelerationInstanceResponseBody(name='body'),
}

async function deleteGlobalAccelerationInstanceWithOptions(request: DeleteGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): DeleteGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteGlobalAccelerationInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteGlobalAccelerationInstance(request: DeleteGlobalAccelerationInstanceRequest): DeleteGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalAccelerationInstanceWithOptions(request, runtime);
}

model DeleteHaVipRequest {
  clientToken?: string(name='ClientToken'),
  haVipId?: string(name='HaVipId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHaVipResponseBody(name='body'),
}

async function deleteHaVipWithOptions(request: DeleteHaVipRequest, runtime: Util.RuntimeOptions): DeleteHaVipResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteHaVip', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteHaVip(request: DeleteHaVipRequest): DeleteHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHaVipWithOptions(request, runtime);
}

model DeleteIPv6TranslatorRequest {
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIPv6TranslatorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIPv6TranslatorResponseBody(name='body'),
}

async function deleteIPv6TranslatorWithOptions(request: DeleteIPv6TranslatorRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIPv6Translator', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIPv6Translator(request: DeleteIPv6TranslatorRequest): DeleteIPv6TranslatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorWithOptions(request, runtime);
}

model DeleteIPv6TranslatorAclListRequest {
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIPv6TranslatorAclListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorAclListResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIPv6TranslatorAclListResponseBody(name='body'),
}

async function deleteIPv6TranslatorAclListWithOptions(request: DeleteIPv6TranslatorAclListRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorAclListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIPv6TranslatorAclList', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIPv6TranslatorAclList(request: DeleteIPv6TranslatorAclListRequest): DeleteIPv6TranslatorAclListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorAclListWithOptions(request, runtime);
}

model DeleteIPv6TranslatorEntryRequest {
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIPv6TranslatorEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIPv6TranslatorEntryResponseBody(name='body'),
}

async function deleteIPv6TranslatorEntryWithOptions(request: DeleteIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIPv6TranslatorEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIPv6TranslatorEntry(request: DeleteIPv6TranslatorEntryRequest): DeleteIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorEntryWithOptions(request, runtime);
}

model DeleteIpsecServerRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: string(name='DryRun'),
  ipsecServerId?: string(name='IpsecServerId'),
  regionId?: string(name='RegionId'),
}

model DeleteIpsecServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpsecServerResponseBody(name='body'),
}

async function deleteIpsecServerWithOptions(request: DeleteIpsecServerRequest, runtime: Util.RuntimeOptions): DeleteIpsecServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpsecServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpsecServer(request: DeleteIpsecServerRequest): DeleteIpsecServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpsecServerWithOptions(request, runtime);
}

model DeleteIpv4GatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpv4GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv4GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv4GatewayResponseBody(name='body'),
}

async function deleteIpv4GatewayWithOptions(request: DeleteIpv4GatewayRequest, runtime: Util.RuntimeOptions): DeleteIpv4GatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpv4Gateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpv4Gateway(request: DeleteIpv4GatewayRequest): DeleteIpv4GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv4GatewayWithOptions(request, runtime);
}

model DeleteIpv6EgressOnlyRuleRequest {
  clientToken?: string(name='ClientToken'),
  ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpv6EgressOnlyRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6EgressOnlyRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv6EgressOnlyRuleResponseBody(name='body'),
}

async function deleteIpv6EgressOnlyRuleWithOptions(request: DeleteIpv6EgressOnlyRuleRequest, runtime: Util.RuntimeOptions): DeleteIpv6EgressOnlyRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpv6EgressOnlyRule', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpv6EgressOnlyRule(request: DeleteIpv6EgressOnlyRuleRequest): DeleteIpv6EgressOnlyRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6EgressOnlyRuleWithOptions(request, runtime);
}

model DeleteIpv6GatewayRequest {
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpv6GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv6GatewayResponseBody(name='body'),
}

async function deleteIpv6GatewayWithOptions(request: DeleteIpv6GatewayRequest, runtime: Util.RuntimeOptions): DeleteIpv6GatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpv6Gateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpv6Gateway(request: DeleteIpv6GatewayRequest): DeleteIpv6GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6GatewayWithOptions(request, runtime);
}

model DeleteIpv6InternetBandwidthRequest {
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpv6InternetBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv6InternetBandwidthResponseBody(name='body'),
}

async function deleteIpv6InternetBandwidthWithOptions(request: DeleteIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): DeleteIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpv6InternetBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpv6InternetBandwidth(request: DeleteIpv6InternetBandwidthRequest): DeleteIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6InternetBandwidthWithOptions(request, runtime);
}

model DeleteNatGatewayRequest {
  force?: boolean(name='Force'),
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteNatGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatGatewayResponseBody(name='body'),
}

async function deleteNatGatewayWithOptions(request: DeleteNatGatewayRequest, runtime: Util.RuntimeOptions): DeleteNatGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNatGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNatGateway(request: DeleteNatGatewayRequest): DeleteNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNatGatewayWithOptions(request, runtime);
}

model DeleteNatIpRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natIpId?: string(name='NatIpId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteNatIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatIpResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatIpResponseBody(name='body'),
}

async function deleteNatIpWithOptions(request: DeleteNatIpRequest, runtime: Util.RuntimeOptions): DeleteNatIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNatIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNatIp(request: DeleteNatIpRequest): DeleteNatIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNatIpWithOptions(request, runtime);
}

model DeleteNatIpCidrRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteNatIpCidrResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatIpCidrResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatIpCidrResponseBody(name='body'),
}

async function deleteNatIpCidrWithOptions(request: DeleteNatIpCidrRequest, runtime: Util.RuntimeOptions): DeleteNatIpCidrResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNatIpCidr', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNatIpCidr(request: DeleteNatIpCidrRequest): DeleteNatIpCidrResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNatIpCidrWithOptions(request, runtime);
}

model DeleteNetworkAclRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkAclResponseBody(name='body'),
}

async function deleteNetworkAclWithOptions(request: DeleteNetworkAclRequest, runtime: Util.RuntimeOptions): DeleteNetworkAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteNetworkAcl', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteNetworkAcl(request: DeleteNetworkAclRequest): DeleteNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNetworkAclWithOptions(request, runtime);
}

model DeletePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeletePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePhysicalConnectionResponseBody(name='body'),
}

async function deletePhysicalConnectionWithOptions(request: DeletePhysicalConnectionRequest, runtime: Util.RuntimeOptions): DeletePhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeletePhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deletePhysicalConnection(request: DeletePhysicalConnectionRequest): DeletePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePhysicalConnectionWithOptions(request, runtime);
}

model DeleteRouteEntryRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  nextHopId?: string(name='NextHopId'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
    }
  ](name='NextHopList'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryId?: string(name='RouteEntryId'),
  routeTableId?: string(name='RouteTableId'),
}

model DeleteRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouteEntryResponseBody(name='body'),
}

async function deleteRouteEntryWithOptions(request: DeleteRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRouteEntry(request: DeleteRouteEntryRequest): DeleteRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouteEntryWithOptions(request, runtime);
}

model DeleteRouteTableRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
}

model DeleteRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouteTableResponseBody(name='body'),
}

async function deleteRouteTableWithOptions(request: DeleteRouteTableRequest, runtime: Util.RuntimeOptions): DeleteRouteTableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRouteTable', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRouteTable(request: DeleteRouteTableRequest): DeleteRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouteTableWithOptions(request, runtime);
}

model DeleteRouterInterfaceRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model DeleteRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouterInterfaceResponseBody(name='body'),
}

async function deleteRouterInterfaceWithOptions(request: DeleteRouterInterfaceRequest, runtime: Util.RuntimeOptions): DeleteRouterInterfaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteRouterInterface', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteRouterInterface(request: DeleteRouterInterfaceRequest): DeleteRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouterInterfaceWithOptions(request, runtime);
}

model DeleteSnatEntryRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snatEntryId?: string(name='SnatEntryId'),
  snatTableId?: string(name='SnatTableId'),
}

model DeleteSnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnatEntryResponseBody(name='body'),
}

async function deleteSnatEntryWithOptions(request: DeleteSnatEntryRequest, runtime: Util.RuntimeOptions): DeleteSnatEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSnatEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSnatEntry(request: DeleteSnatEntryRequest): DeleteSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSnatEntryWithOptions(request, runtime);
}

model DeleteSslVpnClientCertRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model DeleteSslVpnClientCertResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSslVpnClientCertResponseBody(name='body'),
}

async function deleteSslVpnClientCertWithOptions(request: DeleteSslVpnClientCertRequest, runtime: Util.RuntimeOptions): DeleteSslVpnClientCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSslVpnClientCert', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSslVpnClientCert(request: DeleteSslVpnClientCertRequest): DeleteSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSslVpnClientCertWithOptions(request, runtime);
}

model DeleteSslVpnServerRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model DeleteSslVpnServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSslVpnServerResponseBody(name='body'),
}

async function deleteSslVpnServerWithOptions(request: DeleteSslVpnServerRequest, runtime: Util.RuntimeOptions): DeleteSslVpnServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSslVpnServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSslVpnServer(request: DeleteSslVpnServerRequest): DeleteSslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSslVpnServerWithOptions(request, runtime);
}

model DeleteTrafficMirrorFilterRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
}

model DeleteTrafficMirrorFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTrafficMirrorFilterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTrafficMirrorFilterResponseBody(name='body'),
}

async function deleteTrafficMirrorFilterWithOptions(request: DeleteTrafficMirrorFilterRequest, runtime: Util.RuntimeOptions): DeleteTrafficMirrorFilterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTrafficMirrorFilter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTrafficMirrorFilter(request: DeleteTrafficMirrorFilterRequest): DeleteTrafficMirrorFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTrafficMirrorFilterWithOptions(request, runtime);
}

model DeleteTrafficMirrorFilterRulesRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorFilterRuleIds?: [ string ](name='TrafficMirrorFilterRuleIds'),
}

model DeleteTrafficMirrorFilterRulesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTrafficMirrorFilterRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTrafficMirrorFilterRulesResponseBody(name='body'),
}

async function deleteTrafficMirrorFilterRulesWithOptions(request: DeleteTrafficMirrorFilterRulesRequest, runtime: Util.RuntimeOptions): DeleteTrafficMirrorFilterRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTrafficMirrorFilterRules', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTrafficMirrorFilterRules(request: DeleteTrafficMirrorFilterRulesRequest): DeleteTrafficMirrorFilterRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTrafficMirrorFilterRulesWithOptions(request, runtime);
}

model DeleteTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
}

model DeleteTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTrafficMirrorSessionResponseBody(name='body'),
}

async function deleteTrafficMirrorSessionWithOptions(request: DeleteTrafficMirrorSessionRequest, runtime: Util.RuntimeOptions): DeleteTrafficMirrorSessionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTrafficMirrorSession', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTrafficMirrorSession(request: DeleteTrafficMirrorSessionRequest): DeleteTrafficMirrorSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTrafficMirrorSessionWithOptions(request, runtime);
}

model DeleteVSwitchRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model DeleteVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVSwitchResponseBody(name='body'),
}

async function deleteVSwitchWithOptions(request: DeleteVSwitchRequest, runtime: Util.RuntimeOptions): DeleteVSwitchResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVSwitch', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVSwitch(request: DeleteVSwitchRequest): DeleteVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVSwitchWithOptions(request, runtime);
}

model DeleteVbrHaRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteVbrHaResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVbrHaResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVbrHaResponseBody(name='body'),
}

async function deleteVbrHaWithOptions(request: DeleteVbrHaRequest, runtime: Util.RuntimeOptions): DeleteVbrHaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVbrHa', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVbrHa(request: DeleteVbrHaRequest): DeleteVbrHaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVbrHaWithOptions(request, runtime);
}

model DeleteVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model DeleteVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualBorderRouterResponseBody(name='body'),
}

async function deleteVirtualBorderRouterWithOptions(request: DeleteVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): DeleteVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVirtualBorderRouter(request: DeleteVirtualBorderRouterRequest): DeleteVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualBorderRouterWithOptions(request, runtime);
}

model DeleteVpcRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DeleteVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcResponseBody(name='body'),
}

async function deleteVpcWithOptions(request: DeleteVpcRequest, runtime: Util.RuntimeOptions): DeleteVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpc', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpc(request: DeleteVpcRequest): DeleteVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcWithOptions(request, runtime);
}

model DeleteVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken', description='幂等参数'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求'),
  endpointId?: string(name='EndpointId', description='VPC网关实例ID'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteVpcGatewayEndpointResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcGatewayEndpointResponseBody(name='body'),
}

async function deleteVpcGatewayEndpointWithOptions(request: DeleteVpcGatewayEndpointRequest, runtime: Util.RuntimeOptions): DeleteVpcGatewayEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpcGatewayEndpoint', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpcGatewayEndpoint(request: DeleteVpcGatewayEndpointRequest): DeleteVpcGatewayEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcGatewayEndpointWithOptions(request, runtime);
}

model DeleteVpnConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DeleteVpnConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnConnectionResponseBody(name='body'),
}

async function deleteVpnConnectionWithOptions(request: DeleteVpnConnectionRequest, runtime: Util.RuntimeOptions): DeleteVpnConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpnConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpnConnection(request: DeleteVpnConnectionRequest): DeleteVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnConnectionWithOptions(request, runtime);
}

model DeleteVpnGatewayRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DeleteVpnGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnGatewayResponseBody(name='body'),
}

async function deleteVpnGatewayWithOptions(request: DeleteVpnGatewayRequest, runtime: Util.RuntimeOptions): DeleteVpnGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpnGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpnGateway(request: DeleteVpnGatewayRequest): DeleteVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnGatewayWithOptions(request, runtime);
}

model DeleteVpnPbrRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  routeSource?: string(name='RouteSource'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model DeleteVpnPbrRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnPbrRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnPbrRouteEntryResponseBody(name='body'),
}

async function deleteVpnPbrRouteEntryWithOptions(request: DeleteVpnPbrRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteVpnPbrRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpnPbrRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpnPbrRouteEntry(request: DeleteVpnPbrRouteEntryRequest): DeleteVpnPbrRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnPbrRouteEntryWithOptions(request, runtime);
}

model DeleteVpnRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model DeleteVpnRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnRouteEntryResponseBody(name='body'),
}

async function deleteVpnRouteEntryWithOptions(request: DeleteVpnRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteVpnRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVpnRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVpnRouteEntry(request: DeleteVpnRouteEntryRequest): DeleteVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnRouteEntryWithOptions(request, runtime);
}

model DeletionProtectionRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  protectionEnable?: boolean(name='ProtectionEnable'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  type?: string(name='Type'),
}

model DeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletionProtectionResponseBody(name='body'),
}

async function deletionProtectionWithOptions(request: DeletionProtectionRequest, runtime: Util.RuntimeOptions): DeletionProtectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeletionProtection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deletionProtection(request: DeletionProtectionRequest): DeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletionProtectionWithOptions(request, runtime);
}

model DescribeAccessPointsRequest {
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccessPointsResponseBody = {
  accessPointSet?: {
    accessPointType?: [ 
    {
      accessPointFeatureModels?: {
        accessPointFeatureModel?: [ 
        {
          featureKey?: string(name='FeatureKey'),
          featureValue?: string(name='FeatureValue'),
        }
      ](name='AccessPointFeatureModel')
      }(name='AccessPointFeatureModels'),
      accessPointId?: string(name='AccessPointId'),
      attachedRegionNo?: string(name='AttachedRegionNo'),
      description?: string(name='Description'),
      hostOperator?: string(name='HostOperator'),
      location?: string(name='Location'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='AccessPointType')
  }(name='AccessPointSet'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAccessPointsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessPointsResponseBody(name='body'),
}

async function describeAccessPointsWithOptions(request: DescribeAccessPointsRequest, runtime: Util.RuntimeOptions): DescribeAccessPointsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAccessPoints', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAccessPoints(request: DescribeAccessPointsRequest): DescribeAccessPointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessPointsWithOptions(request, runtime);
}

model DescribeBgpGroupsRequest {
  bgpGroupId?: string(name='BgpGroupId'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model DescribeBgpGroupsResponseBody = {
  bgpGroups?: {
    bgpGroup?: [ 
    {
      authKey?: string(name='AuthKey'),
      bgpGroupId?: string(name='BgpGroupId'),
      description?: string(name='Description'),
      hold?: string(name='Hold'),
      ipVersion?: string(name='IpVersion'),
      isFake?: string(name='IsFake'),
      keepalive?: string(name='Keepalive'),
      localAsn?: string(name='LocalAsn'),
      name?: string(name='Name'),
      peerAsn?: string(name='PeerAsn'),
      regionId?: string(name='RegionId'),
      routeLimit?: string(name='RouteLimit'),
      routerId?: string(name='RouterId'),
      status?: string(name='Status'),
    }
  ](name='BgpGroup')
  }(name='BgpGroups'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBgpGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBgpGroupsResponseBody(name='body'),
}

async function describeBgpGroupsWithOptions(request: DescribeBgpGroupsRequest, runtime: Util.RuntimeOptions): DescribeBgpGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeBgpGroups', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeBgpGroups(request: DescribeBgpGroupsRequest): DescribeBgpGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpGroupsWithOptions(request, runtime);
}

model DescribeBgpNetworksRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model DescribeBgpNetworksResponseBody = {
  bgpNetworks?: {
    bgpNetwork?: [ 
    {
      dstCidrBlock?: string(name='DstCidrBlock'),
      routerId?: string(name='RouterId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='BgpNetwork')
  }(name='BgpNetworks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBgpNetworksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBgpNetworksResponseBody(name='body'),
}

async function describeBgpNetworksWithOptions(request: DescribeBgpNetworksRequest, runtime: Util.RuntimeOptions): DescribeBgpNetworksResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeBgpNetworks', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeBgpNetworks(request: DescribeBgpNetworksRequest): DescribeBgpNetworksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpNetworksWithOptions(request, runtime);
}

model DescribeBgpPeersRequest {
  bgpGroupId?: string(name='BgpGroupId'),
  bgpPeerId?: string(name='BgpPeerId'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model DescribeBgpPeersResponseBody = {
  bgpPeers?: {
    bgpPeer?: [ 
    {
      authKey?: string(name='AuthKey'),
      bfdMultiHop?: int32(name='BfdMultiHop'),
      bgpGroupId?: string(name='BgpGroupId'),
      bgpPeerId?: string(name='BgpPeerId'),
      bgpStatus?: string(name='BgpStatus'),
      description?: string(name='Description'),
      enableBfd?: boolean(name='EnableBfd'),
      hold?: string(name='Hold'),
      ipVersion?: string(name='IpVersion'),
      isFake?: string(name='IsFake'),
      keepalive?: string(name='Keepalive'),
      localAsn?: string(name='LocalAsn'),
      name?: string(name='Name'),
      peerAsn?: string(name='PeerAsn'),
      peerIpAddress?: string(name='PeerIpAddress'),
      regionId?: string(name='RegionId'),
      routeLimit?: string(name='RouteLimit'),
      routerId?: string(name='RouterId'),
      status?: string(name='Status'),
    }
  ](name='BgpPeer')
  }(name='BgpPeers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBgpPeersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBgpPeersResponseBody(name='body'),
}

async function describeBgpPeersWithOptions(request: DescribeBgpPeersRequest, runtime: Util.RuntimeOptions): DescribeBgpPeersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeBgpPeers', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeBgpPeers(request: DescribeBgpPeersRequest): DescribeBgpPeersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpPeersWithOptions(request, runtime);
}

model DescribeCommonBandwidthPackagesRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  dryRun?: boolean(name='DryRun'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled', description='是否开启安全防护'),
}

model DescribeCommonBandwidthPackagesResponseBody = {
  commonBandwidthPackages?: {
    commonBandwidthPackage?: [ 
    {
      bandwidth?: string(name='Bandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      deletionProtection?: boolean(name='DeletionProtection'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      hasReservationData?: string(name='HasReservationData'),
      ISP?: string(name='ISP'),
      instanceChargeType?: string(name='InstanceChargeType'),
      internetChargeType?: string(name='InternetChargeType'),
      name?: string(name='Name'),
      publicIpAddresses?: {
        publicIpAddresse?: [ 
        {
          allocationId?: string(name='AllocationId'),
          bandwidthPackageIpRelationStatus?: string(name='BandwidthPackageIpRelationStatus'),
          ipAddress?: string(name='IpAddress'),
        }
      ](name='PublicIpAddresse')
      }(name='PublicIpAddresses'),
      ratio?: int32(name='Ratio'),
      regionId?: string(name='RegionId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityProtectionTypes?: {
        securityProtectionType?: [ string ](name='SecurityProtectionType')
      }(name='SecurityProtectionTypes'),
      serviceManaged?: int32(name='ServiceManaged'),
      status?: string(name='Status'),
    }
  ](name='CommonBandwidthPackage')
  }(name='CommonBandwidthPackages'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCommonBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCommonBandwidthPackagesResponseBody(name='body'),
}

async function describeCommonBandwidthPackagesWithOptions(request: DescribeCommonBandwidthPackagesRequest, runtime: Util.RuntimeOptions): DescribeCommonBandwidthPackagesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCommonBandwidthPackages', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCommonBandwidthPackages(request: DescribeCommonBandwidthPackagesRequest): DescribeCommonBandwidthPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonBandwidthPackagesWithOptions(request, runtime);
}

model DescribeCustomerGatewayRequest {
  customerGatewayId?: string(name='CustomerGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCustomerGatewayResponseBody = {
  asn?: long(name='Asn'),
  authKey?: string(name='AuthKey'),
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model DescribeCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomerGatewayResponseBody(name='body'),
}

async function describeCustomerGatewayWithOptions(request: DescribeCustomerGatewayRequest, runtime: Util.RuntimeOptions): DescribeCustomerGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCustomerGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCustomerGateway(request: DescribeCustomerGatewayRequest): DescribeCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomerGatewayWithOptions(request, runtime);
}

model DescribeCustomerGatewaysRequest {
  customerGatewayId?: string(name='CustomerGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCustomerGatewaysResponseBody = {
  customerGateways?: {
    customerGateway?: [ 
    {
      asn?: long(name='Asn'),
      authKey?: string(name='AuthKey'),
      createTime?: long(name='CreateTime'),
      customerGatewayId?: string(name='CustomerGatewayId'),
      description?: string(name='Description'),
      ipAddress?: string(name='IpAddress'),
      name?: string(name='Name'),
    }
  ](name='CustomerGateway')
  }(name='CustomerGateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCustomerGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomerGatewaysResponseBody(name='body'),
}

async function describeCustomerGatewaysWithOptions(request: DescribeCustomerGatewaysRequest, runtime: Util.RuntimeOptions): DescribeCustomerGatewaysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCustomerGateways', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCustomerGateways(request: DescribeCustomerGatewaysRequest): DescribeCustomerGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomerGatewaysWithOptions(request, runtime);
}

model DescribeEipAddressesRequest {
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter'),
  allocationId?: string(name='AllocationId'),
  associatedInstanceId?: string(name='AssociatedInstanceId'),
  associatedInstanceType?: string(name='AssociatedInstanceType'),
  chargeType?: string(name='ChargeType'),
  dryRun?: boolean(name='DryRun'),
  eipAddress?: string(name='EipAddress'),
  eipName?: string(name='EipName'),
  ISP?: string(name='ISP'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  lockReason?: string(name='LockReason'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled', description='是否开启安全防护'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
  status?: string(name='Status'),
}

model DescribeEipAddressesResponseBody = {
  eipAddresses?: {
    eipAddress?: [ 
    {
      allocationId?: string(name='AllocationId'),
      allocationTime?: string(name='AllocationTime'),
      availableRegions?: {
        availableRegion?: [ string ](name='AvailableRegion')
      }(name='AvailableRegions'),
      bandwidth?: string(name='Bandwidth'),
      bandwidthPackageBandwidth?: string(name='BandwidthPackageBandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidthPackageType?: string(name='BandwidthPackageType'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      deletionProtection?: boolean(name='DeletionProtection'),
      descritpion?: string(name='Descritpion'),
      eipBandwidth?: string(name='EipBandwidth'),
      expiredTime?: string(name='ExpiredTime'),
      HDMonitorStatus?: string(name='HDMonitorStatus'),
      hasReservationData?: string(name='HasReservationData'),
      ISP?: string(name='ISP'),
      instanceId?: string(name='InstanceId'),
      instanceRegionId?: string(name='InstanceRegionId'),
      instanceType?: string(name='InstanceType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipAddress?: string(name='IpAddress'),
      name?: string(name='Name'),
      netmode?: string(name='Netmode'),
      operationLocks?: {
        lockReason?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='LockReason')
      }(name='OperationLocks'),
      regionId?: string(name='RegionId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      secondLimited?: boolean(name='SecondLimited'),
      securityProtectionTypes?: {
        securityProtectionType?: [ string ](name='SecurityProtectionType')
      }(name='SecurityProtectionTypes'),
      segmentInstanceId?: string(name='SegmentInstanceId'),
      serviceManaged?: int32(name='ServiceManaged'),
      status?: string(name='Status'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipAddressesResponseBody(name='body'),
}

async function describeEipAddressesWithOptions(request: DescribeEipAddressesRequest, runtime: Util.RuntimeOptions): DescribeEipAddressesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEipAddresses', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEipAddresses(request: DescribeEipAddressesRequest): DescribeEipAddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipAddressesWithOptions(request, runtime);
}

model DescribeEipGatewayInfoRequest {
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeEipGatewayInfoResponseBody = {
  code?: string(name='Code'),
  eipInfos?: {
    eipInfo?: [ 
    {
      ip?: string(name='Ip'),
      ipGw?: string(name='IpGw'),
      ipMask?: string(name='IpMask'),
    }
  ](name='EipInfo')
  }(name='EipInfos'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeEipGatewayInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipGatewayInfoResponseBody(name='body'),
}

async function describeEipGatewayInfoWithOptions(request: DescribeEipGatewayInfoRequest, runtime: Util.RuntimeOptions): DescribeEipGatewayInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEipGatewayInfo', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEipGatewayInfo(request: DescribeEipGatewayInfoRequest): DescribeEipGatewayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipGatewayInfoWithOptions(request, runtime);
}

model DescribeEipMonitorDataRequest {
  allocationId?: string(name='AllocationId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeEipMonitorDataResponseBody = {
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipBandwidth?: int32(name='EipBandwidth'),
      eipFlow?: int32(name='EipFlow'),
      eipPackets?: int32(name='EipPackets'),
      eipRX?: long(name='EipRX'),
      eipTX?: long(name='EipTX'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipMonitorDataResponseBody(name='body'),
}

async function describeEipMonitorDataWithOptions(request: DescribeEipMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeEipMonitorDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEipMonitorData', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEipMonitorData(request: DescribeEipMonitorDataRequest): DescribeEipMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipMonitorDataWithOptions(request, runtime);
}

model DescribeEipSegmentRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
}

model DescribeEipSegmentResponseBody = {
  eipSegments?: {
    eipSegment?: [ 
    {
      creationTime?: string(name='CreationTime'),
      descritpion?: string(name='Descritpion'),
      instanceId?: string(name='InstanceId'),
      ipCount?: string(name='IpCount'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      segment?: string(name='Segment'),
      status?: string(name='Status'),
    }
  ](name='EipSegment')
  }(name='EipSegments'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEipSegmentResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipSegmentResponseBody(name='body'),
}

async function describeEipSegmentWithOptions(request: DescribeEipSegmentRequest, runtime: Util.RuntimeOptions): DescribeEipSegmentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEipSegment', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEipSegment(request: DescribeEipSegmentRequest): DescribeEipSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipSegmentWithOptions(request, runtime);
}

model DescribeExpressCloudConnectionsRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeExpressCloudConnectionsResponseBody = {
  expressCloudConnectionSet?: {
    expressCloudConnectionType?: [ 
    {
      applicationBandwidth?: string(name='ApplicationBandwidth'),
      applicationId?: string(name='ApplicationId'),
      applicationStatus?: string(name='ApplicationStatus'),
      applicationType?: string(name='ApplicationType'),
      bandwidth?: int32(name='Bandwidth'),
      bgpAs?: string(name='BgpAs'),
      businessStatus?: string(name='BusinessStatus'),
      ceIp?: string(name='CeIp'),
      chargeType?: string(name='ChargeType'),
      circuitCode?: string(name='CircuitCode'),
      constructionPeriod?: string(name='ConstructionPeriod'),
      contactMail?: string(name='ContactMail'),
      contactTel?: string(name='ContactTel'),
      description?: string(name='Description'),
      distance?: int32(name='Distance'),
      endTime?: string(name='EndTime'),
      estimatedTime?: string(name='EstimatedTime'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModify?: string(name='GmtModify'),
      hasReservationData?: string(name='HasReservationData'),
      IDCardNo?: string(name='IDCardNo'),
      idcSP?: string(name='IdcSP'),
      instanceId?: string(name='InstanceId'),
      isp?: string(name='Isp'),
      name?: string(name='Name'),
      peIp?: string(name='PeIp'),
      peerCity?: string(name='PeerCity'),
      peerLocation?: string(name='PeerLocation'),
      portType?: string(name='PortType'),
      redundantEccId?: string(name='RedundantEccId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      virtualBorderRouterModels?: {
        virtualBorderRouterModel?: [ 
        {
          accessPointId?: string(name='AccessPointId'),
          instanceId?: string(name='InstanceId'),
          physicalConnectionId?: string(name='PhysicalConnectionId'),
        }
      ](name='VirtualBorderRouterModel')
      }(name='VirtualBorderRouterModels'),
    }
  ](name='ExpressCloudConnectionType')
  }(name='ExpressCloudConnectionSet'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeExpressCloudConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExpressCloudConnectionsResponseBody(name='body'),
}

async function describeExpressCloudConnectionsWithOptions(request: DescribeExpressCloudConnectionsRequest, runtime: Util.RuntimeOptions): DescribeExpressCloudConnectionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeExpressCloudConnections', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeExpressCloudConnections(request: DescribeExpressCloudConnectionsRequest): DescribeExpressCloudConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExpressCloudConnectionsWithOptions(request, runtime);
}

model DescribeFlowLogsRequest {
  description?: string(name='Description'),
  flowLogId?: string(name='FlowLogId'),
  flowLogName?: string(name='FlowLogName'),
  logStoreName?: string(name='LogStoreName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectName?: string(name='ProjectName'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  trafficType?: string(name='TrafficType'),
  vpcId?: string(name='VpcId'),
}

model DescribeFlowLogsResponseBody = {
  flowLogs?: {
    flowLog?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      flowLogId?: string(name='FlowLogId'),
      flowLogName?: string(name='FlowLogName'),
      logStoreName?: string(name='LogStoreName'),
      projectName?: string(name='ProjectName'),
      regionId?: string(name='RegionId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      status?: string(name='Status'),
      trafficType?: string(name='TrafficType'),
    }
  ](name='FlowLog')
  }(name='FlowLogs'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  totalCount?: string(name='TotalCount'),
}

model DescribeFlowLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowLogsResponseBody(name='body'),
}

async function describeFlowLogsWithOptions(request: DescribeFlowLogsRequest, runtime: Util.RuntimeOptions): DescribeFlowLogsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowLogs', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowLogs(request: DescribeFlowLogsRequest): DescribeFlowLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowLogsWithOptions(request, runtime);
}

model DescribeForwardTableEntriesRequest {
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  forwardEntryId?: string(name='ForwardEntryId'),
  forwardEntryName?: string(name='ForwardEntryName'),
  forwardTableId?: string(name='ForwardTableId'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeForwardTableEntriesResponseBody = {
  forwardTableEntries?: {
    forwardTableEntry?: [ 
    {
      externalIp?: string(name='ExternalIp'),
      externalPort?: string(name='ExternalPort'),
      forwardEntryId?: string(name='ForwardEntryId'),
      forwardEntryName?: string(name='ForwardEntryName'),
      forwardTableId?: string(name='ForwardTableId'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      ipProtocol?: string(name='IpProtocol'),
      status?: string(name='Status'),
    }
  ](name='ForwardTableEntry')
  }(name='ForwardTableEntries'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeForwardTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeForwardTableEntriesResponseBody(name='body'),
}

async function describeForwardTableEntriesWithOptions(request: DescribeForwardTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeForwardTableEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeForwardTableEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): DescribeForwardTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeForwardTableEntriesWithOptions(request, runtime);
}

model DescribeGlobalAccelerationInstancesRequest {
  bandwidthType?: string(name='BandwidthType'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverId?: string(name='ServerId'),
  serviceLocation?: string(name='ServiceLocation'),
  status?: string(name='Status'),
}

model DescribeGlobalAccelerationInstancesResponseBody = {
  globalAccelerationInstances?: {
    globalAccelerationInstance?: [ 
    {
      accelerationLocation?: string(name='AccelerationLocation'),
      backendServers?: {
        backendServer?: [ 
        {
          regionId?: string(name='RegionId'),
          serverId?: string(name='ServerId'),
          serverIpAddress?: string(name='ServerIpAddress'),
          serverType?: string(name='ServerType'),
        }
      ](name='BackendServer')
      }(name='BackendServers'),
      bandwidth?: string(name='Bandwidth'),
      bandwidthType?: string(name='BandwidthType'),
      chargeType?: string(name='ChargeType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
      internetChargeType?: string(name='InternetChargeType'),
      ipAddress?: string(name='IpAddress'),
      name?: string(name='Name'),
      publicIpAddresses?: {
        publicIpAddress?: [ 
        {
          allocationId?: string(name='AllocationId'),
          ipAddress?: string(name='IpAddress'),
        }
      ](name='PublicIpAddress')
      }(name='PublicIpAddresses'),
      regionId?: string(name='RegionId'),
      serviceLocation?: string(name='ServiceLocation'),
      status?: string(name='Status'),
    }
  ](name='GlobalAccelerationInstance')
  }(name='GlobalAccelerationInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGlobalAccelerationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGlobalAccelerationInstancesResponseBody(name='body'),
}

async function describeGlobalAccelerationInstancesWithOptions(request: DescribeGlobalAccelerationInstancesRequest, runtime: Util.RuntimeOptions): DescribeGlobalAccelerationInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGlobalAccelerationInstances', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGlobalAccelerationInstances(request: DescribeGlobalAccelerationInstancesRequest): DescribeGlobalAccelerationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalAccelerationInstancesWithOptions(request, runtime);
}

model DescribeGrantRulesToCenRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeGrantRulesToCenResponseBody = {
  cenGrantRules?: {
    cbnGrantRule?: [ 
    {
      cenInstanceId?: string(name='CenInstanceId'),
      cenOwnerId?: long(name='CenOwnerId'),
      creationTime?: string(name='CreationTime'),
    }
  ](name='CbnGrantRule')
  }(name='CenGrantRules'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGrantRulesToCenResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGrantRulesToCenResponseBody(name='body'),
}

async function describeGrantRulesToCenWithOptions(request: DescribeGrantRulesToCenRequest, runtime: Util.RuntimeOptions): DescribeGrantRulesToCenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGrantRulesToCen', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGrantRulesToCen(request: DescribeGrantRulesToCenRequest): DescribeGrantRulesToCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGrantRulesToCenWithOptions(request, runtime);
}

model DescribeHaVipsRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeHaVipsResponseBody = {
  haVips?: {
    haVip?: [ 
    {
      associatedEipAddresses?: {
        associatedEipAddresse?: [ string ](name='associatedEipAddresse')
      }(name='AssociatedEipAddresses'),
      associatedInstanceType?: string(name='AssociatedInstanceType'),
      associatedInstances?: {
        associatedInstance?: [ string ](name='associatedInstance')
      }(name='AssociatedInstances'),
      chargeType?: string(name='ChargeType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      haVipId?: string(name='HaVipId'),
      ipAddress?: string(name='IpAddress'),
      masterInstanceId?: string(name='MasterInstanceId'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='HaVip')
  }(name='HaVips'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeHaVipsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHaVipsResponseBody(name='body'),
}

async function describeHaVipsWithOptions(request: DescribeHaVipsRequest, runtime: Util.RuntimeOptions): DescribeHaVipsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeHaVips', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeHaVips(request: DescribeHaVipsRequest): DescribeHaVipsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHaVipsWithOptions(request, runtime);
}

model DescribeHighDefinitionMonitorLogAttributeRequest {
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeHighDefinitionMonitorLogAttributeResponseBody = {
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  logProject?: string(name='LogProject'),
  logStore?: string(name='LogStore'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeHighDefinitionMonitorLogAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHighDefinitionMonitorLogAttributeResponseBody(name='body'),
}

async function describeHighDefinitionMonitorLogAttributeWithOptions(request: DescribeHighDefinitionMonitorLogAttributeRequest, runtime: Util.RuntimeOptions): DescribeHighDefinitionMonitorLogAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeHighDefinitionMonitorLogAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeHighDefinitionMonitorLogAttribute(request: DescribeHighDefinitionMonitorLogAttributeRequest): DescribeHighDefinitionMonitorLogAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHighDefinitionMonitorLogAttributeWithOptions(request, runtime);
}

model DescribeIPv6TranslatorAclListAttributesRequest {
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeIPv6TranslatorAclListAttributesResponseBody = {
  aclEntries?: {
    aclEntry?: [ 
    {
      aclEntryComment?: string(name='AclEntryComment'),
      aclEntryId?: string(name='AclEntryId'),
      aclEntryIp?: string(name='AclEntryIp'),
    }
  ](name='AclEntry')
  }(name='AclEntries'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorAclListAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorAclListAttributesResponseBody(name='body'),
}

async function describeIPv6TranslatorAclListAttributesWithOptions(request: DescribeIPv6TranslatorAclListAttributesRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorAclListAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIPv6TranslatorAclListAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIPv6TranslatorAclListAttributes(request: DescribeIPv6TranslatorAclListAttributesRequest): DescribeIPv6TranslatorAclListAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorAclListAttributesWithOptions(request, runtime);
}

model DescribeIPv6TranslatorAclListsRequest {
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeIPv6TranslatorAclListsResponseBody = {
  ipv6TranslatorAcls?: {
    IPv6TranslatorAcl?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
    }
  ](name='IPv6TranslatorAcl')
  }(name='Ipv6TranslatorAcls'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorAclListsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorAclListsResponseBody(name='body'),
}

async function describeIPv6TranslatorAclListsWithOptions(request: DescribeIPv6TranslatorAclListsRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorAclListsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIPv6TranslatorAclLists', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIPv6TranslatorAclLists(request: DescribeIPv6TranslatorAclListsRequest): DescribeIPv6TranslatorAclListsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorAclListsWithOptions(request, runtime);
}

model DescribeIPv6TranslatorEntriesRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: int32(name='BackendIpv4Port'),
  clientToken?: string(name='ClientToken'),
  entryName?: string(name='EntryName'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  transProtocol?: string(name='TransProtocol'),
}

model DescribeIPv6TranslatorEntriesResponseBody = {
  ipv6TranslatorEntries?: {
    ipv6TranslatorEntry?: [ 
    {
      aclId?: string(name='AclId'),
      aclStatus?: string(name='AclStatus'),
      aclType?: string(name='AclType'),
      allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
      allocateIpv6Port?: int32(name='AllocateIpv6Port'),
      backendIpv4Addr?: string(name='BackendIpv4Addr'),
      backendIpv4Port?: string(name='BackendIpv4Port'),
      entryBandwidth?: string(name='EntryBandwidth'),
      entryDescription?: string(name='EntryDescription'),
      entryName?: string(name='EntryName'),
      entryStatus?: string(name='EntryStatus'),
      ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
      ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
      regionId?: string(name='RegionId'),
      transProtocol?: string(name='TransProtocol'),
    }
  ](name='Ipv6TranslatorEntry')
  }(name='Ipv6TranslatorEntries'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorEntriesResponseBody(name='body'),
}

async function describeIPv6TranslatorEntriesWithOptions(request: DescribeIPv6TranslatorEntriesRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIPv6TranslatorEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIPv6TranslatorEntries(request: DescribeIPv6TranslatorEntriesRequest): DescribeIPv6TranslatorEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorEntriesWithOptions(request, runtime);
}

model DescribeIPv6TranslatorsRequest {
  allocateIpv4Addr?: string(name='AllocateIpv4Addr'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
  businessStatus?: string(name='BusinessStatus'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
}

model DescribeIPv6TranslatorsResponseBody = {
  ipv6Translators?: {
    ipv6Translator?: [ 
    {
      allocateIpv4Addr?: string(name='AllocateIpv4Addr'),
      allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
      availableBandwidth?: string(name='AvailableBandwidth'),
      bandwidth?: int32(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      endTime?: long(name='EndTime'),
      ipv6TranslatorEntryIds?: {
        ipv6TranslatorEntryId?: [ string ](name='Ipv6TranslatorEntryId')
      }(name='Ipv6TranslatorEntryIds'),
      ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
      name?: string(name='Name'),
      payType?: string(name='PayType'),
      regionId?: string(name='RegionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
    }
  ](name='Ipv6Translator')
  }(name='Ipv6Translators'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorsResponseBody(name='body'),
}

async function describeIPv6TranslatorsWithOptions(request: DescribeIPv6TranslatorsRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIPv6Translators', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIPv6Translators(request: DescribeIPv6TranslatorsRequest): DescribeIPv6TranslatorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorsWithOptions(request, runtime);
}

model DescribeInstanceAutoRenewAttributeRequest {
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  renewalStatus?: string(name='RenewalStatus'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeInstanceAutoRenewAttributeResponseBody = {
  instanceRenewAttributes?: {
    instanceRenewAttribute?: [ 
    {
      duration?: int32(name='Duration'),
      instanceId?: string(name='InstanceId'),
      pricingCycle?: string(name='PricingCycle'),
      renewalStatus?: string(name='RenewalStatus'),
    }
  ](name='InstanceRenewAttribute')
  }(name='InstanceRenewAttributes'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model DescribeInstanceAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAutoRenewAttributeResponseBody(name='body'),
}

async function describeInstanceAutoRenewAttributeWithOptions(request: DescribeInstanceAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): DescribeInstanceAutoRenewAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeInstanceAutoRenewAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeInstanceAutoRenewAttribute(request: DescribeInstanceAutoRenewAttributeRequest): DescribeInstanceAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAutoRenewAttributeWithOptions(request, runtime);
}

model DescribeIpv6AddressesRequest {
  associatedInstanceId?: string(name='AssociatedInstanceId'),
  associatedInstanceType?: string(name='AssociatedInstanceType'),
  ipv6Address?: string(name='Ipv6Address'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model DescribeIpv6AddressesResponseBody = {
  ipv6Addresses?: {
    ipv6Address?: [ 
    {
      allocationTime?: string(name='AllocationTime'),
      associatedInstanceId?: string(name='AssociatedInstanceId'),
      associatedInstanceType?: string(name='AssociatedInstanceType'),
      ipv6Address?: string(name='Ipv6Address'),
      ipv6AddressId?: string(name='Ipv6AddressId'),
      ipv6AddressName?: string(name='Ipv6AddressName'),
      ipv6GatewayId?: string(name='Ipv6GatewayId'),
      ipv6InternetBandwidth?: {
        bandwidth?: int32(name='Bandwidth'),
        businessStatus?: string(name='BusinessStatus'),
        instanceChargeType?: string(name='InstanceChargeType'),
        internetChargeType?: string(name='InternetChargeType'),
        ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
      }(name='Ipv6InternetBandwidth'),
      ipv6Isp?: string(name='Ipv6Isp'),
      networkType?: string(name='NetworkType'),
      realBandwidth?: int32(name='RealBandwidth'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Ipv6Address')
  }(name='Ipv6Addresses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIpv6AddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6AddressesResponseBody(name='body'),
}

async function describeIpv6AddressesWithOptions(request: DescribeIpv6AddressesRequest, runtime: Util.RuntimeOptions): DescribeIpv6AddressesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpv6Addresses', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpv6Addresses(request: DescribeIpv6AddressesRequest): DescribeIpv6AddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6AddressesWithOptions(request, runtime);
}

model DescribeIpv6EgressOnlyRulesRequest {
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeIpv6EgressOnlyRulesResponseBody = {
  ipv6EgressOnlyRules?: {
    ipv6EgressOnlyRule?: [ 
    {
      description?: string(name='Description'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
      name?: string(name='Name'),
      status?: string(name='Status'),
    }
  ](name='Ipv6EgressOnlyRule')
  }(name='Ipv6EgressOnlyRules'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIpv6EgressOnlyRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6EgressOnlyRulesResponseBody(name='body'),
}

async function describeIpv6EgressOnlyRulesWithOptions(request: DescribeIpv6EgressOnlyRulesRequest, runtime: Util.RuntimeOptions): DescribeIpv6EgressOnlyRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpv6EgressOnlyRules', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpv6EgressOnlyRules(request: DescribeIpv6EgressOnlyRulesRequest): DescribeIpv6EgressOnlyRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6EgressOnlyRulesWithOptions(request, runtime);
}

model DescribeIpv6GatewayAttributeRequest {
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeIpv6GatewayAttributeResponseBody = {
  businessStatus?: string(name='BusinessStatus'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  expiredTime?: string(name='ExpiredTime'),
  instanceChargeType?: string(name='InstanceChargeType'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
}

model DescribeIpv6GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6GatewayAttributeResponseBody(name='body'),
}

async function describeIpv6GatewayAttributeWithOptions(request: DescribeIpv6GatewayAttributeRequest, runtime: Util.RuntimeOptions): DescribeIpv6GatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpv6GatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpv6GatewayAttribute(request: DescribeIpv6GatewayAttributeRequest): DescribeIpv6GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6GatewayAttributeWithOptions(request, runtime);
}

model DescribeIpv6GatewaysRequest {
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DescribeIpv6GatewaysResponseBody = {
  ipv6Gateways?: {
    ipv6Gateway?: [ 
    {
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      instanceChargeType?: string(name='InstanceChargeType'),
      ipv6GatewayId?: string(name='Ipv6GatewayId'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Ipv6Gateway')
  }(name='Ipv6Gateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIpv6GatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6GatewaysResponseBody(name='body'),
}

async function describeIpv6GatewaysWithOptions(request: DescribeIpv6GatewaysRequest, runtime: Util.RuntimeOptions): DescribeIpv6GatewaysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpv6Gateways', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpv6Gateways(request: DescribeIpv6GatewaysRequest): DescribeIpv6GatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6GatewaysWithOptions(request, runtime);
}

model DescribeNatGatewaysRequest {
  dryRun?: boolean(name='DryRun'),
  instanceChargeType?: string(name='InstanceChargeType'),
  name?: string(name='Name'),
  natGatewayId?: string(name='NatGatewayId'),
  natType?: string(name='NatType'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId', description='可用区'),
}

model DescribeNatGatewaysResponseBody = {
  natGateways?: {
    natGateway?: [ 
    {
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      deletionProtection?: boolean(name='DeletionProtection'),
      description?: string(name='Description'),
      ecsMetricEnabled?: boolean(name='EcsMetricEnabled'),
      expiredTime?: string(name='ExpiredTime'),
      forwardTableIds?: {
        forwardTableId?: [ string ](name='ForwardTableId')
      }(name='ForwardTableIds'),
      fullNatTableIds?: {
        fullNatTableId?: [ string ](name='FullNatTableId')
      }(name='FullNatTableIds'),
      icmpReplyEnabled?: boolean(name='IcmpReplyEnabled'),
      instanceChargeType?: string(name='InstanceChargeType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipLists?: {
        ipList?: [ 
        {
          ipAddress?: string(name='IpAddress'),
          privateIpAddress?: string(name='PrivateIpAddress'),
          snatEntryEnabled?: boolean(name='SnatEntryEnabled'),
        }
      ](name='IpList')
      }(name='IpLists'),
      name?: string(name='Name'),
      natGatewayId?: string(name='NatGatewayId'),
      natGatewayPrivateInfo?: {
        eniInstanceId?: string(name='EniInstanceId'),
        eniType?: string(name='EniType'),
        izNo?: string(name='IzNo'),
        maxBandwidth?: int32(name='MaxBandwidth'),
        privateIpAddress?: string(name='PrivateIpAddress'),
        vswitchId?: string(name='VswitchId'),
      }(name='NatGatewayPrivateInfo'),
      natType?: string(name='NatType'),
      networkType?: string(name='NetworkType'),
      privateLinkEnabled?: boolean(name='PrivateLinkEnabled', description='默认不支持私网链接。设置为1则意味着支持私网链接'),
      privateLinkMode?: string(name='PrivateLinkMode', description='Fullnat：使用FullNat模式 Geneve：使用Geneve模式。 预估大部分场景都是非Geneve模式的。'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled'),
      snatTableIds?: {
        snatTableId?: [ string ](name='SnatTableId')
      }(name='SnatTableIds'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='NatGateway')
  }(name='NatGateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNatGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNatGatewaysResponseBody(name='body'),
}

async function describeNatGatewaysWithOptions(request: DescribeNatGatewaysRequest, runtime: Util.RuntimeOptions): DescribeNatGatewaysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNatGateways', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNatGateways(request: DescribeNatGatewaysRequest): DescribeNatGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNatGatewaysWithOptions(request, runtime);
}

model DescribeNetworkAclAttributesRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeNetworkAclAttributesResponseBody = {
  networkAclAttribute?: {
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    egressAclEntries?: {
      egressAclEntry?: [ 
      {
        description?: string(name='Description'),
        destinationCidrIp?: string(name='DestinationCidrIp'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
      }
    ](name='EgressAclEntry')
    }(name='EgressAclEntries'),
    ingressAclEntries?: {
      ingressAclEntry?: [ 
      {
        description?: string(name='Description'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
        sourceCidrIp?: string(name='SourceCidrIp'),
      }
    ](name='IngressAclEntry')
    }(name='IngressAclEntries'),
    networkAclId?: string(name='NetworkAclId'),
    networkAclName?: string(name='NetworkAclName'),
    ownerId?: long(name='OwnerId'),
    regionId?: string(name='RegionId'),
    resources?: {
      resource?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        status?: string(name='Status'),
      }
    ](name='Resource')
    }(name='Resources'),
    status?: string(name='Status'),
    vpcId?: string(name='VpcId'),
  }(name='NetworkAclAttribute'),
  requestId?: string(name='RequestId'),
}

model DescribeNetworkAclAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkAclAttributesResponseBody(name='body'),
}

async function describeNetworkAclAttributesWithOptions(request: DescribeNetworkAclAttributesRequest, runtime: Util.RuntimeOptions): DescribeNetworkAclAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNetworkAclAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNetworkAclAttributes(request: DescribeNetworkAclAttributesRequest): DescribeNetworkAclAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkAclAttributesWithOptions(request, runtime);
}

model DescribeNetworkAclsRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  networkAclName?: string(name='NetworkAclName'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  vpcId?: string(name='VpcId'),
}

model DescribeNetworkAclsResponseBody = {
  networkAcls?: {
    networkAcl?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      egressAclEntries?: {
        egressAclEntry?: [ 
        {
          description?: string(name='Description'),
          destinationCidrIp?: string(name='DestinationCidrIp'),
          networkAclEntryId?: string(name='NetworkAclEntryId'),
          networkAclEntryName?: string(name='NetworkAclEntryName'),
          policy?: string(name='Policy'),
          port?: string(name='Port'),
          protocol?: string(name='Protocol'),
        }
      ](name='EgressAclEntry')
      }(name='EgressAclEntries'),
      ingressAclEntries?: {
        ingressAclEntry?: [ 
        {
          description?: string(name='Description'),
          networkAclEntryId?: string(name='NetworkAclEntryId'),
          networkAclEntryName?: string(name='NetworkAclEntryName'),
          policy?: string(name='Policy'),
          port?: string(name='Port'),
          protocol?: string(name='Protocol'),
          sourceCidrIp?: string(name='SourceCidrIp'),
        }
      ](name='IngressAclEntry')
      }(name='IngressAclEntries'),
      networkAclId?: string(name='NetworkAclId'),
      networkAclName?: string(name='NetworkAclName'),
      ownerId?: long(name='OwnerId'),
      regionId?: string(name='RegionId'),
      resources?: {
        resource?: [ 
        {
          resourceId?: string(name='ResourceId'),
          resourceType?: string(name='ResourceType'),
          status?: string(name='Status'),
        }
      ](name='Resource')
      }(name='Resources'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='NetworkAcl')
  }(name='NetworkAcls'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model DescribeNetworkAclsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkAclsResponseBody(name='body'),
}

async function describeNetworkAclsWithOptions(request: DescribeNetworkAclsRequest, runtime: Util.RuntimeOptions): DescribeNetworkAclsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNetworkAcls', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNetworkAcls(request: DescribeNetworkAclsRequest): DescribeNetworkAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkAclsWithOptions(request, runtime);
}

model DescribeNewProjectEipMonitorDataRequest {
  allocationId?: string(name='AllocationId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeNewProjectEipMonitorDataResponseBody = {
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipBandwidth?: int32(name='EipBandwidth'),
      eipFlow?: int32(name='EipFlow'),
      eipPackets?: int32(name='EipPackets'),
      eipRX?: int32(name='EipRX'),
      eipTX?: int32(name='EipTX'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeNewProjectEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNewProjectEipMonitorDataResponseBody(name='body'),
}

async function describeNewProjectEipMonitorDataWithOptions(request: DescribeNewProjectEipMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeNewProjectEipMonitorDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeNewProjectEipMonitorData', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeNewProjectEipMonitorData(request: DescribeNewProjectEipMonitorDataRequest): DescribeNewProjectEipMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNewProjectEipMonitorDataWithOptions(request, runtime);
}

model DescribePhysicalConnectionLOARequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribePhysicalConnectionLOAResponseBody = {
  physicalConnectionLOAType?: {
    companyLocalizedName?: string(name='CompanyLocalizedName'),
    companyName?: string(name='CompanyName'),
    constructionTime?: string(name='ConstructionTime'),
    instanceId?: string(name='InstanceId'),
    lineCode?: string(name='LineCode'),
    lineLabel?: string(name='LineLabel'),
    lineType?: string(name='LineType'),
    loaUrl?: string(name='LoaUrl'),
    PMInfo?: {
      PMInfo?: [ 
      {
        PMCertificateNo?: string(name='PMCertificateNo'),
        PMCertificateType?: string(name='PMCertificateType'),
        PMContactInfo?: string(name='PMContactInfo'),
        PMGender?: string(name='PMGender'),
        PMName?: string(name='PMName'),
      }
    ](name='PMInfo')
    }(name='PMInfo'),
    SI?: string(name='SI'),
    status?: string(name='Status'),
  }(name='PhysicalConnectionLOAType'),
  requestId?: string(name='RequestId'),
}

model DescribePhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePhysicalConnectionLOAResponseBody(name='body'),
}

async function describePhysicalConnectionLOAWithOptions(request: DescribePhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): DescribePhysicalConnectionLOAResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribePhysicalConnectionLOA', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describePhysicalConnectionLOA(request: DescribePhysicalConnectionLOARequest): DescribePhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePhysicalConnectionLOAWithOptions(request, runtime);
}

model DescribePhysicalConnectionsRequest {
  clientToken?: string(name='ClientToken'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribePhysicalConnectionsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  physicalConnectionSet?: {
    physicalConnectionType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      accessPointType?: string(name='AccessPointType'),
      adLocation?: string(name='AdLocation'),
      bandwidth?: long(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      enabledTime?: string(name='EnabledTime'),
      endTime?: string(name='EndTime'),
      hasReservationData?: string(name='HasReservationData'),
      lineOperator?: string(name='LineOperator'),
      loaStatus?: string(name='LoaStatus'),
      name?: string(name='Name'),
      orderMode?: string(name='OrderMode'),
      parentPhysicalConnectionAliUid?: long(name='ParentPhysicalConnectionAliUid'),
      parentPhysicalConnectionId?: string(name='ParentPhysicalConnectionId'),
      peerLocation?: string(name='PeerLocation'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      portNumber?: string(name='PortNumber'),
      portType?: string(name='PortType'),
      productType?: string(name='ProductType'),
      redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      virtualPhysicalConnectionCount?: int32(name='VirtualPhysicalConnectionCount'),
      vlanId?: string(name='VlanId'),
      vpconnStatus?: string(name='VpconnStatus'),
    }
  ](name='PhysicalConnectionType')
  }(name='PhysicalConnectionSet'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribePhysicalConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePhysicalConnectionsResponseBody(name='body'),
}

async function describePhysicalConnectionsWithOptions(request: DescribePhysicalConnectionsRequest, runtime: Util.RuntimeOptions): DescribePhysicalConnectionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribePhysicalConnections', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describePhysicalConnections(request: DescribePhysicalConnectionsRequest): DescribePhysicalConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePhysicalConnectionsWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRouteEntryListRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  ipVersion?: string(name='IpVersion'),
  maxResult?: int32(name='MaxResult'),
  nextHopId?: string(name='NextHopId'),
  nextHopType?: string(name='NextHopType'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryId?: string(name='RouteEntryId'),
  routeEntryName?: string(name='RouteEntryName'),
  routeEntryType?: string(name='RouteEntryType'),
  routeTableId?: string(name='RouteTableId'),
}

model DescribeRouteEntryListResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  routeEntrys?: {
    routeEntry?: [ 
    {
      description?: string(name='Description'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      ipVersion?: string(name='IpVersion'),
      nextHops?: {
        nextHop?: [ 
        {
          enabled?: int32(name='Enabled'),
          nextHopId?: string(name='NextHopId'),
          nextHopRegionId?: string(name='NextHopRegionId'),
          nextHopRelatedInfo?: {
            instanceId?: string(name='InstanceId'),
            instanceType?: string(name='InstanceType'),
            regionId?: string(name='RegionId'),
          }(name='NextHopRelatedInfo'),
          nextHopType?: string(name='NextHopType'),
          weight?: int32(name='Weight'),
        }
      ](name='NextHop')
      }(name='NextHops'),
      routeEntryId?: string(name='RouteEntryId'),
      routeEntryName?: string(name='RouteEntryName'),
      routeTableId?: string(name='RouteTableId'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='RouteEntry')
  }(name='RouteEntrys'),
}

model DescribeRouteEntryListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteEntryListResponseBody(name='body'),
}

async function describeRouteEntryListWithOptions(request: DescribeRouteEntryListRequest, runtime: Util.RuntimeOptions): DescribeRouteEntryListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouteEntryList', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouteEntryList(request: DescribeRouteEntryListRequest): DescribeRouteEntryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteEntryListWithOptions(request, runtime);
}

model DescribeRouteTableListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
  routerId?: string(name='RouterId'),
  routerType?: string(name='RouterType'),
  vpcId?: string(name='VpcId'),
}

model DescribeRouteTableListResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routerTableList?: {
    routerTableListType?: [ 
    {
      associateType?: string(name='AssociateType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      gatewayIds?: {
        gatewayIds?: [ string ](name='GatewayIds')
      }(name='GatewayIds'),
      ownerId?: long(name='OwnerId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeTableId?: string(name='RouteTableId'),
      routeTableName?: string(name='RouteTableName'),
      routeTableType?: string(name='RouteTableType'),
      routerId?: string(name='RouterId'),
      routerType?: string(name='RouterType'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }
  ](name='RouterTableListType')
  }(name='RouterTableList'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouteTableListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteTableListResponseBody(name='body'),
}

async function describeRouteTableListWithOptions(request: DescribeRouteTableListRequest, runtime: Util.RuntimeOptions): DescribeRouteTableListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouteTableList', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouteTableList(request: DescribeRouteTableListRequest): DescribeRouteTableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteTableListWithOptions(request, runtime);
}

model DescribeRouteTablesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
  routerId?: string(name='RouterId'),
  routerType?: string(name='RouterType'),
  type?: string(name='Type'),
  VRouterId?: string(name='VRouterId'),
}

model DescribeRouteTablesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routeTables?: {
    routeTable?: [ 
    {
      creationTime?: string(name='CreationTime'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeEntrys?: {
        routeEntry?: [ 
        {
          description?: string(name='Description'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          instanceId?: string(name='InstanceId'),
          nextHopType?: string(name='NextHopType'),
          nextHops?: {
            nextHop?: [ 
            {
              enabled?: int32(name='Enabled'),
              nextHopId?: string(name='NextHopId'),
              nextHopType?: string(name='NextHopType'),
              weight?: int32(name='Weight'),
            }
          ](name='NextHop')
          }(name='NextHops'),
          routeEntryId?: string(name='RouteEntryId'),
          routeEntryName?: string(name='RouteEntryName'),
          routeTableId?: string(name='RouteTableId'),
          status?: string(name='Status'),
          type?: string(name='Type'),
        }
      ](name='RouteEntry')
      }(name='RouteEntrys'),
      routeTableId?: string(name='RouteTableId'),
      routeTableType?: string(name='RouteTableType'),
      status?: string(name='Status'),
      VRouterId?: string(name='VRouterId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
    }
  ](name='RouteTable')
  }(name='RouteTables'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouteTablesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteTablesResponseBody(name='body'),
}

async function describeRouteTablesWithOptions(request: DescribeRouteTablesRequest, runtime: Util.RuntimeOptions): DescribeRouteTablesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouteTables', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouteTables(request: DescribeRouteTablesRequest): DescribeRouteTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteTablesWithOptions(request, runtime);
}

model DescribeRouterInterfaceAttributeRequest {
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRouterInterfaceAttributeResponseBody = {
  accessPointId?: string(name='AccessPointId'),
  bandwidth?: int32(name='Bandwidth'),
  businessStatus?: string(name='BusinessStatus'),
  chargeType?: string(name='ChargeType'),
  code?: string(name='Code'),
  connectedTime?: string(name='ConnectedTime'),
  creationTime?: string(name='CreationTime'),
  crossBorder?: boolean(name='CrossBorder'),
  description?: string(name='Description'),
  endTime?: string(name='EndTime'),
  gmtModified?: string(name='GmtModified'),
  hasReservationData?: string(name='HasReservationData'),
  hcRate?: int32(name='HcRate'),
  hcThreshold?: int32(name='HcThreshold'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckStatus?: string(name='HealthCheckStatus'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId'),
  oppositeBandwidth?: int32(name='OppositeBandwidth'),
  oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
  oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
  oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
  oppositeRegionId?: string(name='OppositeRegionId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  oppositeVpcInstanceId?: string(name='OppositeVpcInstanceId'),
  requestId?: string(name='RequestId'),
  reservationActiveTime?: string(name='ReservationActiveTime'),
  reservationBandwidth?: string(name='ReservationBandwidth'),
  reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
  reservationOrderType?: string(name='ReservationOrderType'),
  role?: string(name='Role'),
  routerId?: string(name='RouterId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
  routerType?: string(name='RouterType'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
  vpcInstanceId?: string(name='VpcInstanceId'),
}

model DescribeRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouterInterfaceAttributeResponseBody(name='body'),
}

async function describeRouterInterfaceAttributeWithOptions(request: DescribeRouterInterfaceAttributeRequest, runtime: Util.RuntimeOptions): DescribeRouterInterfaceAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouterInterfaceAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouterInterfaceAttribute(request: DescribeRouterInterfaceAttributeRequest): DescribeRouterInterfaceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouterInterfaceAttributeWithOptions(request, runtime);
}

model DescribeRouterInterfacesRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRouterInterfacesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routerInterfaceSet?: {
    routerInterfaceType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      bandwidth?: int32(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      connectedTime?: string(name='ConnectedTime'),
      creationTime?: string(name='CreationTime'),
      crossBorder?: boolean(name='CrossBorder'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      hasReservationData?: string(name='HasReservationData'),
      hcRate?: int32(name='HcRate'),
      hcThreshold?: int32(name='HcThreshold'),
      healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
      healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
      ipv6Status?: string(name='Ipv6Status'),
      name?: string(name='Name'),
      oppositeAccessPointId?: string(name='OppositeAccessPointId'),
      oppositeBandwidth?: int32(name='OppositeBandwidth'),
      oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
      oppositeInterfaceId?: string(name='OppositeInterfaceId'),
      oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
      oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
      oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
      oppositeRegionId?: string(name='OppositeRegionId'),
      oppositeRouterId?: string(name='OppositeRouterId'),
      oppositeRouterType?: string(name='OppositeRouterType'),
      oppositeVpcInstanceId?: string(name='OppositeVpcInstanceId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      role?: string(name='Role'),
      routerId?: string(name='RouterId'),
      routerInterfaceId?: string(name='RouterInterfaceId'),
      routerType?: string(name='RouterType'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      vpcInstanceId?: string(name='VpcInstanceId'),
    }
  ](name='RouterInterfaceType')
  }(name='RouterInterfaceSet'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouterInterfacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouterInterfacesResponseBody(name='body'),
}

async function describeRouterInterfacesWithOptions(request: DescribeRouterInterfacesRequest, runtime: Util.RuntimeOptions): DescribeRouterInterfacesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRouterInterfaces', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRouterInterfaces(request: DescribeRouterInterfacesRequest): DescribeRouterInterfacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouterInterfacesWithOptions(request, runtime);
}

model DescribeServerRelatedGlobalAccelerationInstancesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverId?: string(name='ServerId'),
  serverType?: string(name='ServerType'),
}

model DescribeServerRelatedGlobalAccelerationInstancesResponseBody = {
  globalAccelerationInstances?: {
    globalAccelerationInstance?: [ 
    {
      globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
      ipAddress?: string(name='IpAddress'),
      regionId?: string(name='RegionId'),
      serverIpAddress?: string(name='ServerIpAddress'),
    }
  ](name='GlobalAccelerationInstance')
  }(name='GlobalAccelerationInstances'),
  requestId?: string(name='RequestId'),
}

model DescribeServerRelatedGlobalAccelerationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServerRelatedGlobalAccelerationInstancesResponseBody(name='body'),
}

async function describeServerRelatedGlobalAccelerationInstancesWithOptions(request: DescribeServerRelatedGlobalAccelerationInstancesRequest, runtime: Util.RuntimeOptions): DescribeServerRelatedGlobalAccelerationInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeServerRelatedGlobalAccelerationInstances', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeServerRelatedGlobalAccelerationInstances(request: DescribeServerRelatedGlobalAccelerationInstancesRequest): DescribeServerRelatedGlobalAccelerationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServerRelatedGlobalAccelerationInstancesWithOptions(request, runtime);
}

model DescribeSnatTableEntriesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snatEntryId?: string(name='SnatEntryId'),
  snatEntryName?: string(name='SnatEntryName'),
  snatIp?: string(name='SnatIp'),
  snatTableId?: string(name='SnatTableId'),
  sourceCIDR?: string(name='SourceCIDR'),
  sourceVSwitchId?: string(name='SourceVSwitchId'),
}

model DescribeSnatTableEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  snatTableEntries?: {
    snatTableEntry?: [ 
    {
      snatEntryId?: string(name='SnatEntryId'),
      snatEntryName?: string(name='SnatEntryName'),
      snatIp?: string(name='SnatIp'),
      snatTableId?: string(name='SnatTableId'),
      sourceCIDR?: string(name='SourceCIDR'),
      sourceVSwitchId?: string(name='SourceVSwitchId'),
      status?: string(name='Status'),
    }
  ](name='SnatTableEntry')
  }(name='SnatTableEntries'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSnatTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnatTableEntriesResponseBody(name='body'),
}

async function describeSnatTableEntriesWithOptions(request: DescribeSnatTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeSnatTableEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSnatTableEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSnatTableEntries(request: DescribeSnatTableEntriesRequest): DescribeSnatTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnatTableEntriesWithOptions(request, runtime);
}

model DescribeSslVpnClientCertRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model DescribeSslVpnClientCertResponseBody = {
  caCert?: string(name='CaCert'),
  clientCert?: string(name='ClientCert'),
  clientConfig?: string(name='ClientConfig'),
  clientKey?: string(name='ClientKey'),
  createTime?: long(name='CreateTime'),
  endTime?: long(name='EndTime'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  status?: string(name='Status'),
}

model DescribeSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSslVpnClientCertResponseBody(name='body'),
}

async function describeSslVpnClientCertWithOptions(request: DescribeSslVpnClientCertRequest, runtime: Util.RuntimeOptions): DescribeSslVpnClientCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSslVpnClientCert', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSslVpnClientCert(request: DescribeSslVpnClientCertRequest): DescribeSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnClientCertWithOptions(request, runtime);
}

model DescribeSslVpnClientCertsRequest {
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model DescribeSslVpnClientCertsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertKeys?: {
    sslVpnClientCertKey?: [ 
    {
      createTime?: long(name='CreateTime'),
      endTime?: long(name='EndTime'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      sslVpnClientCertId?: string(name='SslVpnClientCertId'),
      sslVpnServerId?: string(name='SslVpnServerId'),
      status?: string(name='Status'),
    }
  ](name='SslVpnClientCertKey')
  }(name='SslVpnClientCertKeys'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSslVpnClientCertsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSslVpnClientCertsResponseBody(name='body'),
}

async function describeSslVpnClientCertsWithOptions(request: DescribeSslVpnClientCertsRequest, runtime: Util.RuntimeOptions): DescribeSslVpnClientCertsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSslVpnClientCerts', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSslVpnClientCerts(request: DescribeSslVpnClientCertsRequest): DescribeSslVpnClientCertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnClientCertsWithOptions(request, runtime);
}

model DescribeSslVpnServersRequest {
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeSslVpnServersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sslVpnServers?: {
    sslVpnServer?: [ 
    {
      cipher?: string(name='Cipher'),
      clientIpPool?: string(name='ClientIpPool'),
      compress?: boolean(name='Compress'),
      connections?: int32(name='Connections'),
      createTime?: long(name='CreateTime'),
      enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
      IDaaSInstanceId?: string(name='IDaaSInstanceId'),
      IDaaSRegionId?: string(name='IDaaSRegionId'),
      internetIp?: string(name='InternetIp'),
      localSubnet?: string(name='LocalSubnet'),
      maxConnections?: int32(name='MaxConnections'),
      name?: string(name='Name'),
      port?: int32(name='Port'),
      proto?: string(name='Proto'),
      regionId?: string(name='RegionId'),
      sslVpnServerId?: string(name='SslVpnServerId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='SslVpnServer')
  }(name='SslVpnServers'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSslVpnServersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSslVpnServersResponseBody(name='body'),
}

async function describeSslVpnServersWithOptions(request: DescribeSslVpnServersRequest, runtime: Util.RuntimeOptions): DescribeSslVpnServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSslVpnServers', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSslVpnServers(request: DescribeSslVpnServersRequest): DescribeSslVpnServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnServersWithOptions(request, runtime);
}

model DescribeVRoutersRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VRouterId?: string(name='VRouterId'),
}

model DescribeVRoutersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  VRouters?: {
    VRouter?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      routeTableIds?: {
        routeTableId?: [ string ](name='RouteTableId')
      }(name='RouteTableIds'),
      VRouterId?: string(name='VRouterId'),
      VRouterName?: string(name='VRouterName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='VRouter')
  }(name='VRouters'),
}

model DescribeVRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVRoutersResponseBody(name='body'),
}

async function describeVRoutersWithOptions(request: DescribeVRoutersRequest, runtime: Util.RuntimeOptions): DescribeVRoutersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVRouters', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVRouters(request: DescribeVRoutersRequest): DescribeVRoutersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVRoutersWithOptions(request, runtime);
}

model DescribeVSwitchAttributesRequest {
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model DescribeVSwitchAttributesResponseBody = {
  availableIpAddressCount?: long(name='AvailableIpAddressCount'),
  cidrBlock?: string(name='CidrBlock'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  isDefault?: boolean(name='IsDefault'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  routeTable?: {
    routeTableId?: string(name='RouteTableId'),
    routeTableType?: string(name='RouteTableType'),
  }(name='RouteTable'),
  status?: string(name='Status'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeVSwitchAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchAttributesResponseBody(name='body'),
}

async function describeVSwitchAttributesWithOptions(request: DescribeVSwitchAttributesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVSwitchAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVSwitchAttributes(request: DescribeVSwitchAttributesRequest): DescribeVSwitchAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchAttributesWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  vSwitchOwnerId?: long(name='VSwitchOwnerId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vSwitches?: {
    vSwitch?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      isDefault?: boolean(name='IsDefault'),
      networkAclId?: string(name='NetworkAclId'),
      ownerId?: long(name='OwnerId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeTable?: {
        routeTableId?: string(name='RouteTableId'),
        routeTableType?: string(name='RouteTableType'),
      }(name='RouteTable'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='VSwitch')
  }(name='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVSwitches', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DescribeVbrHaRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrHaId?: string(name='VbrHaId'),
  vbrId?: string(name='VbrId'),
}

model DescribeVbrHaResponseBody = {
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  peerVbrId?: string(name='PeerVbrId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  vbrHaId?: string(name='VbrHaId'),
  vbrId?: string(name='VbrId'),
}

model DescribeVbrHaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVbrHaResponseBody(name='body'),
}

async function describeVbrHaWithOptions(request: DescribeVbrHaRequest, runtime: Util.RuntimeOptions): DescribeVbrHaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVbrHa', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVbrHa(request: DescribeVbrHaRequest): DescribeVbrHaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVbrHaWithOptions(request, runtime);
}

model DescribeVirtualBorderRoutersRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeVirtualBorderRoutersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterSet?: {
    virtualBorderRouterType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      activationTime?: string(name='ActivationTime'),
      associatedCens?: {
        associatedCen?: [ 
        {
          cenId?: string(name='CenId'),
          cenOwnerId?: long(name='CenOwnerId'),
          cenStatus?: string(name='CenStatus'),
        }
      ](name='AssociatedCen')
      }(name='AssociatedCens'),
      associatedPhysicalConnections?: {
        associatedPhysicalConnection?: [ 
        {
          circuitCode?: string(name='CircuitCode'),
          enableIpv6?: boolean(name='EnableIpv6'),
          localGatewayIp?: string(name='LocalGatewayIp'),
          localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
          peerGatewayIp?: string(name='PeerGatewayIp'),
          peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
          peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
          peeringSubnetMask?: string(name='PeeringSubnetMask'),
          physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
          physicalConnectionId?: string(name='PhysicalConnectionId'),
          physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
          physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
          status?: string(name='Status'),
          vlanId?: string(name='VlanId'),
          vlanInterfaceId?: string(name='VlanInterfaceId'),
        }
      ](name='AssociatedPhysicalConnection')
      }(name='AssociatedPhysicalConnections'),
      circuitCode?: string(name='CircuitCode'),
      cloudBoxInstanceId?: string(name='CloudBoxInstanceId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      detectMultiplier?: long(name='DetectMultiplier'),
      eccId?: string(name='EccId'),
      enableIpv6?: boolean(name='EnableIpv6'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
      minRxInterval?: long(name='MinRxInterval'),
      minTxInterval?: long(name='MinTxInterval'),
      name?: string(name='Name'),
      PConnVbrChargeType?: string(name='PConnVbrChargeType'),
      PConnVbrExpireTime?: string(name='PConnVbrExpireTime'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
      peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
      physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
      recoveryTime?: string(name='RecoveryTime'),
      routeTableId?: string(name='RouteTableId'),
      status?: string(name='Status'),
      terminationTime?: string(name='TerminationTime'),
      type?: string(name='Type'),
      vbrId?: string(name='VbrId'),
      vlanId?: int32(name='VlanId'),
      vlanInterfaceId?: string(name='VlanInterfaceId'),
    }
  ](name='VirtualBorderRouterType')
  }(name='VirtualBorderRouterSet'),
}

model DescribeVirtualBorderRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersResponseBody(name='body'),
}

async function describeVirtualBorderRoutersWithOptions(request: DescribeVirtualBorderRoutersRequest, runtime: Util.RuntimeOptions): DescribeVirtualBorderRoutersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVirtualBorderRouters', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVirtualBorderRouters(request: DescribeVirtualBorderRoutersRequest): DescribeVirtualBorderRoutersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualBorderRoutersWithOptions(request, runtime);
}

model DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterForPhysicalConnectionSet?: {
    virtualBorderRouterForPhysicalConnectionType?: [ 
    {
      activationTime?: string(name='ActivationTime'),
      bandwidth?: string(name='Bandwidth'),
      bandwidthStatus?: string(name='BandwidthStatus'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      eccId?: string(name='EccId'),
      enableIpv6?: boolean(name='EnableIpv6'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
      PConnVbrBussinessStatus?: string(name='PConnVbrBussinessStatus'),
      PConnVbrChargeType?: string(name='PConnVbrChargeType'),
      PConnVbrExpireTime?: string(name='PConnVbrExpireTime'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
      peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      recoveryTime?: string(name='RecoveryTime'),
      status?: string(name='Status'),
      terminationTime?: string(name='TerminationTime'),
      type?: string(name='Type'),
      vbrId?: string(name='VbrId'),
      vbrOwnerUid?: long(name='VbrOwnerUid'),
      vlanId?: int32(name='VlanId'),
    }
  ](name='VirtualBorderRouterForPhysicalConnectionType')
  }(name='VirtualBorderRouterForPhysicalConnectionSet'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody(name='body'),
}

async function describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest, runtime: Util.RuntimeOptions): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVirtualBorderRoutersForPhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVirtualBorderRoutersForPhysicalConnection(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request, runtime);
}

model DescribeVpcAttributeRequest {
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DescribeVpcAttributeResponseBody = {
  associatedCens?: {
    associatedCen?: [ 
    {
      cenId?: string(name='CenId'),
      cenOwnerId?: long(name='CenOwnerId'),
      cenStatus?: string(name='CenStatus'),
    }
  ](name='AssociatedCen')
  }(name='AssociatedCens'),
  cidrBlock?: string(name='CidrBlock'),
  classicLinkEnabled?: boolean(name='ClassicLinkEnabled'),
  cloudResources?: {
    cloudResourceSetType?: [ 
    {
      resourceCount?: int32(name='ResourceCount'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='CloudResourceSetType')
  }(name='CloudResources'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dhcpOptionsSetStatus?: string(name='DhcpOptionsSetStatus'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  ipv6CidrBlocks?: {
    ipv6CidrBlock?: [ 
    {
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      ipv6Isp?: string(name='Ipv6Isp'),
    }
  ](name='Ipv6CidrBlock')
  }(name='Ipv6CidrBlocks'),
  isDefault?: boolean(name='IsDefault'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  secondaryCidrBlocks?: {
    secondaryCidrBlock?: [ string ](name='SecondaryCidrBlock')
  }(name='SecondaryCidrBlocks'),
  status?: string(name='Status'),
  userCidrs?: {
    userCidr?: [ string ](name='UserCidr')
  }(name='UserCidrs'),
  VRouterId?: string(name='VRouterId'),
  vSwitchIds?: {
    vSwitchId?: [ string ](name='VSwitchId')
  }(name='VSwitchIds'),
  vpcId?: string(name='VpcId'),
  vpcName?: string(name='VpcName'),
}

model DescribeVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcAttributeResponseBody(name='body'),
}

async function describeVpcAttributeWithOptions(request: DescribeVpcAttributeRequest, runtime: Util.RuntimeOptions): DescribeVpcAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpcAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpcAttribute(request: DescribeVpcAttributeRequest): DescribeVpcAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcAttributeWithOptions(request, runtime);
}

model DescribeVpcsRequest {
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
  vpcName?: string(name='VpcName'),
  vpcOwnerId?: long(name='VpcOwnerId'),
}

model DescribeVpcsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpcs?: {
    vpc?: [ 
    {
      cenStatus?: string(name='CenStatus'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
      dhcpOptionsSetStatus?: string(name='DhcpOptionsSetStatus'),
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      ipv6CidrBlocks?: {
        ipv6CidrBlock?: [ 
        {
          ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
          ipv6Isp?: string(name='Ipv6Isp'),
        }
      ](name='Ipv6CidrBlock')
      }(name='Ipv6CidrBlocks'),
      isDefault?: boolean(name='IsDefault'),
      natGatewayIds?: {
        natGatewayIds?: [ string ](name='NatGatewayIds')
      }(name='NatGatewayIds'),
      ownerId?: long(name='OwnerId'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routerTableIds?: {
        routerTableIds?: [ string ](name='RouterTableIds')
      }(name='RouterTableIds'),
      secondaryCidrBlocks?: {
        secondaryCidrBlock?: [ string ](name='SecondaryCidrBlock')
      }(name='SecondaryCidrBlocks'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      userCidrs?: {
        userCidr?: [ string ](name='UserCidr')
      }(name='UserCidrs'),
      VRouterId?: string(name='VRouterId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Vpc')
  }(name='Vpcs'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: Util.RuntimeOptions): DescribeVpcsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpcs', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcsWithOptions(request, runtime);
}

model DescribeVpnConnectionRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DescribeVpnConnectionResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  ikeConfig?: {
    ikeAuthAlg?: string(name='IkeAuthAlg'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeMode?: string(name='IkeMode'),
    ikePfs?: string(name='IkePfs'),
    ikeVersion?: string(name='IkeVersion'),
    localId?: string(name='LocalId'),
    psk?: string(name='Psk'),
    remoteId?: string(name='RemoteId'),
  }(name='IkeConfig'),
  ipsecConfig?: {
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecPfs?: string(name='IpsecPfs'),
  }(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
  remoteSubnet?: string(name='RemoteSubnet'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  vcoHealthCheck?: {
    dip?: string(name='Dip'),
    enable?: string(name='Enable'),
    interval?: int32(name='Interval'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
    status?: string(name='Status'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig?: {
    authKey?: string(name='AuthKey'),
    enableBgp?: string(name='EnableBgp'),
    localAsn?: long(name='LocalAsn'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: long(name='PeerAsn'),
    peerBgpIp?: string(name='PeerBgpIp'),
    status?: string(name='Status'),
    tunnelCidr?: string(name='TunnelCidr'),
  }(name='VpnBgpConfig'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnConnectionResponseBody(name='body'),
}

async function describeVpnConnectionWithOptions(request: DescribeVpnConnectionRequest, runtime: Util.RuntimeOptions): DescribeVpnConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnConnection(request: DescribeVpnConnectionRequest): DescribeVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnConnectionWithOptions(request, runtime);
}

model DescribeVpnConnectionsRequest {
  customerGatewayId?: string(name='CustomerGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnConnectionsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnConnections?: {
    vpnConnection?: [ 
    {
      createTime?: long(name='CreateTime'),
      customerGatewayId?: string(name='CustomerGatewayId'),
      effectImmediately?: boolean(name='EffectImmediately'),
      enableDpd?: boolean(name='EnableDpd'),
      enableNatTraversal?: boolean(name='EnableNatTraversal'),
      ikeConfig?: {
        ikeAuthAlg?: string(name='IkeAuthAlg'),
        ikeEncAlg?: string(name='IkeEncAlg'),
        ikeLifetime?: long(name='IkeLifetime'),
        ikeMode?: string(name='IkeMode'),
        ikePfs?: string(name='IkePfs'),
        ikeVersion?: string(name='IkeVersion'),
        localId?: string(name='LocalId'),
        psk?: string(name='Psk'),
        remoteId?: string(name='RemoteId'),
      }(name='IkeConfig'),
      ipsecConfig?: {
        ipsecAuthAlg?: string(name='IpsecAuthAlg'),
        ipsecEncAlg?: string(name='IpsecEncAlg'),
        ipsecLifetime?: long(name='IpsecLifetime'),
        ipsecPfs?: string(name='IpsecPfs'),
      }(name='IpsecConfig'),
      localSubnet?: string(name='LocalSubnet'),
      name?: string(name='Name'),
      remoteCaCertificate?: string(name='RemoteCaCertificate'),
      remoteSubnet?: string(name='RemoteSubnet'),
      status?: string(name='Status'),
      vcoHealthCheck?: {
        dip?: string(name='Dip'),
        enable?: string(name='Enable'),
        interval?: int32(name='Interval'),
        retry?: int32(name='Retry'),
        sip?: string(name='Sip'),
        status?: string(name='Status'),
      }(name='VcoHealthCheck'),
      vpnBgpConfig?: {
        authKey?: string(name='AuthKey'),
        localAsn?: long(name='LocalAsn'),
        localBgpIp?: string(name='LocalBgpIp'),
        peerAsn?: long(name='PeerAsn'),
        peerBgpIp?: string(name='PeerBgpIp'),
        status?: string(name='Status'),
        tunnelCidr?: string(name='TunnelCidr'),
      }(name='VpnBgpConfig'),
      vpnConnectionId?: string(name='VpnConnectionId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='VpnConnection')
  }(name='VpnConnections'),
}

model DescribeVpnConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnConnectionsResponseBody(name='body'),
}

async function describeVpnConnectionsWithOptions(request: DescribeVpnConnectionsRequest, runtime: Util.RuntimeOptions): DescribeVpnConnectionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnConnections', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnConnections(request: DescribeVpnConnectionsRequest): DescribeVpnConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnConnectionsWithOptions(request, runtime);
}

model DescribeVpnGatewayRequest {
  includeReservationData?: boolean(name='IncludeReservationData'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnGatewayResponseBody = {
  autoPropagate?: boolean(name='AutoPropagate'),
  businessStatus?: string(name='BusinessStatus'),
  chargeType?: string(name='ChargeType'),
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  enableBgp?: boolean(name='EnableBgp'),
  endTime?: long(name='EndTime'),
  internetIp?: string(name='InternetIp'),
  ipsecVpn?: string(name='IpsecVpn'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  reservationData?: {
    reservationEndTime?: string(name='ReservationEndTime'),
    reservationIpsec?: string(name='ReservationIpsec'),
    reservationMaxConnections?: int32(name='ReservationMaxConnections'),
    reservationOrderType?: string(name='ReservationOrderType'),
    reservationSpec?: string(name='ReservationSpec'),
    reservationSsl?: string(name='ReservationSsl'),
    status?: string(name='Status'),
  }(name='ReservationData'),
  spec?: string(name='Spec'),
  sslMaxConnections?: long(name='SslMaxConnections'),
  sslVpn?: string(name='SslVpn'),
  status?: string(name='Status'),
  tag?: string(name='Tag'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  vpnType?: string(name='VpnType'),
}

model DescribeVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnGatewayResponseBody(name='body'),
}

async function describeVpnGatewayWithOptions(request: DescribeVpnGatewayRequest, runtime: Util.RuntimeOptions): DescribeVpnGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnGateway(request: DescribeVpnGatewayRequest): DescribeVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnGatewayWithOptions(request, runtime);
}

model DescribeVpnGatewaysRequest {
  businessStatus?: string(name='BusinessStatus'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: string(name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnGatewaysResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnGateways?: {
    vpnGateway?: [ 
    {
      autoPropagate?: boolean(name='AutoPropagate'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      enableBgp?: boolean(name='EnableBgp'),
      endTime?: long(name='EndTime'),
      internetIp?: string(name='InternetIp'),
      ipsecVpn?: string(name='IpsecVpn'),
      name?: string(name='Name'),
      reservationData?: {
        reservationEndTime?: string(name='ReservationEndTime'),
        reservationIpsec?: string(name='ReservationIpsec'),
        reservationMaxConnections?: int32(name='ReservationMaxConnections'),
        reservationOrderType?: string(name='ReservationOrderType'),
        reservationSpec?: string(name='ReservationSpec'),
        reservationSsl?: string(name='ReservationSsl'),
        status?: string(name='Status'),
      }(name='ReservationData'),
      spec?: string(name='Spec'),
      sslMaxConnections?: long(name='SslMaxConnections'),
      sslVpn?: string(name='SslVpn'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
      vpnType?: string(name='VpnType'),
    }
  ](name='VpnGateway')
  }(name='VpnGateways'),
}

model DescribeVpnGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnGatewaysResponseBody(name='body'),
}

async function describeVpnGatewaysWithOptions(request: DescribeVpnGatewaysRequest, runtime: Util.RuntimeOptions): DescribeVpnGatewaysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnGateways', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnGateways(request: DescribeVpnGatewaysRequest): DescribeVpnGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnGatewaysWithOptions(request, runtime);
}

model DescribeVpnPbrRouteEntriesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnPbrRouteEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnPbrRouteEntries?: {
    vpnPbrRouteEntry?: [ 
    {
      createTime?: long(name='CreateTime'),
      nextHop?: string(name='NextHop'),
      routeDest?: string(name='RouteDest'),
      routeSource?: string(name='RouteSource'),
      state?: string(name='State'),
      vpnInstanceId?: string(name='VpnInstanceId'),
      weight?: int32(name='Weight'),
    }
  ](name='VpnPbrRouteEntry')
  }(name='VpnPbrRouteEntries'),
}

model DescribeVpnPbrRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnPbrRouteEntriesResponseBody(name='body'),
}

async function describeVpnPbrRouteEntriesWithOptions(request: DescribeVpnPbrRouteEntriesRequest, runtime: Util.RuntimeOptions): DescribeVpnPbrRouteEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnPbrRouteEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnPbrRouteEntries(request: DescribeVpnPbrRouteEntriesRequest): DescribeVpnPbrRouteEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnPbrRouteEntriesWithOptions(request, runtime);
}

model DescribeVpnRouteEntriesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryType?: string(name='RouteEntryType'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnRouteEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnRouteEntries?: {
    vpnRouteEntry?: [ 
    {
      asPath?: string(name='AsPath'),
      community?: string(name='Community'),
      createTime?: long(name='CreateTime'),
      nextHop?: string(name='NextHop'),
      routeDest?: string(name='RouteDest'),
      routeEntryType?: string(name='RouteEntryType'),
      source?: string(name='Source'),
      state?: string(name='State'),
      vpnInstanceId?: string(name='VpnInstanceId'),
      weight?: int32(name='Weight'),
    }
  ](name='VpnRouteEntry')
  }(name='VpnRouteEntries'),
}

model DescribeVpnRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnRouteEntriesResponseBody(name='body'),
}

async function describeVpnRouteEntriesWithOptions(request: DescribeVpnRouteEntriesRequest, runtime: Util.RuntimeOptions): DescribeVpnRouteEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnRouteEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnRouteEntries(request: DescribeVpnRouteEntriesRequest): DescribeVpnRouteEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnRouteEntriesWithOptions(request, runtime);
}

model DescribeVpnSslServerLogsRequest {
  from?: int32(name='From'),
  minutePeriod?: int32(name='MinutePeriod'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  to?: int32(name='To'),
  vpnSslServerId?: string(name='VpnSslServerId'),
}

model DescribeVpnSslServerLogsResponseBody = {
  count?: int32(name='Count'),
  data?: {
    logs?: [ string ](name='Logs')
  }(name='Data'),
  isCompleted?: boolean(name='IsCompleted'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
}

model DescribeVpnSslServerLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnSslServerLogsResponseBody(name='body'),
}

async function describeVpnSslServerLogsWithOptions(request: DescribeVpnSslServerLogsRequest, runtime: Util.RuntimeOptions): DescribeVpnSslServerLogsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeVpnSslServerLogs', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeVpnSslServerLogs(request: DescribeVpnSslServerLogsRequest): DescribeVpnSslServerLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnSslServerLogsWithOptions(request, runtime);
}

model DescribeZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneType?: string(name='ZoneType'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
      zoneType?: string(name='ZoneType'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeZones', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model DetachDhcpOptionsSetFromVpcRequest {
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DetachDhcpOptionsSetFromVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachDhcpOptionsSetFromVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDhcpOptionsSetFromVpcResponseBody(name='body'),
}

async function detachDhcpOptionsSetFromVpcWithOptions(request: DetachDhcpOptionsSetFromVpcRequest, runtime: Util.RuntimeOptions): DetachDhcpOptionsSetFromVpcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetachDhcpOptionsSetFromVpc', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detachDhcpOptionsSetFromVpc(request: DetachDhcpOptionsSetFromVpcRequest): DetachDhcpOptionsSetFromVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDhcpOptionsSetFromVpcWithOptions(request, runtime);
}

model DisableNatGatewayEcsMetricRequest {
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  regionId?: string(name='RegionId'),
}

model DisableNatGatewayEcsMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  body: DisableNatGatewayEcsMetricResponseBody(name='body'),
}

async function disableNatGatewayEcsMetricWithOptions(request: DisableNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): DisableNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableNatGatewayEcsMetric', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableNatGatewayEcsMetric(request: DisableNatGatewayEcsMetricRequest): DisableNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableNatGatewayEcsMetricWithOptions(request, runtime);
}

model DisableVpcClassicLinkRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DisableVpcClassicLinkResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableVpcClassicLinkResponse = {
  headers: map[string]string(name='headers'),
  body: DisableVpcClassicLinkResponseBody(name='body'),
}

async function disableVpcClassicLinkWithOptions(request: DisableVpcClassicLinkRequest, runtime: Util.RuntimeOptions): DisableVpcClassicLinkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableVpcClassicLink', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableVpcClassicLink(request: DisableVpcClassicLinkRequest): DisableVpcClassicLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableVpcClassicLinkWithOptions(request, runtime);
}

model DissociateRouteTableFromGatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  gatewayId?: string(name='GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
}

model DissociateRouteTableFromGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateRouteTableFromGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateRouteTableFromGatewayResponseBody(name='body'),
}

async function dissociateRouteTableFromGatewayWithOptions(request: DissociateRouteTableFromGatewayRequest, runtime: Util.RuntimeOptions): DissociateRouteTableFromGatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DissociateRouteTableFromGateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function dissociateRouteTableFromGateway(request: DissociateRouteTableFromGatewayRequest): DissociateRouteTableFromGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateRouteTableFromGatewayWithOptions(request, runtime);
}

model DissociateRouteTablesFromVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken', description='幂等参数'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求'),
  endpointId?: string(name='EndpointId', description='VPC网关实例ID'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableIds?: [ string ](name='RouteTableIds', description='路由表列表'),
}

model DissociateRouteTablesFromVpcGatewayEndpointResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DissociateRouteTablesFromVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateRouteTablesFromVpcGatewayEndpointResponseBody(name='body'),
}

async function dissociateRouteTablesFromVpcGatewayEndpointWithOptions(request: DissociateRouteTablesFromVpcGatewayEndpointRequest, runtime: Util.RuntimeOptions): DissociateRouteTablesFromVpcGatewayEndpointResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DissociateRouteTablesFromVpcGatewayEndpoint', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function dissociateRouteTablesFromVpcGatewayEndpoint(request: DissociateRouteTablesFromVpcGatewayEndpointRequest): DissociateRouteTablesFromVpcGatewayEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateRouteTablesFromVpcGatewayEndpointWithOptions(request, runtime);
}

model DissociateVpnGatewayWithCertificateRequest {
  certificateId?: string(name='CertificateId'),
  certificateType?: string(name='CertificateType'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DissociateVpnGatewayWithCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateVpnGatewayWithCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateVpnGatewayWithCertificateResponseBody(name='body'),
}

async function dissociateVpnGatewayWithCertificateWithOptions(request: DissociateVpnGatewayWithCertificateRequest, runtime: Util.RuntimeOptions): DissociateVpnGatewayWithCertificateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DissociateVpnGatewayWithCertificate', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function dissociateVpnGatewayWithCertificate(request: DissociateVpnGatewayWithCertificateRequest): DissociateVpnGatewayWithCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateVpnGatewayWithCertificateWithOptions(request, runtime);
}

model DownloadVpnConnectionConfigRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DownloadVpnConnectionConfigResponseBody = {
  requestId?: string(name='RequestId'),
  vpnConnectionConfig?: {
    ikeConfig?: {
      ikeAuthAlg?: string(name='IkeAuthAlg'),
      ikeEncAlg?: string(name='IkeEncAlg'),
      ikeLifetime?: long(name='IkeLifetime'),
      ikeMode?: string(name='IkeMode'),
      ikePfs?: string(name='IkePfs'),
      ikeVersion?: string(name='IkeVersion'),
      localId?: string(name='LocalId'),
      psk?: string(name='Psk'),
      remoteId?: string(name='RemoteId'),
    }(name='IkeConfig'),
    ipsecConfig?: {
      ipsecAuthAlg?: string(name='IpsecAuthAlg'),
      ipsecEncAlg?: string(name='IpsecEncAlg'),
      ipsecLifetime?: long(name='IpsecLifetime'),
      ipsecPfs?: string(name='IpsecPfs'),
    }(name='IpsecConfig'),
    local?: string(name='Local'),
    localSubnet?: string(name='LocalSubnet'),
    remote?: string(name='Remote'),
    remoteSubnet?: string(name='RemoteSubnet'),
  }(name='VpnConnectionConfig'),
}

model DownloadVpnConnectionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DownloadVpnConnectionConfigResponseBody(name='body'),
}

async function downloadVpnConnectionConfigWithOptions(request: DownloadVpnConnectionConfigRequest, runtime: Util.RuntimeOptions): DownloadVpnConnectionConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DownloadVpnConnectionConfig', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function downloadVpnConnectionConfig(request: DownloadVpnConnectionConfigRequest): DownloadVpnConnectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadVpnConnectionConfigWithOptions(request, runtime);
}

model EnableNatGatewayEcsMetricRequest {
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  regionId?: string(name='RegionId'),
}

model EnableNatGatewayEcsMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  body: EnableNatGatewayEcsMetricResponseBody(name='body'),
}

async function enableNatGatewayEcsMetricWithOptions(request: EnableNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): EnableNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableNatGatewayEcsMetric', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableNatGatewayEcsMetric(request: EnableNatGatewayEcsMetricRequest): EnableNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableNatGatewayEcsMetricWithOptions(request, runtime);
}

model EnablePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model EnablePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnablePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: EnablePhysicalConnectionResponseBody(name='body'),
}

async function enablePhysicalConnectionWithOptions(request: EnablePhysicalConnectionRequest, runtime: Util.RuntimeOptions): EnablePhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnablePhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enablePhysicalConnection(request: EnablePhysicalConnectionRequest): EnablePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enablePhysicalConnectionWithOptions(request, runtime);
}

model EnableVpcClassicLinkRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model EnableVpcClassicLinkResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableVpcClassicLinkResponse = {
  headers: map[string]string(name='headers'),
  body: EnableVpcClassicLinkResponseBody(name='body'),
}

async function enableVpcClassicLinkWithOptions(request: EnableVpcClassicLinkRequest, runtime: Util.RuntimeOptions): EnableVpcClassicLinkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableVpcClassicLink', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableVpcClassicLink(request: EnableVpcClassicLinkRequest): EnableVpcClassicLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableVpcClassicLinkWithOptions(request, runtime);
}

model EnableVpcIpv4GatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableList?: [ string ](name='RouteTableList'),
}

model EnableVpcIpv4GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableVpcIpv4GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: EnableVpcIpv4GatewayResponseBody(name='body'),
}

async function enableVpcIpv4GatewayWithOptions(request: EnableVpcIpv4GatewayRequest, runtime: Util.RuntimeOptions): EnableVpcIpv4GatewayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableVpcIpv4Gateway', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableVpcIpv4Gateway(request: EnableVpcIpv4GatewayRequest): EnableVpcIpv4GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableVpcIpv4GatewayWithOptions(request, runtime);
}

model GetDhcpOptionsSetRequest {
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetDhcpOptionsSetResponseBody = {
  associateVpcs?: [ 
    {
      associateStatus?: string(name='AssociateStatus'),
      vpcId?: string(name='VpcId'),
    }
  ](name='AssociateVpcs'),
  dhcpOptions?: {
    bootFileName?: string(name='BootFileName'),
    domainName?: string(name='DomainName'),
    domainNameServers?: string(name='DomainNameServers'),
    TFTPServerName?: string(name='TFTPServerName'),
  }(name='DhcpOptions'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  ownerId?: long(name='OwnerId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: GetDhcpOptionsSetResponseBody(name='body'),
}

async function getDhcpOptionsSetWithOptions(request: GetDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): GetDhcpOptionsSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDhcpOptionsSet', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDhcpOptionsSet(request: GetDhcpOptionsSetRequest): GetDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDhcpOptionsSetWithOptions(request, runtime);
}

model GetIpv4GatewayAttributeRequest {
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetIpv4GatewayAttributeResponseBody = {
  enabled?: boolean(name='Enabled'),
  ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ipv4GatewayName?: string(name='Ipv4GatewayName'),
  ipv4GatewayRouteTableId?: string(name='Ipv4GatewayRouteTableId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
}

model GetIpv4GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetIpv4GatewayAttributeResponseBody(name='body'),
}

async function getIpv4GatewayAttributeWithOptions(request: GetIpv4GatewayAttributeRequest, runtime: Util.RuntimeOptions): GetIpv4GatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetIpv4GatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getIpv4GatewayAttribute(request: GetIpv4GatewayAttributeRequest): GetIpv4GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIpv4GatewayAttributeWithOptions(request, runtime);
}

model GetNatGatewayAttributeRequest {
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetNatGatewayAttributeResponseBody = {
  billingConfig?: {
    autoPay?: string(name='AutoPay'),
    instanceChargeType?: string(name='InstanceChargeType'),
    internetChargeType?: string(name='InternetChargeType'),
    spec?: string(name='Spec'),
  }(name='BillingConfig'),
  businessStatus?: string(name='BusinessStatus'),
  creationTime?: string(name='CreationTime'),
  deletionProtectionInfo?: {
    enabled?: boolean(name='Enabled'),
  }(name='DeletionProtectionInfo'),
  description?: string(name='Description'),
  ecsMetricEnabled?: boolean(name='EcsMetricEnabled'),
  expiredTime?: string(name='ExpiredTime'),
  forwardTable?: {
    forwardEntryCount?: int32(name='ForwardEntryCount'),
    forwardTableId?: string(name='ForwardTableId'),
  }(name='ForwardTable'),
  fullNatTable?: {
    fullNatEntryCount?: long(name='FullNatEntryCount'),
    fullNatTableId?: string(name='FullNatTableId'),
  }(name='FullNatTable'),
  ipList?: [ 
    {
      allocationId?: string(name='AllocationId'),
      ipAddress?: string(name='IpAddress'),
      usingStatus?: string(name='UsingStatus'),
    }
  ](name='IpList'),
  name?: string(name='Name'),
  natGatewayId?: string(name='NatGatewayId'),
  natType?: string(name='NatType'),
  networkType?: string(name='NetworkType'),
  privateInfo?: {
    eniInstanceId?: string(name='EniInstanceId'),
    izNo?: string(name='IzNo'),
    maxBandwidth?: int32(name='MaxBandwidth'),
    privateIpAddress?: string(name='PrivateIpAddress'),
    vswitchId?: string(name='VswitchId'),
  }(name='PrivateInfo'),
  privateLinkEnabled?: boolean(name='PrivateLinkEnabled', description='默认不支持私网链接。设置为1则意味着支持私网链接'),
  privateLinkMode?: string(name='PrivateLinkMode', description='Fullnat：使用FullNat模式 Geneve：使用Geneve模式。 预估大部分场景都是非Geneve模式的。'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  snatTable?: {
    snatEntryCount?: int32(name='SnatEntryCount'),
    snatTableId?: string(name='SnatTableId'),
  }(name='SnatTable'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
}

model GetNatGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetNatGatewayAttributeResponseBody(name='body'),
}

async function getNatGatewayAttributeWithOptions(request: GetNatGatewayAttributeRequest, runtime: Util.RuntimeOptions): GetNatGatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNatGatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNatGatewayAttribute(request: GetNatGatewayAttributeRequest): GetNatGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNatGatewayAttributeWithOptions(request, runtime);
}

model GetNatGatewayConvertStatusRequest {
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetNatGatewayConvertStatusResponseBody = {
  convertSteps?: [ 
    {
      stepName?: string(name='StepName'),
      stepStartTime?: string(name='StepStartTime'),
      stepStatus?: string(name='StepStatus'),
    }
  ](name='ConvertSteps'),
  dstNatType?: string(name='DstNatType'),
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId'),
}

model GetNatGatewayConvertStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetNatGatewayConvertStatusResponseBody(name='body'),
}

async function getNatGatewayConvertStatusWithOptions(request: GetNatGatewayConvertStatusRequest, runtime: Util.RuntimeOptions): GetNatGatewayConvertStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNatGatewayConvertStatus', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNatGatewayConvertStatus(request: GetNatGatewayConvertStatusRequest): GetNatGatewayConvertStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNatGatewayConvertStatusWithOptions(request, runtime);
}

model GetPhysicalConnectionServiceStatusRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetPhysicalConnectionServiceStatusResponseBody = {
  enabled?: boolean(name='Enabled', description='是否开通出云流量服务'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetPhysicalConnectionServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetPhysicalConnectionServiceStatusResponseBody(name='body'),
}

async function getPhysicalConnectionServiceStatusWithOptions(request: GetPhysicalConnectionServiceStatusRequest, runtime: Util.RuntimeOptions): GetPhysicalConnectionServiceStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetPhysicalConnectionServiceStatus', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getPhysicalConnectionServiceStatus(request: GetPhysicalConnectionServiceStatusRequest): GetPhysicalConnectionServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPhysicalConnectionServiceStatusWithOptions(request, runtime);
}

model GetTrafficMirrorServiceStatusRequest {
  ownerId?: long(name='OwnerId'),
}

model GetTrafficMirrorServiceStatusResponseBody = {
  enabled?: boolean(name='Enabled'),
  requestId?: string(name='RequestId'),
}

model GetTrafficMirrorServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetTrafficMirrorServiceStatusResponseBody(name='body'),
}

async function getTrafficMirrorServiceStatusWithOptions(request: GetTrafficMirrorServiceStatusRequest, runtime: Util.RuntimeOptions): GetTrafficMirrorServiceStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetTrafficMirrorServiceStatus', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getTrafficMirrorServiceStatus(request: GetTrafficMirrorServiceStatusRequest): GetTrafficMirrorServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTrafficMirrorServiceStatusWithOptions(request, runtime);
}

model GetVpcGatewayEndpointAttributeRequest {
  endpointId?: string(name='EndpointId', description='VPC网关实例ID'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetVpcGatewayEndpointAttributeResponseBody = {
  creationTime?: string(name='CreationTime'),
  endpointDescription?: string(name='EndpointDescription'),
  endpointId?: string(name='EndpointId'),
  endpointName?: string(name='EndpointName'),
  endpointStatus?: string(name='EndpointStatus'),
  policyDocument?: string(name='PolicyDocument'),
  requestId?: string(name='RequestId', description='Id of the request'),
  routeTables?: [ string ](name='RouteTables'),
  serviceName?: string(name='ServiceName'),
  vpcId?: string(name='VpcId'),
}

model GetVpcGatewayEndpointAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetVpcGatewayEndpointAttributeResponseBody(name='body'),
}

async function getVpcGatewayEndpointAttributeWithOptions(request: GetVpcGatewayEndpointAttributeRequest, runtime: Util.RuntimeOptions): GetVpcGatewayEndpointAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetVpcGatewayEndpointAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getVpcGatewayEndpointAttribute(request: GetVpcGatewayEndpointAttributeRequest): GetVpcGatewayEndpointAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVpcGatewayEndpointAttributeWithOptions(request, runtime);
}

model GrantInstanceToCenRequest {
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GrantInstanceToCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model GrantInstanceToCenResponse = {
  headers: map[string]string(name='headers'),
  body: GrantInstanceToCenResponseBody(name='body'),
}

async function grantInstanceToCenWithOptions(request: GrantInstanceToCenRequest, runtime: Util.RuntimeOptions): GrantInstanceToCenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GrantInstanceToCen', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function grantInstanceToCen(request: GrantInstanceToCenRequest): GrantInstanceToCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantInstanceToCenWithOptions(request, runtime);
}

model ListDhcpOptionsSetsRequest {
  dhcpOptionsSetId?: [ string ](name='DhcpOptionsSetId'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  domainName?: string(name='DomainName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListDhcpOptionsSetsResponseBody = {
  dhcpOptionsSets?: [ 
    {
      associateVpcCount?: int32(name='AssociateVpcCount'),
      dhcpOptions?: {
        domainName?: string(name='DomainName'),
        domainNameServers?: string(name='DomainNameServers'),
      }(name='DhcpOptions'),
      dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
      dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
      dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
      ownerId?: long(name='OwnerId'),
      status?: string(name='Status'),
    }
  ](name='DhcpOptionsSets'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListDhcpOptionsSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDhcpOptionsSetsResponseBody(name='body'),
}

async function listDhcpOptionsSetsWithOptions(request: ListDhcpOptionsSetsRequest, runtime: Util.RuntimeOptions): ListDhcpOptionsSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListDhcpOptionsSets', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listDhcpOptionsSets(request: ListDhcpOptionsSetsRequest): ListDhcpOptionsSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDhcpOptionsSetsWithOptions(request, runtime);
}

model ListEnhanhcedNatGatewayAvailableZonesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListEnhanhcedNatGatewayAvailableZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zones'),
}

model ListEnhanhcedNatGatewayAvailableZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEnhanhcedNatGatewayAvailableZonesResponseBody(name='body'),
}

async function listEnhanhcedNatGatewayAvailableZonesWithOptions(request: ListEnhanhcedNatGatewayAvailableZonesRequest, runtime: Util.RuntimeOptions): ListEnhanhcedNatGatewayAvailableZonesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListEnhanhcedNatGatewayAvailableZones', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listEnhanhcedNatGatewayAvailableZones(request: ListEnhanhcedNatGatewayAvailableZonesRequest): ListEnhanhcedNatGatewayAvailableZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEnhanhcedNatGatewayAvailableZonesWithOptions(request, runtime);
}

model ListFullNatEntriesRequest {
  clientToken?: string(name='ClientToken'),
  fullNatEntryId?: string(name='FullNatEntryId'),
  fullNatEntryNames?: [ string ](name='FullNatEntryNames'),
  fullNatTableId?: string(name='FullNatTableId'),
  ipProtocol?: string(name='IpProtocol'),
  maxResults?: long(name='MaxResults'),
  networkInterfaceIds?: [ string ](name='NetworkInterfaceIds'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListFullNatEntriesResponseBody = {
  fullNatEntries?: [ 
    {
      accessIp?: string(name='AccessIp', description='通过DNAT条目进行公网通信的ECS实例的私网IP地址。'),
      accessPort?: string(name='AccessPort', description='DNAT条目中进行端口转发的内部端口，取值范围：1-65535。'),
      creationTime?: string(name='CreationTime'),
      fullNatEntryDescription?: string(name='FullNatEntryDescription'),
      fullNatEntryId?: string(name='FullNatEntryId'),
      fullNatEntryName?: string(name='FullNatEntryName', description='FULLNAT规则的名称。 长度为2~128个字符，必须以大小写字母或中文开头，但不能以http://或https://开头。'),
      fullNatEntryStatus?: string(name='FullNatEntryStatus'),
      ipProtocol?: string(name='IpProtocol', description='协议类型，取值： • TCP：转发TCP协议的报文。 • UDP：转发UDP协议的报文。'),
      natIp?: string(name='NatIp', description='DNAT条目中提供公网访问的公网IP地址。'),
      natIpPort?: string(name='NatIpPort', description='DNAT条目中进行端口转发的外部端口，取值范围：1~65535。'),
      networkInterfaceId?: string(name='NetworkInterfaceId', description='当前VpcNat作为服务资源所加入的eni'),
      networkInterfaceType?: string(name='NetworkInterfaceType', description='ENI类型，目前仅支持Endpoint'),
    }
  ](name='FullNatEntries'),
  fullNatTableId?: string(name='FullNatTableId'),
  maxResults?: long(name='MaxResults'),
  natGatewayId?: string(name='NatGatewayId'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListFullNatEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFullNatEntriesResponseBody(name='body'),
}

async function listFullNatEntriesWithOptions(request: ListFullNatEntriesRequest, runtime: Util.RuntimeOptions): ListFullNatEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFullNatEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFullNatEntries(request: ListFullNatEntriesRequest): ListFullNatEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFullNatEntriesWithOptions(request, runtime);
}

model ListGatewayRouteTableEntriesRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  gatewayRouteTableId?: string(name='GatewayRouteTableId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListGatewayRouteTableEntriesResponseBody = {
  gatewayRouteEntryModels?: [ 
    {
      description?: string(name='Description'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      name?: string(name='Name'),
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
      status?: string(name='Status'),
    }
  ](name='GatewayRouteEntryModels'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListGatewayRouteTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayRouteTableEntriesResponseBody(name='body'),
}

async function listGatewayRouteTableEntriesWithOptions(request: ListGatewayRouteTableEntriesRequest, runtime: Util.RuntimeOptions): ListGatewayRouteTableEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListGatewayRouteTableEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listGatewayRouteTableEntries(request: ListGatewayRouteTableEntriesRequest): ListGatewayRouteTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayRouteTableEntriesWithOptions(request, runtime);
}

model ListIpsecServersRequest {
  ipsecServerId?: [ string ](name='IpsecServerId'),
  ipsecServerName?: string(name='IpsecServerName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ListIpsecServersResponseBody = {
  ipsecServers?: [ 
    {
      clientIpPool?: string(name='ClientIpPool'),
      creationTime?: string(name='CreationTime'),
      effectImmediately?: boolean(name='EffectImmediately'),
      IDaaSInstanceId?: string(name='IDaaSInstanceId'),
      ikeConfig?: {
        ikeAuthAlg?: string(name='IkeAuthAlg'),
        ikeEncAlg?: string(name='IkeEncAlg'),
        ikeLifetime?: long(name='IkeLifetime'),
        ikeMode?: string(name='IkeMode'),
        ikePfs?: string(name='IkePfs'),
        ikeVersion?: string(name='IkeVersion'),
        localId?: string(name='LocalId'),
        remoteId?: string(name='RemoteId'),
      }(name='IkeConfig'),
      internetIp?: string(name='InternetIp'),
      ipsecConfig?: {
        ipsecAuthAlg?: string(name='IpsecAuthAlg'),
        ipsecEncAlg?: string(name='IpsecEncAlg'),
        ipsecLifetime?: long(name='IpsecLifetime'),
        ipsecPfs?: string(name='IpsecPfs'),
      }(name='IpsecConfig'),
      ipsecServerId?: string(name='IpsecServerId'),
      ipsecServerName?: string(name='IpsecServerName'),
      localSubnet?: string(name='LocalSubnet'),
      maxConnections?: int32(name='MaxConnections'),
      multiFactorAuthEnabled?: boolean(name='MultiFactorAuthEnabled'),
      onlineClientCount?: int32(name='OnlineClientCount'),
      psk?: string(name='Psk'),
      pskEnabled?: boolean(name='PskEnabled'),
      regionId?: string(name='RegionId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='IpsecServers'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIpsecServersResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpsecServersResponseBody(name='body'),
}

async function listIpsecServersWithOptions(request: ListIpsecServersRequest, runtime: Util.RuntimeOptions): ListIpsecServersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListIpsecServers', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listIpsecServers(request: ListIpsecServersRequest): ListIpsecServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpsecServersWithOptions(request, runtime);
}

model ListIpv4GatewaysRequest {
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ipv4GatewayName?: string(name='Ipv4GatewayName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model ListIpv4GatewaysResponseBody = {
  ipv4GatewayModels?: [ 
    {
      enabled?: boolean(name='Enabled'),
      gmtCreate?: string(name='GmtCreate'),
      ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
      ipv4GatewayId?: string(name='Ipv4GatewayId'),
      ipv4GatewayName?: string(name='Ipv4GatewayName'),
      ipv4GatewayRouteTableId?: string(name='Ipv4GatewayRouteTableId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Ipv4GatewayModels'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListIpv4GatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpv4GatewaysResponseBody(name='body'),
}

async function listIpv4GatewaysWithOptions(request: ListIpv4GatewaysRequest, runtime: Util.RuntimeOptions): ListIpv4GatewaysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListIpv4Gateways', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listIpv4Gateways(request: ListIpv4GatewaysRequest): ListIpv4GatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpv4GatewaysWithOptions(request, runtime);
}

model ListNatGatewayEcsMetricRequest {
  dryRun?: boolean(name='DryRun'),
  maxResults?: string(name='MaxResults'),
  natGatewayId?: string(name='NatGatewayId'),
  nextToken?: string(name='NextToken'),
  orderKey?: string(name='OrderKey'),
  orderType?: string(name='OrderType'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  timePoint?: long(name='TimePoint'),
}

model ListNatGatewayEcsMetricResponseBody = {
  maxResults?: int32(name='MaxResults'),
  metricDataList?: [ 
    {
      activeSessionNum?: long(name='ActiveSessionNum'),
      natGatewayId?: string(name='NatGatewayId'),
      newSessionRate?: long(name='NewSessionRate'),
      privateIpAddress?: string(name='PrivateIpAddress'),
      rxBps?: long(name='RxBps'),
      rxPps?: long(name='RxPps'),
      timestamp?: long(name='Timestamp'),
      txBps?: long(name='TxBps'),
      txPps?: long(name='TxPps'),
    }
  ](name='MetricDataList'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  body: ListNatGatewayEcsMetricResponseBody(name='body'),
}

async function listNatGatewayEcsMetricWithOptions(request: ListNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): ListNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNatGatewayEcsMetric', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNatGatewayEcsMetric(request: ListNatGatewayEcsMetricRequest): ListNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNatGatewayEcsMetricWithOptions(request, runtime);
}

model ListNatIpCidrsRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  maxResults?: string(name='MaxResults'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpCidrName?: [ string ](name='NatIpCidrName'),
  natIpCidrStatus?: string(name='NatIpCidrStatus'),
  natIpCidrs?: [ string ](name='NatIpCidrs'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListNatIpCidrsResponseBody = {
  natIpCidrs?: [ 
    {
      creationTime?: string(name='CreationTime'),
      isDefault?: boolean(name='IsDefault'),
      natGatewayId?: string(name='NatGatewayId'),
      natIpCidr?: string(name='NatIpCidr'),
      natIpCidrDescription?: string(name='NatIpCidrDescription'),
      natIpCidrId?: string(name='NatIpCidrId'),
      natIpCidrName?: string(name='NatIpCidrName'),
      natIpCidrStatus?: string(name='NatIpCidrStatus'),
    }
  ](name='NatIpCidrs'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListNatIpCidrsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNatIpCidrsResponseBody(name='body'),
}

async function listNatIpCidrsWithOptions(request: ListNatIpCidrsRequest, runtime: Util.RuntimeOptions): ListNatIpCidrsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNatIpCidrs', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNatIpCidrs(request: ListNatIpCidrsRequest): ListNatIpCidrsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNatIpCidrsWithOptions(request, runtime);
}

model ListNatIpsRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  maxResults?: string(name='MaxResults'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpIds?: [ string ](name='NatIpIds'),
  natIpName?: [ string ](name='NatIpName'),
  natIpStatus?: string(name='NatIpStatus'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListNatIpsResponseBody = {
  natIps?: [ 
    {
      isDefault?: boolean(name='IsDefault'),
      natGatewayId?: string(name='NatGatewayId'),
      natIp?: string(name='NatIp'),
      natIpCidr?: string(name='NatIpCidr'),
      natIpDescription?: string(name='NatIpDescription'),
      natIpId?: string(name='NatIpId'),
      natIpName?: string(name='NatIpName'),
      natIpStatus?: string(name='NatIpStatus'),
    }
  ](name='NatIps'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListNatIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNatIpsResponseBody(name='body'),
}

async function listNatIpsWithOptions(request: ListNatIpsRequest, runtime: Util.RuntimeOptions): ListNatIpsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNatIps', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNatIps(request: ListNatIpsRequest): ListNatIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNatIpsWithOptions(request, runtime);
}

model ListPhysicalConnectionFeaturesRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListPhysicalConnectionFeaturesResponseBody = {
  physicalConnectionFeatures?: [ 
    {
      featureKey?: string(name='FeatureKey'),
      featureValue?: string(name='FeatureValue'),
    }
  ](name='PhysicalConnectionFeatures'),
  requestId?: string(name='RequestId'),
}

model ListPhysicalConnectionFeaturesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPhysicalConnectionFeaturesResponseBody(name='body'),
}

async function listPhysicalConnectionFeaturesWithOptions(request: ListPhysicalConnectionFeaturesRequest, runtime: Util.RuntimeOptions): ListPhysicalConnectionFeaturesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListPhysicalConnectionFeatures', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listPhysicalConnectionFeatures(request: ListPhysicalConnectionFeaturesRequest): ListPhysicalConnectionFeaturesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPhysicalConnectionFeaturesWithOptions(request, runtime);
}

model ListPrefixListsRequest {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  prefixListIds?: [ string ](name='PrefixListIds', description='前缀列表的实例ID'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListPrefixListsResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  prefixLists?: [ 
    {
      cidrBlocks?: [ string ](name='CidrBlocks', description='前缀列表包含的网段'),
      creationTime?: string(name='CreationTime', description='创建时间'),
      ipVersion?: string(name='IpVersion', description='IpVersion'),
      prefixListDescription?: string(name='PrefixListDescription', description='描述'),
      prefixListId?: string(name='PrefixListId', description='前缀列表的实例ID'),
      prefixListName?: string(name='PrefixListName', description='名称'),
      prefixListStatus?: string(name='PrefixListStatus', description='状态'),
    }
  ](name='PrefixLists'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListPrefixListsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPrefixListsResponseBody(name='body'),
}

async function listPrefixListsWithOptions(request: ListPrefixListsRequest, runtime: Util.RuntimeOptions): ListPrefixListsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListPrefixLists', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listPrefixLists(request: ListPrefixListsRequest): ListPrefixListsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrefixListsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagResources', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTrafficMirrorFiltersRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterIds?: [ string ](name='TrafficMirrorFilterIds'),
  trafficMirrorFilterName?: string(name='TrafficMirrorFilterName'),
}

model ListTrafficMirrorFiltersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
  trafficMirrorFilters?: [ 
    {
      egressRules?: [ 
        {
          action?: string(name='Action'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          destinationPortRange?: string(name='DestinationPortRange'),
          priority?: int32(name='Priority'),
          protocol?: string(name='Protocol'),
          sourceCidrBlock?: string(name='SourceCidrBlock'),
          sourcePortRange?: string(name='SourcePortRange'),
          trafficDirection?: string(name='TrafficDirection'),
          trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
          trafficMirrorFilterRuleId?: string(name='TrafficMirrorFilterRuleId'),
          trafficMirrorFilterRuleStatus?: string(name='TrafficMirrorFilterRuleStatus'),
        }
      ](name='EgressRules'),
      ingressRules?: [ 
        {
          action?: string(name='Action'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          destinationPortRange?: string(name='DestinationPortRange'),
          priority?: int32(name='Priority'),
          protocol?: string(name='Protocol'),
          sourceCidrBlock?: string(name='SourceCidrBlock'),
          sourcePortRange?: string(name='SourcePortRange'),
          trafficDirection?: string(name='TrafficDirection'),
          trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
          trafficMirrorFilterRuleId?: string(name='TrafficMirrorFilterRuleId'),
          trafficMirrorFilterRuleStatus?: string(name='TrafficMirrorFilterRuleStatus'),
        }
      ](name='IngressRules'),
      trafficMirrorFilterDescription?: string(name='TrafficMirrorFilterDescription'),
      trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
      trafficMirrorFilterName?: string(name='TrafficMirrorFilterName'),
      trafficMirrorFilterStatus?: string(name='TrafficMirrorFilterStatus'),
    }
  ](name='TrafficMirrorFilters'),
}

model ListTrafficMirrorFiltersResponse = {
  headers: map[string]string(name='headers'),
  body: ListTrafficMirrorFiltersResponseBody(name='body'),
}

async function listTrafficMirrorFiltersWithOptions(request: ListTrafficMirrorFiltersRequest, runtime: Util.RuntimeOptions): ListTrafficMirrorFiltersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTrafficMirrorFilters', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTrafficMirrorFilters(request: ListTrafficMirrorFiltersRequest): ListTrafficMirrorFiltersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTrafficMirrorFiltersWithOptions(request, runtime);
}

model ListTrafficMirrorSessionsRequest {
  enabled?: boolean(name='Enabled'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorSessionIds?: [ string ](name='TrafficMirrorSessionIds'),
  trafficMirrorSessionName?: string(name='TrafficMirrorSessionName'),
  trafficMirrorSourceId?: string(name='TrafficMirrorSourceId'),
  trafficMirrorTargetId?: string(name='TrafficMirrorTargetId'),
  virtualNetworkId?: int32(name='VirtualNetworkId'),
}

model ListTrafficMirrorSessionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
  trafficMirrorSessions?: [ 
    {
      enabled?: boolean(name='Enabled'),
      packetLength?: int32(name='PacketLength'),
      priority?: int32(name='Priority'),
      trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
      trafficMirrorSessionBusinessStatus?: string(name='TrafficMirrorSessionBusinessStatus'),
      trafficMirrorSessionDescription?: string(name='TrafficMirrorSessionDescription'),
      trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
      trafficMirrorSessionName?: string(name='TrafficMirrorSessionName'),
      trafficMirrorSessionStatus?: string(name='TrafficMirrorSessionStatus'),
      trafficMirrorSourceIds?: [ string ](name='TrafficMirrorSourceIds'),
      trafficMirrorTargetId?: string(name='TrafficMirrorTargetId'),
      trafficMirrorTargetType?: string(name='TrafficMirrorTargetType'),
      virtualNetworkId?: int32(name='VirtualNetworkId'),
    }
  ](name='TrafficMirrorSessions'),
}

model ListTrafficMirrorSessionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTrafficMirrorSessionsResponseBody(name='body'),
}

async function listTrafficMirrorSessionsWithOptions(request: ListTrafficMirrorSessionsRequest, runtime: Util.RuntimeOptions): ListTrafficMirrorSessionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTrafficMirrorSessions', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTrafficMirrorSessions(request: ListTrafficMirrorSessionsRequest): ListTrafficMirrorSessionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTrafficMirrorSessionsWithOptions(request, runtime);
}

model ListVirtualPhysicalConnectionsRequest {
  isConfirmed?: boolean(name='IsConfirmed', description='Vpconn是否被确认'),
  maxResults?: int32(name='MaxResults', description='单次查询最大量'),
  nextToken?: string(name='NextToken', description='单次查询最大量'),
  physicalConnectionId?: string(name='PhysicalConnectionId', description='Vpconn的主Pconn'),
  regionId?: string(name='RegionId'),
  virtualPhysicalConnectionAliUids?: [ string ](name='VirtualPhysicalConnectionAliUids', description='Vpconn的OwnerUid'),
  virtualPhysicalConnectionBusinessStatus?: string(name='VirtualPhysicalConnectionBusinessStatus', description='Vpconn的商业状态'),
  virtualPhysicalConnectionIds?: [ string ](name='VirtualPhysicalConnectionIds', description='根据Vpconn的ID列表过滤'),
  virtualPhysicalConnectionStatuses?: [ string ](name='VirtualPhysicalConnectionStatuses', description='Vpconn的状态'),
  vlanIds?: [ string ](name='VlanIds', description='Vpconn的vlanId'),
}

model ListVirtualPhysicalConnectionsResponseBody = {
  count?: int32(name='Count', description='本次查询数量'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount', description='总数'),
  virtualPhysicalConnections?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      adLocation?: string(name='AdLocation'),
      aliUid?: string(name='AliUid'),
      bandwidth?: long(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      enabledTime?: string(name='EnabledTime'),
      endTime?: string(name='EndTime'),
      lineOperator?: string(name='LineOperator'),
      loaStatus?: string(name='LoaStatus'),
      name?: string(name='Name'),
      orderMode?: string(name='OrderMode'),
      parentPhysicalConnectionAliUid?: string(name='ParentPhysicalConnectionAliUid'),
      parentPhysicalConnectionId?: string(name='ParentPhysicalConnectionId'),
      peerLocation?: string(name='PeerLocation'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      portNumber?: string(name='PortNumber'),
      portType?: string(name='PortType'),
      productType?: string(name='ProductType'),
      redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      virtualPhysicalConnectionStatus?: string(name='VirtualPhysicalConnectionStatus'),
      vlanId?: string(name='VlanId'),
    }
  ](name='VirtualPhysicalConnections', description='Vpconn'),
}

model ListVirtualPhysicalConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVirtualPhysicalConnectionsResponseBody(name='body'),
}

async function listVirtualPhysicalConnectionsWithOptions(request: ListVirtualPhysicalConnectionsRequest, runtime: Util.RuntimeOptions): ListVirtualPhysicalConnectionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVirtualPhysicalConnections', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVirtualPhysicalConnections(request: ListVirtualPhysicalConnectionsRequest): ListVirtualPhysicalConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirtualPhysicalConnectionsWithOptions(request, runtime);
}

model ListVpcEndpointServicesByEndUserRequest {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceName?: string(name='ServiceName'),
}

model ListVpcEndpointServicesByEndUserResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  services?: [ 
    {
      defaultPolicyDocument?: string(name='DefaultPolicyDocument'),
      serviceDomain?: string(name='ServiceDomain'),
      serviceId?: string(name='ServiceId'),
      serviceName?: string(name='ServiceName'),
      supportPolicy?: boolean(name='SupportPolicy'),
    }
  ](name='Services'),
}

model ListVpcEndpointServicesByEndUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointServicesByEndUserResponseBody(name='body'),
}

async function listVpcEndpointServicesByEndUserWithOptions(request: ListVpcEndpointServicesByEndUserRequest, runtime: Util.RuntimeOptions): ListVpcEndpointServicesByEndUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcEndpointServicesByEndUser', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcEndpointServicesByEndUser(request: ListVpcEndpointServicesByEndUserRequest): ListVpcEndpointServicesByEndUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointServicesByEndUserWithOptions(request, runtime);
}

model ListVpcGatewayEndpointsRequest {
  endpointId?: string(name='EndpointId', description='VPC网关实例ID'),
  endpointName?: string(name='EndpointName', description='VPC网关实例名称'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceName?: string(name='ServiceName', description='后端的服务名称'),
}

model ListVpcGatewayEndpointsResponseBody = {
  endpoints?: [ 
    {
      associatedRouteTables?: [ string ](name='AssociatedRouteTables'),
      creationTime?: string(name='CreationTime'),
      endpointDescription?: string(name='EndpointDescription'),
      endpointId?: string(name='EndpointId'),
      endpointName?: string(name='EndpointName'),
      endpointStatus?: string(name='EndpointStatus'),
      policyDocument?: string(name='PolicyDocument'),
      serviceName?: string(name='ServiceName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Endpoints'),
  maxResults?: long(name='MaxResults', description='本次请求最大数量'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListVpcGatewayEndpointsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcGatewayEndpointsResponseBody(name='body'),
}

async function listVpcGatewayEndpointsWithOptions(request: ListVpcGatewayEndpointsRequest, runtime: Util.RuntimeOptions): ListVpcGatewayEndpointsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpcGatewayEndpoints', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpcGatewayEndpoints(request: ListVpcGatewayEndpointsRequest): ListVpcGatewayEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcGatewayEndpointsWithOptions(request, runtime);
}

model ListVpnCertificateAssociationsRequest {
  certificateId?: [ string ](name='CertificateId'),
  certificateType?: string(name='CertificateType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: [ string ](name='VpnGatewayId'),
}

model ListVpnCertificateAssociationsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnCertificateRelations?: [ 
    {
      associationTime?: string(name='AssociationTime'),
      certificateId?: string(name='CertificateId'),
      certificateType?: string(name='CertificateType'),
      regionId?: string(name='RegionId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='VpnCertificateRelations'),
}

model ListVpnCertificateAssociationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpnCertificateAssociationsResponseBody(name='body'),
}

async function listVpnCertificateAssociationsWithOptions(request: ListVpnCertificateAssociationsRequest, runtime: Util.RuntimeOptions): ListVpnCertificateAssociationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVpnCertificateAssociations', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVpnCertificateAssociations(request: ListVpnCertificateAssociationsRequest): ListVpnCertificateAssociationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpnCertificateAssociationsWithOptions(request, runtime);
}

model ModifyBgpGroupAttributeRequest {
  authKey?: string(name='AuthKey'),
  bgpGroupId?: string(name='BgpGroupId'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  isFakeAsn?: boolean(name='IsFakeAsn'),
  localAsn?: long(name='LocalAsn'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerAsn?: long(name='PeerAsn'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyBgpGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBgpGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBgpGroupAttributeResponseBody(name='body'),
}

async function modifyBgpGroupAttributeWithOptions(request: ModifyBgpGroupAttributeRequest, runtime: Util.RuntimeOptions): ModifyBgpGroupAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyBgpGroupAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyBgpGroupAttribute(request: ModifyBgpGroupAttributeRequest): ModifyBgpGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBgpGroupAttributeWithOptions(request, runtime);
}

model ModifyBgpPeerAttributeRequest {
  bfdMultiHop?: int32(name='BfdMultiHop'),
  bgpGroupId?: string(name='BgpGroupId'),
  bgpPeerId?: string(name='BgpPeerId'),
  clientToken?: string(name='ClientToken'),
  enableBfd?: boolean(name='EnableBfd'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerIpAddress?: string(name='PeerIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyBgpPeerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBgpPeerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBgpPeerAttributeResponseBody(name='body'),
}

async function modifyBgpPeerAttributeWithOptions(request: ModifyBgpPeerAttributeRequest, runtime: Util.RuntimeOptions): ModifyBgpPeerAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyBgpPeerAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyBgpPeerAttribute(request: ModifyBgpPeerAttributeRequest): ModifyBgpPeerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBgpPeerAttributeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageAttributeRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyCommonBandwidthPackageAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageAttributeResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageAttributeWithOptions(request: ModifyCommonBandwidthPackageAttributeRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackageAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackageAttribute(request: ModifyCommonBandwidthPackageAttributeRequest): ModifyCommonBandwidthPackageAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageAttributeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageInternetChargeTypeRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  ratio?: int32(name='Ratio'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyCommonBandwidthPackageInternetChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageInternetChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageInternetChargeTypeResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageInternetChargeTypeWithOptions(request: ModifyCommonBandwidthPackageInternetChargeTypeRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageInternetChargeTypeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackageInternetChargeType', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackageInternetChargeType(request: ModifyCommonBandwidthPackageInternetChargeTypeRequest): ModifyCommonBandwidthPackageInternetChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageInternetChargeTypeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageIpBandwidthRequest {
  bandwidth?: string(name='Bandwidth'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  eipId?: string(name='EipId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyCommonBandwidthPackageIpBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageIpBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageIpBandwidthResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageIpBandwidthWithOptions(request: ModifyCommonBandwidthPackageIpBandwidthRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageIpBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackageIpBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackageIpBandwidth(request: ModifyCommonBandwidthPackageIpBandwidthRequest): ModifyCommonBandwidthPackageIpBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackagePayTypeRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: string(name='Bandwidth'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  duration?: int32(name='Duration'),
  kbpsBandwidth?: string(name='KbpsBandwidth'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceBid?: string(name='ResourceBid'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceUid?: long(name='ResourceUid'),
}

model ModifyCommonBandwidthPackagePayTypeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackagePayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackagePayTypeResponseBody(name='body'),
}

async function modifyCommonBandwidthPackagePayTypeWithOptions(request: ModifyCommonBandwidthPackagePayTypeRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackagePayTypeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackagePayType', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackagePayType(request: ModifyCommonBandwidthPackagePayTypeRequest): ModifyCommonBandwidthPackagePayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackagePayTypeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageSpecRequest {
  bandwidth?: string(name='Bandwidth'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyCommonBandwidthPackageSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageSpecResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageSpecWithOptions(request: ModifyCommonBandwidthPackageSpecRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageSpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCommonBandwidthPackageSpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCommonBandwidthPackageSpec(request: ModifyCommonBandwidthPackageSpecRequest): ModifyCommonBandwidthPackageSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageSpecWithOptions(request, runtime);
}

model ModifyCustomerGatewayAttributeRequest {
  authKey?: string(name='AuthKey'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyCustomerGatewayAttributeResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model ModifyCustomerGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCustomerGatewayAttributeResponseBody(name='body'),
}

async function modifyCustomerGatewayAttributeWithOptions(request: ModifyCustomerGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyCustomerGatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyCustomerGatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyCustomerGatewayAttribute(request: ModifyCustomerGatewayAttributeRequest): ModifyCustomerGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCustomerGatewayAttributeWithOptions(request, runtime);
}

model ModifyEipAddressAttributeRequest {
  allocationId?: string(name='AllocationId'),
  bandwidth?: string(name='Bandwidth'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyEipAddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEipAddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEipAddressAttributeResponseBody(name='body'),
}

async function modifyEipAddressAttributeWithOptions(request: ModifyEipAddressAttributeRequest, runtime: Util.RuntimeOptions): ModifyEipAddressAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyEipAddressAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyEipAddressAttribute(request: ModifyEipAddressAttributeRequest): ModifyEipAddressAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEipAddressAttributeWithOptions(request, runtime);
}

model ModifyExpressCloudConnectionAttributeRequest {
  bgpAs?: string(name='BgpAs'),
  ceIp?: string(name='CeIp'),
  description?: string(name='Description'),
  eccId?: string(name='EccId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peIp?: string(name='PeIp'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyExpressCloudConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExpressCloudConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyExpressCloudConnectionAttributeResponseBody(name='body'),
}

async function modifyExpressCloudConnectionAttributeWithOptions(request: ModifyExpressCloudConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyExpressCloudConnectionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyExpressCloudConnectionAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyExpressCloudConnectionAttribute(request: ModifyExpressCloudConnectionAttributeRequest): ModifyExpressCloudConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyExpressCloudConnectionAttributeWithOptions(request, runtime);
}

model ModifyExpressCloudConnectionBandwidthRequest {
  bandwidth?: string(name='Bandwidth'),
  eccId?: string(name='EccId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyExpressCloudConnectionBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExpressCloudConnectionBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyExpressCloudConnectionBandwidthResponseBody(name='body'),
}

async function modifyExpressCloudConnectionBandwidthWithOptions(request: ModifyExpressCloudConnectionBandwidthRequest, runtime: Util.RuntimeOptions): ModifyExpressCloudConnectionBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyExpressCloudConnectionBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyExpressCloudConnectionBandwidth(request: ModifyExpressCloudConnectionBandwidthRequest): ModifyExpressCloudConnectionBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyExpressCloudConnectionBandwidthWithOptions(request, runtime);
}

model ModifyFlowLogAttributeRequest {
  description?: string(name='Description'),
  flowLogId?: string(name='FlowLogId'),
  flowLogName?: string(name='FlowLogName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyFlowLogAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ModifyFlowLogAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowLogAttributeResponseBody(name='body'),
}

async function modifyFlowLogAttributeWithOptions(request: ModifyFlowLogAttributeRequest, runtime: Util.RuntimeOptions): ModifyFlowLogAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFlowLogAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFlowLogAttribute(request: ModifyFlowLogAttributeRequest): ModifyFlowLogAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowLogAttributeWithOptions(request, runtime);
}

model ModifyForwardEntryRequest {
  clientToken?: string(name='ClientToken'),
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  forwardEntryId?: string(name='ForwardEntryId'),
  forwardEntryName?: string(name='ForwardEntryName'),
  forwardTableId?: string(name='ForwardTableId'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  portBreak?: boolean(name='PortBreak'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyForwardEntryResponseBody(name='body'),
}

async function modifyForwardEntryWithOptions(request: ModifyForwardEntryRequest, runtime: Util.RuntimeOptions): ModifyForwardEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyForwardEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyForwardEntry(request: ModifyForwardEntryRequest): ModifyForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyForwardEntryWithOptions(request, runtime);
}

model ModifyFullNatEntryAttributeRequest {
  accessIp?: string(name='AccessIp'),
  accessPort?: string(name='AccessPort'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  fullNatEntryDescription?: string(name='FullNatEntryDescription'),
  fullNatEntryId?: string(name='FullNatEntryId'),
  fullNatEntryName?: string(name='FullNatEntryName'),
  fullNatTableId?: string(name='FullNatTableId'),
  ipProtocol?: string(name='IpProtocol'),
  natIp?: string(name='NatIp'),
  natIpPort?: string(name='NatIpPort'),
  networkInterfaceId?: string(name='NetworkInterfaceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyFullNatEntryAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyFullNatEntryAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFullNatEntryAttributeResponseBody(name='body'),
}

async function modifyFullNatEntryAttributeWithOptions(request: ModifyFullNatEntryAttributeRequest, runtime: Util.RuntimeOptions): ModifyFullNatEntryAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFullNatEntryAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFullNatEntryAttribute(request: ModifyFullNatEntryAttributeRequest): ModifyFullNatEntryAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFullNatEntryAttributeWithOptions(request, runtime);
}

model ModifyGlobalAccelerationInstanceAttributesRequest {
  description?: string(name='Description'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyGlobalAccelerationInstanceAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyGlobalAccelerationInstanceAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGlobalAccelerationInstanceAttributesResponseBody(name='body'),
}

async function modifyGlobalAccelerationInstanceAttributesWithOptions(request: ModifyGlobalAccelerationInstanceAttributesRequest, runtime: Util.RuntimeOptions): ModifyGlobalAccelerationInstanceAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyGlobalAccelerationInstanceAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyGlobalAccelerationInstanceAttributes(request: ModifyGlobalAccelerationInstanceAttributesRequest): ModifyGlobalAccelerationInstanceAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalAccelerationInstanceAttributesWithOptions(request, runtime);
}

model ModifyGlobalAccelerationInstanceSpecRequest {
  bandwidth?: string(name='Bandwidth'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyGlobalAccelerationInstanceSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyGlobalAccelerationInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGlobalAccelerationInstanceSpecResponseBody(name='body'),
}

async function modifyGlobalAccelerationInstanceSpecWithOptions(request: ModifyGlobalAccelerationInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyGlobalAccelerationInstanceSpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyGlobalAccelerationInstanceSpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyGlobalAccelerationInstanceSpec(request: ModifyGlobalAccelerationInstanceSpecRequest): ModifyGlobalAccelerationInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalAccelerationInstanceSpecWithOptions(request, runtime);
}

model ModifyHaVipAttributeRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  haVipId?: string(name='HaVipId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyHaVipAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHaVipAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHaVipAttributeResponseBody(name='body'),
}

async function modifyHaVipAttributeWithOptions(request: ModifyHaVipAttributeRequest, runtime: Util.RuntimeOptions): ModifyHaVipAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyHaVipAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyHaVipAttribute(request: ModifyHaVipAttributeRequest): ModifyHaVipAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHaVipAttributeWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAclAttributeRequest {
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIPv6TranslatorAclAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAclAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorAclAttributeResponseBody(name='body'),
}

async function modifyIPv6TranslatorAclAttributeWithOptions(request: ModifyIPv6TranslatorAclAttributeRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAclAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorAclAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorAclAttribute(request: ModifyIPv6TranslatorAclAttributeRequest): ModifyIPv6TranslatorAclAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAclAttributeWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAclListEntryRequest {
  aclEntryComment?: string(name='AclEntryComment'),
  aclEntryId?: string(name='AclEntryId'),
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIPv6TranslatorAclListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function modifyIPv6TranslatorAclListEntryWithOptions(request: ModifyIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorAclListEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorAclListEntry(request: ModifyIPv6TranslatorAclListEntryRequest): ModifyIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAttributeRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIPv6TranslatorAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorAttributeResponseBody(name='body'),
}

async function modifyIPv6TranslatorAttributeWithOptions(request: ModifyIPv6TranslatorAttributeRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorAttribute(request: ModifyIPv6TranslatorAttributeRequest): ModifyIPv6TranslatorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAttributeWithOptions(request, runtime);
}

model ModifyIPv6TranslatorBandwidthRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIPv6TranslatorBandwidthResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorBandwidthResponseBody(name='body'),
}

async function modifyIPv6TranslatorBandwidthWithOptions(request: ModifyIPv6TranslatorBandwidthRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorBandwidth(request: ModifyIPv6TranslatorBandwidthRequest): ModifyIPv6TranslatorBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorBandwidthWithOptions(request, runtime);
}

model ModifyIPv6TranslatorEntryRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: int32(name='BackendIpv4Port'),
  entryBandwidth?: int32(name='EntryBandwidth'),
  entryDescription?: string(name='EntryDescription'),
  entryName?: string(name='EntryName'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  transProtocol?: string(name='TransProtocol'),
}

model ModifyIPv6TranslatorEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorEntryResponseBody(name='body'),
}

async function modifyIPv6TranslatorEntryWithOptions(request: ModifyIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIPv6TranslatorEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIPv6TranslatorEntry(request: ModifyIPv6TranslatorEntryRequest): ModifyIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorEntryWithOptions(request, runtime);
}

model ModifyInstanceAutoRenewalAttributeRequest {
  clientToken?: string(name='ClientToken'),
  duration?: int32(name='Duration'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerId?: long(name='OwnerId'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  renewalStatus?: string(name='RenewalStatus'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyInstanceAutoRenewalAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoRenewalAttributeResponseBody(name='body'),
}

async function modifyInstanceAutoRenewalAttributeWithOptions(request: ModifyInstanceAutoRenewalAttributeRequest, runtime: Util.RuntimeOptions): ModifyInstanceAutoRenewalAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyInstanceAutoRenewalAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyInstanceAutoRenewalAttribute(request: ModifyInstanceAutoRenewalAttributeRequest): ModifyInstanceAutoRenewalAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAutoRenewalAttributeWithOptions(request, runtime);
}

model ModifyIpv6AddressAttributeRequest {
  description?: string(name='Description'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIpv6AddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6AddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6AddressAttributeResponseBody(name='body'),
}

async function modifyIpv6AddressAttributeWithOptions(request: ModifyIpv6AddressAttributeRequest, runtime: Util.RuntimeOptions): ModifyIpv6AddressAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIpv6AddressAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIpv6AddressAttribute(request: ModifyIpv6AddressAttributeRequest): ModifyIpv6AddressAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6AddressAttributeWithOptions(request, runtime);
}

model ModifyIpv6GatewayAttributeRequest {
  description?: string(name='Description'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIpv6GatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6GatewayAttributeResponseBody(name='body'),
}

async function modifyIpv6GatewayAttributeWithOptions(request: ModifyIpv6GatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyIpv6GatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIpv6GatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIpv6GatewayAttribute(request: ModifyIpv6GatewayAttributeRequest): ModifyIpv6GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6GatewayAttributeWithOptions(request, runtime);
}

model ModifyIpv6GatewaySpecRequest {
  clientToken?: string(name='ClientToken'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
}

model ModifyIpv6GatewaySpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6GatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6GatewaySpecResponseBody(name='body'),
}

async function modifyIpv6GatewaySpecWithOptions(request: ModifyIpv6GatewaySpecRequest, runtime: Util.RuntimeOptions): ModifyIpv6GatewaySpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIpv6GatewaySpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIpv6GatewaySpec(request: ModifyIpv6GatewaySpecRequest): ModifyIpv6GatewaySpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6GatewaySpecWithOptions(request, runtime);
}

model ModifyIpv6InternetBandwidthRequest {
  bandwidth?: long(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIpv6InternetBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6InternetBandwidthResponseBody(name='body'),
}

async function modifyIpv6InternetBandwidthWithOptions(request: ModifyIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): ModifyIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyIpv6InternetBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyIpv6InternetBandwidth(request: ModifyIpv6InternetBandwidthRequest): ModifyIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6InternetBandwidthWithOptions(request, runtime);
}

model ModifyNatGatewayAttributeRequest {
  description?: string(name='Description'),
  icmpReplyEnabled?: boolean(name='IcmpReplyEnabled'),
  name?: string(name='Name'),
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyNatGatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatGatewayAttributeResponseBody(name='body'),
}

async function modifyNatGatewayAttributeWithOptions(request: ModifyNatGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyNatGatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyNatGatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyNatGatewayAttribute(request: ModifyNatGatewayAttributeRequest): ModifyNatGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatGatewayAttributeWithOptions(request, runtime);
}

model ModifyNatGatewaySpecRequest {
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
}

model ModifyNatGatewaySpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatGatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatGatewaySpecResponseBody(name='body'),
}

async function modifyNatGatewaySpecWithOptions(request: ModifyNatGatewaySpecRequest, runtime: Util.RuntimeOptions): ModifyNatGatewaySpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyNatGatewaySpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyNatGatewaySpec(request: ModifyNatGatewaySpecRequest): ModifyNatGatewaySpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatGatewaySpecWithOptions(request, runtime);
}

model ModifyNatIpAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natIpDescription?: string(name='NatIpDescription'),
  natIpId?: string(name='NatIpId'),
  natIpName?: string(name='NatIpName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyNatIpAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatIpAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatIpAttributeResponseBody(name='body'),
}

async function modifyNatIpAttributeWithOptions(request: ModifyNatIpAttributeRequest, runtime: Util.RuntimeOptions): ModifyNatIpAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyNatIpAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyNatIpAttribute(request: ModifyNatIpAttributeRequest): ModifyNatIpAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatIpAttributeWithOptions(request, runtime);
}

model ModifyNatIpCidrAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpCidrDescription?: string(name='NatIpCidrDescription'),
  natIpCidrName?: string(name='NatIpCidrName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyNatIpCidrAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatIpCidrAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatIpCidrAttributeResponseBody(name='body'),
}

async function modifyNatIpCidrAttributeWithOptions(request: ModifyNatIpCidrAttributeRequest, runtime: Util.RuntimeOptions): ModifyNatIpCidrAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyNatIpCidrAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyNatIpCidrAttribute(request: ModifyNatIpCidrAttributeRequest): ModifyNatIpCidrAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatIpCidrAttributeWithOptions(request, runtime);
}

model ModifyNetworkAclAttributesRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  networkAclId?: string(name='NetworkAclId'),
  networkAclName?: string(name='NetworkAclName'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyNetworkAclAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkAclAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkAclAttributesResponseBody(name='body'),
}

async function modifyNetworkAclAttributesWithOptions(request: ModifyNetworkAclAttributesRequest, runtime: Util.RuntimeOptions): ModifyNetworkAclAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyNetworkAclAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyNetworkAclAttributes(request: ModifyNetworkAclAttributesRequest): ModifyNetworkAclAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNetworkAclAttributesWithOptions(request, runtime);
}

model ModifyPhysicalConnectionAttributeRequest {
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  lineOperator?: string(name='LineOperator'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerLocation?: string(name='PeerLocation'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  portType?: string(name='PortType'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bandwidth?: int32(name='bandwidth'),
}

model ModifyPhysicalConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPhysicalConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPhysicalConnectionAttributeResponseBody(name='body'),
}

async function modifyPhysicalConnectionAttributeWithOptions(request: ModifyPhysicalConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyPhysicalConnectionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyPhysicalConnectionAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyPhysicalConnectionAttribute(request: ModifyPhysicalConnectionAttributeRequest): ModifyPhysicalConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPhysicalConnectionAttributeWithOptions(request, runtime);
}

model ModifyRouteEntryRequest {
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryId?: string(name='RouteEntryId'),
  routeEntryName?: string(name='RouteEntryName'),
}

model ModifyRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouteEntryResponseBody(name='body'),
}

async function modifyRouteEntryWithOptions(request: ModifyRouteEntryRequest, runtime: Util.RuntimeOptions): ModifyRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyRouteEntry(request: ModifyRouteEntryRequest): ModifyRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouteEntryWithOptions(request, runtime);
}

model ModifyRouteTableAttributesRequest {
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
}

model ModifyRouteTableAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouteTableAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouteTableAttributesResponseBody(name='body'),
}

async function modifyRouteTableAttributesWithOptions(request: ModifyRouteTableAttributesRequest, runtime: Util.RuntimeOptions): ModifyRouteTableAttributesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyRouteTableAttributes', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyRouteTableAttributes(request: ModifyRouteTableAttributesRequest): ModifyRouteTableAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouteTableAttributesWithOptions(request, runtime);
}

model ModifyRouterInterfaceAttributeRequest {
  deleteHealthCheckIp?: boolean(name='DeleteHealthCheckIp'),
  description?: string(name='Description'),
  hcRate?: int32(name='HcRate'),
  hcThreshold?: int32(name='HcThreshold'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  name?: string(name='Name'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeInterfaceOwnerId?: long(name='OppositeInterfaceOwnerId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model ModifyRouterInterfaceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceAttributeResponseBody(name='body'),
}

async function modifyRouterInterfaceAttributeWithOptions(request: ModifyRouterInterfaceAttributeRequest, runtime: Util.RuntimeOptions): ModifyRouterInterfaceAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyRouterInterfaceAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyRouterInterfaceAttribute(request: ModifyRouterInterfaceAttributeRequest): ModifyRouterInterfaceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouterInterfaceAttributeWithOptions(request, runtime);
}

model ModifyRouterInterfaceSpecRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
  spec?: string(name='Spec'),
}

model ModifyRouterInterfaceSpecResponseBody = {
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
}

model ModifyRouterInterfaceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceSpecResponseBody(name='body'),
}

async function modifyRouterInterfaceSpecWithOptions(request: ModifyRouterInterfaceSpecRequest, runtime: Util.RuntimeOptions): ModifyRouterInterfaceSpecResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyRouterInterfaceSpec', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyRouterInterfaceSpec(request: ModifyRouterInterfaceSpecRequest): ModifyRouterInterfaceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouterInterfaceSpecWithOptions(request, runtime);
}

model ModifySnatEntryRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snatEntryId?: string(name='SnatEntryId'),
  snatEntryName?: string(name='SnatEntryName'),
  snatIp?: string(name='SnatIp'),
  snatTableId?: string(name='SnatTableId'),
}

model ModifySnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySnatEntryResponseBody(name='body'),
}

async function modifySnatEntryWithOptions(request: ModifySnatEntryRequest, runtime: Util.RuntimeOptions): ModifySnatEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifySnatEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifySnatEntry(request: ModifySnatEntryRequest): ModifySnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySnatEntryWithOptions(request, runtime);
}

model ModifySslVpnClientCertRequest {
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model ModifySslVpnClientCertResponseBody = {
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model ModifySslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySslVpnClientCertResponseBody(name='body'),
}

async function modifySslVpnClientCertWithOptions(request: ModifySslVpnClientCertRequest, runtime: Util.RuntimeOptions): ModifySslVpnClientCertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifySslVpnClientCert', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifySslVpnClientCert(request: ModifySslVpnClientCertRequest): ModifySslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySslVpnClientCertWithOptions(request, runtime);
}

model ModifySslVpnServerRequest {
  cipher?: string(name='Cipher'),
  clientIpPool?: string(name='ClientIpPool'),
  clientToken?: string(name='ClientToken'),
  compress?: boolean(name='Compress'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
  IDaaSRegionId?: string(name='IDaaSRegionId'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: int32(name='Port'),
  proto?: string(name='Proto'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model ModifySslVpnServerResponseBody = {
  cipher?: string(name='Cipher'),
  clientIpPool?: string(name='ClientIpPool'),
  compress?: boolean(name='Compress'),
  connections?: int32(name='Connections'),
  createTime?: long(name='CreateTime'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
  internetIp?: string(name='InternetIp'),
  localSubnet?: string(name='LocalSubnet'),
  maxConnections?: int32(name='MaxConnections'),
  name?: string(name='Name'),
  port?: int32(name='Port'),
  proto?: string(name='Proto'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifySslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySslVpnServerResponseBody(name='body'),
}

async function modifySslVpnServerWithOptions(request: ModifySslVpnServerRequest, runtime: Util.RuntimeOptions): ModifySslVpnServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifySslVpnServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifySslVpnServer(request: ModifySslVpnServerRequest): ModifySslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySslVpnServerWithOptions(request, runtime);
}

model ModifyVRouterAttributeRequest {
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VRouterId?: string(name='VRouterId'),
  VRouterName?: string(name='VRouterName'),
}

model ModifyVRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVRouterAttributeResponseBody(name='body'),
}

async function modifyVRouterAttributeWithOptions(request: ModifyVRouterAttributeRequest, runtime: Util.RuntimeOptions): ModifyVRouterAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVRouterAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVRouterAttribute(request: ModifyVRouterAttributeRequest): ModifyVRouterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVRouterAttributeWithOptions(request, runtime);
}

model ModifyVSwitchAttributeRequest {
  description?: string(name='Description'),
  enableIPv6?: boolean(name='EnableIPv6'),
  ipv6CidrBlock?: int32(name='Ipv6CidrBlock'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  vpcIpv6CidrBlock?: string(name='VpcIpv6CidrBlock'),
}

model ModifyVSwitchAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVSwitchAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVSwitchAttributeResponseBody(name='body'),
}

async function modifyVSwitchAttributeWithOptions(request: ModifyVSwitchAttributeRequest, runtime: Util.RuntimeOptions): ModifyVSwitchAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVSwitchAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): ModifyVSwitchAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVSwitchAttributeWithOptions(request, runtime);
}

model ModifyVirtualBorderRouterAttributeRequest {
  associatedPhysicalConnections?: string(name='AssociatedPhysicalConnections'),
  bandwidth?: int32(name='Bandwidth'),
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  detectMultiplier?: long(name='DetectMultiplier'),
  enableIpv6?: boolean(name='EnableIpv6'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  minRxInterval?: long(name='MinRxInterval'),
  minTxInterval?: long(name='MinTxInterval'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
  vlanId?: int32(name='VlanId'),
}

model ModifyVirtualBorderRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVirtualBorderRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVirtualBorderRouterAttributeResponseBody(name='body'),
}

async function modifyVirtualBorderRouterAttributeWithOptions(request: ModifyVirtualBorderRouterAttributeRequest, runtime: Util.RuntimeOptions): ModifyVirtualBorderRouterAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVirtualBorderRouterAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVirtualBorderRouterAttribute(request: ModifyVirtualBorderRouterAttributeRequest): ModifyVirtualBorderRouterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVirtualBorderRouterAttributeWithOptions(request, runtime);
}

model ModifyVpcAttributeRequest {
  cidrBlock?: string(name='CidrBlock'),
  description?: string(name='Description'),
  enableIPv6?: boolean(name='EnableIPv6'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  ipv6Isp?: string(name='Ipv6Isp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
  vpcName?: string(name='VpcName'),
}

model ModifyVpcAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpcAttributeResponseBody(name='body'),
}

async function modifyVpcAttributeWithOptions(request: ModifyVpcAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpcAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpcAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpcAttribute(request: ModifyVpcAttributeRequest): ModifyVpcAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpcAttributeWithOptions(request, runtime);
}

model ModifyVpnConnectionAttributeRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  bgpConfig?: string(name='BgpConfig'),
  clientToken?: string(name='ClientToken'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
  remoteSubnet?: string(name='RemoteSubnet'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model ModifyVpnConnectionAttributeResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  ikeConfig?: {
    ikeAuthAlg?: string(name='IkeAuthAlg'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeMode?: string(name='IkeMode'),
    ikePfs?: string(name='IkePfs'),
    ikeVersion?: string(name='IkeVersion'),
    localId?: string(name='LocalId'),
    psk?: string(name='Psk'),
    remoteId?: string(name='RemoteId'),
  }(name='IkeConfig'),
  ipsecConfig?: {
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecPfs?: string(name='IpsecPfs'),
  }(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  remoteSubnet?: string(name='RemoteSubnet'),
  requestId?: string(name='RequestId'),
  vcoHealthCheck?: {
    dip?: string(name='Dip'),
    enable?: string(name='Enable'),
    interval?: int32(name='Interval'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig?: {
    enableBgp?: string(name='EnableBgp'),
    localAsn?: int32(name='LocalAsn'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: int32(name='PeerAsn'),
    peerBgpIp?: string(name='PeerBgpIp'),
    status?: string(name='Status'),
    tunnelCidr?: string(name='TunnelCidr'),
  }(name='VpnBgpConfig'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnConnectionAttributeResponseBody(name='body'),
}

async function modifyVpnConnectionAttributeWithOptions(request: ModifyVpnConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpnConnectionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpnConnectionAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpnConnectionAttribute(request: ModifyVpnConnectionAttributeRequest): ModifyVpnConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnConnectionAttributeWithOptions(request, runtime);
}

model ModifyVpnGatewayAttributeRequest {
  autoPropagate?: boolean(name='AutoPropagate'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnGatewayAttributeResponseBody = {
  autoPropagate?: boolean(name='AutoPropagate'),
  businessStatus?: string(name='BusinessStatus'),
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  enableBgp?: boolean(name='EnableBgp'),
  endTime?: long(name='EndTime'),
  internetIp?: string(name='InternetIp'),
  intranetIp?: string(name='IntranetIp'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnGatewayAttributeResponseBody(name='body'),
}

async function modifyVpnGatewayAttributeWithOptions(request: ModifyVpnGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpnGatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpnGatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpnGatewayAttribute(request: ModifyVpnGatewayAttributeRequest): ModifyVpnGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnGatewayAttributeWithOptions(request, runtime);
}

model ModifyVpnPbrRouteEntryWeightRequest {
  clientToken?: string(name='ClientToken'),
  newWeight?: int32(name='NewWeight'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  routeSource?: string(name='RouteSource'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model ModifyVpnPbrRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpnPbrRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnPbrRouteEntryWeightResponseBody(name='body'),
}

async function modifyVpnPbrRouteEntryWeightWithOptions(request: ModifyVpnPbrRouteEntryWeightRequest, runtime: Util.RuntimeOptions): ModifyVpnPbrRouteEntryWeightResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpnPbrRouteEntryWeight', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpnPbrRouteEntryWeight(request: ModifyVpnPbrRouteEntryWeightRequest): ModifyVpnPbrRouteEntryWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnPbrRouteEntryWeightWithOptions(request, runtime);
}

model ModifyVpnRouteEntryWeightRequest {
  clientToken?: string(name='ClientToken'),
  newWeight?: int32(name='NewWeight'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model ModifyVpnRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpnRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnRouteEntryWeightResponseBody(name='body'),
}

async function modifyVpnRouteEntryWeightWithOptions(request: ModifyVpnRouteEntryWeightRequest, runtime: Util.RuntimeOptions): ModifyVpnRouteEntryWeightResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyVpnRouteEntryWeight', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyVpnRouteEntryWeight(request: ModifyVpnRouteEntryWeightRequest): ModifyVpnRouteEntryWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnRouteEntryWeightWithOptions(request, runtime);
}

model MoveResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('MoveResourceGroup', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model OpenPhysicalConnectionServiceRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model OpenPhysicalConnectionServiceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model OpenPhysicalConnectionServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenPhysicalConnectionServiceResponseBody(name='body'),
}

async function openPhysicalConnectionServiceWithOptions(request: OpenPhysicalConnectionServiceRequest, runtime: Util.RuntimeOptions): OpenPhysicalConnectionServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('OpenPhysicalConnectionService', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function openPhysicalConnectionService(request: OpenPhysicalConnectionServiceRequest): OpenPhysicalConnectionServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openPhysicalConnectionServiceWithOptions(request, runtime);
}

model OpenTrafficMirrorServiceRequest {
  ownerId?: long(name='OwnerId'),
}

model OpenTrafficMirrorServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenTrafficMirrorServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenTrafficMirrorServiceResponseBody(name='body'),
}

async function openTrafficMirrorServiceWithOptions(request: OpenTrafficMirrorServiceRequest, runtime: Util.RuntimeOptions): OpenTrafficMirrorServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('OpenTrafficMirrorService', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function openTrafficMirrorService(request: OpenTrafficMirrorServiceRequest): OpenTrafficMirrorServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openTrafficMirrorServiceWithOptions(request, runtime);
}

model PublishVpnRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  nextHop?: string(name='NextHop'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publishVpc?: boolean(name='PublishVpc'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  routeType?: string(name='RouteType'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model PublishVpnRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model PublishVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: PublishVpnRouteEntryResponseBody(name='body'),
}

async function publishVpnRouteEntryWithOptions(request: PublishVpnRouteEntryRequest, runtime: Util.RuntimeOptions): PublishVpnRouteEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PublishVpnRouteEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function publishVpnRouteEntry(request: PublishVpnRouteEntryRequest): PublishVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishVpnRouteEntryWithOptions(request, runtime);
}

model RecoverPhysicalConnectionRequest {
  dryRun?: boolean(name='DryRun', description='DryRun'),
  instanceId?: string(name='InstanceId', description='恢复的Pconn'),
  regionId?: string(name='RegionId'),
  token?: string(name='Token', description='幂等Token'),
}

model RecoverPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RecoverPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverPhysicalConnectionResponseBody(name='body'),
}

async function recoverPhysicalConnectionWithOptions(request: RecoverPhysicalConnectionRequest, runtime: Util.RuntimeOptions): RecoverPhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecoverPhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recoverPhysicalConnection(request: RecoverPhysicalConnectionRequest): RecoverPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoverPhysicalConnectionWithOptions(request, runtime);
}

model RecoverVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model RecoverVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model RecoverVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverVirtualBorderRouterResponseBody(name='body'),
}

async function recoverVirtualBorderRouterWithOptions(request: RecoverVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): RecoverVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecoverVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recoverVirtualBorderRouter(request: RecoverVirtualBorderRouterRequest): RecoverVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoverVirtualBorderRouterWithOptions(request, runtime);
}

model ReleaseEipAddressRequest {
  allocationId?: string(name='AllocationId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReleaseEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseEipAddressResponseBody(name='body'),
}

async function releaseEipAddressWithOptions(request: ReleaseEipAddressRequest, runtime: Util.RuntimeOptions): ReleaseEipAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReleaseEipAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function releaseEipAddress(request: ReleaseEipAddressRequest): ReleaseEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseEipAddressWithOptions(request, runtime);
}

model ReleaseEipSegmentAddressRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
}

model ReleaseEipSegmentAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipSegmentAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseEipSegmentAddressResponseBody(name='body'),
}

async function releaseEipSegmentAddressWithOptions(request: ReleaseEipSegmentAddressRequest, runtime: Util.RuntimeOptions): ReleaseEipSegmentAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReleaseEipSegmentAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function releaseEipSegmentAddress(request: ReleaseEipSegmentAddressRequest): ReleaseEipSegmentAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseEipSegmentAddressWithOptions(request, runtime);
}

model RemoveCommonBandwidthPackageIpRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  ipInstanceId?: string(name='IpInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RemoveCommonBandwidthPackageIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveCommonBandwidthPackageIpResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveCommonBandwidthPackageIpResponseBody(name='body'),
}

async function removeCommonBandwidthPackageIpWithOptions(request: RemoveCommonBandwidthPackageIpRequest, runtime: Util.RuntimeOptions): RemoveCommonBandwidthPackageIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveCommonBandwidthPackageIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeCommonBandwidthPackageIp(request: RemoveCommonBandwidthPackageIpRequest): RemoveCommonBandwidthPackageIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCommonBandwidthPackageIpWithOptions(request, runtime);
}

model RemoveGlobalAccelerationInstanceIpRequest {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipInstanceId?: string(name='IpInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RemoveGlobalAccelerationInstanceIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveGlobalAccelerationInstanceIpResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveGlobalAccelerationInstanceIpResponseBody(name='body'),
}

async function removeGlobalAccelerationInstanceIpWithOptions(request: RemoveGlobalAccelerationInstanceIpRequest, runtime: Util.RuntimeOptions): RemoveGlobalAccelerationInstanceIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveGlobalAccelerationInstanceIp', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeGlobalAccelerationInstanceIp(request: RemoveGlobalAccelerationInstanceIpRequest): RemoveGlobalAccelerationInstanceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

model RemoveIPv6TranslatorAclListEntryRequest {
  aclEntryId?: string(name='AclEntryId'),
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RemoveIPv6TranslatorAclListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function removeIPv6TranslatorAclListEntryWithOptions(request: RemoveIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): RemoveIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveIPv6TranslatorAclListEntry', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeIPv6TranslatorAclListEntry(request: RemoveIPv6TranslatorAclListEntryRequest): RemoveIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model RemoveSourcesFromTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
  trafficMirrorSourceIds?: [ string ](name='TrafficMirrorSourceIds'),
}

model RemoveSourcesFromTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveSourcesFromTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveSourcesFromTrafficMirrorSessionResponseBody(name='body'),
}

async function removeSourcesFromTrafficMirrorSessionWithOptions(request: RemoveSourcesFromTrafficMirrorSessionRequest, runtime: Util.RuntimeOptions): RemoveSourcesFromTrafficMirrorSessionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveSourcesFromTrafficMirrorSession', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeSourcesFromTrafficMirrorSession(request: RemoveSourcesFromTrafficMirrorSessionRequest): RemoveSourcesFromTrafficMirrorSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeSourcesFromTrafficMirrorSessionWithOptions(request, runtime);
}

model RenewInstanceRequest {
  duration?: int32(name='Duration'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerId?: long(name='OwnerId'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RenewInstanceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RenewInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstanceWithOptions(request, runtime);
}

model ReplaceVpcDhcpOptionsSetRequest {
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model ReplaceVpcDhcpOptionsSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReplaceVpcDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: ReplaceVpcDhcpOptionsSetResponseBody(name='body'),
}

async function replaceVpcDhcpOptionsSetWithOptions(request: ReplaceVpcDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): ReplaceVpcDhcpOptionsSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReplaceVpcDhcpOptionsSet', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function replaceVpcDhcpOptionsSet(request: ReplaceVpcDhcpOptionsSetRequest): ReplaceVpcDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceVpcDhcpOptionsSetWithOptions(request, runtime);
}

model RevokeInstanceFromCenRequest {
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RevokeInstanceFromCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeInstanceFromCenResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeInstanceFromCenResponseBody(name='body'),
}

async function revokeInstanceFromCenWithOptions(request: RevokeInstanceFromCenRequest, runtime: Util.RuntimeOptions): RevokeInstanceFromCenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RevokeInstanceFromCen', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function revokeInstanceFromCen(request: RevokeInstanceFromCenRequest): RevokeInstanceFromCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeInstanceFromCenWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResources', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TerminatePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model TerminatePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: TerminatePhysicalConnectionResponseBody(name='body'),
}

async function terminatePhysicalConnectionWithOptions(request: TerminatePhysicalConnectionRequest, runtime: Util.RuntimeOptions): TerminatePhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TerminatePhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function terminatePhysicalConnection(request: TerminatePhysicalConnectionRequest): TerminatePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminatePhysicalConnectionWithOptions(request, runtime);
}

model TerminateVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model TerminateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: TerminateVirtualBorderRouterResponseBody(name='body'),
}

async function terminateVirtualBorderRouterWithOptions(request: TerminateVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): TerminateVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TerminateVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function terminateVirtualBorderRouter(request: TerminateVirtualBorderRouterRequest): TerminateVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateVirtualBorderRouterWithOptions(request, runtime);
}

model UnTagResourcesRequest {
  all?: boolean(name='All'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResourcesWithOptions(request: UnTagResourcesRequest, runtime: Util.RuntimeOptions): UnTagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnTagResources', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return unTagResourcesWithOptions(request, runtime);
}

model UnassociateEipAddressRequest {
  allocationId?: string(name='AllocationId'),
  clientToken?: string(name='ClientToken'),
  force?: boolean(name='Force'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnassociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateEipAddressResponseBody(name='body'),
}

async function unassociateEipAddressWithOptions(request: UnassociateEipAddressRequest, runtime: Util.RuntimeOptions): UnassociateEipAddressResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateEipAddress', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateEipAddress(request: UnassociateEipAddressRequest): UnassociateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateEipAddressWithOptions(request, runtime);
}

model UnassociateGlobalAccelerationInstanceRequest {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnassociateGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function unassociateGlobalAccelerationInstanceWithOptions(request: UnassociateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): UnassociateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateGlobalAccelerationInstance', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateGlobalAccelerationInstance(request: UnassociateGlobalAccelerationInstanceRequest): UnassociateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateGlobalAccelerationInstanceWithOptions(request, runtime);
}

model UnassociateHaVipRequest {
  clientToken?: string(name='ClientToken'),
  force?: string(name='Force'),
  haVipId?: string(name='HaVipId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnassociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateHaVipResponseBody(name='body'),
}

async function unassociateHaVipWithOptions(request: UnassociateHaVipRequest, runtime: Util.RuntimeOptions): UnassociateHaVipResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateHaVip', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateHaVip(request: UnassociateHaVipRequest): UnassociateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateHaVipWithOptions(request, runtime);
}

model UnassociateNetworkAclRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resource'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnassociateNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateNetworkAclResponseBody(name='body'),
}

async function unassociateNetworkAclWithOptions(request: UnassociateNetworkAclRequest, runtime: Util.RuntimeOptions): UnassociateNetworkAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateNetworkAcl', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateNetworkAcl(request: UnassociateNetworkAclRequest): UnassociateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateNetworkAclWithOptions(request, runtime);
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody(name='body'),
}

async function unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociatePhysicalConnectionFromVirtualBorderRouter', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociatePhysicalConnectionFromVirtualBorderRouter(request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest): UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request, runtime);
}

model UnassociateRouteTableRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  vSwitchId?: string(name='VSwitchId'),
}

model UnassociateRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateRouteTableResponseBody(name='body'),
}

async function unassociateRouteTableWithOptions(request: UnassociateRouteTableRequest, runtime: Util.RuntimeOptions): UnassociateRouteTableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateRouteTable', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateRouteTable(request: UnassociateRouteTableRequest): UnassociateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateRouteTableWithOptions(request, runtime);
}

model UnassociateVpcCidrBlockRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock'),
  vpcId?: string(name='VpcId'),
}

model UnassociateVpcCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateVpcCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateVpcCidrBlockResponseBody(name='body'),
}

async function unassociateVpcCidrBlockWithOptions(request: UnassociateVpcCidrBlockRequest, runtime: Util.RuntimeOptions): UnassociateVpcCidrBlockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnassociateVpcCidrBlock', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unassociateVpcCidrBlock(request: UnassociateVpcCidrBlockRequest): UnassociateVpcCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateVpcCidrBlockWithOptions(request, runtime);
}

model UpdateCrossBoarderStatusRequest {
  enable?: boolean(name='Enable', description='开通还是关闭服务'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='region'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceUid?: long(name='ResourceUid', description='开通服务的帐号'),
}

model UpdateCrossBoarderStatusResponseBody = {
  code?: string(name='Code', description='返回码'),
  message?: string(name='Message', description='返回信息'),
  requestId?: string(name='RequestId', description='请求的唯一标识'),
  success?: boolean(name='Success', description='是否操作成功'),
}

model UpdateCrossBoarderStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCrossBoarderStatusResponseBody(name='body'),
}

async function updateCrossBoarderStatusWithOptions(request: UpdateCrossBoarderStatusRequest, runtime: Util.RuntimeOptions): UpdateCrossBoarderStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateCrossBoarderStatus', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateCrossBoarderStatus(request: UpdateCrossBoarderStatusRequest): UpdateCrossBoarderStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCrossBoarderStatusWithOptions(request, runtime);
}

model UpdateDhcpOptionsSetAttributeRequest {
  bootFileName?: string(name='BootFileName'),
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  domainName?: string(name='DomainName'),
  domainNameServers?: string(name='DomainNameServers'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TFTPServerName?: string(name='TFTPServerName'),
}

model UpdateDhcpOptionsSetAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDhcpOptionsSetAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDhcpOptionsSetAttributeResponseBody(name='body'),
}

async function updateDhcpOptionsSetAttributeWithOptions(request: UpdateDhcpOptionsSetAttributeRequest, runtime: Util.RuntimeOptions): UpdateDhcpOptionsSetAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateDhcpOptionsSetAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateDhcpOptionsSetAttribute(request: UpdateDhcpOptionsSetAttributeRequest): UpdateDhcpOptionsSetAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDhcpOptionsSetAttributeWithOptions(request, runtime);
}

model UpdateGatewayRouteTableEntryAttributeRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  dryRun?: boolean(name='DryRun'),
  IPv4GatewayRouteTableId?: string(name='IPv4GatewayRouteTableId'),
  name?: string(name='Name'),
  nextHopId?: string(name='NextHopId'),
  nextHopType?: string(name='NextHopType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateGatewayRouteTableEntryAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGatewayRouteTableEntryAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteTableEntryAttributeResponseBody(name='body'),
}

async function updateGatewayRouteTableEntryAttributeWithOptions(request: UpdateGatewayRouteTableEntryAttributeRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteTableEntryAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateGatewayRouteTableEntryAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateGatewayRouteTableEntryAttribute(request: UpdateGatewayRouteTableEntryAttributeRequest): UpdateGatewayRouteTableEntryAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteTableEntryAttributeWithOptions(request, runtime);
}

model UpdateIpsecServerRequest {
  clientIpPool?: string(name='ClientIpPool'),
  clientToken?: string(name='ClientToken'),
  dryRun?: string(name='DryRun'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  ipsecServerId?: string(name='IpsecServerId'),
  ipsecServerName?: string(name='IpsecServerName'),
  localSubnet?: string(name='LocalSubnet'),
  psk?: string(name='Psk'),
  pskEnabled?: boolean(name='PskEnabled'),
  regionId?: string(name='RegionId'),
}

model UpdateIpsecServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpsecServerResponseBody(name='body'),
}

async function updateIpsecServerWithOptions(request: UpdateIpsecServerRequest, runtime: Util.RuntimeOptions): UpdateIpsecServerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIpsecServer', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIpsecServer(request: UpdateIpsecServerRequest): UpdateIpsecServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpsecServerWithOptions(request, runtime);
}

model UpdateIpv4GatewayAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ipv4GatewayName?: string(name='Ipv4GatewayName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateIpv4GatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpv4GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpv4GatewayAttributeResponseBody(name='body'),
}

async function updateIpv4GatewayAttributeWithOptions(request: UpdateIpv4GatewayAttributeRequest, runtime: Util.RuntimeOptions): UpdateIpv4GatewayAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIpv4GatewayAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIpv4GatewayAttribute(request: UpdateIpv4GatewayAttributeRequest): UpdateIpv4GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpv4GatewayAttributeWithOptions(request, runtime);
}

model UpdateNatGatewayNatTypeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natType?: string(name='NatType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model UpdateNatGatewayNatTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNatGatewayNatTypeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNatGatewayNatTypeResponseBody(name='body'),
}

async function updateNatGatewayNatTypeWithOptions(request: UpdateNatGatewayNatTypeRequest, runtime: Util.RuntimeOptions): UpdateNatGatewayNatTypeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNatGatewayNatType', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNatGatewayNatType(request: UpdateNatGatewayNatTypeRequest): UpdateNatGatewayNatTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNatGatewayNatTypeWithOptions(request, runtime);
}

model UpdateNetworkAclEntriesRequest {
  clientToken?: string(name='ClientToken'),
  egressAclEntries?: [ 
    {
      description?: string(name='Description'),
      destinationCidrIp?: string(name='DestinationCidrIp'),
      entryType?: string(name='EntryType'),
      networkAclEntryId?: string(name='NetworkAclEntryId'),
      networkAclEntryName?: string(name='NetworkAclEntryName'),
      policy?: string(name='Policy'),
      port?: string(name='Port'),
      protocol?: string(name='Protocol'),
    }
  ](name='EgressAclEntries'),
  ingressAclEntries?: [ 
    {
      description?: string(name='Description'),
      entryType?: string(name='EntryType'),
      networkAclEntryId?: string(name='NetworkAclEntryId'),
      networkAclEntryName?: string(name='NetworkAclEntryName'),
      policy?: string(name='Policy'),
      port?: string(name='Port'),
      protocol?: string(name='Protocol'),
      sourceCidrIp?: string(name='SourceCidrIp'),
    }
  ](name='IngressAclEntries'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  updateEgressAclEntries?: boolean(name='UpdateEgressAclEntries'),
  updateIngressAclEntries?: boolean(name='UpdateIngressAclEntries'),
}

model UpdateNetworkAclEntriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNetworkAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNetworkAclEntriesResponseBody(name='body'),
}

async function updateNetworkAclEntriesWithOptions(request: UpdateNetworkAclEntriesRequest, runtime: Util.RuntimeOptions): UpdateNetworkAclEntriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateNetworkAclEntries', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateNetworkAclEntries(request: UpdateNetworkAclEntriesRequest): UpdateNetworkAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNetworkAclEntriesWithOptions(request, runtime);
}

model UpdateTrafficMirrorFilterAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterDescription?: string(name='TrafficMirrorFilterDescription'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorFilterName?: string(name='TrafficMirrorFilterName'),
}

model UpdateTrafficMirrorFilterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrafficMirrorFilterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTrafficMirrorFilterAttributeResponseBody(name='body'),
}

async function updateTrafficMirrorFilterAttributeWithOptions(request: UpdateTrafficMirrorFilterAttributeRequest, runtime: Util.RuntimeOptions): UpdateTrafficMirrorFilterAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTrafficMirrorFilterAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTrafficMirrorFilterAttribute(request: UpdateTrafficMirrorFilterAttributeRequest): UpdateTrafficMirrorFilterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrafficMirrorFilterAttributeWithOptions(request, runtime);
}

model UpdateTrafficMirrorFilterRuleAttributeRequest {
  clientToken?: string(name='ClientToken'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  destinationPortRange?: string(name='DestinationPortRange'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  protocol?: string(name='Protocol'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleAction?: string(name='RuleAction'),
  sourceCidrBlock?: string(name='SourceCidrBlock'),
  sourcePortRange?: string(name='SourcePortRange'),
  trafficMirrorFilterRuleId?: string(name='TrafficMirrorFilterRuleId'),
}

model UpdateTrafficMirrorFilterRuleAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrafficMirrorFilterRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTrafficMirrorFilterRuleAttributeResponseBody(name='body'),
}

async function updateTrafficMirrorFilterRuleAttributeWithOptions(request: UpdateTrafficMirrorFilterRuleAttributeRequest, runtime: Util.RuntimeOptions): UpdateTrafficMirrorFilterRuleAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTrafficMirrorFilterRuleAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTrafficMirrorFilterRuleAttribute(request: UpdateTrafficMirrorFilterRuleAttributeRequest): UpdateTrafficMirrorFilterRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrafficMirrorFilterRuleAttributeWithOptions(request, runtime);
}

model UpdateTrafficMirrorSessionAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  enabled?: boolean(name='Enabled'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorSessionDescription?: string(name='TrafficMirrorSessionDescription'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
  trafficMirrorSessionName?: string(name='TrafficMirrorSessionName'),
  trafficMirrorTargetId?: string(name='TrafficMirrorTargetId'),
  trafficMirrorTargetType?: string(name='TrafficMirrorTargetType'),
  virtualNetworkId?: int32(name='VirtualNetworkId'),
}

model UpdateTrafficMirrorSessionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrafficMirrorSessionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTrafficMirrorSessionAttributeResponseBody(name='body'),
}

async function updateTrafficMirrorSessionAttributeWithOptions(request: UpdateTrafficMirrorSessionAttributeRequest, runtime: Util.RuntimeOptions): UpdateTrafficMirrorSessionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTrafficMirrorSessionAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTrafficMirrorSessionAttribute(request: UpdateTrafficMirrorSessionAttributeRequest): UpdateTrafficMirrorSessionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrafficMirrorSessionAttributeWithOptions(request, runtime);
}

model UpdateVirtualBorderBandwidthRequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  virtualBorderRouterId?: string(name='VirtualBorderRouterId'),
}

model UpdateVirtualBorderBandwidthResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateVirtualBorderBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVirtualBorderBandwidthResponseBody(name='body'),
}

async function updateVirtualBorderBandwidthWithOptions(request: UpdateVirtualBorderBandwidthRequest, runtime: Util.RuntimeOptions): UpdateVirtualBorderBandwidthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateVirtualBorderBandwidth', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateVirtualBorderBandwidth(request: UpdateVirtualBorderBandwidthRequest): UpdateVirtualBorderBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVirtualBorderBandwidthWithOptions(request, runtime);
}

model UpdateVirtualPhysicalConnectionRequest {
  dryRun?: boolean(name='DryRun', description='DryRun'),
  instanceId?: string(name='InstanceId', description='Vpconn的实例ID'),
  regionId?: string(name='RegionId'),
  token?: string(name='Token', description='幂等Token'),
  vlanId?: long(name='VlanId', description='vpconn的VlanID'),
}

model UpdateVirtualPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: string(name='Success', description='是否修改成功'),
}

model UpdateVirtualPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVirtualPhysicalConnectionResponseBody(name='body'),
}

async function updateVirtualPhysicalConnectionWithOptions(request: UpdateVirtualPhysicalConnectionRequest, runtime: Util.RuntimeOptions): UpdateVirtualPhysicalConnectionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateVirtualPhysicalConnection', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateVirtualPhysicalConnection(request: UpdateVirtualPhysicalConnectionRequest): UpdateVirtualPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVirtualPhysicalConnectionWithOptions(request, runtime);
}

model UpdateVpcGatewayEndpointAttributeRequest {
  clientToken?: string(name='ClientToken', description='幂等参数'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求'),
  endpointDescription?: string(name='EndpointDescription', description='网关节点描述'),
  endpointId?: string(name='EndpointId', description='VPC网关实例ID'),
  endpointName?: string(name='EndpointName', description='网关节点名称'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  policyDocument?: string(name='PolicyDocument', description='访问云服务的权限控制策略'),
  regionId?: string(name='RegionId', description='地域'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateVpcGatewayEndpointAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateVpcGatewayEndpointAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVpcGatewayEndpointAttributeResponseBody(name='body'),
}

async function updateVpcGatewayEndpointAttributeWithOptions(request: UpdateVpcGatewayEndpointAttributeRequest, runtime: Util.RuntimeOptions): UpdateVpcGatewayEndpointAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateVpcGatewayEndpointAttribute', '2016-04-28', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateVpcGatewayEndpointAttribute(request: UpdateVpcGatewayEndpointAttributeRequest): UpdateVpcGatewayEndpointAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVpcGatewayEndpointAttributeWithOptions(request, runtime);
}

