/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'vpc.aliyuncs.com',
    cn-beijing = 'vpc.aliyuncs.com',
    cn-hangzhou = 'vpc.aliyuncs.com',
    cn-shanghai = 'vpc.aliyuncs.com',
    cn-shenzhen = 'vpc.aliyuncs.com',
    cn-hongkong = 'vpc.aliyuncs.com',
    ap-southeast-1 = 'vpc.aliyuncs.com',
    us-east-1 = 'vpc.aliyuncs.com',
    us-west-1 = 'vpc.aliyuncs.com',
    cn-shanghai-finance-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-finance-1 = 'vpc.aliyuncs.com',
    cn-north-2-gov-1 = 'vpc.aliyuncs.com',
    ap-northeast-2-pop = 'vpc.aliyuncs.com',
    cn-beijing-finance-pop = 'vpc.aliyuncs.com',
    cn-beijing-gov-1 = 'vpc.aliyuncs.com',
    cn-beijing-nu16-b01 = 'vpc.aliyuncs.com',
    cn-edge-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-fujian = 'vpc.aliyuncs.com',
    cn-haidian-cm12-c01 = 'vpc.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'vpc.aliyuncs.com',
    cn-hangzhou-finance = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'vpc.aliyuncs.com',
    cn-hangzhou-test-306 = 'vpc.aliyuncs.com',
    cn-hongkong-finance-pop = 'vpc.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-qingdao-nebula = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-shanghai-et15-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-et2-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-inner = 'vpc.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-inner = 'vpc.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'vpc.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'vpc.aliyuncs.com',
    cn-wuhan = 'vpc.aliyuncs.com',
    cn-yushanfang = 'vpc.aliyuncs.com',
    cn-zhangbei = 'vpc.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'vpc.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'vpc.cn-zhangjiakou.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    eu-west-1-oxs = 'vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com',
    rus-west-1-pop = 'vpc.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('vpc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model ActivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ActivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActivateRouterInterfaceResponseBody(name='body'),
}

async function activateRouterInterfaceWithOptions(request: ActivateRouterInterfaceRequest, runtime: Util.RuntimeOptions): ActivateRouterInterfaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerInterfaceId)) {
    query['RouterInterfaceId'] = request.routerInterfaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ActivateRouterInterface',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activateRouterInterface(request: ActivateRouterInterfaceRequest): ActivateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateRouterInterfaceWithOptions(request, runtime);
}

model ActiveFlowLogRequest {
  flowLogId?: string(name='FlowLogId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ActiveFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ActiveFlowLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActiveFlowLogResponseBody(name='body'),
}

async function activeFlowLogWithOptions(request: ActiveFlowLogRequest, runtime: Util.RuntimeOptions): ActiveFlowLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.flowLogId)) {
    query['FlowLogId'] = request.flowLogId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ActiveFlowLog',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activeFlowLog(request: ActiveFlowLogRequest): ActiveFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return activeFlowLogWithOptions(request, runtime);
}

model AddBgpNetworkRequest {
  clientToken?: string(name='ClientToken'),
  dstCidrBlock?: string(name='DstCidrBlock'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
  vpcId?: string(name='VpcId'),
}

model AddBgpNetworkResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddBgpNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddBgpNetworkResponseBody(name='body'),
}

async function addBgpNetworkWithOptions(request: AddBgpNetworkRequest, runtime: Util.RuntimeOptions): AddBgpNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dstCidrBlock)) {
    query['DstCidrBlock'] = request.dstCidrBlock;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerId)) {
    query['RouterId'] = request.routerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddBgpNetwork',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addBgpNetwork(request: AddBgpNetworkRequest): AddBgpNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBgpNetworkWithOptions(request, runtime);
}

model AddCommonBandwidthPackageIpRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  ipInstanceId?: string(name='IpInstanceId'),
  ipType?: string(name='IpType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddCommonBandwidthPackageIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCommonBandwidthPackageIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCommonBandwidthPackageIpResponseBody(name='body'),
}

async function addCommonBandwidthPackageIpWithOptions(request: AddCommonBandwidthPackageIpRequest, runtime: Util.RuntimeOptions): AddCommonBandwidthPackageIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipInstanceId)) {
    query['IpInstanceId'] = request.ipInstanceId;
  }
  if (!Util.isUnset(request.ipType)) {
    query['IpType'] = request.ipType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCommonBandwidthPackageIp',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCommonBandwidthPackageIp(request: AddCommonBandwidthPackageIpRequest): AddCommonBandwidthPackageIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCommonBandwidthPackageIpWithOptions(request, runtime);
}

model AddCommonBandwidthPackageIpsRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  ipInstanceIds?: [ string ](name='IpInstanceIds'),
  ipType?: string(name='IpType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddCommonBandwidthPackageIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCommonBandwidthPackageIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCommonBandwidthPackageIpsResponseBody(name='body'),
}

async function addCommonBandwidthPackageIpsWithOptions(request: AddCommonBandwidthPackageIpsRequest, runtime: Util.RuntimeOptions): AddCommonBandwidthPackageIpsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipInstanceIds)) {
    query['IpInstanceIds'] = request.ipInstanceIds;
  }
  if (!Util.isUnset(request.ipType)) {
    query['IpType'] = request.ipType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddCommonBandwidthPackageIps',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCommonBandwidthPackageIps(request: AddCommonBandwidthPackageIpsRequest): AddCommonBandwidthPackageIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCommonBandwidthPackageIpsWithOptions(request, runtime);
}

model AddGlobalAccelerationInstanceIpRequest {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipInstanceId?: string(name='IpInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddGlobalAccelerationInstanceIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddGlobalAccelerationInstanceIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddGlobalAccelerationInstanceIpResponseBody(name='body'),
}

async function addGlobalAccelerationInstanceIpWithOptions(request: AddGlobalAccelerationInstanceIpRequest, runtime: Util.RuntimeOptions): AddGlobalAccelerationInstanceIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalAccelerationInstanceId)) {
    query['GlobalAccelerationInstanceId'] = request.globalAccelerationInstanceId;
  }
  if (!Util.isUnset(request.ipInstanceId)) {
    query['IpInstanceId'] = request.ipInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGlobalAccelerationInstanceIp',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addGlobalAccelerationInstanceIp(request: AddGlobalAccelerationInstanceIpRequest): AddGlobalAccelerationInstanceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

model AddIPv6TranslatorAclListEntryRequest {
  aclEntryComment?: string(name='AclEntryComment'),
  aclEntryIp?: string(name='AclEntryIp'),
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddIPv6TranslatorAclListEntryResponseBody = {
  aclEntryId?: string(name='AclEntryId'),
  requestId?: string(name='RequestId'),
}

model AddIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function addIPv6TranslatorAclListEntryWithOptions(request: AddIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): AddIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntryComment)) {
    query['AclEntryComment'] = request.aclEntryComment;
  }
  if (!Util.isUnset(request.aclEntryIp)) {
    query['AclEntryIp'] = request.aclEntryIp;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddIPv6TranslatorAclListEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addIPv6TranslatorAclListEntry(request: AddIPv6TranslatorAclListEntryRequest): AddIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model AddPublicIpAddressPoolCidrBlockRequest {
  cidrBlock?: string(name='CidrBlock'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AddPublicIpAddressPoolCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddPublicIpAddressPoolCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddPublicIpAddressPoolCidrBlockResponseBody(name='body'),
}

async function addPublicIpAddressPoolCidrBlockWithOptions(request: AddPublicIpAddressPoolCidrBlockRequest, runtime: Util.RuntimeOptions): AddPublicIpAddressPoolCidrBlockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publicIpAddressPoolId)) {
    query['PublicIpAddressPoolId'] = request.publicIpAddressPoolId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPublicIpAddressPoolCidrBlock',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addPublicIpAddressPoolCidrBlock(request: AddPublicIpAddressPoolCidrBlockRequest): AddPublicIpAddressPoolCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return addPublicIpAddressPoolCidrBlockWithOptions(request, runtime);
}

model AddSourcesToTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
  trafficMirrorSourceIds?: [ string ](name='TrafficMirrorSourceIds'),
}

model AddSourcesToTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddSourcesToTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSourcesToTrafficMirrorSessionResponseBody(name='body'),
}

async function addSourcesToTrafficMirrorSessionWithOptions(request: AddSourcesToTrafficMirrorSessionRequest, runtime: Util.RuntimeOptions): AddSourcesToTrafficMirrorSessionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorSessionId)) {
    query['TrafficMirrorSessionId'] = request.trafficMirrorSessionId;
  }
  if (!Util.isUnset(request.trafficMirrorSourceIds)) {
    query['TrafficMirrorSourceIds'] = request.trafficMirrorSourceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSourcesToTrafficMirrorSession',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSourcesToTrafficMirrorSession(request: AddSourcesToTrafficMirrorSessionRequest): AddSourcesToTrafficMirrorSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSourcesToTrafficMirrorSessionWithOptions(request, runtime);
}

model AllocateEipAddressRequest {
  activityId?: long(name='ActivityId'),
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: string(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ISP?: string(name='ISP'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  name?: string(name='Name'),
  netmode?: string(name='Netmode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  pricingCycle?: string(name='PricingCycle'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionTypes?: [ string ](name='SecurityProtectionTypes'),
}

model AllocateEipAddressResponseBody = {
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model AllocateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocateEipAddressResponseBody(name='body'),
}

async function allocateEipAddressWithOptions(request: AllocateEipAddressRequest, runtime: Util.RuntimeOptions): AllocateEipAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.activityId)) {
    query['ActivityId'] = request.activityId;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ISP)) {
    query['ISP'] = request.ISP;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.netmode)) {
    query['Netmode'] = request.netmode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.publicIpAddressPoolId)) {
    query['PublicIpAddressPoolId'] = request.publicIpAddressPoolId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityProtectionTypes)) {
    query['SecurityProtectionTypes'] = request.securityProtectionTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateEipAddress',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocateEipAddress(request: AllocateEipAddressRequest): AllocateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipAddressWithOptions(request, runtime);
}

model AllocateEipAddressProRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: string(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ISP?: string(name='ISP'),
  instanceChargeType?: string(name='InstanceChargeType'),
  instanceId?: string(name='InstanceId'),
  internetChargeType?: string(name='InternetChargeType'),
  ipAddress?: string(name='IpAddress'),
  netmode?: string(name='Netmode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  pricingCycle?: string(name='PricingCycle'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionTypes?: [ string ](name='SecurityProtectionTypes'),
}

model AllocateEipAddressProResponseBody = {
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model AllocateEipAddressProResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocateEipAddressProResponseBody(name='body'),
}

async function allocateEipAddressProWithOptions(request: AllocateEipAddressProRequest, runtime: Util.RuntimeOptions): AllocateEipAddressProResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ISP)) {
    query['ISP'] = request.ISP;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.ipAddress)) {
    query['IpAddress'] = request.ipAddress;
  }
  if (!Util.isUnset(request.netmode)) {
    query['Netmode'] = request.netmode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.publicIpAddressPoolId)) {
    query['PublicIpAddressPoolId'] = request.publicIpAddressPoolId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityProtectionTypes)) {
    query['SecurityProtectionTypes'] = request.securityProtectionTypes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateEipAddressPro',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocateEipAddressPro(request: AllocateEipAddressProRequest): AllocateEipAddressProResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipAddressProWithOptions(request, runtime);
}

model AllocateEipSegmentAddressRequest {
  bandwidth?: string(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  eipMask?: string(name='EipMask'),
  internetChargeType?: string(name='InternetChargeType'),
  isp?: string(name='Isp'),
  netmode?: string(name='Netmode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AllocateEipSegmentAddressResponseBody = {
  eipSegmentInstanceId?: string(name='EipSegmentInstanceId'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model AllocateEipSegmentAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocateEipSegmentAddressResponseBody(name='body'),
}

async function allocateEipSegmentAddressWithOptions(request: AllocateEipSegmentAddressRequest, runtime: Util.RuntimeOptions): AllocateEipSegmentAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.eipMask)) {
    query['EipMask'] = request.eipMask;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.netmode)) {
    query['Netmode'] = request.netmode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateEipSegmentAddress',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocateEipSegmentAddress(request: AllocateEipSegmentAddressRequest): AllocateEipSegmentAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipSegmentAddressWithOptions(request, runtime);
}

model AllocateIpv6InternetBandwidthRequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  internetChargeType?: string(name='InternetChargeType'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AllocateIpv6InternetBandwidthResponseBody = {
  internetBandwidthId?: string(name='InternetBandwidthId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  requestId?: string(name='RequestId'),
}

model AllocateIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocateIpv6InternetBandwidthResponseBody(name='body'),
}

async function allocateIpv6InternetBandwidthWithOptions(request: AllocateIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): AllocateIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.ipv6AddressId)) {
    query['Ipv6AddressId'] = request.ipv6AddressId;
  }
  if (!Util.isUnset(request.ipv6GatewayId)) {
    query['Ipv6GatewayId'] = request.ipv6GatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateIpv6InternetBandwidth',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocateIpv6InternetBandwidth(request: AllocateIpv6InternetBandwidthRequest): AllocateIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateIpv6InternetBandwidthWithOptions(request, runtime);
}

model AllocateVpcIpv6CidrRequest {
  addressPoolType?: string(name='AddressPoolType'),
  clientToken?: string(name='ClientToken'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  ipv6Isp?: string(name='Ipv6Isp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AllocateVpcIpv6CidrResponseBody = {
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  requestId?: string(name='RequestId'),
}

model AllocateVpcIpv6CidrResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocateVpcIpv6CidrResponseBody(name='body'),
}

async function allocateVpcIpv6CidrWithOptions(request: AllocateVpcIpv6CidrRequest, runtime: Util.RuntimeOptions): AllocateVpcIpv6CidrResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressPoolType)) {
    query['AddressPoolType'] = request.addressPoolType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipv6CidrBlock)) {
    query['Ipv6CidrBlock'] = request.ipv6CidrBlock;
  }
  if (!Util.isUnset(request.ipv6Isp)) {
    query['Ipv6Isp'] = request.ipv6Isp;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateVpcIpv6Cidr',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocateVpcIpv6Cidr(request: AllocateVpcIpv6CidrRequest): AllocateVpcIpv6CidrResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateVpcIpv6CidrWithOptions(request, runtime);
}

model ApplyPhysicalConnectionLOARequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  companyName?: string(name='CompanyName'),
  constructionTime?: string(name='ConstructionTime'),
  instanceId?: string(name='InstanceId'),
  lineType?: string(name='LineType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  PMInfo?: [ 
    {
      PMCertificateNo?: string(name='PMCertificateNo'),
      PMCertificateType?: string(name='PMCertificateType'),
      PMContactInfo?: string(name='PMContactInfo'),
      PMGender?: string(name='PMGender'),
      PMName?: string(name='PMName'),
    }
  ](name='PMInfo'),
  peerLocation?: string(name='PeerLocation'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  si?: string(name='Si'),
}

model ApplyPhysicalConnectionLOAResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApplyPhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyPhysicalConnectionLOAResponseBody(name='body'),
}

async function applyPhysicalConnectionLOAWithOptions(request: ApplyPhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): ApplyPhysicalConnectionLOAResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.companyName)) {
    query['CompanyName'] = request.companyName;
  }
  if (!Util.isUnset(request.constructionTime)) {
    query['ConstructionTime'] = request.constructionTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lineType)) {
    query['LineType'] = request.lineType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.PMInfo)) {
    query['PMInfo'] = request.PMInfo;
  }
  if (!Util.isUnset(request.peerLocation)) {
    query['PeerLocation'] = request.peerLocation;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.si)) {
    query['Si'] = request.si;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyPhysicalConnectionLOA',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyPhysicalConnectionLOA(request: ApplyPhysicalConnectionLOARequest): ApplyPhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyPhysicalConnectionLOAWithOptions(request, runtime);
}

model AssociateEipAddressRequest {
  allocationId?: string(name='AllocationId'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  instanceRegionId?: string(name='InstanceRegionId'),
  instanceType?: string(name='InstanceType'),
  mode?: string(name='Mode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AssociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateEipAddressResponseBody(name='body'),
}

async function associateEipAddressWithOptions(request: AssociateEipAddressRequest, runtime: Util.RuntimeOptions): AssociateEipAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceRegionId)) {
    query['InstanceRegionId'] = request.instanceRegionId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateEipAddress',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateEipAddress(request: AssociateEipAddressRequest): AssociateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateEipAddressWithOptions(request, runtime);
}

model AssociateGlobalAccelerationInstanceRequest {
  backendServerId?: string(name='BackendServerId'),
  backendServerRegionId?: string(name='BackendServerRegionId'),
  backendServerType?: string(name='BackendServerType'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AssociateGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function associateGlobalAccelerationInstanceWithOptions(request: AssociateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): AssociateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendServerId)) {
    query['BackendServerId'] = request.backendServerId;
  }
  if (!Util.isUnset(request.backendServerRegionId)) {
    query['BackendServerRegionId'] = request.backendServerRegionId;
  }
  if (!Util.isUnset(request.backendServerType)) {
    query['BackendServerType'] = request.backendServerType;
  }
  if (!Util.isUnset(request.globalAccelerationInstanceId)) {
    query['GlobalAccelerationInstanceId'] = request.globalAccelerationInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateGlobalAccelerationInstance',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateGlobalAccelerationInstance(request: AssociateGlobalAccelerationInstanceRequest): AssociateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateGlobalAccelerationInstanceWithOptions(request, runtime);
}

model AssociateHaVipRequest {
  clientToken?: string(name='ClientToken'),
  haVipId?: string(name='HaVipId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AssociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateHaVipResponseBody(name='body'),
}

async function associateHaVipWithOptions(request: AssociateHaVipRequest, runtime: Util.RuntimeOptions): AssociateHaVipResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.haVipId)) {
    query['HaVipId'] = request.haVipId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateHaVip',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateHaVip(request: AssociateHaVipRequest): AssociateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateHaVipWithOptions(request, runtime);
}

model AssociateNetworkAclRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resource'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AssociateNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateNetworkAclResponseBody(name='body'),
}

async function associateNetworkAclWithOptions(request: AssociateNetworkAclRequest, runtime: Util.RuntimeOptions): AssociateNetworkAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.networkAclId)) {
    query['NetworkAclId'] = request.networkAclId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resource)) {
    query['Resource'] = request.resource;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateNetworkAcl',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateNetworkAcl(request: AssociateNetworkAclRequest): AssociateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateNetworkAclWithOptions(request, runtime);
}

model AssociatePhysicalConnectionToVirtualBorderRouterRequest {
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  enableIpv6?: string(name='EnableIpv6'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
  vlanId?: string(name='VlanId'),
}

model AssociatePhysicalConnectionToVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociatePhysicalConnectionToVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociatePhysicalConnectionToVirtualBorderRouterResponseBody(name='body'),
}

async function associatePhysicalConnectionToVirtualBorderRouterWithOptions(request: AssociatePhysicalConnectionToVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): AssociatePhysicalConnectionToVirtualBorderRouterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.circuitCode)) {
    query['CircuitCode'] = request.circuitCode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableIpv6)) {
    query['EnableIpv6'] = request.enableIpv6;
  }
  if (!Util.isUnset(request.localGatewayIp)) {
    query['LocalGatewayIp'] = request.localGatewayIp;
  }
  if (!Util.isUnset(request.localIpv6GatewayIp)) {
    query['LocalIpv6GatewayIp'] = request.localIpv6GatewayIp;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerGatewayIp)) {
    query['PeerGatewayIp'] = request.peerGatewayIp;
  }
  if (!Util.isUnset(request.peerIpv6GatewayIp)) {
    query['PeerIpv6GatewayIp'] = request.peerIpv6GatewayIp;
  }
  if (!Util.isUnset(request.peeringIpv6SubnetMask)) {
    query['PeeringIpv6SubnetMask'] = request.peeringIpv6SubnetMask;
  }
  if (!Util.isUnset(request.peeringSubnetMask)) {
    query['PeeringSubnetMask'] = request.peeringSubnetMask;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  if (!Util.isUnset(request.vlanId)) {
    query['VlanId'] = request.vlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociatePhysicalConnectionToVirtualBorderRouter',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associatePhysicalConnectionToVirtualBorderRouter(request: AssociatePhysicalConnectionToVirtualBorderRouterRequest): AssociatePhysicalConnectionToVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return associatePhysicalConnectionToVirtualBorderRouterWithOptions(request, runtime);
}

model AssociateRouteTableRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  vSwitchId?: string(name='VSwitchId'),
}

model AssociateRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateRouteTableResponseBody(name='body'),
}

async function associateRouteTableWithOptions(request: AssociateRouteTableRequest, runtime: Util.RuntimeOptions): AssociateRouteTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateRouteTable',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateRouteTable(request: AssociateRouteTableRequest): AssociateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateRouteTableWithOptions(request, runtime);
}

model AssociateRouteTableWithGatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  gatewayId?: string(name='GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
}

model AssociateRouteTableWithGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateRouteTableWithGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateRouteTableWithGatewayResponseBody(name='body'),
}

async function associateRouteTableWithGatewayWithOptions(request: AssociateRouteTableWithGatewayRequest, runtime: Util.RuntimeOptions): AssociateRouteTableWithGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateRouteTableWithGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateRouteTableWithGateway(request: AssociateRouteTableWithGatewayRequest): AssociateRouteTableWithGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateRouteTableWithGatewayWithOptions(request, runtime);
}

model AssociateRouteTablesWithVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointId?: string(name='EndpointId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableIds?: [ string ](name='RouteTableIds'),
}

model AssociateRouteTablesWithVpcGatewayEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateRouteTablesWithVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateRouteTablesWithVpcGatewayEndpointResponseBody(name='body'),
}

async function associateRouteTablesWithVpcGatewayEndpointWithOptions(request: AssociateRouteTablesWithVpcGatewayEndpointRequest, runtime: Util.RuntimeOptions): AssociateRouteTablesWithVpcGatewayEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endpointId)) {
    query['EndpointId'] = request.endpointId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableIds)) {
    query['RouteTableIds'] = request.routeTableIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateRouteTablesWithVpcGatewayEndpoint',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateRouteTablesWithVpcGatewayEndpoint(request: AssociateRouteTablesWithVpcGatewayEndpointRequest): AssociateRouteTablesWithVpcGatewayEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateRouteTablesWithVpcGatewayEndpointWithOptions(request, runtime);
}

model AssociateVpcCidrBlockRequest {
  IPv6CidrBlock?: string(name='IPv6CidrBlock'),
  ipVersion?: string(name='IpVersion'),
  ipv6Isp?: string(name='Ipv6Isp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock'),
  vpcId?: string(name='VpcId'),
}

model AssociateVpcCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateVpcCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateVpcCidrBlockResponseBody(name='body'),
}

async function associateVpcCidrBlockWithOptions(request: AssociateVpcCidrBlockRequest, runtime: Util.RuntimeOptions): AssociateVpcCidrBlockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.IPv6CidrBlock)) {
    query['IPv6CidrBlock'] = request.IPv6CidrBlock;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.ipv6Isp)) {
    query['Ipv6Isp'] = request.ipv6Isp;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.secondaryCidrBlock)) {
    query['SecondaryCidrBlock'] = request.secondaryCidrBlock;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateVpcCidrBlock',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateVpcCidrBlock(request: AssociateVpcCidrBlockRequest): AssociateVpcCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateVpcCidrBlockWithOptions(request, runtime);
}

model AssociateVpnGatewayWithCertificateRequest {
  certificateId?: string(name='CertificateId'),
  certificateType?: string(name='CertificateType'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model AssociateVpnGatewayWithCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateVpnGatewayWithCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateVpnGatewayWithCertificateResponseBody(name='body'),
}

async function associateVpnGatewayWithCertificateWithOptions(request: AssociateVpnGatewayWithCertificateRequest, runtime: Util.RuntimeOptions): AssociateVpnGatewayWithCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.certificateType)) {
    query['CertificateType'] = request.certificateType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateVpnGatewayWithCertificate',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateVpnGatewayWithCertificate(request: AssociateVpnGatewayWithCertificateRequest): AssociateVpnGatewayWithCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateVpnGatewayWithCertificateWithOptions(request, runtime);
}

model AttachDhcpOptionsSetToVpcRequest {
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model AttachDhcpOptionsSetToVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachDhcpOptionsSetToVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachDhcpOptionsSetToVpcResponseBody(name='body'),
}

async function attachDhcpOptionsSetToVpcWithOptions(request: AttachDhcpOptionsSetToVpcRequest, runtime: Util.RuntimeOptions): AttachDhcpOptionsSetToVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dhcpOptionsSetId)) {
    query['DhcpOptionsSetId'] = request.dhcpOptionsSetId;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachDhcpOptionsSetToVpc',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachDhcpOptionsSetToVpc(request: AttachDhcpOptionsSetToVpcRequest): AttachDhcpOptionsSetToVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDhcpOptionsSetToVpcWithOptions(request, runtime);
}

model AttachVbrToVpconnRequest {
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  token?: string(name='Token'),
  vbrId?: string(name='VbrId'),
  vpconnId?: string(name='VpconnId'),
}

model AttachVbrToVpconnResponseBody = {
  requestId?: string(name='RequestId'),
  virtualPhysicalConnection?: string(name='VirtualPhysicalConnection'),
}

model AttachVbrToVpconnResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachVbrToVpconnResponseBody(name='body'),
}

async function attachVbrToVpconnWithOptions(request: AttachVbrToVpconnRequest, runtime: Util.RuntimeOptions): AttachVbrToVpconnResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  if (!Util.isUnset(request.vpconnId)) {
    query['VpconnId'] = request.vpconnId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachVbrToVpconn',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachVbrToVpconn(request: AttachVbrToVpconnRequest): AttachVbrToVpconnResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachVbrToVpconnWithOptions(request, runtime);
}

model CancelCommonBandwidthPackageIpBandwidthRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  eipId?: string(name='EipId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelCommonBandwidthPackageIpBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCommonBandwidthPackageIpBandwidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelCommonBandwidthPackageIpBandwidthResponseBody(name='body'),
}

async function cancelCommonBandwidthPackageIpBandwidthWithOptions(request: CancelCommonBandwidthPackageIpBandwidthRequest, runtime: Util.RuntimeOptions): CancelCommonBandwidthPackageIpBandwidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.eipId)) {
    query['EipId'] = request.eipId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelCommonBandwidthPackageIpBandwidth',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelCommonBandwidthPackageIpBandwidth(request: CancelCommonBandwidthPackageIpBandwidthRequest): CancelCommonBandwidthPackageIpBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

model CancelPhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelPhysicalConnectionResponseBody(name='body'),
}

async function cancelPhysicalConnectionWithOptions(request: CancelPhysicalConnectionRequest, runtime: Util.RuntimeOptions): CancelPhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelPhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelPhysicalConnection(request: CancelPhysicalConnectionRequest): CancelPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelPhysicalConnectionWithOptions(request, runtime);
}

model CheckCanAllocateVpcPrivateIpAddressRequest {
  ipVersion?: string(name='IpVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CheckCanAllocateVpcPrivateIpAddressResponseBody = {
  canAllocate?: boolean(name='CanAllocate'),
  requestId?: string(name='RequestId'),
}

model CheckCanAllocateVpcPrivateIpAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckCanAllocateVpcPrivateIpAddressResponseBody(name='body'),
}

async function checkCanAllocateVpcPrivateIpAddressWithOptions(request: CheckCanAllocateVpcPrivateIpAddressRequest, runtime: Util.RuntimeOptions): CheckCanAllocateVpcPrivateIpAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckCanAllocateVpcPrivateIpAddress',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkCanAllocateVpcPrivateIpAddress(request: CheckCanAllocateVpcPrivateIpAddressRequest): CheckCanAllocateVpcPrivateIpAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkCanAllocateVpcPrivateIpAddressWithOptions(request, runtime);
}

model CheckVpnBgpEnabledRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckVpnBgpEnabledResponseBody = {
  bgpEnabled?: boolean(name='BgpEnabled'),
  requestId?: string(name='RequestId'),
}

model CheckVpnBgpEnabledResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckVpnBgpEnabledResponseBody(name='body'),
}

async function checkVpnBgpEnabledWithOptions(request: CheckVpnBgpEnabledRequest, runtime: Util.RuntimeOptions): CheckVpnBgpEnabledResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckVpnBgpEnabled',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkVpnBgpEnabled(request: CheckVpnBgpEnabledRequest): CheckVpnBgpEnabledResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkVpnBgpEnabledWithOptions(request, runtime);
}

model CompletePhysicalConnectionLOARequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  lineCode?: string(name='LineCode'),
  lineLabel?: string(name='LineLabel'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CompletePhysicalConnectionLOAResponseBody = {
  requestId?: string(name='RequestId'),
}

model CompletePhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompletePhysicalConnectionLOAResponseBody(name='body'),
}

async function completePhysicalConnectionLOAWithOptions(request: CompletePhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): CompletePhysicalConnectionLOAResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lineCode)) {
    query['LineCode'] = request.lineCode;
  }
  if (!Util.isUnset(request.lineLabel)) {
    query['LineLabel'] = request.lineLabel;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CompletePhysicalConnectionLOA',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function completePhysicalConnectionLOA(request: CompletePhysicalConnectionLOARequest): CompletePhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return completePhysicalConnectionLOAWithOptions(request, runtime);
}

model ConfirmPhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ConfirmPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfirmPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmPhysicalConnectionResponseBody(name='body'),
}

async function confirmPhysicalConnectionWithOptions(request: ConfirmPhysicalConnectionRequest, runtime: Util.RuntimeOptions): ConfirmPhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmPhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmPhysicalConnection(request: ConfirmPhysicalConnectionRequest): ConfirmPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmPhysicalConnectionWithOptions(request, runtime);
}

model ConnectRouterInterfaceRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model ConnectRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConnectRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConnectRouterInterfaceResponseBody(name='body'),
}

async function connectRouterInterfaceWithOptions(request: ConnectRouterInterfaceRequest, runtime: Util.RuntimeOptions): ConnectRouterInterfaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerInterfaceId)) {
    query['RouterInterfaceId'] = request.routerInterfaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConnectRouterInterface',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function connectRouterInterface(request: ConnectRouterInterfaceRequest): ConnectRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return connectRouterInterfaceWithOptions(request, runtime);
}

model ConvertBandwidthPackageRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ConvertBandwidthPackageResponseBody = {
  convertInstanceId?: string(name='ConvertInstanceId'),
  requestId?: string(name='RequestId'),
}

model ConvertBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConvertBandwidthPackageResponseBody(name='body'),
}

async function convertBandwidthPackageWithOptions(request: ConvertBandwidthPackageRequest, runtime: Util.RuntimeOptions): ConvertBandwidthPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertBandwidthPackage',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertBandwidthPackage(request: ConvertBandwidthPackageRequest): ConvertBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertBandwidthPackageWithOptions(request, runtime);
}

model CopyNetworkAclEntriesRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceNetworkAclId?: string(name='SourceNetworkAclId'),
}

model CopyNetworkAclEntriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model CopyNetworkAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyNetworkAclEntriesResponseBody(name='body'),
}

async function copyNetworkAclEntriesWithOptions(request: CopyNetworkAclEntriesRequest, runtime: Util.RuntimeOptions): CopyNetworkAclEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.networkAclId)) {
    query['NetworkAclId'] = request.networkAclId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceNetworkAclId)) {
    query['SourceNetworkAclId'] = request.sourceNetworkAclId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyNetworkAclEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyNetworkAclEntries(request: CopyNetworkAclEntriesRequest): CopyNetworkAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyNetworkAclEntriesWithOptions(request, runtime);
}

model CreateBgpGroupRequest {
  authKey?: string(name='AuthKey'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipVersion?: string(name='IpVersion'),
  isFakeAsn?: boolean(name='IsFakeAsn'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerAsn?: long(name='PeerAsn'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model CreateBgpGroupResponseBody = {
  bgpGroupId?: string(name='BgpGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateBgpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBgpGroupResponseBody(name='body'),
}

async function createBgpGroupWithOptions(request: CreateBgpGroupRequest, runtime: Util.RuntimeOptions): CreateBgpGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authKey)) {
    query['AuthKey'] = request.authKey;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.isFakeAsn)) {
    query['IsFakeAsn'] = request.isFakeAsn;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerAsn)) {
    query['PeerAsn'] = request.peerAsn;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerId)) {
    query['RouterId'] = request.routerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBgpGroup',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBgpGroup(request: CreateBgpGroupRequest): CreateBgpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBgpGroupWithOptions(request, runtime);
}

model CreateBgpPeerRequest {
  bfdMultiHop?: int32(name='BfdMultiHop'),
  bgpGroupId?: string(name='BgpGroupId'),
  clientToken?: string(name='ClientToken'),
  enableBfd?: boolean(name='EnableBfd'),
  ipVersion?: string(name='IpVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerIpAddress?: string(name='PeerIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateBgpPeerResponseBody = {
  bgpPeerId?: string(name='BgpPeerId'),
  requestId?: string(name='RequestId'),
}

model CreateBgpPeerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBgpPeerResponseBody(name='body'),
}

async function createBgpPeerWithOptions(request: CreateBgpPeerRequest, runtime: Util.RuntimeOptions): CreateBgpPeerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bfdMultiHop)) {
    query['BfdMultiHop'] = request.bfdMultiHop;
  }
  if (!Util.isUnset(request.bgpGroupId)) {
    query['BgpGroupId'] = request.bgpGroupId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableBfd)) {
    query['EnableBfd'] = request.enableBfd;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerIpAddress)) {
    query['PeerIpAddress'] = request.peerIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBgpPeer',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBgpPeer(request: CreateBgpPeerRequest): CreateBgpPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBgpPeerWithOptions(request, runtime);
}

model CreateCommonBandwidthPackageRequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ISP?: string(name='ISP'),
  internetChargeType?: string(name='InternetChargeType'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  ratio?: int32(name='Ratio'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionTypes?: [ string ](name='SecurityProtectionTypes'),
  zone?: string(name='Zone'),
}

model CreateCommonBandwidthPackageResponseBody = {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateCommonBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCommonBandwidthPackageResponseBody(name='body'),
}

async function createCommonBandwidthPackageWithOptions(request: CreateCommonBandwidthPackageRequest, runtime: Util.RuntimeOptions): CreateCommonBandwidthPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ISP)) {
    query['ISP'] = request.ISP;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.ratio)) {
    query['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityProtectionTypes)) {
    query['SecurityProtectionTypes'] = request.securityProtectionTypes;
  }
  if (!Util.isUnset(request.zone)) {
    query['Zone'] = request.zone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCommonBandwidthPackage',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCommonBandwidthPackage(request: CreateCommonBandwidthPackageRequest): CreateCommonBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCommonBandwidthPackageWithOptions(request, runtime);
}

model CreateCustomerGatewayRequest {
  asn?: string(name='Asn'),
  authKey?: string(name='AuthKey'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateCustomerGatewayResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model CreateCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCustomerGatewayResponseBody(name='body'),
}

async function createCustomerGatewayWithOptions(request: CreateCustomerGatewayRequest, runtime: Util.RuntimeOptions): CreateCustomerGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asn)) {
    query['Asn'] = request.asn;
  }
  if (!Util.isUnset(request.authKey)) {
    query['AuthKey'] = request.authKey;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ipAddress)) {
    query['IpAddress'] = request.ipAddress;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomerGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCustomerGateway(request: CreateCustomerGatewayRequest): CreateCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomerGatewayWithOptions(request, runtime);
}

model CreateDhcpOptionsSetRequest {
  bootFileName?: string(name='BootFileName'),
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  domainName?: string(name='DomainName'),
  domainNameServers?: string(name='DomainNameServers'),
  dryRun?: boolean(name='DryRun'),
  ipv6LeaseTime?: string(name='Ipv6LeaseTime'),
  leaseTime?: string(name='LeaseTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TFTPServerName?: string(name='TFTPServerName'),
}

model CreateDhcpOptionsSetResponseBody = {
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  requestId?: string(name='RequestId'),
}

model CreateDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDhcpOptionsSetResponseBody(name='body'),
}

async function createDhcpOptionsSetWithOptions(request: CreateDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): CreateDhcpOptionsSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bootFileName)) {
    query['BootFileName'] = request.bootFileName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dhcpOptionsSetDescription)) {
    query['DhcpOptionsSetDescription'] = request.dhcpOptionsSetDescription;
  }
  if (!Util.isUnset(request.dhcpOptionsSetName)) {
    query['DhcpOptionsSetName'] = request.dhcpOptionsSetName;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainNameServers)) {
    query['DomainNameServers'] = request.domainNameServers;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ipv6LeaseTime)) {
    query['Ipv6LeaseTime'] = request.ipv6LeaseTime;
  }
  if (!Util.isUnset(request.leaseTime)) {
    query['LeaseTime'] = request.leaseTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TFTPServerName)) {
    query['TFTPServerName'] = request.TFTPServerName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDhcpOptionsSet',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDhcpOptionsSet(request: CreateDhcpOptionsSetRequest): CreateDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDhcpOptionsSetWithOptions(request, runtime);
}

model CreateExpressCloudConnectionRequest {
  bandwidth?: int32(name='Bandwidth'),
  contactMail?: string(name='ContactMail'),
  contactTel?: string(name='ContactTel'),
  description?: string(name='Description'),
  IDCardNo?: string(name='IDCardNo'),
  idcSP?: string(name='IdcSP'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerCity?: string(name='PeerCity'),
  peerLocation?: string(name='PeerLocation'),
  portType?: string(name='PortType'),
  redundantEccId?: string(name='RedundantEccId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateExpressCloudConnectionResponseBody = {
  eccId?: string(name='EccId'),
  requestId?: string(name='RequestId'),
}

model CreateExpressCloudConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateExpressCloudConnectionResponseBody(name='body'),
}

async function createExpressCloudConnectionWithOptions(request: CreateExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): CreateExpressCloudConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.contactMail)) {
    query['ContactMail'] = request.contactMail;
  }
  if (!Util.isUnset(request.contactTel)) {
    query['ContactTel'] = request.contactTel;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.IDCardNo)) {
    query['IDCardNo'] = request.IDCardNo;
  }
  if (!Util.isUnset(request.idcSP)) {
    query['IdcSP'] = request.idcSP;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerCity)) {
    query['PeerCity'] = request.peerCity;
  }
  if (!Util.isUnset(request.peerLocation)) {
    query['PeerLocation'] = request.peerLocation;
  }
  if (!Util.isUnset(request.portType)) {
    query['PortType'] = request.portType;
  }
  if (!Util.isUnset(request.redundantEccId)) {
    query['RedundantEccId'] = request.redundantEccId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateExpressCloudConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createExpressCloudConnection(request: CreateExpressCloudConnectionRequest): CreateExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExpressCloudConnectionWithOptions(request, runtime);
}

model CreateFlowLogRequest {
  aggregationInterval?: int32(name='AggregationInterval'),
  description?: string(name='Description'),
  flowLogName?: string(name='FlowLogName'),
  logStoreName?: string(name='LogStoreName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  projectName?: string(name='ProjectName'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  trafficType?: string(name='TrafficType'),
}

model CreateFlowLogResponseBody = {
  flowLogId?: string(name='FlowLogId'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateFlowLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowLogResponseBody(name='body'),
}

async function createFlowLogWithOptions(request: CreateFlowLogRequest, runtime: Util.RuntimeOptions): CreateFlowLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregationInterval)) {
    query['AggregationInterval'] = request.aggregationInterval;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.flowLogName)) {
    query['FlowLogName'] = request.flowLogName;
  }
  if (!Util.isUnset(request.logStoreName)) {
    query['LogStoreName'] = request.logStoreName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.trafficType)) {
    query['TrafficType'] = request.trafficType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowLog',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowLog(request: CreateFlowLogRequest): CreateFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowLogWithOptions(request, runtime);
}

model CreateForwardEntryRequest {
  clientToken?: string(name='ClientToken'),
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  forwardEntryName?: string(name='ForwardEntryName'),
  forwardTableId?: string(name='ForwardTableId'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  portBreak?: boolean(name='PortBreak'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateForwardEntryResponseBody = {
  forwardEntryId?: string(name='ForwardEntryId'),
  requestId?: string(name='RequestId'),
}

model CreateForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateForwardEntryResponseBody(name='body'),
}

async function createForwardEntryWithOptions(request: CreateForwardEntryRequest, runtime: Util.RuntimeOptions): CreateForwardEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.externalIp)) {
    query['ExternalIp'] = request.externalIp;
  }
  if (!Util.isUnset(request.externalPort)) {
    query['ExternalPort'] = request.externalPort;
  }
  if (!Util.isUnset(request.forwardEntryName)) {
    query['ForwardEntryName'] = request.forwardEntryName;
  }
  if (!Util.isUnset(request.forwardTableId)) {
    query['ForwardTableId'] = request.forwardTableId;
  }
  if (!Util.isUnset(request.internalIp)) {
    query['InternalIp'] = request.internalIp;
  }
  if (!Util.isUnset(request.internalPort)) {
    query['InternalPort'] = request.internalPort;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.portBreak)) {
    query['PortBreak'] = request.portBreak;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateForwardEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createForwardEntry(request: CreateForwardEntryRequest): CreateForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createForwardEntryWithOptions(request, runtime);
}

model CreateFullNatEntryRequest {
  accessIp?: string(name='AccessIp'),
  accessPort?: string(name='AccessPort'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  fullNatEntryDescription?: string(name='FullNatEntryDescription'),
  fullNatEntryName?: string(name='FullNatEntryName'),
  fullNatTableId?: string(name='FullNatTableId'),
  ipProtocol?: string(name='IpProtocol'),
  natIp?: string(name='NatIp'),
  natIpPort?: string(name='NatIpPort'),
  networkInterfaceId?: string(name='NetworkInterfaceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateFullNatEntryResponseBody = {
  fullNatEntryId?: string(name='FullNatEntryId'),
  requestId?: string(name='RequestId'),
}

model CreateFullNatEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFullNatEntryResponseBody(name='body'),
}

async function createFullNatEntryWithOptions(request: CreateFullNatEntryRequest, runtime: Util.RuntimeOptions): CreateFullNatEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessIp)) {
    query['AccessIp'] = request.accessIp;
  }
  if (!Util.isUnset(request.accessPort)) {
    query['AccessPort'] = request.accessPort;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.fullNatEntryDescription)) {
    query['FullNatEntryDescription'] = request.fullNatEntryDescription;
  }
  if (!Util.isUnset(request.fullNatEntryName)) {
    query['FullNatEntryName'] = request.fullNatEntryName;
  }
  if (!Util.isUnset(request.fullNatTableId)) {
    query['FullNatTableId'] = request.fullNatTableId;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.natIp)) {
    query['NatIp'] = request.natIp;
  }
  if (!Util.isUnset(request.natIpPort)) {
    query['NatIpPort'] = request.natIpPort;
  }
  if (!Util.isUnset(request.networkInterfaceId)) {
    query['NetworkInterfaceId'] = request.networkInterfaceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFullNatEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFullNatEntry(request: CreateFullNatEntryRequest): CreateFullNatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFullNatEntryWithOptions(request, runtime);
}

model CreateGlobalAccelerationInstanceRequest {
  bandwidth?: string(name='Bandwidth'),
  bandwidthType?: string(name='BandwidthType'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceLocation?: string(name='ServiceLocation'),
}

model CreateGlobalAccelerationInstanceResponseBody = {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipAddress?: string(name='IpAddress'),
  requestId?: string(name='RequestId'),
}

model CreateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function createGlobalAccelerationInstanceWithOptions(request: CreateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): CreateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.bandwidthType)) {
    query['BandwidthType'] = request.bandwidthType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serviceLocation)) {
    query['ServiceLocation'] = request.serviceLocation;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGlobalAccelerationInstance',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGlobalAccelerationInstance(request: CreateGlobalAccelerationInstanceRequest): CreateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalAccelerationInstanceWithOptions(request, runtime);
}

model CreateHaVipRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateHaVipResponseBody = {
  haVipId?: string(name='HaVipId'),
  ipAddress?: string(name='IpAddress'),
  requestId?: string(name='RequestId'),
}

model CreateHaVipResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHaVipResponseBody(name='body'),
}

async function createHaVipWithOptions(request: CreateHaVipRequest, runtime: Util.RuntimeOptions): CreateHaVipResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ipAddress)) {
    query['IpAddress'] = request.ipAddress;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHaVip',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHaVip(request: CreateHaVipRequest): CreateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHaVipWithOptions(request, runtime);
}

model CreateIPv6TranslatorRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  duration?: int32(name='Duration'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
}

model CreateIPv6TranslatorResponseBody = {
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
}

model CreateIPv6TranslatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIPv6TranslatorResponseBody(name='body'),
}

async function createIPv6TranslatorWithOptions(request: CreateIPv6TranslatorRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIPv6Translator',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIPv6Translator(request: CreateIPv6TranslatorRequest): CreateIPv6TranslatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorWithOptions(request, runtime);
}

model CreateIPv6TranslatorAclListRequest {
  aclName?: string(name='AclName'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateIPv6TranslatorAclListResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId'),
}

model CreateIPv6TranslatorAclListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIPv6TranslatorAclListResponseBody(name='body'),
}

async function createIPv6TranslatorAclListWithOptions(request: CreateIPv6TranslatorAclListRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorAclListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIPv6TranslatorAclList',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIPv6TranslatorAclList(request: CreateIPv6TranslatorAclListRequest): CreateIPv6TranslatorAclListResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorAclListWithOptions(request, runtime);
}

model CreateIPv6TranslatorEntryRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: int32(name='BackendIpv4Port'),
  entryBandwidth?: int32(name='EntryBandwidth'),
  entryDescription?: string(name='EntryDescription'),
  entryName?: string(name='EntryName'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  transProtocol?: string(name='TransProtocol'),
}

model CreateIPv6TranslatorEntryResponseBody = {
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  requestId?: string(name='RequestId'),
}

model CreateIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIPv6TranslatorEntryResponseBody(name='body'),
}

async function createIPv6TranslatorEntryWithOptions(request: CreateIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.allocateIpv6Port)) {
    query['AllocateIpv6Port'] = request.allocateIpv6Port;
  }
  if (!Util.isUnset(request.backendIpv4Addr)) {
    query['BackendIpv4Addr'] = request.backendIpv4Addr;
  }
  if (!Util.isUnset(request.backendIpv4Port)) {
    query['BackendIpv4Port'] = request.backendIpv4Port;
  }
  if (!Util.isUnset(request.entryBandwidth)) {
    query['EntryBandwidth'] = request.entryBandwidth;
  }
  if (!Util.isUnset(request.entryDescription)) {
    query['EntryDescription'] = request.entryDescription;
  }
  if (!Util.isUnset(request.entryName)) {
    query['EntryName'] = request.entryName;
  }
  if (!Util.isUnset(request.ipv6TranslatorId)) {
    query['Ipv6TranslatorId'] = request.ipv6TranslatorId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.transProtocol)) {
    query['TransProtocol'] = request.transProtocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIPv6TranslatorEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIPv6TranslatorEntry(request: CreateIPv6TranslatorEntryRequest): CreateIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorEntryWithOptions(request, runtime);
}

model CreateIpsecServerRequest {
  clientIpPool?: string(name='ClientIpPool'),
  clientToken?: string(name='ClientToken'),
  dryRun?: string(name='DryRun'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipSecServerName?: string(name='IpSecServerName'),
  ipsecConfig?: string(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  psk?: string(name='Psk'),
  pskEnabled?: boolean(name='PskEnabled'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateIpsecServerResponseBody = {
  creationTime?: string(name='CreationTime'),
  ipsecServerId?: string(name='IpsecServerId'),
  ipsecServerName?: string(name='IpsecServerName'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIpsecServerResponseBody(name='body'),
}

async function createIpsecServerWithOptions(request: CreateIpsecServerRequest, runtime: Util.RuntimeOptions): CreateIpsecServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientIpPool)) {
    query['ClientIpPool'] = request.clientIpPool;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.effectImmediately)) {
    query['EffectImmediately'] = request.effectImmediately;
  }
  if (!Util.isUnset(request.ikeConfig)) {
    query['IkeConfig'] = request.ikeConfig;
  }
  if (!Util.isUnset(request.ipSecServerName)) {
    query['IpSecServerName'] = request.ipSecServerName;
  }
  if (!Util.isUnset(request.ipsecConfig)) {
    query['IpsecConfig'] = request.ipsecConfig;
  }
  if (!Util.isUnset(request.localSubnet)) {
    query['LocalSubnet'] = request.localSubnet;
  }
  if (!Util.isUnset(request.psk)) {
    query['Psk'] = request.psk;
  }
  if (!Util.isUnset(request.pskEnabled)) {
    query['PskEnabled'] = request.pskEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIpsecServer',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIpsecServer(request: CreateIpsecServerRequest): CreateIpsecServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpsecServerWithOptions(request, runtime);
}

model CreateIpv4GatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
  ipv4GatewayName?: string(name='Ipv4GatewayName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model CreateIpv4GatewayResponseBody = {
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv4GatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIpv4GatewayResponseBody(name='body'),
}

async function createIpv4GatewayWithOptions(request: CreateIpv4GatewayRequest, runtime: Util.RuntimeOptions): CreateIpv4GatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ipv4GatewayDescription)) {
    query['Ipv4GatewayDescription'] = request.ipv4GatewayDescription;
  }
  if (!Util.isUnset(request.ipv4GatewayName)) {
    query['Ipv4GatewayName'] = request.ipv4GatewayName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIpv4Gateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIpv4Gateway(request: CreateIpv4GatewayRequest): CreateIpv4GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv4GatewayWithOptions(request, runtime);
}

model CreateIpv6EgressOnlyRuleRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateIpv6EgressOnlyRuleResponseBody = {
  ipv6EgressRuleId?: string(name='Ipv6EgressRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv6EgressOnlyRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIpv6EgressOnlyRuleResponseBody(name='body'),
}

async function createIpv6EgressOnlyRuleWithOptions(request: CreateIpv6EgressOnlyRuleRequest, runtime: Util.RuntimeOptions): CreateIpv6EgressOnlyRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ipv6GatewayId)) {
    query['Ipv6GatewayId'] = request.ipv6GatewayId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIpv6EgressOnlyRule',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIpv6EgressOnlyRule(request: CreateIpv6EgressOnlyRuleRequest): CreateIpv6EgressOnlyRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv6EgressOnlyRuleWithOptions(request, runtime);
}

model CreateIpv6GatewayRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
  vpcId?: string(name='VpcId'),
}

model CreateIpv6GatewayResponseBody = {
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv6GatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIpv6GatewayResponseBody(name='body'),
}

async function createIpv6GatewayWithOptions(request: CreateIpv6GatewayRequest, runtime: Util.RuntimeOptions): CreateIpv6GatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIpv6Gateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIpv6Gateway(request: CreateIpv6GatewayRequest): CreateIpv6GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv6GatewayWithOptions(request, runtime);
}

model CreateNatGatewayRequest {
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  duration?: string(name='Duration'),
  eipBindMode?: string(name='EipBindMode'),
  icmpReplyEnabled?: boolean(name='IcmpReplyEnabled'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  name?: string(name='Name'),
  natType?: string(name='NatType'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled'),
  spec?: string(name='Spec'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model CreateNatGatewayResponseBody = {
  forwardTableIds?: {
    forwardTableId?: [ string ](name='ForwardTableId')
  }(name='ForwardTableIds'),
  fullNatTableIds?: {
    fullNatTableId?: [ string ](name='FullNatTableId')
  }(name='FullNatTableIds'),
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId'),
  snatTableIds?: {
    snatTableId?: [ string ](name='SnatTableId')
  }(name='SnatTableIds'),
}

model CreateNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNatGatewayResponseBody(name='body'),
}

async function createNatGatewayWithOptions(request: CreateNatGatewayRequest, runtime: Util.RuntimeOptions): CreateNatGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.eipBindMode)) {
    query['EipBindMode'] = request.eipBindMode;
  }
  if (!Util.isUnset(request.icmpReplyEnabled)) {
    query['IcmpReplyEnabled'] = request.icmpReplyEnabled;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.internetChargeType)) {
    query['InternetChargeType'] = request.internetChargeType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.natType)) {
    query['NatType'] = request.natType;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityProtectionEnabled)) {
    query['SecurityProtectionEnabled'] = request.securityProtectionEnabled;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNatGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNatGateway(request: CreateNatGatewayRequest): CreateNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNatGatewayWithOptions(request, runtime);
}

model CreateNatIpRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natIp?: string(name='NatIp'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpCidrId?: string(name='NatIpCidrId'),
  natIpDescription?: string(name='NatIpDescription'),
  natIpName?: string(name='NatIpName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateNatIpResponseBody = {
  natIp?: string(name='NatIp'),
  natIpId?: string(name='NatIpId'),
  requestId?: string(name='RequestId'),
}

model CreateNatIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNatIpResponseBody(name='body'),
}

async function createNatIpWithOptions(request: CreateNatIpRequest, runtime: Util.RuntimeOptions): CreateNatIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.natIp)) {
    query['NatIp'] = request.natIp;
  }
  if (!Util.isUnset(request.natIpCidr)) {
    query['NatIpCidr'] = request.natIpCidr;
  }
  if (!Util.isUnset(request.natIpCidrId)) {
    query['NatIpCidrId'] = request.natIpCidrId;
  }
  if (!Util.isUnset(request.natIpDescription)) {
    query['NatIpDescription'] = request.natIpDescription;
  }
  if (!Util.isUnset(request.natIpName)) {
    query['NatIpName'] = request.natIpName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNatIp',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNatIp(request: CreateNatIpRequest): CreateNatIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNatIpWithOptions(request, runtime);
}

model CreateNatIpCidrRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpCidrDescription?: string(name='NatIpCidrDescription'),
  natIpCidrName?: string(name='NatIpCidrName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateNatIpCidrResponseBody = {
  natIpCidrId?: string(name='NatIpCidrId'),
  requestId?: string(name='RequestId'),
}

model CreateNatIpCidrResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNatIpCidrResponseBody(name='body'),
}

async function createNatIpCidrWithOptions(request: CreateNatIpCidrRequest, runtime: Util.RuntimeOptions): CreateNatIpCidrResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.natIpCidr)) {
    query['NatIpCidr'] = request.natIpCidr;
  }
  if (!Util.isUnset(request.natIpCidrDescription)) {
    query['NatIpCidrDescription'] = request.natIpCidrDescription;
  }
  if (!Util.isUnset(request.natIpCidrName)) {
    query['NatIpCidrName'] = request.natIpCidrName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNatIpCidr',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNatIpCidr(request: CreateNatIpCidrRequest): CreateNatIpCidrResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNatIpCidrWithOptions(request, runtime);
}

model CreateNetworkAclRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  networkAclName?: string(name='NetworkAclName'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model CreateNetworkAclResponseBody = {
  networkAclAttribute?: {
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    egressAclEntries?: {
      egressAclEntry?: [ 
      {
        description?: string(name='Description'),
        destinationCidrIp?: string(name='DestinationCidrIp'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
      }
    ](name='EgressAclEntry')
    }(name='EgressAclEntries'),
    ingressAclEntries?: {
      ingressAclEntry?: [ 
      {
        description?: string(name='Description'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
        sourceCidrIp?: string(name='SourceCidrIp'),
      }
    ](name='IngressAclEntry')
    }(name='IngressAclEntries'),
    networkAclId?: string(name='NetworkAclId'),
    networkAclName?: string(name='NetworkAclName'),
    regionId?: string(name='RegionId'),
    resources?: {
      resource?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        status?: string(name='Status'),
      }
    ](name='Resource')
    }(name='Resources'),
    status?: string(name='Status'),
    vpcId?: string(name='VpcId'),
  }(name='NetworkAclAttribute'),
  networkAclId?: string(name='NetworkAclId'),
  requestId?: string(name='RequestId'),
}

model CreateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNetworkAclResponseBody(name='body'),
}

async function createNetworkAclWithOptions(request: CreateNetworkAclRequest, runtime: Util.RuntimeOptions): CreateNetworkAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.networkAclName)) {
    query['NetworkAclName'] = request.networkAclName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNetworkAcl',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNetworkAcl(request: CreateNetworkAclRequest): CreateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNetworkAclWithOptions(request, runtime);
}

model CreatePhysicalConnectionRequest {
  accessPointId?: string(name='AccessPointId'),
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  lineOperator?: string(name='LineOperator'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerLocation?: string(name='PeerLocation'),
  portType?: string(name='PortType'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  type?: string(name='Type'),
  bandwidth?: int32(name='bandwidth'),
}

model CreatePhysicalConnectionResponseBody = {
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePhysicalConnectionResponseBody(name='body'),
}

async function createPhysicalConnectionWithOptions(request: CreatePhysicalConnectionRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessPointId)) {
    query['AccessPointId'] = request.accessPointId;
  }
  if (!Util.isUnset(request.circuitCode)) {
    query['CircuitCode'] = request.circuitCode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.lineOperator)) {
    query['LineOperator'] = request.lineOperator;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerLocation)) {
    query['PeerLocation'] = request.peerLocation;
  }
  if (!Util.isUnset(request.portType)) {
    query['PortType'] = request.portType;
  }
  if (!Util.isUnset(request.redundantPhysicalConnectionId)) {
    query['RedundantPhysicalConnectionId'] = request.redundantPhysicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['bandwidth'] = request.bandwidth;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPhysicalConnection(request: CreatePhysicalConnectionRequest): CreatePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionWithOptions(request, runtime);
}

model CreatePhysicalConnectionOccupancyOrderRequest {
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  instanceChargeType?: string(name='InstanceChargeType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreatePhysicalConnectionOccupancyOrderResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionOccupancyOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePhysicalConnectionOccupancyOrderResponseBody(name='body'),
}

async function createPhysicalConnectionOccupancyOrderWithOptions(request: CreatePhysicalConnectionOccupancyOrderRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionOccupancyOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePhysicalConnectionOccupancyOrder',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPhysicalConnectionOccupancyOrder(request: CreatePhysicalConnectionOccupancyOrderRequest): CreatePhysicalConnectionOccupancyOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionOccupancyOrderWithOptions(request, runtime);
}

model CreatePhysicalConnectionSetupOrderRequest {
  accessPointId?: string(name='AccessPointId'),
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  lineOperator?: string(name='LineOperator'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  portType?: string(name='PortType'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreatePhysicalConnectionSetupOrderResponseBody = {
  orderId?: string(name='OrderId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionSetupOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePhysicalConnectionSetupOrderResponseBody(name='body'),
}

async function createPhysicalConnectionSetupOrderWithOptions(request: CreatePhysicalConnectionSetupOrderRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionSetupOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessPointId)) {
    query['AccessPointId'] = request.accessPointId;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lineOperator)) {
    query['LineOperator'] = request.lineOperator;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.portType)) {
    query['PortType'] = request.portType;
  }
  if (!Util.isUnset(request.redundantPhysicalConnectionId)) {
    query['RedundantPhysicalConnectionId'] = request.redundantPhysicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePhysicalConnectionSetupOrder',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPhysicalConnectionSetupOrder(request: CreatePhysicalConnectionSetupOrderRequest): CreatePhysicalConnectionSetupOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionSetupOrderWithOptions(request, runtime);
}

model CreatePublicIpAddressPoolRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  isp?: string(name='Isp'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreatePublicIpAddressPoolResponseBody = {
  pulbicIpAddressPoolId?: string(name='PulbicIpAddressPoolId'),
  requestId?: string(name='RequestId'),
}

model CreatePublicIpAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePublicIpAddressPoolResponseBody(name='body'),
}

async function createPublicIpAddressPoolWithOptions(request: CreatePublicIpAddressPoolRequest, runtime: Util.RuntimeOptions): CreatePublicIpAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePublicIpAddressPool',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPublicIpAddressPool(request: CreatePublicIpAddressPoolRequest): CreatePublicIpAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPublicIpAddressPoolWithOptions(request, runtime);
}

model CreateRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  nextHopId?: string(name='NextHopId'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
      weight?: int32(name='Weight'),
    }
  ](name='NextHopList'),
  nextHopType?: string(name='NextHopType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryName?: string(name='RouteEntryName'),
  routeTableId?: string(name='RouteTableId'),
}

model CreateRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
  routeEntryId?: string(name='RouteEntryId'),
}

model CreateRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRouteEntryResponseBody(name='body'),
}

async function createRouteEntryWithOptions(request: CreateRouteEntryRequest, runtime: Util.RuntimeOptions): CreateRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destinationCidrBlock)) {
    query['DestinationCidrBlock'] = request.destinationCidrBlock;
  }
  if (!Util.isUnset(request.nextHopId)) {
    query['NextHopId'] = request.nextHopId;
  }
  if (!Util.isUnset(request.nextHopList)) {
    query['NextHopList'] = request.nextHopList;
  }
  if (!Util.isUnset(request.nextHopType)) {
    query['NextHopType'] = request.nextHopType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeEntryName)) {
    query['RouteEntryName'] = request.routeEntryName;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRouteEntry(request: CreateRouteEntryRequest): CreateRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouteEntryWithOptions(request, runtime);
}

model CreateRouteTableRequest {
  associateType?: string(name='AssociateType'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableName?: string(name='RouteTableName'),
  vpcId?: string(name='VpcId'),
}

model CreateRouteTableResponseBody = {
  associateType?: string(name='AssociateType'),
  requestId?: string(name='RequestId'),
  routeTableId?: string(name='RouteTableId'),
}

model CreateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRouteTableResponseBody(name='body'),
}

async function createRouteTableWithOptions(request: CreateRouteTableRequest, runtime: Util.RuntimeOptions): CreateRouteTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.associateType)) {
    query['AssociateType'] = request.associateType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableName)) {
    query['RouteTableName'] = request.routeTableName;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRouteTable',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRouteTable(request: CreateRouteTableRequest): CreateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouteTableWithOptions(request, runtime);
}

model CreateRouterInterfaceRequest {
  accessPointId?: string(name='AccessPointId'),
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  instanceChargeType?: string(name='InstanceChargeType'),
  name?: string(name='Name'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
  oppositeRegionId?: string(name='OppositeRegionId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  role?: string(name='Role'),
  routerId?: string(name='RouterId'),
  routerType?: string(name='RouterType'),
  spec?: string(name='Spec'),
}

model CreateRouterInterfaceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model CreateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRouterInterfaceResponseBody(name='body'),
}

async function createRouterInterfaceWithOptions(request: CreateRouterInterfaceRequest, runtime: Util.RuntimeOptions): CreateRouterInterfaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessPointId)) {
    query['AccessPointId'] = request.accessPointId;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.healthCheckSourceIp)) {
    query['HealthCheckSourceIp'] = request.healthCheckSourceIp;
  }
  if (!Util.isUnset(request.healthCheckTargetIp)) {
    query['HealthCheckTargetIp'] = request.healthCheckTargetIp;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.oppositeAccessPointId)) {
    query['OppositeAccessPointId'] = request.oppositeAccessPointId;
  }
  if (!Util.isUnset(request.oppositeInterfaceId)) {
    query['OppositeInterfaceId'] = request.oppositeInterfaceId;
  }
  if (!Util.isUnset(request.oppositeInterfaceOwnerId)) {
    query['OppositeInterfaceOwnerId'] = request.oppositeInterfaceOwnerId;
  }
  if (!Util.isUnset(request.oppositeRegionId)) {
    query['OppositeRegionId'] = request.oppositeRegionId;
  }
  if (!Util.isUnset(request.oppositeRouterId)) {
    query['OppositeRouterId'] = request.oppositeRouterId;
  }
  if (!Util.isUnset(request.oppositeRouterType)) {
    query['OppositeRouterType'] = request.oppositeRouterType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  if (!Util.isUnset(request.routerId)) {
    query['RouterId'] = request.routerId;
  }
  if (!Util.isUnset(request.routerType)) {
    query['RouterType'] = request.routerType;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRouterInterface',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRouterInterface(request: CreateRouterInterfaceRequest): CreateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouterInterfaceWithOptions(request, runtime);
}

model CreateSnatEntryRequest {
  clientToken?: string(name='ClientToken'),
  eipAffinity?: int32(name='EipAffinity'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snatEntryName?: string(name='SnatEntryName'),
  snatIp?: string(name='SnatIp'),
  snatTableId?: string(name='SnatTableId'),
  sourceCIDR?: string(name='SourceCIDR'),
  sourceVSwitchId?: string(name='SourceVSwitchId'),
}

model CreateSnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
  snatEntryId?: string(name='SnatEntryId'),
}

model CreateSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSnatEntryResponseBody(name='body'),
}

async function createSnatEntryWithOptions(request: CreateSnatEntryRequest, runtime: Util.RuntimeOptions): CreateSnatEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.eipAffinity)) {
    query['EipAffinity'] = request.eipAffinity;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.snatEntryName)) {
    query['SnatEntryName'] = request.snatEntryName;
  }
  if (!Util.isUnset(request.snatIp)) {
    query['SnatIp'] = request.snatIp;
  }
  if (!Util.isUnset(request.snatTableId)) {
    query['SnatTableId'] = request.snatTableId;
  }
  if (!Util.isUnset(request.sourceCIDR)) {
    query['SourceCIDR'] = request.sourceCIDR;
  }
  if (!Util.isUnset(request.sourceVSwitchId)) {
    query['SourceVSwitchId'] = request.sourceVSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSnatEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSnatEntry(request: CreateSnatEntryRequest): CreateSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSnatEntryWithOptions(request, runtime);
}

model CreateSslVpnClientCertRequest {
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model CreateSslVpnClientCertResponseBody = {
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model CreateSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSslVpnClientCertResponseBody(name='body'),
}

async function createSslVpnClientCertWithOptions(request: CreateSslVpnClientCertRequest, runtime: Util.RuntimeOptions): CreateSslVpnClientCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslVpnServerId)) {
    query['SslVpnServerId'] = request.sslVpnServerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSslVpnClientCert',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSslVpnClientCert(request: CreateSslVpnClientCertRequest): CreateSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSslVpnClientCertWithOptions(request, runtime);
}

model CreateSslVpnServerRequest {
  cipher?: string(name='Cipher'),
  clientIpPool?: string(name='ClientIpPool'),
  clientToken?: string(name='ClientToken'),
  compress?: boolean(name='Compress'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
  IDaaSRegionId?: string(name='IDaaSRegionId'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: int32(name='Port'),
  proto?: string(name='Proto'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateSslVpnServerResponseBody = {
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model CreateSslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSslVpnServerResponseBody(name='body'),
}

async function createSslVpnServerWithOptions(request: CreateSslVpnServerRequest, runtime: Util.RuntimeOptions): CreateSslVpnServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cipher)) {
    query['Cipher'] = request.cipher;
  }
  if (!Util.isUnset(request.clientIpPool)) {
    query['ClientIpPool'] = request.clientIpPool;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compress)) {
    query['Compress'] = request.compress;
  }
  if (!Util.isUnset(request.enableMultiFactorAuth)) {
    query['EnableMultiFactorAuth'] = request.enableMultiFactorAuth;
  }
  if (!Util.isUnset(request.IDaaSInstanceId)) {
    query['IDaaSInstanceId'] = request.IDaaSInstanceId;
  }
  if (!Util.isUnset(request.IDaaSRegionId)) {
    query['IDaaSRegionId'] = request.IDaaSRegionId;
  }
  if (!Util.isUnset(request.localSubnet)) {
    query['LocalSubnet'] = request.localSubnet;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.proto)) {
    query['Proto'] = request.proto;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSslVpnServer',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSslVpnServer(request: CreateSslVpnServerRequest): CreateSslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSslVpnServerWithOptions(request, runtime);
}

model CreateTrafficMirrorFilterRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  egressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='EgressRules'),
  ingressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='IngressRules'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterDescription?: string(name='TrafficMirrorFilterDescription'),
  trafficMirrorFilterName?: string(name='TrafficMirrorFilterName'),
}

model CreateTrafficMirrorFilterResponseBody = {
  requestId?: string(name='RequestId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
}

model CreateTrafficMirrorFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTrafficMirrorFilterResponseBody(name='body'),
}

async function createTrafficMirrorFilterWithOptions(request: CreateTrafficMirrorFilterRequest, runtime: Util.RuntimeOptions): CreateTrafficMirrorFilterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.egressRules)) {
    query['EgressRules'] = request.egressRules;
  }
  if (!Util.isUnset(request.ingressRules)) {
    query['IngressRules'] = request.ingressRules;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterDescription)) {
    query['TrafficMirrorFilterDescription'] = request.trafficMirrorFilterDescription;
  }
  if (!Util.isUnset(request.trafficMirrorFilterName)) {
    query['TrafficMirrorFilterName'] = request.trafficMirrorFilterName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrafficMirrorFilter',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTrafficMirrorFilter(request: CreateTrafficMirrorFilterRequest): CreateTrafficMirrorFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTrafficMirrorFilterWithOptions(request, runtime);
}

model CreateTrafficMirrorFilterRulesRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  egressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='EgressRules'),
  ingressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='IngressRules'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
}

model CreateTrafficMirrorFilterRulesResponseBody = {
  egressRules?: [ 
    {
      instanceId?: string(name='InstanceId'),
    }
  ](name='EgressRules'),
  ingressRules?: [ 
    {
      instanceId?: string(name='InstanceId'),
    }
  ](name='IngressRules'),
  requestId?: string(name='RequestId'),
}

model CreateTrafficMirrorFilterRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTrafficMirrorFilterRulesResponseBody(name='body'),
}

async function createTrafficMirrorFilterRulesWithOptions(request: CreateTrafficMirrorFilterRulesRequest, runtime: Util.RuntimeOptions): CreateTrafficMirrorFilterRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.egressRules)) {
    query['EgressRules'] = request.egressRules;
  }
  if (!Util.isUnset(request.ingressRules)) {
    query['IngressRules'] = request.ingressRules;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterId)) {
    query['TrafficMirrorFilterId'] = request.trafficMirrorFilterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrafficMirrorFilterRules',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTrafficMirrorFilterRules(request: CreateTrafficMirrorFilterRulesRequest): CreateTrafficMirrorFilterRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTrafficMirrorFilterRulesWithOptions(request, runtime);
}

model CreateTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  enabled?: boolean(name='Enabled'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  packetLength?: int32(name='PacketLength'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorSessionDescription?: string(name='TrafficMirrorSessionDescription'),
  trafficMirrorSessionName?: string(name='TrafficMirrorSessionName'),
  trafficMirrorSourceIds?: [ string ](name='TrafficMirrorSourceIds'),
  trafficMirrorTargetId?: string(name='TrafficMirrorTargetId'),
  trafficMirrorTargetType?: string(name='TrafficMirrorTargetType'),
  virtualNetworkId?: int32(name='VirtualNetworkId'),
}

model CreateTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
}

model CreateTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTrafficMirrorSessionResponseBody(name='body'),
}

async function createTrafficMirrorSessionWithOptions(request: CreateTrafficMirrorSessionRequest, runtime: Util.RuntimeOptions): CreateTrafficMirrorSessionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.packetLength)) {
    query['PacketLength'] = request.packetLength;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterId)) {
    query['TrafficMirrorFilterId'] = request.trafficMirrorFilterId;
  }
  if (!Util.isUnset(request.trafficMirrorSessionDescription)) {
    query['TrafficMirrorSessionDescription'] = request.trafficMirrorSessionDescription;
  }
  if (!Util.isUnset(request.trafficMirrorSessionName)) {
    query['TrafficMirrorSessionName'] = request.trafficMirrorSessionName;
  }
  if (!Util.isUnset(request.trafficMirrorSourceIds)) {
    query['TrafficMirrorSourceIds'] = request.trafficMirrorSourceIds;
  }
  if (!Util.isUnset(request.trafficMirrorTargetId)) {
    query['TrafficMirrorTargetId'] = request.trafficMirrorTargetId;
  }
  if (!Util.isUnset(request.trafficMirrorTargetType)) {
    query['TrafficMirrorTargetType'] = request.trafficMirrorTargetType;
  }
  if (!Util.isUnset(request.virtualNetworkId)) {
    query['VirtualNetworkId'] = request.virtualNetworkId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrafficMirrorSession',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTrafficMirrorSession(request: CreateTrafficMirrorSessionRequest): CreateTrafficMirrorSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTrafficMirrorSessionWithOptions(request, runtime);
}

model CreateVSwitchRequest {
  cidrBlock?: string(name='CidrBlock'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipv6CidrBlock?: int32(name='Ipv6CidrBlock'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchName?: string(name='VSwitchName'),
  vpcId?: string(name='VpcId'),
  vpcIpv6CidrBlock?: string(name='VpcIpv6CidrBlock'),
  zoneId?: string(name='ZoneId'),
}

model CreateVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateVSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVSwitchResponseBody(name='body'),
}

async function createVSwitchWithOptions(request: CreateVSwitchRequest, runtime: Util.RuntimeOptions): CreateVSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ipv6CidrBlock)) {
    query['Ipv6CidrBlock'] = request.ipv6CidrBlock;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchName)) {
    query['VSwitchName'] = request.vSwitchName;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vpcIpv6CidrBlock)) {
    query['VpcIpv6CidrBlock'] = request.vpcIpv6CidrBlock;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVSwitch',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVSwitch(request: CreateVSwitchRequest): CreateVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVSwitchWithOptions(request, runtime);
}

model CreateVbrHaRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerVbrId?: string(name='PeerVbrId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model CreateVbrHaResponseBody = {
  requestId?: string(name='RequestId'),
  vbrHaId?: string(name='VbrHaId'),
}

model CreateVbrHaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVbrHaResponseBody(name='body'),
}

async function createVbrHaWithOptions(request: CreateVbrHaRequest, runtime: Util.RuntimeOptions): CreateVbrHaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerVbrId)) {
    query['PeerVbrId'] = request.peerVbrId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVbrHa',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVbrHa(request: CreateVbrHaRequest): CreateVbrHaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVbrHaWithOptions(request, runtime);
}

model CreateVcoRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  weight?: int32(name='Weight'),
}

model CreateVcoRouteEntryResponseBody = {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  requestId?: string(name='RequestId'),
  routeDest?: string(name='RouteDest'),
  state?: string(name='State'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  weight?: int32(name='Weight'),
}

model CreateVcoRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVcoRouteEntryResponseBody(name='body'),
}

async function createVcoRouteEntryWithOptions(request: CreateVcoRouteEntryRequest, runtime: Util.RuntimeOptions): CreateVcoRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.overlayMode)) {
    query['OverlayMode'] = request.overlayMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVcoRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVcoRouteEntry(request: CreateVcoRouteEntryRequest): CreateVcoRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVcoRouteEntryWithOptions(request, runtime);
}

model CreateVirtualBorderRouterRequest {
  bandwidth?: long(name='Bandwidth'),
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  enableIpv6?: boolean(name='EnableIpv6'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrOwnerId?: long(name='VbrOwnerId'),
  vlanId?: int32(name='VlanId'),
}

model CreateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
  vbrId?: string(name='VbrId'),
}

model CreateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVirtualBorderRouterResponseBody(name='body'),
}

async function createVirtualBorderRouterWithOptions(request: CreateVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): CreateVirtualBorderRouterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.circuitCode)) {
    query['CircuitCode'] = request.circuitCode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableIpv6)) {
    query['EnableIpv6'] = request.enableIpv6;
  }
  if (!Util.isUnset(request.localGatewayIp)) {
    query['LocalGatewayIp'] = request.localGatewayIp;
  }
  if (!Util.isUnset(request.localIpv6GatewayIp)) {
    query['LocalIpv6GatewayIp'] = request.localIpv6GatewayIp;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerGatewayIp)) {
    query['PeerGatewayIp'] = request.peerGatewayIp;
  }
  if (!Util.isUnset(request.peerIpv6GatewayIp)) {
    query['PeerIpv6GatewayIp'] = request.peerIpv6GatewayIp;
  }
  if (!Util.isUnset(request.peeringIpv6SubnetMask)) {
    query['PeeringIpv6SubnetMask'] = request.peeringIpv6SubnetMask;
  }
  if (!Util.isUnset(request.peeringSubnetMask)) {
    query['PeeringSubnetMask'] = request.peeringSubnetMask;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vbrOwnerId)) {
    query['VbrOwnerId'] = request.vbrOwnerId;
  }
  if (!Util.isUnset(request.vlanId)) {
    query['VlanId'] = request.vlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVirtualBorderRouter',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVirtualBorderRouter(request: CreateVirtualBorderRouterRequest): CreateVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualBorderRouterWithOptions(request, runtime);
}

model CreateVirtualPhysicalConnectionRequest {
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  orderMode?: string(name='OrderMode'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  spec?: string(name='Spec'),
  token?: string(name='Token'),
  vlanId?: long(name='VlanId'),
  vpconnAliUid?: long(name='VpconnAliUid'),
}

model CreateVirtualPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
  virtualPhysicalConnection?: string(name='VirtualPhysicalConnection'),
}

model CreateVirtualPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVirtualPhysicalConnectionResponseBody(name='body'),
}

async function createVirtualPhysicalConnectionWithOptions(request: CreateVirtualPhysicalConnectionRequest, runtime: Util.RuntimeOptions): CreateVirtualPhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.orderMode)) {
    query['OrderMode'] = request.orderMode;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.vlanId)) {
    query['VlanId'] = request.vlanId;
  }
  if (!Util.isUnset(request.vpconnAliUid)) {
    query['VpconnAliUid'] = request.vpconnAliUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVirtualPhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVirtualPhysicalConnection(request: CreateVirtualPhysicalConnectionRequest): CreateVirtualPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualPhysicalConnectionWithOptions(request, runtime);
}

model CreateVpcRequest {
  cidrBlock?: string(name='CidrBlock'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  enableIpv6?: boolean(name='EnableIpv6'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  ipv6Isp?: string(name='Ipv6Isp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userCidr?: string(name='UserCidr'),
  vpcName?: string(name='VpcName'),
}

model CreateVpcResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  routeTableId?: string(name='RouteTableId'),
  VRouterId?: string(name='VRouterId'),
  vpcId?: string(name='VpcId'),
}

model CreateVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpcResponseBody(name='body'),
}

async function createVpcWithOptions(request: CreateVpcRequest, runtime: Util.RuntimeOptions): CreateVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.enableIpv6)) {
    query['EnableIpv6'] = request.enableIpv6;
  }
  if (!Util.isUnset(request.ipv6CidrBlock)) {
    query['Ipv6CidrBlock'] = request.ipv6CidrBlock;
  }
  if (!Util.isUnset(request.ipv6Isp)) {
    query['Ipv6Isp'] = request.ipv6Isp;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.userCidr)) {
    query['UserCidr'] = request.userCidr;
  }
  if (!Util.isUnset(request.vpcName)) {
    query['VpcName'] = request.vpcName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpc',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpc(request: CreateVpcRequest): CreateVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcWithOptions(request, runtime);
}

model CreateVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointDescription?: string(name='EndpointDescription'),
  endpointName?: string(name='EndpointName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  policyDocument?: string(name='PolicyDocument'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceName?: string(name='ServiceName'),
  vpcId?: string(name='VpcId'),
}

model CreateVpcGatewayEndpointResponseBody = {
  creationTime?: string(name='CreationTime'),
  endpointId?: string(name='EndpointId'),
  endpointName?: string(name='EndpointName'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
}

model CreateVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpcGatewayEndpointResponseBody(name='body'),
}

async function createVpcGatewayEndpointWithOptions(request: CreateVpcGatewayEndpointRequest, runtime: Util.RuntimeOptions): CreateVpcGatewayEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endpointDescription)) {
    query['EndpointDescription'] = request.endpointDescription;
  }
  if (!Util.isUnset(request.endpointName)) {
    query['EndpointName'] = request.endpointName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.policyDocument)) {
    query['PolicyDocument'] = request.policyDocument;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcGatewayEndpoint',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpcGatewayEndpoint(request: CreateVpcGatewayEndpointRequest): CreateVpcGatewayEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcGatewayEndpointWithOptions(request, runtime);
}

model CreateVpcPrefixListRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ipVersion?: string(name='IpVersion'),
  maxEntries?: int32(name='MaxEntries'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  prefixListDescription?: string(name='PrefixListDescription'),
  prefixListEntrys?: [ 
    {
      cidr?: string(name='Cidr'),
      description?: string(name='Description'),
    }
  ](name='PrefixListEntrys'),
  prefixListName?: string(name='PrefixListName'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateVpcPrefixListResponseBody = {
  prefixListId?: string(name='PrefixListId'),
  requestId?: string(name='RequestId'),
}

model CreateVpcPrefixListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpcPrefixListResponseBody(name='body'),
}

async function createVpcPrefixListWithOptions(request: CreateVpcPrefixListRequest, runtime: Util.RuntimeOptions): CreateVpcPrefixListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.maxEntries)) {
    query['MaxEntries'] = request.maxEntries;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.prefixListDescription)) {
    query['PrefixListDescription'] = request.prefixListDescription;
  }
  if (!Util.isUnset(request.prefixListEntrys)) {
    query['PrefixListEntrys'] = request.prefixListEntrys;
  }
  if (!Util.isUnset(request.prefixListName)) {
    query['PrefixListName'] = request.prefixListName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcPrefixList',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpcPrefixList(request: CreateVpcPrefixListRequest): CreateVpcPrefixListResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcPrefixListWithOptions(request, runtime);
}

model CreateVpconnFromVbrRequest {
  dryRun?: boolean(name='DryRun'),
  orderMode?: string(name='OrderMode'),
  regionId?: string(name='RegionId'),
  token?: string(name='Token'),
  vbrId?: string(name='VbrId'),
}

model CreateVpconnFromVbrResponseBody = {
  requestId?: string(name='RequestId'),
  virtualPhysicalConnection?: string(name='VirtualPhysicalConnection'),
}

model CreateVpconnFromVbrResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpconnFromVbrResponseBody(name='body'),
}

async function createVpconnFromVbrWithOptions(request: CreateVpconnFromVbrRequest, runtime: Util.RuntimeOptions): CreateVpconnFromVbrResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.orderMode)) {
    query['OrderMode'] = request.orderMode;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpconnFromVbr',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpconnFromVbr(request: CreateVpconnFromVbrRequest): CreateVpconnFromVbrResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpconnFromVbrWithOptions(request, runtime);
}

model CreateVpnAttachmentRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  bgpConfig?: string(name='BgpConfig'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  remoteCaCert?: string(name='RemoteCaCert'),
  remoteSubnet?: string(name='RemoteSubnet'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateVpnAttachmentResponseBody = {
  code?: string(name='Code'),
  createTime?: long(name='CreateTime'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model CreateVpnAttachmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpnAttachmentResponseBody(name='body'),
}

async function createVpnAttachmentWithOptions(request: CreateVpnAttachmentRequest, runtime: Util.RuntimeOptions): CreateVpnAttachmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoConfigRoute)) {
    query['AutoConfigRoute'] = request.autoConfigRoute;
  }
  if (!Util.isUnset(request.bgpConfig)) {
    query['BgpConfig'] = request.bgpConfig;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.customerGatewayId)) {
    query['CustomerGatewayId'] = request.customerGatewayId;
  }
  if (!Util.isUnset(request.effectImmediately)) {
    query['EffectImmediately'] = request.effectImmediately;
  }
  if (!Util.isUnset(request.enableDpd)) {
    query['EnableDpd'] = request.enableDpd;
  }
  if (!Util.isUnset(request.enableNatTraversal)) {
    query['EnableNatTraversal'] = request.enableNatTraversal;
  }
  if (!Util.isUnset(request.healthCheckConfig)) {
    query['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.ikeConfig)) {
    query['IkeConfig'] = request.ikeConfig;
  }
  if (!Util.isUnset(request.ipsecConfig)) {
    query['IpsecConfig'] = request.ipsecConfig;
  }
  if (!Util.isUnset(request.localSubnet)) {
    query['LocalSubnet'] = request.localSubnet;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remoteCaCert)) {
    query['RemoteCaCert'] = request.remoteCaCert;
  }
  if (!Util.isUnset(request.remoteSubnet)) {
    query['RemoteSubnet'] = request.remoteSubnet;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpnAttachment',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpnAttachment(request: CreateVpnAttachmentRequest): CreateVpnAttachmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnAttachmentWithOptions(request, runtime);
}

model CreateVpnConnectionRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  bgpConfig?: string(name='BgpConfig'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
  remoteSubnet?: string(name='RemoteSubnet'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateVpnConnectionResponseBody = {
  createTime?: long(name='CreateTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model CreateVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpnConnectionResponseBody(name='body'),
}

async function createVpnConnectionWithOptions(request: CreateVpnConnectionRequest, runtime: Util.RuntimeOptions): CreateVpnConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoConfigRoute)) {
    query['AutoConfigRoute'] = request.autoConfigRoute;
  }
  if (!Util.isUnset(request.bgpConfig)) {
    query['BgpConfig'] = request.bgpConfig;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.customerGatewayId)) {
    query['CustomerGatewayId'] = request.customerGatewayId;
  }
  if (!Util.isUnset(request.effectImmediately)) {
    query['EffectImmediately'] = request.effectImmediately;
  }
  if (!Util.isUnset(request.enableDpd)) {
    query['EnableDpd'] = request.enableDpd;
  }
  if (!Util.isUnset(request.enableNatTraversal)) {
    query['EnableNatTraversal'] = request.enableNatTraversal;
  }
  if (!Util.isUnset(request.healthCheckConfig)) {
    query['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.ikeConfig)) {
    query['IkeConfig'] = request.ikeConfig;
  }
  if (!Util.isUnset(request.ipsecConfig)) {
    query['IpsecConfig'] = request.ipsecConfig;
  }
  if (!Util.isUnset(request.localSubnet)) {
    query['LocalSubnet'] = request.localSubnet;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remoteCaCertificate)) {
    query['RemoteCaCertificate'] = request.remoteCaCertificate;
  }
  if (!Util.isUnset(request.remoteSubnet)) {
    query['RemoteSubnet'] = request.remoteSubnet;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpnConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpnConnection(request: CreateVpnConnectionRequest): CreateVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnConnectionWithOptions(request, runtime);
}

model CreateVpnGatewayRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  enableIpsec?: boolean(name='EnableIpsec'),
  enableSsl?: boolean(name='EnableSsl'),
  instanceChargeType?: string(name='InstanceChargeType'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslConnections?: int32(name='SslConnections'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  vpnType?: string(name='VpnType'),
}

model CreateVpnGatewayResponseBody = {
  name?: string(name='Name'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpnGatewayResponseBody(name='body'),
}

async function createVpnGatewayWithOptions(request: CreateVpnGatewayRequest, runtime: Util.RuntimeOptions): CreateVpnGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableIpsec)) {
    query['EnableIpsec'] = request.enableIpsec;
  }
  if (!Util.isUnset(request.enableSsl)) {
    query['EnableSsl'] = request.enableSsl;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslConnections)) {
    query['SslConnections'] = request.sslConnections;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vpnType)) {
    query['VpnType'] = request.vpnType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpnGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpnGateway(request: CreateVpnGatewayRequest): CreateVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnGatewayWithOptions(request, runtime);
}

model CreateVpnPbrRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publishVpc?: boolean(name='PublishVpc'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  routeSource?: string(name='RouteSource'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model CreateVpnPbrRouteEntryResponseBody = {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  requestId?: string(name='RequestId'),
  routeDest?: string(name='RouteDest'),
  routeSource?: string(name='RouteSource'),
  state?: string(name='State'),
  vpnInstanceId?: string(name='VpnInstanceId'),
  weight?: int32(name='Weight'),
}

model CreateVpnPbrRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpnPbrRouteEntryResponseBody(name='body'),
}

async function createVpnPbrRouteEntryWithOptions(request: CreateVpnPbrRouteEntryRequest, runtime: Util.RuntimeOptions): CreateVpnPbrRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.overlayMode)) {
    query['OverlayMode'] = request.overlayMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publishVpc)) {
    query['PublishVpc'] = request.publishVpc;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.routeSource)) {
    query['RouteSource'] = request.routeSource;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpnPbrRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpnPbrRouteEntry(request: CreateVpnPbrRouteEntryRequest): CreateVpnPbrRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnPbrRouteEntryWithOptions(request, runtime);
}

model CreateVpnRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publishVpc?: boolean(name='PublishVpc'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model CreateVpnRouteEntryResponseBody = {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  requestId?: string(name='RequestId'),
  routeDest?: string(name='RouteDest'),
  state?: string(name='State'),
  vpnInstanceId?: string(name='VpnInstanceId'),
  weight?: int32(name='Weight'),
}

model CreateVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpnRouteEntryResponseBody(name='body'),
}

async function createVpnRouteEntryWithOptions(request: CreateVpnRouteEntryRequest, runtime: Util.RuntimeOptions): CreateVpnRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.overlayMode)) {
    query['OverlayMode'] = request.overlayMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publishVpc)) {
    query['PublishVpc'] = request.publishVpc;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpnRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVpnRouteEntry(request: CreateVpnRouteEntryRequest): CreateVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnRouteEntryWithOptions(request, runtime);
}

model DeactivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model DeactivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeactivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeactivateRouterInterfaceResponseBody(name='body'),
}

async function deactivateRouterInterfaceWithOptions(request: DeactivateRouterInterfaceRequest, runtime: Util.RuntimeOptions): DeactivateRouterInterfaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerInterfaceId)) {
    query['RouterInterfaceId'] = request.routerInterfaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeactivateRouterInterface',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deactivateRouterInterface(request: DeactivateRouterInterfaceRequest): DeactivateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactivateRouterInterfaceWithOptions(request, runtime);
}

model DeactiveFlowLogRequest {
  flowLogId?: string(name='FlowLogId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeactiveFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeactiveFlowLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeactiveFlowLogResponseBody(name='body'),
}

async function deactiveFlowLogWithOptions(request: DeactiveFlowLogRequest, runtime: Util.RuntimeOptions): DeactiveFlowLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.flowLogId)) {
    query['FlowLogId'] = request.flowLogId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeactiveFlowLog',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deactiveFlowLog(request: DeactiveFlowLogRequest): DeactiveFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactiveFlowLogWithOptions(request, runtime);
}

model DeleteBgpGroupRequest {
  bgpGroupId?: string(name='BgpGroupId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteBgpGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBgpGroupResponseBody(name='body'),
}

async function deleteBgpGroupWithOptions(request: DeleteBgpGroupRequest, runtime: Util.RuntimeOptions): DeleteBgpGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bgpGroupId)) {
    query['BgpGroupId'] = request.bgpGroupId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBgpGroup',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBgpGroup(request: DeleteBgpGroupRequest): DeleteBgpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpGroupWithOptions(request, runtime);
}

model DeleteBgpNetworkRequest {
  clientToken?: string(name='ClientToken'),
  dstCidrBlock?: string(name='DstCidrBlock'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model DeleteBgpNetworkResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBgpNetworkResponseBody(name='body'),
}

async function deleteBgpNetworkWithOptions(request: DeleteBgpNetworkRequest, runtime: Util.RuntimeOptions): DeleteBgpNetworkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dstCidrBlock)) {
    query['DstCidrBlock'] = request.dstCidrBlock;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerId)) {
    query['RouterId'] = request.routerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBgpNetwork',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBgpNetwork(request: DeleteBgpNetworkRequest): DeleteBgpNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpNetworkWithOptions(request, runtime);
}

model DeleteBgpPeerRequest {
  bgpPeerId?: string(name='BgpPeerId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteBgpPeerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpPeerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBgpPeerResponseBody(name='body'),
}

async function deleteBgpPeerWithOptions(request: DeleteBgpPeerRequest, runtime: Util.RuntimeOptions): DeleteBgpPeerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bgpPeerId)) {
    query['BgpPeerId'] = request.bgpPeerId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBgpPeer',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBgpPeer(request: DeleteBgpPeerRequest): DeleteBgpPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpPeerWithOptions(request, runtime);
}

model DeleteCommonBandwidthPackageRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  force?: string(name='Force'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteCommonBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCommonBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCommonBandwidthPackageResponseBody(name='body'),
}

async function deleteCommonBandwidthPackageWithOptions(request: DeleteCommonBandwidthPackageRequest, runtime: Util.RuntimeOptions): DeleteCommonBandwidthPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCommonBandwidthPackage',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCommonBandwidthPackage(request: DeleteCommonBandwidthPackageRequest): DeleteCommonBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCommonBandwidthPackageWithOptions(request, runtime);
}

model DeleteCustomerGatewayRequest {
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteCustomerGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCustomerGatewayResponseBody(name='body'),
}

async function deleteCustomerGatewayWithOptions(request: DeleteCustomerGatewayRequest, runtime: Util.RuntimeOptions): DeleteCustomerGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.customerGatewayId)) {
    query['CustomerGatewayId'] = request.customerGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomerGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomerGateway(request: DeleteCustomerGatewayRequest): DeleteCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomerGatewayWithOptions(request, runtime);
}

model DeleteDhcpOptionsSetRequest {
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDhcpOptionsSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDhcpOptionsSetResponseBody(name='body'),
}

async function deleteDhcpOptionsSetWithOptions(request: DeleteDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): DeleteDhcpOptionsSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dhcpOptionsSetId)) {
    query['DhcpOptionsSetId'] = request.dhcpOptionsSetId;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDhcpOptionsSet',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDhcpOptionsSet(request: DeleteDhcpOptionsSetRequest): DeleteDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDhcpOptionsSetWithOptions(request, runtime);
}

model DeleteFlowLogRequest {
  flowLogId?: string(name='FlowLogId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteFlowLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowLogResponseBody(name='body'),
}

async function deleteFlowLogWithOptions(request: DeleteFlowLogRequest, runtime: Util.RuntimeOptions): DeleteFlowLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.flowLogId)) {
    query['FlowLogId'] = request.flowLogId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowLog',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlowLog(request: DeleteFlowLogRequest): DeleteFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowLogWithOptions(request, runtime);
}

model DeleteForwardEntryRequest {
  clientToken?: string(name='ClientToken'),
  forwardEntryId?: string(name='ForwardEntryId'),
  forwardTableId?: string(name='ForwardTableId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteForwardEntryResponseBody(name='body'),
}

async function deleteForwardEntryWithOptions(request: DeleteForwardEntryRequest, runtime: Util.RuntimeOptions): DeleteForwardEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forwardEntryId)) {
    query['ForwardEntryId'] = request.forwardEntryId;
  }
  if (!Util.isUnset(request.forwardTableId)) {
    query['ForwardTableId'] = request.forwardTableId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteForwardEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteForwardEntry(request: DeleteForwardEntryRequest): DeleteForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteForwardEntryWithOptions(request, runtime);
}

model DeleteFullNatEntryRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  fullNatEntryId?: string(name='FullNatEntryId'),
  fullNatTableId?: string(name='FullNatTableId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteFullNatEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFullNatEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFullNatEntryResponseBody(name='body'),
}

async function deleteFullNatEntryWithOptions(request: DeleteFullNatEntryRequest, runtime: Util.RuntimeOptions): DeleteFullNatEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.fullNatEntryId)) {
    query['FullNatEntryId'] = request.fullNatEntryId;
  }
  if (!Util.isUnset(request.fullNatTableId)) {
    query['FullNatTableId'] = request.fullNatTableId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFullNatEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFullNatEntry(request: DeleteFullNatEntryRequest): DeleteFullNatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFullNatEntryWithOptions(request, runtime);
}

model DeleteGlobalAccelerationInstanceRequest {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGlobalAccelerationInstanceResponseBody(name='body'),
}

async function deleteGlobalAccelerationInstanceWithOptions(request: DeleteGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): DeleteGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalAccelerationInstanceId)) {
    query['GlobalAccelerationInstanceId'] = request.globalAccelerationInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGlobalAccelerationInstance',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGlobalAccelerationInstance(request: DeleteGlobalAccelerationInstanceRequest): DeleteGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalAccelerationInstanceWithOptions(request, runtime);
}

model DeleteHaVipRequest {
  clientToken?: string(name='ClientToken'),
  haVipId?: string(name='HaVipId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHaVipResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHaVipResponseBody(name='body'),
}

async function deleteHaVipWithOptions(request: DeleteHaVipRequest, runtime: Util.RuntimeOptions): DeleteHaVipResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.haVipId)) {
    query['HaVipId'] = request.haVipId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHaVip',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHaVip(request: DeleteHaVipRequest): DeleteHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHaVipWithOptions(request, runtime);
}

model DeleteIPv6TranslatorRequest {
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIPv6TranslatorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIPv6TranslatorResponseBody(name='body'),
}

async function deleteIPv6TranslatorWithOptions(request: DeleteIPv6TranslatorRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipv6TranslatorId)) {
    query['Ipv6TranslatorId'] = request.ipv6TranslatorId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIPv6Translator',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIPv6Translator(request: DeleteIPv6TranslatorRequest): DeleteIPv6TranslatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorWithOptions(request, runtime);
}

model DeleteIPv6TranslatorAclListRequest {
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIPv6TranslatorAclListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorAclListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIPv6TranslatorAclListResponseBody(name='body'),
}

async function deleteIPv6TranslatorAclListWithOptions(request: DeleteIPv6TranslatorAclListRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorAclListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIPv6TranslatorAclList',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIPv6TranslatorAclList(request: DeleteIPv6TranslatorAclListRequest): DeleteIPv6TranslatorAclListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorAclListWithOptions(request, runtime);
}

model DeleteIPv6TranslatorEntryRequest {
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIPv6TranslatorEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIPv6TranslatorEntryResponseBody(name='body'),
}

async function deleteIPv6TranslatorEntryWithOptions(request: DeleteIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipv6TranslatorEntryId)) {
    query['Ipv6TranslatorEntryId'] = request.ipv6TranslatorEntryId;
  }
  if (!Util.isUnset(request.ipv6TranslatorId)) {
    query['Ipv6TranslatorId'] = request.ipv6TranslatorId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIPv6TranslatorEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIPv6TranslatorEntry(request: DeleteIPv6TranslatorEntryRequest): DeleteIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorEntryWithOptions(request, runtime);
}

model DeleteIpsecServerRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: string(name='DryRun'),
  ipsecServerId?: string(name='IpsecServerId'),
  regionId?: string(name='RegionId'),
}

model DeleteIpsecServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIpsecServerResponseBody(name='body'),
}

async function deleteIpsecServerWithOptions(request: DeleteIpsecServerRequest, runtime: Util.RuntimeOptions): DeleteIpsecServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ipsecServerId)) {
    query['IpsecServerId'] = request.ipsecServerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIpsecServer',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIpsecServer(request: DeleteIpsecServerRequest): DeleteIpsecServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpsecServerWithOptions(request, runtime);
}

model DeleteIpv4GatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpv4GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv4GatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIpv4GatewayResponseBody(name='body'),
}

async function deleteIpv4GatewayWithOptions(request: DeleteIpv4GatewayRequest, runtime: Util.RuntimeOptions): DeleteIpv4GatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ipv4GatewayId)) {
    query['Ipv4GatewayId'] = request.ipv4GatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIpv4Gateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIpv4Gateway(request: DeleteIpv4GatewayRequest): DeleteIpv4GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv4GatewayWithOptions(request, runtime);
}

model DeleteIpv6EgressOnlyRuleRequest {
  clientToken?: string(name='ClientToken'),
  ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpv6EgressOnlyRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6EgressOnlyRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIpv6EgressOnlyRuleResponseBody(name='body'),
}

async function deleteIpv6EgressOnlyRuleWithOptions(request: DeleteIpv6EgressOnlyRuleRequest, runtime: Util.RuntimeOptions): DeleteIpv6EgressOnlyRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipv6EgressOnlyRuleId)) {
    query['Ipv6EgressOnlyRuleId'] = request.ipv6EgressOnlyRuleId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIpv6EgressOnlyRule',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIpv6EgressOnlyRule(request: DeleteIpv6EgressOnlyRuleRequest): DeleteIpv6EgressOnlyRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6EgressOnlyRuleWithOptions(request, runtime);
}

model DeleteIpv6GatewayRequest {
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpv6GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6GatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIpv6GatewayResponseBody(name='body'),
}

async function deleteIpv6GatewayWithOptions(request: DeleteIpv6GatewayRequest, runtime: Util.RuntimeOptions): DeleteIpv6GatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipv6GatewayId)) {
    query['Ipv6GatewayId'] = request.ipv6GatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIpv6Gateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIpv6Gateway(request: DeleteIpv6GatewayRequest): DeleteIpv6GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6GatewayWithOptions(request, runtime);
}

model DeleteIpv6InternetBandwidthRequest {
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteIpv6InternetBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIpv6InternetBandwidthResponseBody(name='body'),
}

async function deleteIpv6InternetBandwidthWithOptions(request: DeleteIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): DeleteIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipv6AddressId)) {
    query['Ipv6AddressId'] = request.ipv6AddressId;
  }
  if (!Util.isUnset(request.ipv6InternetBandwidthId)) {
    query['Ipv6InternetBandwidthId'] = request.ipv6InternetBandwidthId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIpv6InternetBandwidth',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIpv6InternetBandwidth(request: DeleteIpv6InternetBandwidthRequest): DeleteIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6InternetBandwidthWithOptions(request, runtime);
}

model DeleteNatGatewayRequest {
  force?: boolean(name='Force'),
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteNatGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNatGatewayResponseBody(name='body'),
}

async function deleteNatGatewayWithOptions(request: DeleteNatGatewayRequest, runtime: Util.RuntimeOptions): DeleteNatGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNatGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNatGateway(request: DeleteNatGatewayRequest): DeleteNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNatGatewayWithOptions(request, runtime);
}

model DeleteNatIpRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natIpId?: string(name='NatIpId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteNatIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNatIpResponseBody(name='body'),
}

async function deleteNatIpWithOptions(request: DeleteNatIpRequest, runtime: Util.RuntimeOptions): DeleteNatIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.natIpId)) {
    query['NatIpId'] = request.natIpId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNatIp',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNatIp(request: DeleteNatIpRequest): DeleteNatIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNatIpWithOptions(request, runtime);
}

model DeleteNatIpCidrRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteNatIpCidrResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatIpCidrResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNatIpCidrResponseBody(name='body'),
}

async function deleteNatIpCidrWithOptions(request: DeleteNatIpCidrRequest, runtime: Util.RuntimeOptions): DeleteNatIpCidrResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.natIpCidr)) {
    query['NatIpCidr'] = request.natIpCidr;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNatIpCidr',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNatIpCidr(request: DeleteNatIpCidrRequest): DeleteNatIpCidrResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNatIpCidrWithOptions(request, runtime);
}

model DeleteNetworkAclRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNetworkAclResponseBody(name='body'),
}

async function deleteNetworkAclWithOptions(request: DeleteNetworkAclRequest, runtime: Util.RuntimeOptions): DeleteNetworkAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.networkAclId)) {
    query['NetworkAclId'] = request.networkAclId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNetworkAcl',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNetworkAcl(request: DeleteNetworkAclRequest): DeleteNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNetworkAclWithOptions(request, runtime);
}

model DeletePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeletePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePhysicalConnectionResponseBody(name='body'),
}

async function deletePhysicalConnectionWithOptions(request: DeletePhysicalConnectionRequest, runtime: Util.RuntimeOptions): DeletePhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePhysicalConnection(request: DeletePhysicalConnectionRequest): DeletePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePhysicalConnectionWithOptions(request, runtime);
}

model DeletePublicIpAddressPoolRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeletePublicIpAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicIpAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePublicIpAddressPoolResponseBody(name='body'),
}

async function deletePublicIpAddressPoolWithOptions(request: DeletePublicIpAddressPoolRequest, runtime: Util.RuntimeOptions): DeletePublicIpAddressPoolResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publicIpAddressPoolId)) {
    query['PublicIpAddressPoolId'] = request.publicIpAddressPoolId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePublicIpAddressPool',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePublicIpAddressPool(request: DeletePublicIpAddressPoolRequest): DeletePublicIpAddressPoolResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePublicIpAddressPoolWithOptions(request, runtime);
}

model DeletePublicIpAddressPoolCidrBlockRequest {
  cidrBlock?: string(name='CidrBlock'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeletePublicIpAddressPoolCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicIpAddressPoolCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePublicIpAddressPoolCidrBlockResponseBody(name='body'),
}

async function deletePublicIpAddressPoolCidrBlockWithOptions(request: DeletePublicIpAddressPoolCidrBlockRequest, runtime: Util.RuntimeOptions): DeletePublicIpAddressPoolCidrBlockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publicIpAddressPoolId)) {
    query['PublicIpAddressPoolId'] = request.publicIpAddressPoolId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePublicIpAddressPoolCidrBlock',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePublicIpAddressPoolCidrBlock(request: DeletePublicIpAddressPoolCidrBlockRequest): DeletePublicIpAddressPoolCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePublicIpAddressPoolCidrBlockWithOptions(request, runtime);
}

model DeleteRouteEntryRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  nextHopId?: string(name='NextHopId'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
    }
  ](name='NextHopList'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryId?: string(name='RouteEntryId'),
  routeTableId?: string(name='RouteTableId'),
}

model DeleteRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRouteEntryResponseBody(name='body'),
}

async function deleteRouteEntryWithOptions(request: DeleteRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationCidrBlock)) {
    query['DestinationCidrBlock'] = request.destinationCidrBlock;
  }
  if (!Util.isUnset(request.nextHopId)) {
    query['NextHopId'] = request.nextHopId;
  }
  if (!Util.isUnset(request.nextHopList)) {
    query['NextHopList'] = request.nextHopList;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeEntryId)) {
    query['RouteEntryId'] = request.routeEntryId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRouteEntry(request: DeleteRouteEntryRequest): DeleteRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouteEntryWithOptions(request, runtime);
}

model DeleteRouteTableRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
}

model DeleteRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRouteTableResponseBody(name='body'),
}

async function deleteRouteTableWithOptions(request: DeleteRouteTableRequest, runtime: Util.RuntimeOptions): DeleteRouteTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRouteTable',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRouteTable(request: DeleteRouteTableRequest): DeleteRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouteTableWithOptions(request, runtime);
}

model DeleteRouterInterfaceRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model DeleteRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRouterInterfaceResponseBody(name='body'),
}

async function deleteRouterInterfaceWithOptions(request: DeleteRouterInterfaceRequest, runtime: Util.RuntimeOptions): DeleteRouterInterfaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerInterfaceId)) {
    query['RouterInterfaceId'] = request.routerInterfaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRouterInterface',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRouterInterface(request: DeleteRouterInterfaceRequest): DeleteRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouterInterfaceWithOptions(request, runtime);
}

model DeleteSnatEntryRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snatEntryId?: string(name='SnatEntryId'),
  snatTableId?: string(name='SnatTableId'),
}

model DeleteSnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSnatEntryResponseBody(name='body'),
}

async function deleteSnatEntryWithOptions(request: DeleteSnatEntryRequest, runtime: Util.RuntimeOptions): DeleteSnatEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.snatEntryId)) {
    query['SnatEntryId'] = request.snatEntryId;
  }
  if (!Util.isUnset(request.snatTableId)) {
    query['SnatTableId'] = request.snatTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSnatEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSnatEntry(request: DeleteSnatEntryRequest): DeleteSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSnatEntryWithOptions(request, runtime);
}

model DeleteSslVpnClientCertRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model DeleteSslVpnClientCertResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSslVpnClientCertResponseBody(name='body'),
}

async function deleteSslVpnClientCertWithOptions(request: DeleteSslVpnClientCertRequest, runtime: Util.RuntimeOptions): DeleteSslVpnClientCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslVpnClientCertId)) {
    query['SslVpnClientCertId'] = request.sslVpnClientCertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSslVpnClientCert',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSslVpnClientCert(request: DeleteSslVpnClientCertRequest): DeleteSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSslVpnClientCertWithOptions(request, runtime);
}

model DeleteSslVpnServerRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model DeleteSslVpnServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSslVpnServerResponseBody(name='body'),
}

async function deleteSslVpnServerWithOptions(request: DeleteSslVpnServerRequest, runtime: Util.RuntimeOptions): DeleteSslVpnServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslVpnServerId)) {
    query['SslVpnServerId'] = request.sslVpnServerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSslVpnServer',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSslVpnServer(request: DeleteSslVpnServerRequest): DeleteSslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSslVpnServerWithOptions(request, runtime);
}

model DeleteTrafficMirrorFilterRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
}

model DeleteTrafficMirrorFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTrafficMirrorFilterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTrafficMirrorFilterResponseBody(name='body'),
}

async function deleteTrafficMirrorFilterWithOptions(request: DeleteTrafficMirrorFilterRequest, runtime: Util.RuntimeOptions): DeleteTrafficMirrorFilterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterId)) {
    query['TrafficMirrorFilterId'] = request.trafficMirrorFilterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrafficMirrorFilter',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTrafficMirrorFilter(request: DeleteTrafficMirrorFilterRequest): DeleteTrafficMirrorFilterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTrafficMirrorFilterWithOptions(request, runtime);
}

model DeleteTrafficMirrorFilterRulesRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorFilterRuleIds?: [ string ](name='TrafficMirrorFilterRuleIds'),
}

model DeleteTrafficMirrorFilterRulesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTrafficMirrorFilterRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTrafficMirrorFilterRulesResponseBody(name='body'),
}

async function deleteTrafficMirrorFilterRulesWithOptions(request: DeleteTrafficMirrorFilterRulesRequest, runtime: Util.RuntimeOptions): DeleteTrafficMirrorFilterRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterId)) {
    query['TrafficMirrorFilterId'] = request.trafficMirrorFilterId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterRuleIds)) {
    query['TrafficMirrorFilterRuleIds'] = request.trafficMirrorFilterRuleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrafficMirrorFilterRules',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTrafficMirrorFilterRules(request: DeleteTrafficMirrorFilterRulesRequest): DeleteTrafficMirrorFilterRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTrafficMirrorFilterRulesWithOptions(request, runtime);
}

model DeleteTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
}

model DeleteTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTrafficMirrorSessionResponseBody(name='body'),
}

async function deleteTrafficMirrorSessionWithOptions(request: DeleteTrafficMirrorSessionRequest, runtime: Util.RuntimeOptions): DeleteTrafficMirrorSessionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorSessionId)) {
    query['TrafficMirrorSessionId'] = request.trafficMirrorSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrafficMirrorSession',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTrafficMirrorSession(request: DeleteTrafficMirrorSessionRequest): DeleteTrafficMirrorSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTrafficMirrorSessionWithOptions(request, runtime);
}

model DeleteVSwitchRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model DeleteVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVSwitchResponseBody(name='body'),
}

async function deleteVSwitchWithOptions(request: DeleteVSwitchRequest, runtime: Util.RuntimeOptions): DeleteVSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVSwitch',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVSwitch(request: DeleteVSwitchRequest): DeleteVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVSwitchWithOptions(request, runtime);
}

model DeleteVbrHaRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteVbrHaResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVbrHaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVbrHaResponseBody(name='body'),
}

async function deleteVbrHaWithOptions(request: DeleteVbrHaRequest, runtime: Util.RuntimeOptions): DeleteVbrHaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVbrHa',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVbrHa(request: DeleteVbrHaRequest): DeleteVbrHaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVbrHaWithOptions(request, runtime);
}

model DeleteVcoRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  weight?: int32(name='Weight'),
}

model DeleteVcoRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVcoRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVcoRouteEntryResponseBody(name='body'),
}

async function deleteVcoRouteEntryWithOptions(request: DeleteVcoRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteVcoRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.overlayMode)) {
    query['OverlayMode'] = request.overlayMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVcoRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVcoRouteEntry(request: DeleteVcoRouteEntryRequest): DeleteVcoRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVcoRouteEntryWithOptions(request, runtime);
}

model DeleteVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model DeleteVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVirtualBorderRouterResponseBody(name='body'),
}

async function deleteVirtualBorderRouterWithOptions(request: DeleteVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): DeleteVirtualBorderRouterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVirtualBorderRouter',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVirtualBorderRouter(request: DeleteVirtualBorderRouterRequest): DeleteVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualBorderRouterWithOptions(request, runtime);
}

model DeleteVpcRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DeleteVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpcResponseBody(name='body'),
}

async function deleteVpcWithOptions(request: DeleteVpcRequest, runtime: Util.RuntimeOptions): DeleteVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpc',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpc(request: DeleteVpcRequest): DeleteVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcWithOptions(request, runtime);
}

model DeleteVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointId?: string(name='EndpointId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteVpcGatewayEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpcGatewayEndpointResponseBody(name='body'),
}

async function deleteVpcGatewayEndpointWithOptions(request: DeleteVpcGatewayEndpointRequest, runtime: Util.RuntimeOptions): DeleteVpcGatewayEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endpointId)) {
    query['EndpointId'] = request.endpointId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcGatewayEndpoint',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpcGatewayEndpoint(request: DeleteVpcGatewayEndpointRequest): DeleteVpcGatewayEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcGatewayEndpointWithOptions(request, runtime);
}

model DeleteVpcPrefixListRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  prefixListId?: string(name='PrefixListId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteVpcPrefixListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcPrefixListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpcPrefixListResponseBody(name='body'),
}

async function deleteVpcPrefixListWithOptions(request: DeleteVpcPrefixListRequest, runtime: Util.RuntimeOptions): DeleteVpcPrefixListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.prefixListId)) {
    query['PrefixListId'] = request.prefixListId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcPrefixList',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpcPrefixList(request: DeleteVpcPrefixListRequest): DeleteVpcPrefixListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcPrefixListWithOptions(request, runtime);
}

model DeleteVpnAttachmentRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DeleteVpnAttachmentResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteVpnAttachmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpnAttachmentResponseBody(name='body'),
}

async function deleteVpnAttachmentWithOptions(request: DeleteVpnAttachmentRequest, runtime: Util.RuntimeOptions): DeleteVpnAttachmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpnAttachment',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpnAttachment(request: DeleteVpnAttachmentRequest): DeleteVpnAttachmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnAttachmentWithOptions(request, runtime);
}

model DeleteVpnConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DeleteVpnConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpnConnectionResponseBody(name='body'),
}

async function deleteVpnConnectionWithOptions(request: DeleteVpnConnectionRequest, runtime: Util.RuntimeOptions): DeleteVpnConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpnConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpnConnection(request: DeleteVpnConnectionRequest): DeleteVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnConnectionWithOptions(request, runtime);
}

model DeleteVpnGatewayRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DeleteVpnGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpnGatewayResponseBody(name='body'),
}

async function deleteVpnGatewayWithOptions(request: DeleteVpnGatewayRequest, runtime: Util.RuntimeOptions): DeleteVpnGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpnGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpnGateway(request: DeleteVpnGatewayRequest): DeleteVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnGatewayWithOptions(request, runtime);
}

model DeleteVpnPbrRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  routeSource?: string(name='RouteSource'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model DeleteVpnPbrRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnPbrRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpnPbrRouteEntryResponseBody(name='body'),
}

async function deleteVpnPbrRouteEntryWithOptions(request: DeleteVpnPbrRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteVpnPbrRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.overlayMode)) {
    query['OverlayMode'] = request.overlayMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.routeSource)) {
    query['RouteSource'] = request.routeSource;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpnPbrRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpnPbrRouteEntry(request: DeleteVpnPbrRouteEntryRequest): DeleteVpnPbrRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnPbrRouteEntryWithOptions(request, runtime);
}

model DeleteVpnRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model DeleteVpnRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpnRouteEntryResponseBody(name='body'),
}

async function deleteVpnRouteEntryWithOptions(request: DeleteVpnRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteVpnRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.overlayMode)) {
    query['OverlayMode'] = request.overlayMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpnRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpnRouteEntry(request: DeleteVpnRouteEntryRequest): DeleteVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnRouteEntryWithOptions(request, runtime);
}

model DeletionProtectionRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  protectionEnable?: boolean(name='ProtectionEnable'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  type?: string(name='Type'),
}

model DeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletionProtectionResponseBody(name='body'),
}

async function deletionProtectionWithOptions(request: DeletionProtectionRequest, runtime: Util.RuntimeOptions): DeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.protectionEnable)) {
    query['ProtectionEnable'] = request.protectionEnable;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletionProtection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletionProtection(request: DeletionProtectionRequest): DeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletionProtectionWithOptions(request, runtime);
}

model DescribeAccessPointsRequest {
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccessPointsResponseBody = {
  accessPointSet?: {
    accessPointType?: [ 
    {
      accessPointFeatureModels?: {
        accessPointFeatureModel?: [ 
        {
          featureKey?: string(name='FeatureKey'),
          featureValue?: string(name='FeatureValue'),
        }
      ](name='AccessPointFeatureModel')
      }(name='AccessPointFeatureModels'),
      accessPointId?: string(name='AccessPointId'),
      attachedRegionNo?: string(name='AttachedRegionNo'),
      description?: string(name='Description'),
      hostOperator?: string(name='HostOperator'),
      location?: string(name='Location'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='AccessPointType')
  }(name='AccessPointSet'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAccessPointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccessPointsResponseBody(name='body'),
}

async function describeAccessPointsWithOptions(request: DescribeAccessPointsRequest, runtime: Util.RuntimeOptions): DescribeAccessPointsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccessPoints',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccessPoints(request: DescribeAccessPointsRequest): DescribeAccessPointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessPointsWithOptions(request, runtime);
}

model DescribeBgpGroupsRequest {
  bgpGroupId?: string(name='BgpGroupId'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model DescribeBgpGroupsResponseBody = {
  bgpGroups?: {
    bgpGroup?: [ 
    {
      authKey?: string(name='AuthKey'),
      bgpGroupId?: string(name='BgpGroupId'),
      description?: string(name='Description'),
      hold?: string(name='Hold'),
      ipVersion?: string(name='IpVersion'),
      isFake?: string(name='IsFake'),
      keepalive?: string(name='Keepalive'),
      localAsn?: string(name='LocalAsn'),
      name?: string(name='Name'),
      peerAsn?: string(name='PeerAsn'),
      regionId?: string(name='RegionId'),
      routeLimit?: string(name='RouteLimit'),
      routerId?: string(name='RouterId'),
      status?: string(name='Status'),
    }
  ](name='BgpGroup')
  }(name='BgpGroups'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBgpGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBgpGroupsResponseBody(name='body'),
}

async function describeBgpGroupsWithOptions(request: DescribeBgpGroupsRequest, runtime: Util.RuntimeOptions): DescribeBgpGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bgpGroupId)) {
    query['BgpGroupId'] = request.bgpGroupId;
  }
  if (!Util.isUnset(request.isDefault)) {
    query['IsDefault'] = request.isDefault;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerId)) {
    query['RouterId'] = request.routerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBgpGroups',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBgpGroups(request: DescribeBgpGroupsRequest): DescribeBgpGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpGroupsWithOptions(request, runtime);
}

model DescribeBgpNetworksRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model DescribeBgpNetworksResponseBody = {
  bgpNetworks?: {
    bgpNetwork?: [ 
    {
      dstCidrBlock?: string(name='DstCidrBlock'),
      routerId?: string(name='RouterId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='BgpNetwork')
  }(name='BgpNetworks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBgpNetworksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBgpNetworksResponseBody(name='body'),
}

async function describeBgpNetworksWithOptions(request: DescribeBgpNetworksRequest, runtime: Util.RuntimeOptions): DescribeBgpNetworksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerId)) {
    query['RouterId'] = request.routerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBgpNetworks',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBgpNetworks(request: DescribeBgpNetworksRequest): DescribeBgpNetworksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpNetworksWithOptions(request, runtime);
}

model DescribeBgpPeersRequest {
  bgpGroupId?: string(name='BgpGroupId'),
  bgpPeerId?: string(name='BgpPeerId'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerId?: string(name='RouterId'),
}

model DescribeBgpPeersResponseBody = {
  bgpPeers?: {
    bgpPeer?: [ 
    {
      advertisedRouteCount?: int32(name='AdvertisedRouteCount'),
      authKey?: string(name='AuthKey'),
      bfdMultiHop?: int32(name='BfdMultiHop'),
      bgpGroupId?: string(name='BgpGroupId'),
      bgpPeerId?: string(name='BgpPeerId'),
      bgpStatus?: string(name='BgpStatus'),
      description?: string(name='Description'),
      enableBfd?: boolean(name='EnableBfd'),
      gmtModified?: string(name='GmtModified'),
      hold?: string(name='Hold'),
      ipVersion?: string(name='IpVersion'),
      isFake?: boolean(name='IsFake'),
      keepalive?: string(name='Keepalive'),
      localAsn?: string(name='LocalAsn'),
      name?: string(name='Name'),
      peerAsn?: string(name='PeerAsn'),
      peerIpAddress?: string(name='PeerIpAddress'),
      receivedRouteCount?: int32(name='ReceivedRouteCount'),
      regionId?: string(name='RegionId'),
      routeLimit?: string(name='RouteLimit'),
      routerId?: string(name='RouterId'),
      status?: string(name='Status'),
    }
  ](name='BgpPeer')
  }(name='BgpPeers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBgpPeersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBgpPeersResponseBody(name='body'),
}

async function describeBgpPeersWithOptions(request: DescribeBgpPeersRequest, runtime: Util.RuntimeOptions): DescribeBgpPeersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bgpGroupId)) {
    query['BgpGroupId'] = request.bgpGroupId;
  }
  if (!Util.isUnset(request.bgpPeerId)) {
    query['BgpPeerId'] = request.bgpPeerId;
  }
  if (!Util.isUnset(request.isDefault)) {
    query['IsDefault'] = request.isDefault;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerId)) {
    query['RouterId'] = request.routerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBgpPeers',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBgpPeers(request: DescribeBgpPeersRequest): DescribeBgpPeersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpPeersWithOptions(request, runtime);
}

model DescribeCommonBandwidthPackagesRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  dryRun?: boolean(name='DryRun'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled'),
}

model DescribeCommonBandwidthPackagesResponseBody = {
  commonBandwidthPackages?: {
    commonBandwidthPackage?: [ 
    {
      bandwidth?: string(name='Bandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      deletionProtection?: boolean(name='DeletionProtection'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      hasReservationData?: string(name='HasReservationData'),
      ISP?: string(name='ISP'),
      instanceChargeType?: string(name='InstanceChargeType'),
      internetChargeType?: string(name='InternetChargeType'),
      name?: string(name='Name'),
      publicIpAddresses?: {
        publicIpAddresse?: [ 
        {
          allocationId?: string(name='AllocationId'),
          bandwidthPackageIpRelationStatus?: string(name='BandwidthPackageIpRelationStatus'),
          ipAddress?: string(name='IpAddress'),
        }
      ](name='PublicIpAddresse')
      }(name='PublicIpAddresses'),
      ratio?: int32(name='Ratio'),
      regionId?: string(name='RegionId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityProtectionTypes?: {
        securityProtectionType?: [ string ](name='SecurityProtectionType')
      }(name='SecurityProtectionTypes'),
      serviceManaged?: int32(name='ServiceManaged'),
      status?: string(name='Status'),
    }
  ](name='CommonBandwidthPackage')
  }(name='CommonBandwidthPackages'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCommonBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCommonBandwidthPackagesResponseBody(name='body'),
}

async function describeCommonBandwidthPackagesWithOptions(request: DescribeCommonBandwidthPackagesRequest, runtime: Util.RuntimeOptions): DescribeCommonBandwidthPackagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.includeReservationData)) {
    query['IncludeReservationData'] = request.includeReservationData;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityProtectionEnabled)) {
    query['SecurityProtectionEnabled'] = request.securityProtectionEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCommonBandwidthPackages',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCommonBandwidthPackages(request: DescribeCommonBandwidthPackagesRequest): DescribeCommonBandwidthPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonBandwidthPackagesWithOptions(request, runtime);
}

model DescribeCustomerGatewayRequest {
  customerGatewayId?: string(name='CustomerGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCustomerGatewayResponseBody = {
  asn?: long(name='Asn'),
  authKey?: string(name='AuthKey'),
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model DescribeCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomerGatewayResponseBody(name='body'),
}

async function describeCustomerGatewayWithOptions(request: DescribeCustomerGatewayRequest, runtime: Util.RuntimeOptions): DescribeCustomerGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customerGatewayId)) {
    query['CustomerGatewayId'] = request.customerGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomerGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomerGateway(request: DescribeCustomerGatewayRequest): DescribeCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomerGatewayWithOptions(request, runtime);
}

model DescribeCustomerGatewaysRequest {
  customerGatewayId?: string(name='CustomerGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCustomerGatewaysResponseBody = {
  customerGateways?: {
    customerGateway?: [ 
    {
      asn?: long(name='Asn'),
      authKey?: string(name='AuthKey'),
      createTime?: long(name='CreateTime'),
      customerGatewayId?: string(name='CustomerGatewayId'),
      description?: string(name='Description'),
      ipAddress?: string(name='IpAddress'),
      name?: string(name='Name'),
    }
  ](name='CustomerGateway')
  }(name='CustomerGateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCustomerGatewaysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomerGatewaysResponseBody(name='body'),
}

async function describeCustomerGatewaysWithOptions(request: DescribeCustomerGatewaysRequest, runtime: Util.RuntimeOptions): DescribeCustomerGatewaysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customerGatewayId)) {
    query['CustomerGatewayId'] = request.customerGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomerGateways',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomerGateways(request: DescribeCustomerGatewaysRequest): DescribeCustomerGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomerGatewaysWithOptions(request, runtime);
}

model DescribeEipAddressesRequest {
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter'),
  allocationId?: string(name='AllocationId'),
  associatedInstanceId?: string(name='AssociatedInstanceId'),
  associatedInstanceType?: string(name='AssociatedInstanceType'),
  chargeType?: string(name='ChargeType'),
  dryRun?: boolean(name='DryRun'),
  eipAddress?: string(name='EipAddress'),
  eipName?: string(name='EipName'),
  ISP?: string(name='ISP'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  lockReason?: string(name='LockReason'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
  status?: string(name='Status'),
}

model DescribeEipAddressesResponseBody = {
  eipAddresses?: {
    eipAddress?: [ 
    {
      allocationId?: string(name='AllocationId'),
      allocationTime?: string(name='AllocationTime'),
      availableRegions?: {
        availableRegion?: [ string ](name='AvailableRegion')
      }(name='AvailableRegions'),
      bandwidth?: string(name='Bandwidth'),
      bandwidthPackageBandwidth?: string(name='BandwidthPackageBandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidthPackageType?: string(name='BandwidthPackageType'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      deletionProtection?: boolean(name='DeletionProtection'),
      description?: string(name='Description'),
      eipBandwidth?: string(name='EipBandwidth'),
      expiredTime?: string(name='ExpiredTime'),
      HDMonitorStatus?: string(name='HDMonitorStatus'),
      hasReservationData?: string(name='HasReservationData'),
      ISP?: string(name='ISP'),
      instanceId?: string(name='InstanceId'),
      instanceRegionId?: string(name='InstanceRegionId'),
      instanceType?: string(name='InstanceType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipAddress?: string(name='IpAddress'),
      name?: string(name='Name'),
      netmode?: string(name='Netmode'),
      operationLocks?: {
        lockReason?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='LockReason')
      }(name='OperationLocks'),
      publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
      regionId?: string(name='RegionId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      secondLimited?: boolean(name='SecondLimited'),
      securityProtectionTypes?: {
        securityProtectionType?: [ string ](name='SecurityProtectionType')
      }(name='SecurityProtectionTypes'),
      segmentInstanceId?: string(name='SegmentInstanceId'),
      serviceManaged?: int32(name='ServiceManaged'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEipAddressesResponseBody(name='body'),
}

async function describeEipAddressesWithOptions(request: DescribeEipAddressesRequest, runtime: Util.RuntimeOptions): DescribeEipAddressesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  if (!Util.isUnset(request.associatedInstanceId)) {
    query['AssociatedInstanceId'] = request.associatedInstanceId;
  }
  if (!Util.isUnset(request.associatedInstanceType)) {
    query['AssociatedInstanceType'] = request.associatedInstanceType;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.eipAddress)) {
    query['EipAddress'] = request.eipAddress;
  }
  if (!Util.isUnset(request.eipName)) {
    query['EipName'] = request.eipName;
  }
  if (!Util.isUnset(request.ISP)) {
    query['ISP'] = request.ISP;
  }
  if (!Util.isUnset(request.includeReservationData)) {
    query['IncludeReservationData'] = request.includeReservationData;
  }
  if (!Util.isUnset(request.lockReason)) {
    query['LockReason'] = request.lockReason;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.publicIpAddressPoolId)) {
    query['PublicIpAddressPoolId'] = request.publicIpAddressPoolId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityProtectionEnabled)) {
    query['SecurityProtectionEnabled'] = request.securityProtectionEnabled;
  }
  if (!Util.isUnset(request.segmentInstanceId)) {
    query['SegmentInstanceId'] = request.segmentInstanceId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEipAddresses',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEipAddresses(request: DescribeEipAddressesRequest): DescribeEipAddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipAddressesWithOptions(request, runtime);
}

model DescribeEipGatewayInfoRequest {
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeEipGatewayInfoResponseBody = {
  code?: string(name='Code'),
  eipInfos?: {
    eipInfo?: [ 
    {
      ip?: string(name='Ip'),
      ipGw?: string(name='IpGw'),
      ipMask?: string(name='IpMask'),
    }
  ](name='EipInfo')
  }(name='EipInfos'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeEipGatewayInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEipGatewayInfoResponseBody(name='body'),
}

async function describeEipGatewayInfoWithOptions(request: DescribeEipGatewayInfoRequest, runtime: Util.RuntimeOptions): DescribeEipGatewayInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEipGatewayInfo',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEipGatewayInfo(request: DescribeEipGatewayInfoRequest): DescribeEipGatewayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipGatewayInfoWithOptions(request, runtime);
}

model DescribeEipMonitorDataRequest {
  allocationId?: string(name='AllocationId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeEipMonitorDataResponseBody = {
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipBandwidth?: int32(name='EipBandwidth'),
      eipFlow?: int32(name='EipFlow'),
      eipPackets?: int32(name='EipPackets'),
      eipRX?: long(name='EipRX'),
      eipTX?: long(name='EipTX'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEipMonitorDataResponseBody(name='body'),
}

async function describeEipMonitorDataWithOptions(request: DescribeEipMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeEipMonitorDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEipMonitorData',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEipMonitorData(request: DescribeEipMonitorDataRequest): DescribeEipMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipMonitorDataWithOptions(request, runtime);
}

model DescribeEipSegmentRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
}

model DescribeEipSegmentResponseBody = {
  eipSegments?: {
    eipSegment?: [ 
    {
      creationTime?: string(name='CreationTime'),
      descritpion?: string(name='Descritpion'),
      instanceId?: string(name='InstanceId'),
      ipCount?: string(name='IpCount'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      segment?: string(name='Segment'),
      status?: string(name='Status'),
    }
  ](name='EipSegment')
  }(name='EipSegments'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEipSegmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEipSegmentResponseBody(name='body'),
}

async function describeEipSegmentWithOptions(request: DescribeEipSegmentRequest, runtime: Util.RuntimeOptions): DescribeEipSegmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.segmentInstanceId)) {
    query['SegmentInstanceId'] = request.segmentInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEipSegment',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEipSegment(request: DescribeEipSegmentRequest): DescribeEipSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipSegmentWithOptions(request, runtime);
}

model DescribeFlowLogsRequest {
  description?: string(name='Description'),
  flowLogId?: string(name='FlowLogId'),
  flowLogName?: string(name='FlowLogName'),
  logStoreName?: string(name='LogStoreName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectName?: string(name='ProjectName'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  status?: string(name='Status'),
  trafficType?: string(name='TrafficType'),
  vpcId?: string(name='VpcId'),
}

model DescribeFlowLogsResponseBody = {
  flowLogs?: {
    flowLog?: [ 
    {
      aggregationInterval?: int32(name='AggregationInterval'),
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      flowLogId?: string(name='FlowLogId'),
      flowLogName?: string(name='FlowLogName'),
      logStoreName?: string(name='LogStoreName'),
      projectName?: string(name='ProjectName'),
      regionId?: string(name='RegionId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      status?: string(name='Status'),
      trafficType?: string(name='TrafficType'),
    }
  ](name='FlowLog')
  }(name='FlowLogs'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  totalCount?: string(name='TotalCount'),
}

model DescribeFlowLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowLogsResponseBody(name='body'),
}

async function describeFlowLogsWithOptions(request: DescribeFlowLogsRequest, runtime: Util.RuntimeOptions): DescribeFlowLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.flowLogId)) {
    query['FlowLogId'] = request.flowLogId;
  }
  if (!Util.isUnset(request.flowLogName)) {
    query['FlowLogName'] = request.flowLogName;
  }
  if (!Util.isUnset(request.logStoreName)) {
    query['LogStoreName'] = request.logStoreName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.trafficType)) {
    query['TrafficType'] = request.trafficType;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowLogs',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowLogs(request: DescribeFlowLogsRequest): DescribeFlowLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowLogsWithOptions(request, runtime);
}

model DescribeForwardTableEntriesRequest {
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  forwardEntryId?: string(name='ForwardEntryId'),
  forwardEntryName?: string(name='ForwardEntryName'),
  forwardTableId?: string(name='ForwardTableId'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeForwardTableEntriesResponseBody = {
  forwardTableEntries?: {
    forwardTableEntry?: [ 
    {
      externalIp?: string(name='ExternalIp'),
      externalPort?: string(name='ExternalPort'),
      forwardEntryId?: string(name='ForwardEntryId'),
      forwardEntryName?: string(name='ForwardEntryName'),
      forwardTableId?: string(name='ForwardTableId'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      ipProtocol?: string(name='IpProtocol'),
      status?: string(name='Status'),
    }
  ](name='ForwardTableEntry')
  }(name='ForwardTableEntries'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeForwardTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeForwardTableEntriesResponseBody(name='body'),
}

async function describeForwardTableEntriesWithOptions(request: DescribeForwardTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeForwardTableEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.externalIp)) {
    query['ExternalIp'] = request.externalIp;
  }
  if (!Util.isUnset(request.externalPort)) {
    query['ExternalPort'] = request.externalPort;
  }
  if (!Util.isUnset(request.forwardEntryId)) {
    query['ForwardEntryId'] = request.forwardEntryId;
  }
  if (!Util.isUnset(request.forwardEntryName)) {
    query['ForwardEntryName'] = request.forwardEntryName;
  }
  if (!Util.isUnset(request.forwardTableId)) {
    query['ForwardTableId'] = request.forwardTableId;
  }
  if (!Util.isUnset(request.internalIp)) {
    query['InternalIp'] = request.internalIp;
  }
  if (!Util.isUnset(request.internalPort)) {
    query['InternalPort'] = request.internalPort;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeForwardTableEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): DescribeForwardTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeForwardTableEntriesWithOptions(request, runtime);
}

model DescribeGlobalAccelerationInstancesRequest {
  bandwidthType?: string(name='BandwidthType'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverId?: string(name='ServerId'),
  serviceLocation?: string(name='ServiceLocation'),
  status?: string(name='Status'),
}

model DescribeGlobalAccelerationInstancesResponseBody = {
  globalAccelerationInstances?: {
    globalAccelerationInstance?: [ 
    {
      accelerationLocation?: string(name='AccelerationLocation'),
      backendServers?: {
        backendServer?: [ 
        {
          regionId?: string(name='RegionId'),
          serverId?: string(name='ServerId'),
          serverIpAddress?: string(name='ServerIpAddress'),
          serverType?: string(name='ServerType'),
        }
      ](name='BackendServer')
      }(name='BackendServers'),
      bandwidth?: string(name='Bandwidth'),
      bandwidthType?: string(name='BandwidthType'),
      chargeType?: string(name='ChargeType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
      internetChargeType?: string(name='InternetChargeType'),
      ipAddress?: string(name='IpAddress'),
      name?: string(name='Name'),
      publicIpAddresses?: {
        publicIpAddress?: [ 
        {
          allocationId?: string(name='AllocationId'),
          ipAddress?: string(name='IpAddress'),
        }
      ](name='PublicIpAddress')
      }(name='PublicIpAddresses'),
      regionId?: string(name='RegionId'),
      serviceLocation?: string(name='ServiceLocation'),
      status?: string(name='Status'),
    }
  ](name='GlobalAccelerationInstance')
  }(name='GlobalAccelerationInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGlobalAccelerationInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGlobalAccelerationInstancesResponseBody(name='body'),
}

async function describeGlobalAccelerationInstancesWithOptions(request: DescribeGlobalAccelerationInstancesRequest, runtime: Util.RuntimeOptions): DescribeGlobalAccelerationInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthType)) {
    query['BandwidthType'] = request.bandwidthType;
  }
  if (!Util.isUnset(request.globalAccelerationInstanceId)) {
    query['GlobalAccelerationInstanceId'] = request.globalAccelerationInstanceId;
  }
  if (!Util.isUnset(request.includeReservationData)) {
    query['IncludeReservationData'] = request.includeReservationData;
  }
  if (!Util.isUnset(request.ipAddress)) {
    query['IpAddress'] = request.ipAddress;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverId)) {
    query['ServerId'] = request.serverId;
  }
  if (!Util.isUnset(request.serviceLocation)) {
    query['ServiceLocation'] = request.serviceLocation;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalAccelerationInstances',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGlobalAccelerationInstances(request: DescribeGlobalAccelerationInstancesRequest): DescribeGlobalAccelerationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalAccelerationInstancesWithOptions(request, runtime);
}

model DescribeGrantRulesToCenRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeGrantRulesToCenResponseBody = {
  cenGrantRules?: {
    cbnGrantRule?: [ 
    {
      cenInstanceId?: string(name='CenInstanceId'),
      cenOwnerId?: long(name='CenOwnerId'),
      creationTime?: string(name='CreationTime'),
    }
  ](name='CbnGrantRule')
  }(name='CenGrantRules'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGrantRulesToCenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGrantRulesToCenResponseBody(name='body'),
}

async function describeGrantRulesToCenWithOptions(request: DescribeGrantRulesToCenRequest, runtime: Util.RuntimeOptions): DescribeGrantRulesToCenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGrantRulesToCen',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGrantRulesToCen(request: DescribeGrantRulesToCenRequest): DescribeGrantRulesToCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGrantRulesToCenWithOptions(request, runtime);
}

model DescribeHaVipsRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeHaVipsResponseBody = {
  haVips?: {
    haVip?: [ 
    {
      associatedEipAddresses?: {
        associatedEipAddresse?: [ string ](name='associatedEipAddresse')
      }(name='AssociatedEipAddresses'),
      associatedInstanceType?: string(name='AssociatedInstanceType'),
      associatedInstances?: {
        associatedInstance?: [ string ](name='associatedInstance')
      }(name='AssociatedInstances'),
      chargeType?: string(name='ChargeType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      haVipId?: string(name='HaVipId'),
      ipAddress?: string(name='IpAddress'),
      masterInstanceId?: string(name='MasterInstanceId'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='HaVip')
  }(name='HaVips'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeHaVipsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHaVipsResponseBody(name='body'),
}

async function describeHaVipsWithOptions(request: DescribeHaVipsRequest, runtime: Util.RuntimeOptions): DescribeHaVipsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHaVips',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHaVips(request: DescribeHaVipsRequest): DescribeHaVipsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHaVipsWithOptions(request, runtime);
}

model DescribeHighDefinitionMonitorLogAttributeRequest {
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeHighDefinitionMonitorLogAttributeResponseBody = {
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  logProject?: string(name='LogProject'),
  logStore?: string(name='LogStore'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeHighDefinitionMonitorLogAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHighDefinitionMonitorLogAttributeResponseBody(name='body'),
}

async function describeHighDefinitionMonitorLogAttributeWithOptions(request: DescribeHighDefinitionMonitorLogAttributeRequest, runtime: Util.RuntimeOptions): DescribeHighDefinitionMonitorLogAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHighDefinitionMonitorLogAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHighDefinitionMonitorLogAttribute(request: DescribeHighDefinitionMonitorLogAttributeRequest): DescribeHighDefinitionMonitorLogAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHighDefinitionMonitorLogAttributeWithOptions(request, runtime);
}

model DescribeIPv6TranslatorAclListAttributesRequest {
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeIPv6TranslatorAclListAttributesResponseBody = {
  aclEntries?: {
    aclEntry?: [ 
    {
      aclEntryComment?: string(name='AclEntryComment'),
      aclEntryId?: string(name='AclEntryId'),
      aclEntryIp?: string(name='AclEntryIp'),
    }
  ](name='AclEntry')
  }(name='AclEntries'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorAclListAttributesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIPv6TranslatorAclListAttributesResponseBody(name='body'),
}

async function describeIPv6TranslatorAclListAttributesWithOptions(request: DescribeIPv6TranslatorAclListAttributesRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorAclListAttributesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIPv6TranslatorAclListAttributes',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIPv6TranslatorAclListAttributes(request: DescribeIPv6TranslatorAclListAttributesRequest): DescribeIPv6TranslatorAclListAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorAclListAttributesWithOptions(request, runtime);
}

model DescribeIPv6TranslatorAclListsRequest {
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeIPv6TranslatorAclListsResponseBody = {
  ipv6TranslatorAcls?: {
    IPv6TranslatorAcl?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
    }
  ](name='IPv6TranslatorAcl')
  }(name='Ipv6TranslatorAcls'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorAclListsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIPv6TranslatorAclListsResponseBody(name='body'),
}

async function describeIPv6TranslatorAclListsWithOptions(request: DescribeIPv6TranslatorAclListsRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorAclListsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIPv6TranslatorAclLists',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIPv6TranslatorAclLists(request: DescribeIPv6TranslatorAclListsRequest): DescribeIPv6TranslatorAclListsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorAclListsWithOptions(request, runtime);
}

model DescribeIPv6TranslatorEntriesRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: int32(name='BackendIpv4Port'),
  clientToken?: string(name='ClientToken'),
  entryName?: string(name='EntryName'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  transProtocol?: string(name='TransProtocol'),
}

model DescribeIPv6TranslatorEntriesResponseBody = {
  ipv6TranslatorEntries?: {
    ipv6TranslatorEntry?: [ 
    {
      aclId?: string(name='AclId'),
      aclStatus?: string(name='AclStatus'),
      aclType?: string(name='AclType'),
      allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
      allocateIpv6Port?: int32(name='AllocateIpv6Port'),
      backendIpv4Addr?: string(name='BackendIpv4Addr'),
      backendIpv4Port?: string(name='BackendIpv4Port'),
      entryBandwidth?: string(name='EntryBandwidth'),
      entryDescription?: string(name='EntryDescription'),
      entryName?: string(name='EntryName'),
      entryStatus?: string(name='EntryStatus'),
      ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
      ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
      regionId?: string(name='RegionId'),
      transProtocol?: string(name='TransProtocol'),
    }
  ](name='Ipv6TranslatorEntry')
  }(name='Ipv6TranslatorEntries'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIPv6TranslatorEntriesResponseBody(name='body'),
}

async function describeIPv6TranslatorEntriesWithOptions(request: DescribeIPv6TranslatorEntriesRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.allocateIpv6Addr)) {
    query['AllocateIpv6Addr'] = request.allocateIpv6Addr;
  }
  if (!Util.isUnset(request.allocateIpv6Port)) {
    query['AllocateIpv6Port'] = request.allocateIpv6Port;
  }
  if (!Util.isUnset(request.backendIpv4Addr)) {
    query['BackendIpv4Addr'] = request.backendIpv4Addr;
  }
  if (!Util.isUnset(request.backendIpv4Port)) {
    query['BackendIpv4Port'] = request.backendIpv4Port;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.entryName)) {
    query['EntryName'] = request.entryName;
  }
  if (!Util.isUnset(request.ipv6TranslatorEntryId)) {
    query['Ipv6TranslatorEntryId'] = request.ipv6TranslatorEntryId;
  }
  if (!Util.isUnset(request.ipv6TranslatorId)) {
    query['Ipv6TranslatorId'] = request.ipv6TranslatorId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.transProtocol)) {
    query['TransProtocol'] = request.transProtocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIPv6TranslatorEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIPv6TranslatorEntries(request: DescribeIPv6TranslatorEntriesRequest): DescribeIPv6TranslatorEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorEntriesWithOptions(request, runtime);
}

model DescribeIPv6TranslatorsRequest {
  allocateIpv4Addr?: string(name='AllocateIpv4Addr'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
  businessStatus?: string(name='BusinessStatus'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
}

model DescribeIPv6TranslatorsResponseBody = {
  ipv6Translators?: {
    ipv6Translator?: [ 
    {
      allocateIpv4Addr?: string(name='AllocateIpv4Addr'),
      allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
      availableBandwidth?: string(name='AvailableBandwidth'),
      bandwidth?: int32(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      endTime?: long(name='EndTime'),
      ipv6TranslatorEntryIds?: {
        ipv6TranslatorEntryId?: [ string ](name='Ipv6TranslatorEntryId')
      }(name='Ipv6TranslatorEntryIds'),
      ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
      name?: string(name='Name'),
      payType?: string(name='PayType'),
      regionId?: string(name='RegionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
    }
  ](name='Ipv6Translator')
  }(name='Ipv6Translators'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIPv6TranslatorsResponseBody(name='body'),
}

async function describeIPv6TranslatorsWithOptions(request: DescribeIPv6TranslatorsRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocateIpv4Addr)) {
    query['AllocateIpv4Addr'] = request.allocateIpv4Addr;
  }
  if (!Util.isUnset(request.allocateIpv6Addr)) {
    query['AllocateIpv6Addr'] = request.allocateIpv6Addr;
  }
  if (!Util.isUnset(request.businessStatus)) {
    query['BusinessStatus'] = request.businessStatus;
  }
  if (!Util.isUnset(request.ipv6TranslatorId)) {
    query['Ipv6TranslatorId'] = request.ipv6TranslatorId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIPv6Translators',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIPv6Translators(request: DescribeIPv6TranslatorsRequest): DescribeIPv6TranslatorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorsWithOptions(request, runtime);
}

model DescribeIpv6AddressesRequest {
  associatedInstanceId?: string(name='AssociatedInstanceId'),
  associatedInstanceType?: string(name='AssociatedInstanceType'),
  ipv6Address?: string(name='Ipv6Address'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
}

model DescribeIpv6AddressesResponseBody = {
  ipv6Addresses?: {
    ipv6Address?: [ 
    {
      allocationTime?: string(name='AllocationTime'),
      associatedInstanceId?: string(name='AssociatedInstanceId'),
      associatedInstanceType?: string(name='AssociatedInstanceType'),
      ipv6Address?: string(name='Ipv6Address'),
      ipv6AddressId?: string(name='Ipv6AddressId'),
      ipv6AddressName?: string(name='Ipv6AddressName'),
      ipv6GatewayId?: string(name='Ipv6GatewayId'),
      ipv6InternetBandwidth?: {
        bandwidth?: int32(name='Bandwidth'),
        businessStatus?: string(name='BusinessStatus'),
        instanceChargeType?: string(name='InstanceChargeType'),
        internetChargeType?: string(name='InternetChargeType'),
        ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
      }(name='Ipv6InternetBandwidth'),
      ipv6Isp?: string(name='Ipv6Isp'),
      networkType?: string(name='NetworkType'),
      realBandwidth?: int32(name='RealBandwidth'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Ipv6Address')
  }(name='Ipv6Addresses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIpv6AddressesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIpv6AddressesResponseBody(name='body'),
}

async function describeIpv6AddressesWithOptions(request: DescribeIpv6AddressesRequest, runtime: Util.RuntimeOptions): DescribeIpv6AddressesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.associatedInstanceId)) {
    query['AssociatedInstanceId'] = request.associatedInstanceId;
  }
  if (!Util.isUnset(request.associatedInstanceType)) {
    query['AssociatedInstanceType'] = request.associatedInstanceType;
  }
  if (!Util.isUnset(request.ipv6Address)) {
    query['Ipv6Address'] = request.ipv6Address;
  }
  if (!Util.isUnset(request.ipv6AddressId)) {
    query['Ipv6AddressId'] = request.ipv6AddressId;
  }
  if (!Util.isUnset(request.ipv6InternetBandwidthId)) {
    query['Ipv6InternetBandwidthId'] = request.ipv6InternetBandwidthId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIpv6Addresses',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIpv6Addresses(request: DescribeIpv6AddressesRequest): DescribeIpv6AddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6AddressesWithOptions(request, runtime);
}

model DescribeIpv6EgressOnlyRulesRequest {
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeIpv6EgressOnlyRulesResponseBody = {
  ipv6EgressOnlyRules?: {
    ipv6EgressOnlyRule?: [ 
    {
      description?: string(name='Description'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
      name?: string(name='Name'),
      status?: string(name='Status'),
    }
  ](name='Ipv6EgressOnlyRule')
  }(name='Ipv6EgressOnlyRules'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIpv6EgressOnlyRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIpv6EgressOnlyRulesResponseBody(name='body'),
}

async function describeIpv6EgressOnlyRulesWithOptions(request: DescribeIpv6EgressOnlyRulesRequest, runtime: Util.RuntimeOptions): DescribeIpv6EgressOnlyRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ipv6EgressOnlyRuleId)) {
    query['Ipv6EgressOnlyRuleId'] = request.ipv6EgressOnlyRuleId;
  }
  if (!Util.isUnset(request.ipv6GatewayId)) {
    query['Ipv6GatewayId'] = request.ipv6GatewayId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIpv6EgressOnlyRules',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIpv6EgressOnlyRules(request: DescribeIpv6EgressOnlyRulesRequest): DescribeIpv6EgressOnlyRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6EgressOnlyRulesWithOptions(request, runtime);
}

model DescribeIpv6GatewayAttributeRequest {
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeIpv6GatewayAttributeResponseBody = {
  businessStatus?: string(name='BusinessStatus'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  expiredTime?: string(name='ExpiredTime'),
  instanceChargeType?: string(name='InstanceChargeType'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
}

model DescribeIpv6GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIpv6GatewayAttributeResponseBody(name='body'),
}

async function describeIpv6GatewayAttributeWithOptions(request: DescribeIpv6GatewayAttributeRequest, runtime: Util.RuntimeOptions): DescribeIpv6GatewayAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipv6GatewayId)) {
    query['Ipv6GatewayId'] = request.ipv6GatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIpv6GatewayAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIpv6GatewayAttribute(request: DescribeIpv6GatewayAttributeRequest): DescribeIpv6GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6GatewayAttributeWithOptions(request, runtime);
}

model DescribeIpv6GatewaysRequest {
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DescribeIpv6GatewaysResponseBody = {
  ipv6Gateways?: {
    ipv6Gateway?: [ 
    {
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      instanceChargeType?: string(name='InstanceChargeType'),
      ipv6GatewayId?: string(name='Ipv6GatewayId'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Ipv6Gateway')
  }(name='Ipv6Gateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIpv6GatewaysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIpv6GatewaysResponseBody(name='body'),
}

async function describeIpv6GatewaysWithOptions(request: DescribeIpv6GatewaysRequest, runtime: Util.RuntimeOptions): DescribeIpv6GatewaysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipv6GatewayId)) {
    query['Ipv6GatewayId'] = request.ipv6GatewayId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIpv6Gateways',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIpv6Gateways(request: DescribeIpv6GatewaysRequest): DescribeIpv6GatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6GatewaysWithOptions(request, runtime);
}

model DescribeNatGatewaysRequest {
  dryRun?: boolean(name='DryRun'),
  instanceChargeType?: string(name='InstanceChargeType'),
  name?: string(name='Name'),
  natGatewayId?: string(name='NatGatewayId'),
  natType?: string(name='NatType'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeNatGatewaysResponseBody = {
  natGateways?: {
    natGateway?: [ 
    {
      autoPay?: boolean(name='AutoPay'),
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      deletionProtection?: boolean(name='DeletionProtection'),
      description?: string(name='Description'),
      ecsMetricEnabled?: boolean(name='EcsMetricEnabled'),
      eipBindMode?: string(name='EipBindMode'),
      expiredTime?: string(name='ExpiredTime'),
      forwardTableIds?: {
        forwardTableId?: [ string ](name='ForwardTableId')
      }(name='ForwardTableIds'),
      fullNatTableIds?: {
        fullNatTableId?: [ string ](name='FullNatTableId')
      }(name='FullNatTableIds'),
      icmpReplyEnabled?: boolean(name='IcmpReplyEnabled'),
      instanceChargeType?: string(name='InstanceChargeType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipLists?: {
        ipList?: [ 
        {
          allocationId?: string(name='AllocationId'),
          ipAddress?: string(name='IpAddress'),
          privateIpAddress?: string(name='PrivateIpAddress'),
          snatEntryEnabled?: boolean(name='SnatEntryEnabled'),
          usingStatus?: string(name='UsingStatus'),
        }
      ](name='IpList')
      }(name='IpLists'),
      name?: string(name='Name'),
      natGatewayId?: string(name='NatGatewayId'),
      natGatewayPrivateInfo?: {
        eniInstanceId?: string(name='EniInstanceId'),
        eniType?: string(name='EniType'),
        izNo?: string(name='IzNo'),
        maxBandwidth?: int32(name='MaxBandwidth'),
        maxSessionEstablishRate?: int32(name='MaxSessionEstablishRate'),
        maxSessionQuota?: int32(name='MaxSessionQuota'),
        privateIpAddress?: string(name='PrivateIpAddress'),
        vswitchId?: string(name='VswitchId'),
      }(name='NatGatewayPrivateInfo'),
      natType?: string(name='NatType'),
      networkType?: string(name='NetworkType'),
      privateLinkEnabled?: boolean(name='PrivateLinkEnabled'),
      privateLinkMode?: string(name='PrivateLinkMode'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled'),
      snatTableIds?: {
        snatTableId?: [ string ](name='SnatTableId')
      }(name='SnatTableIds'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      vpcId?: string(name='VpcId'),
    }
  ](name='NatGateway')
  }(name='NatGateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNatGatewaysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNatGatewaysResponseBody(name='body'),
}

async function describeNatGatewaysWithOptions(request: DescribeNatGatewaysRequest, runtime: Util.RuntimeOptions): DescribeNatGatewaysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.natType)) {
    query['NatType'] = request.natType;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNatGateways',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNatGateways(request: DescribeNatGatewaysRequest): DescribeNatGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNatGatewaysWithOptions(request, runtime);
}

model DescribeNetworkAclAttributesRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeNetworkAclAttributesResponseBody = {
  networkAclAttribute?: {
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    egressAclEntries?: {
      egressAclEntry?: [ 
      {
        description?: string(name='Description'),
        destinationCidrIp?: string(name='DestinationCidrIp'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
      }
    ](name='EgressAclEntry')
    }(name='EgressAclEntries'),
    ingressAclEntries?: {
      ingressAclEntry?: [ 
      {
        description?: string(name='Description'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
        sourceCidrIp?: string(name='SourceCidrIp'),
      }
    ](name='IngressAclEntry')
    }(name='IngressAclEntries'),
    networkAclId?: string(name='NetworkAclId'),
    networkAclName?: string(name='NetworkAclName'),
    ownerId?: long(name='OwnerId'),
    regionId?: string(name='RegionId'),
    resources?: {
      resource?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        status?: string(name='Status'),
      }
    ](name='Resource')
    }(name='Resources'),
    status?: string(name='Status'),
    vpcId?: string(name='VpcId'),
  }(name='NetworkAclAttribute'),
  requestId?: string(name='RequestId'),
}

model DescribeNetworkAclAttributesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNetworkAclAttributesResponseBody(name='body'),
}

async function describeNetworkAclAttributesWithOptions(request: DescribeNetworkAclAttributesRequest, runtime: Util.RuntimeOptions): DescribeNetworkAclAttributesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.networkAclId)) {
    query['NetworkAclId'] = request.networkAclId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworkAclAttributes',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNetworkAclAttributes(request: DescribeNetworkAclAttributesRequest): DescribeNetworkAclAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkAclAttributesWithOptions(request, runtime);
}

model DescribeNetworkAclsRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  networkAclName?: string(name='NetworkAclName'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  vpcId?: string(name='VpcId'),
}

model DescribeNetworkAclsResponseBody = {
  networkAcls?: {
    networkAcl?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      egressAclEntries?: {
        egressAclEntry?: [ 
        {
          description?: string(name='Description'),
          destinationCidrIp?: string(name='DestinationCidrIp'),
          networkAclEntryId?: string(name='NetworkAclEntryId'),
          networkAclEntryName?: string(name='NetworkAclEntryName'),
          policy?: string(name='Policy'),
          port?: string(name='Port'),
          protocol?: string(name='Protocol'),
        }
      ](name='EgressAclEntry')
      }(name='EgressAclEntries'),
      ingressAclEntries?: {
        ingressAclEntry?: [ 
        {
          description?: string(name='Description'),
          networkAclEntryId?: string(name='NetworkAclEntryId'),
          networkAclEntryName?: string(name='NetworkAclEntryName'),
          policy?: string(name='Policy'),
          port?: string(name='Port'),
          protocol?: string(name='Protocol'),
          sourceCidrIp?: string(name='SourceCidrIp'),
        }
      ](name='IngressAclEntry')
      }(name='IngressAclEntries'),
      networkAclId?: string(name='NetworkAclId'),
      networkAclName?: string(name='NetworkAclName'),
      ownerId?: long(name='OwnerId'),
      regionId?: string(name='RegionId'),
      resources?: {
        resource?: [ 
        {
          resourceId?: string(name='ResourceId'),
          resourceType?: string(name='ResourceType'),
          status?: string(name='Status'),
        }
      ](name='Resource')
      }(name='Resources'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='NetworkAcl')
  }(name='NetworkAcls'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model DescribeNetworkAclsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNetworkAclsResponseBody(name='body'),
}

async function describeNetworkAclsWithOptions(request: DescribeNetworkAclsRequest, runtime: Util.RuntimeOptions): DescribeNetworkAclsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.networkAclId)) {
    query['NetworkAclId'] = request.networkAclId;
  }
  if (!Util.isUnset(request.networkAclName)) {
    query['NetworkAclName'] = request.networkAclName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworkAcls',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNetworkAcls(request: DescribeNetworkAclsRequest): DescribeNetworkAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkAclsWithOptions(request, runtime);
}

model DescribePhysicalConnectionLOARequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribePhysicalConnectionLOAResponseBody = {
  physicalConnectionLOAType?: {
    companyLocalizedName?: string(name='CompanyLocalizedName'),
    companyName?: string(name='CompanyName'),
    constructionTime?: string(name='ConstructionTime'),
    instanceId?: string(name='InstanceId'),
    lineCode?: string(name='LineCode'),
    lineLabel?: string(name='LineLabel'),
    lineType?: string(name='LineType'),
    loaUrl?: string(name='LoaUrl'),
    PMInfo?: {
      PMInfo?: [ 
      {
        PMCertificateNo?: string(name='PMCertificateNo'),
        PMCertificateType?: string(name='PMCertificateType'),
        PMContactInfo?: string(name='PMContactInfo'),
        PMGender?: string(name='PMGender'),
        PMName?: string(name='PMName'),
      }
    ](name='PMInfo')
    }(name='PMInfo'),
    SI?: string(name='SI'),
    status?: string(name='Status'),
  }(name='PhysicalConnectionLOAType'),
  requestId?: string(name='RequestId'),
}

model DescribePhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePhysicalConnectionLOAResponseBody(name='body'),
}

async function describePhysicalConnectionLOAWithOptions(request: DescribePhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): DescribePhysicalConnectionLOAResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePhysicalConnectionLOA',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePhysicalConnectionLOA(request: DescribePhysicalConnectionLOARequest): DescribePhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePhysicalConnectionLOAWithOptions(request, runtime);
}

model DescribePhysicalConnectionsRequest {
  clientToken?: string(name='ClientToken'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model DescribePhysicalConnectionsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  physicalConnectionSet?: {
    physicalConnectionType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      accessPointType?: string(name='AccessPointType'),
      adLocation?: string(name='AdLocation'),
      bandwidth?: long(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      enabledTime?: string(name='EnabledTime'),
      endTime?: string(name='EndTime'),
      expectSpec?: string(name='ExpectSpec'),
      hasReservationData?: string(name='HasReservationData'),
      lineOperator?: string(name='LineOperator'),
      loaStatus?: string(name='LoaStatus'),
      name?: string(name='Name'),
      orderMode?: string(name='OrderMode'),
      parentPhysicalConnectionAliUid?: long(name='ParentPhysicalConnectionAliUid'),
      parentPhysicalConnectionId?: string(name='ParentPhysicalConnectionId'),
      peerLocation?: string(name='PeerLocation'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      portNumber?: string(name='PortNumber'),
      portType?: string(name='PortType'),
      productType?: string(name='ProductType'),
      redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      virtualPhysicalConnectionCount?: int32(name='VirtualPhysicalConnectionCount'),
      vlanId?: string(name='VlanId'),
      vpconnStatus?: string(name='VpconnStatus'),
    }
  ](name='PhysicalConnectionType')
  }(name='PhysicalConnectionSet'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribePhysicalConnectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePhysicalConnectionsResponseBody(name='body'),
}

async function describePhysicalConnectionsWithOptions(request: DescribePhysicalConnectionsRequest, runtime: Util.RuntimeOptions): DescribePhysicalConnectionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.includeReservationData)) {
    query['IncludeReservationData'] = request.includeReservationData;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePhysicalConnections',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePhysicalConnections(request: DescribePhysicalConnectionsRequest): DescribePhysicalConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePhysicalConnectionsWithOptions(request, runtime);
}

model DescribePublicIpAddressRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribePublicIpAddressResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  publicIpAddress?: [ string ](name='PublicIpAddress'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribePublicIpAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePublicIpAddressResponseBody(name='body'),
}

async function describePublicIpAddressWithOptions(request: DescribePublicIpAddressRequest, runtime: Util.RuntimeOptions): DescribePublicIpAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePublicIpAddress',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePublicIpAddress(request: DescribePublicIpAddressRequest): DescribePublicIpAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePublicIpAddressWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRouteEntryListRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  ipVersion?: string(name='IpVersion'),
  maxResult?: int32(name='MaxResult'),
  nextHopId?: string(name='NextHopId'),
  nextHopType?: string(name='NextHopType'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryId?: string(name='RouteEntryId'),
  routeEntryName?: string(name='RouteEntryName'),
  routeEntryType?: string(name='RouteEntryType'),
  routeTableId?: string(name='RouteTableId'),
}

model DescribeRouteEntryListResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  routeEntrys?: {
    routeEntry?: [ 
    {
      description?: string(name='Description'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      gmtModified?: string(name='GmtModified'),
      ipVersion?: string(name='IpVersion'),
      nextHops?: {
        nextHop?: [ 
        {
          enabled?: int32(name='Enabled'),
          nextHopId?: string(name='NextHopId'),
          nextHopRegionId?: string(name='NextHopRegionId'),
          nextHopRelatedInfo?: {
            instanceId?: string(name='InstanceId'),
            instanceType?: string(name='InstanceType'),
            regionId?: string(name='RegionId'),
          }(name='NextHopRelatedInfo'),
          nextHopType?: string(name='NextHopType'),
          weight?: int32(name='Weight'),
        }
      ](name='NextHop')
      }(name='NextHops'),
      routeEntryId?: string(name='RouteEntryId'),
      routeEntryName?: string(name='RouteEntryName'),
      routeTableId?: string(name='RouteTableId'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='RouteEntry')
  }(name='RouteEntrys'),
}

model DescribeRouteEntryListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRouteEntryListResponseBody(name='body'),
}

async function describeRouteEntryListWithOptions(request: DescribeRouteEntryListRequest, runtime: Util.RuntimeOptions): DescribeRouteEntryListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationCidrBlock)) {
    query['DestinationCidrBlock'] = request.destinationCidrBlock;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.maxResult)) {
    query['MaxResult'] = request.maxResult;
  }
  if (!Util.isUnset(request.nextHopId)) {
    query['NextHopId'] = request.nextHopId;
  }
  if (!Util.isUnset(request.nextHopType)) {
    query['NextHopType'] = request.nextHopType;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeEntryId)) {
    query['RouteEntryId'] = request.routeEntryId;
  }
  if (!Util.isUnset(request.routeEntryName)) {
    query['RouteEntryName'] = request.routeEntryName;
  }
  if (!Util.isUnset(request.routeEntryType)) {
    query['RouteEntryType'] = request.routeEntryType;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRouteEntryList',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRouteEntryList(request: DescribeRouteEntryListRequest): DescribeRouteEntryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteEntryListWithOptions(request, runtime);
}

model DescribeRouteTableListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
  routerId?: string(name='RouterId'),
  routerType?: string(name='RouterType'),
  vpcId?: string(name='VpcId'),
}

model DescribeRouteTableListResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routerTableList?: {
    routerTableListType?: [ 
    {
      associateType?: string(name='AssociateType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      gatewayIds?: {
        gatewayIds?: [ string ](name='GatewayIds')
      }(name='GatewayIds'),
      ownerId?: long(name='OwnerId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeTableId?: string(name='RouteTableId'),
      routeTableName?: string(name='RouteTableName'),
      routeTableType?: string(name='RouteTableType'),
      routerId?: string(name='RouterId'),
      routerType?: string(name='RouterType'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }
  ](name='RouterTableListType')
  }(name='RouterTableList'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouteTableListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRouteTableListResponseBody(name='body'),
}

async function describeRouteTableListWithOptions(request: DescribeRouteTableListRequest, runtime: Util.RuntimeOptions): DescribeRouteTableListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  if (!Util.isUnset(request.routeTableName)) {
    query['RouteTableName'] = request.routeTableName;
  }
  if (!Util.isUnset(request.routerId)) {
    query['RouterId'] = request.routerId;
  }
  if (!Util.isUnset(request.routerType)) {
    query['RouterType'] = request.routerType;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRouteTableList',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRouteTableList(request: DescribeRouteTableListRequest): DescribeRouteTableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteTableListWithOptions(request, runtime);
}

model DescribeRouteTablesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
  routerId?: string(name='RouterId'),
  routerType?: string(name='RouterType'),
  type?: string(name='Type'),
  VRouterId?: string(name='VRouterId'),
}

model DescribeRouteTablesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routeTables?: {
    routeTable?: [ 
    {
      creationTime?: string(name='CreationTime'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeEntrys?: {
        routeEntry?: [ 
        {
          description?: string(name='Description'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          instanceId?: string(name='InstanceId'),
          nextHopType?: string(name='NextHopType'),
          nextHops?: {
            nextHop?: [ 
            {
              enabled?: int32(name='Enabled'),
              nextHopId?: string(name='NextHopId'),
              nextHopType?: string(name='NextHopType'),
              weight?: int32(name='Weight'),
            }
          ](name='NextHop')
          }(name='NextHops'),
          routeEntryId?: string(name='RouteEntryId'),
          routeEntryName?: string(name='RouteEntryName'),
          routeTableId?: string(name='RouteTableId'),
          status?: string(name='Status'),
          type?: string(name='Type'),
        }
      ](name='RouteEntry')
      }(name='RouteEntrys'),
      routeTableId?: string(name='RouteTableId'),
      routeTableType?: string(name='RouteTableType'),
      status?: string(name='Status'),
      VRouterId?: string(name='VRouterId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
    }
  ](name='RouteTable')
  }(name='RouteTables'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouteTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRouteTablesResponseBody(name='body'),
}

async function describeRouteTablesWithOptions(request: DescribeRouteTablesRequest, runtime: Util.RuntimeOptions): DescribeRouteTablesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  if (!Util.isUnset(request.routeTableName)) {
    query['RouteTableName'] = request.routeTableName;
  }
  if (!Util.isUnset(request.routerId)) {
    query['RouterId'] = request.routerId;
  }
  if (!Util.isUnset(request.routerType)) {
    query['RouterType'] = request.routerType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.VRouterId)) {
    query['VRouterId'] = request.VRouterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRouteTables',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRouteTables(request: DescribeRouteTablesRequest): DescribeRouteTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteTablesWithOptions(request, runtime);
}

model DescribeRouterInterfaceAttributeRequest {
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRouterInterfaceAttributeResponseBody = {
  accessPointId?: string(name='AccessPointId'),
  bandwidth?: int32(name='Bandwidth'),
  businessStatus?: string(name='BusinessStatus'),
  chargeType?: string(name='ChargeType'),
  code?: string(name='Code'),
  connectedTime?: string(name='ConnectedTime'),
  creationTime?: string(name='CreationTime'),
  crossBorder?: boolean(name='CrossBorder'),
  description?: string(name='Description'),
  endTime?: string(name='EndTime'),
  gmtModified?: string(name='GmtModified'),
  hasReservationData?: string(name='HasReservationData'),
  hcRate?: int32(name='HcRate'),
  hcThreshold?: int32(name='HcThreshold'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckStatus?: string(name='HealthCheckStatus'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId'),
  oppositeBandwidth?: int32(name='OppositeBandwidth'),
  oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
  oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
  oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
  oppositeRegionId?: string(name='OppositeRegionId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  oppositeVpcInstanceId?: string(name='OppositeVpcInstanceId'),
  requestId?: string(name='RequestId'),
  reservationActiveTime?: string(name='ReservationActiveTime'),
  reservationBandwidth?: string(name='ReservationBandwidth'),
  reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
  reservationOrderType?: string(name='ReservationOrderType'),
  role?: string(name='Role'),
  routerId?: string(name='RouterId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
  routerType?: string(name='RouterType'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
  vpcInstanceId?: string(name='VpcInstanceId'),
}

model DescribeRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRouterInterfaceAttributeResponseBody(name='body'),
}

async function describeRouterInterfaceAttributeWithOptions(request: DescribeRouterInterfaceAttributeRequest, runtime: Util.RuntimeOptions): DescribeRouterInterfaceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRouterInterfaceAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRouterInterfaceAttribute(request: DescribeRouterInterfaceAttributeRequest): DescribeRouterInterfaceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouterInterfaceAttributeWithOptions(request, runtime);
}

model DescribeRouterInterfacesRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRouterInterfacesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routerInterfaceSet?: {
    routerInterfaceType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      bandwidth?: int32(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      connectedTime?: string(name='ConnectedTime'),
      creationTime?: string(name='CreationTime'),
      crossBorder?: boolean(name='CrossBorder'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      fastLinkMode?: boolean(name='FastLinkMode'),
      hasReservationData?: string(name='HasReservationData'),
      hcRate?: int32(name='HcRate'),
      hcThreshold?: int32(name='HcThreshold'),
      healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
      healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
      ipv6Status?: string(name='Ipv6Status'),
      name?: string(name='Name'),
      oppositeAccessPointId?: string(name='OppositeAccessPointId'),
      oppositeBandwidth?: int32(name='OppositeBandwidth'),
      oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
      oppositeInterfaceId?: string(name='OppositeInterfaceId'),
      oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
      oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
      oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
      oppositeRegionId?: string(name='OppositeRegionId'),
      oppositeRouterId?: string(name='OppositeRouterId'),
      oppositeRouterType?: string(name='OppositeRouterType'),
      oppositeVpcInstanceId?: string(name='OppositeVpcInstanceId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      role?: string(name='Role'),
      routerId?: string(name='RouterId'),
      routerInterfaceId?: string(name='RouterInterfaceId'),
      routerType?: string(name='RouterType'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      vpcInstanceId?: string(name='VpcInstanceId'),
    }
  ](name='RouterInterfaceType')
  }(name='RouterInterfaceSet'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouterInterfacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRouterInterfacesResponseBody(name='body'),
}

async function describeRouterInterfacesWithOptions(request: DescribeRouterInterfacesRequest, runtime: Util.RuntimeOptions): DescribeRouterInterfacesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.includeReservationData)) {
    query['IncludeReservationData'] = request.includeReservationData;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRouterInterfaces',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRouterInterfaces(request: DescribeRouterInterfacesRequest): DescribeRouterInterfacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouterInterfacesWithOptions(request, runtime);
}

model DescribeServerRelatedGlobalAccelerationInstancesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverId?: string(name='ServerId'),
  serverType?: string(name='ServerType'),
}

model DescribeServerRelatedGlobalAccelerationInstancesResponseBody = {
  globalAccelerationInstances?: {
    globalAccelerationInstance?: [ 
    {
      globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
      ipAddress?: string(name='IpAddress'),
      regionId?: string(name='RegionId'),
      serverIpAddress?: string(name='ServerIpAddress'),
    }
  ](name='GlobalAccelerationInstance')
  }(name='GlobalAccelerationInstances'),
  requestId?: string(name='RequestId'),
}

model DescribeServerRelatedGlobalAccelerationInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServerRelatedGlobalAccelerationInstancesResponseBody(name='body'),
}

async function describeServerRelatedGlobalAccelerationInstancesWithOptions(request: DescribeServerRelatedGlobalAccelerationInstancesRequest, runtime: Util.RuntimeOptions): DescribeServerRelatedGlobalAccelerationInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverId)) {
    query['ServerId'] = request.serverId;
  }
  if (!Util.isUnset(request.serverType)) {
    query['ServerType'] = request.serverType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServerRelatedGlobalAccelerationInstances',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServerRelatedGlobalAccelerationInstances(request: DescribeServerRelatedGlobalAccelerationInstancesRequest): DescribeServerRelatedGlobalAccelerationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServerRelatedGlobalAccelerationInstancesWithOptions(request, runtime);
}

model DescribeSnatTableEntriesRequest {
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snatEntryId?: string(name='SnatEntryId'),
  snatEntryName?: string(name='SnatEntryName'),
  snatIp?: string(name='SnatIp'),
  snatTableId?: string(name='SnatTableId'),
  sourceCIDR?: string(name='SourceCIDR'),
  sourceVSwitchId?: string(name='SourceVSwitchId'),
}

model DescribeSnatTableEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  snatTableEntries?: {
    snatTableEntry?: [ 
    {
      snatEntryId?: string(name='SnatEntryId'),
      snatEntryName?: string(name='SnatEntryName'),
      snatIp?: string(name='SnatIp'),
      snatTableId?: string(name='SnatTableId'),
      sourceCIDR?: string(name='SourceCIDR'),
      sourceVSwitchId?: string(name='SourceVSwitchId'),
      status?: string(name='Status'),
    }
  ](name='SnatTableEntry')
  }(name='SnatTableEntries'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSnatTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSnatTableEntriesResponseBody(name='body'),
}

async function describeSnatTableEntriesWithOptions(request: DescribeSnatTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeSnatTableEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.snatEntryId)) {
    query['SnatEntryId'] = request.snatEntryId;
  }
  if (!Util.isUnset(request.snatEntryName)) {
    query['SnatEntryName'] = request.snatEntryName;
  }
  if (!Util.isUnset(request.snatIp)) {
    query['SnatIp'] = request.snatIp;
  }
  if (!Util.isUnset(request.snatTableId)) {
    query['SnatTableId'] = request.snatTableId;
  }
  if (!Util.isUnset(request.sourceCIDR)) {
    query['SourceCIDR'] = request.sourceCIDR;
  }
  if (!Util.isUnset(request.sourceVSwitchId)) {
    query['SourceVSwitchId'] = request.sourceVSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnatTableEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSnatTableEntries(request: DescribeSnatTableEntriesRequest): DescribeSnatTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnatTableEntriesWithOptions(request, runtime);
}

model DescribeSslVpnClientCertRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model DescribeSslVpnClientCertResponseBody = {
  caCert?: string(name='CaCert'),
  clientCert?: string(name='ClientCert'),
  clientConfig?: string(name='ClientConfig'),
  clientKey?: string(name='ClientKey'),
  createTime?: long(name='CreateTime'),
  endTime?: long(name='EndTime'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  status?: string(name='Status'),
}

model DescribeSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSslVpnClientCertResponseBody(name='body'),
}

async function describeSslVpnClientCertWithOptions(request: DescribeSslVpnClientCertRequest, runtime: Util.RuntimeOptions): DescribeSslVpnClientCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslVpnClientCertId)) {
    query['SslVpnClientCertId'] = request.sslVpnClientCertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSslVpnClientCert',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSslVpnClientCert(request: DescribeSslVpnClientCertRequest): DescribeSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnClientCertWithOptions(request, runtime);
}

model DescribeSslVpnClientCertsRequest {
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model DescribeSslVpnClientCertsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertKeys?: {
    sslVpnClientCertKey?: [ 
    {
      createTime?: long(name='CreateTime'),
      endTime?: long(name='EndTime'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      sslVpnClientCertId?: string(name='SslVpnClientCertId'),
      sslVpnServerId?: string(name='SslVpnServerId'),
      status?: string(name='Status'),
    }
  ](name='SslVpnClientCertKey')
  }(name='SslVpnClientCertKeys'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSslVpnClientCertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSslVpnClientCertsResponseBody(name='body'),
}

async function describeSslVpnClientCertsWithOptions(request: DescribeSslVpnClientCertsRequest, runtime: Util.RuntimeOptions): DescribeSslVpnClientCertsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslVpnClientCertId)) {
    query['SslVpnClientCertId'] = request.sslVpnClientCertId;
  }
  if (!Util.isUnset(request.sslVpnServerId)) {
    query['SslVpnServerId'] = request.sslVpnServerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSslVpnClientCerts',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSslVpnClientCerts(request: DescribeSslVpnClientCertsRequest): DescribeSslVpnClientCertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnClientCertsWithOptions(request, runtime);
}

model DescribeSslVpnServersRequest {
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeSslVpnServersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sslVpnServers?: {
    sslVpnServer?: [ 
    {
      cipher?: string(name='Cipher'),
      clientIpPool?: string(name='ClientIpPool'),
      compress?: boolean(name='Compress'),
      connections?: int32(name='Connections'),
      createTime?: long(name='CreateTime'),
      enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
      IDaaSInstanceId?: string(name='IDaaSInstanceId'),
      IDaaSRegionId?: string(name='IDaaSRegionId'),
      internetIp?: string(name='InternetIp'),
      localSubnet?: string(name='LocalSubnet'),
      maxConnections?: int32(name='MaxConnections'),
      name?: string(name='Name'),
      port?: int32(name='Port'),
      proto?: string(name='Proto'),
      regionId?: string(name='RegionId'),
      sslVpnServerId?: string(name='SslVpnServerId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='SslVpnServer')
  }(name='SslVpnServers'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSslVpnServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSslVpnServersResponseBody(name='body'),
}

async function describeSslVpnServersWithOptions(request: DescribeSslVpnServersRequest, runtime: Util.RuntimeOptions): DescribeSslVpnServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslVpnServerId)) {
    query['SslVpnServerId'] = request.sslVpnServerId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSslVpnServers',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSslVpnServers(request: DescribeSslVpnServersRequest): DescribeSslVpnServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnServersWithOptions(request, runtime);
}

model DescribeVRoutersRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VRouterId?: string(name='VRouterId'),
}

model DescribeVRoutersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  VRouters?: {
    VRouter?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      routeTableIds?: {
        routeTableId?: [ string ](name='RouteTableId')
      }(name='RouteTableIds'),
      VRouterId?: string(name='VRouterId'),
      VRouterName?: string(name='VRouterName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='VRouter')
  }(name='VRouters'),
}

model DescribeVRoutersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVRoutersResponseBody(name='body'),
}

async function describeVRoutersWithOptions(request: DescribeVRoutersRequest, runtime: Util.RuntimeOptions): DescribeVRoutersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VRouterId)) {
    query['VRouterId'] = request.VRouterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVRouters',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVRouters(request: DescribeVRoutersRequest): DescribeVRoutersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVRoutersWithOptions(request, runtime);
}

model DescribeVSwitchAttributesRequest {
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model DescribeVSwitchAttributesResponseBody = {
  availableIpAddressCount?: long(name='AvailableIpAddressCount'),
  cidrBlock?: string(name='CidrBlock'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  isDefault?: boolean(name='IsDefault'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  routeTable?: {
    routeTableId?: string(name='RouteTableId'),
    routeTableType?: string(name='RouteTableType'),
  }(name='RouteTable'),
  status?: string(name='Status'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeVSwitchAttributesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVSwitchAttributesResponseBody(name='body'),
}

async function describeVSwitchAttributesWithOptions(request: DescribeVSwitchAttributesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchAttributesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVSwitchAttributes',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVSwitchAttributes(request: DescribeVSwitchAttributesRequest): DescribeVSwitchAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchAttributesWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  vSwitchOwnerId?: long(name='VSwitchOwnerId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vSwitches?: {
    vSwitch?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      isDefault?: boolean(name='IsDefault'),
      networkAclId?: string(name='NetworkAclId'),
      ownerId?: long(name='OwnerId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeTable?: {
        routeTableId?: string(name='RouteTableId'),
        routeTableType?: string(name='RouteTableType'),
      }(name='RouteTable'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='VSwitch')
  }(name='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.isDefault)) {
    query['IsDefault'] = request.isDefault;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchName)) {
    query['VSwitchName'] = request.vSwitchName;
  }
  if (!Util.isUnset(request.vSwitchOwnerId)) {
    query['VSwitchOwnerId'] = request.vSwitchOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVSwitches',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DescribeVbrHaRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrHaId?: string(name='VbrHaId'),
  vbrId?: string(name='VbrId'),
}

model DescribeVbrHaResponseBody = {
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  peerVbrId?: string(name='PeerVbrId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  vbrHaId?: string(name='VbrHaId'),
  vbrId?: string(name='VbrId'),
}

model DescribeVbrHaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVbrHaResponseBody(name='body'),
}

async function describeVbrHaWithOptions(request: DescribeVbrHaRequest, runtime: Util.RuntimeOptions): DescribeVbrHaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vbrHaId)) {
    query['VbrHaId'] = request.vbrHaId;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVbrHa',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVbrHa(request: DescribeVbrHaRequest): DescribeVbrHaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVbrHaWithOptions(request, runtime);
}

model DescribeVcoRouteEntriesRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryType?: string(name='RouteEntryType'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DescribeVcoRouteEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vcoRouteEntries?: [ 
    {
      asPath?: string(name='AsPath'),
      community?: string(name='Community'),
      createTime?: long(name='CreateTime'),
      nextHop?: string(name='NextHop'),
      routeDest?: string(name='RouteDest'),
      routeEntryType?: string(name='RouteEntryType'),
      source?: string(name='Source'),
      state?: string(name='State'),
      vpnConnectionId?: string(name='VpnConnectionId'),
      weight?: int32(name='Weight'),
    }
  ](name='VcoRouteEntries'),
}

model DescribeVcoRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVcoRouteEntriesResponseBody(name='body'),
}

async function describeVcoRouteEntriesWithOptions(request: DescribeVcoRouteEntriesRequest, runtime: Util.RuntimeOptions): DescribeVcoRouteEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeEntryType)) {
    query['RouteEntryType'] = request.routeEntryType;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVcoRouteEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVcoRouteEntries(request: DescribeVcoRouteEntriesRequest): DescribeVcoRouteEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVcoRouteEntriesWithOptions(request, runtime);
}

model DescribeVirtualBorderRoutersRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeVirtualBorderRoutersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterSet?: {
    virtualBorderRouterType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      activationTime?: string(name='ActivationTime'),
      associatedCens?: {
        associatedCen?: [ 
        {
          cenId?: string(name='CenId'),
          cenOwnerId?: long(name='CenOwnerId'),
          cenStatus?: string(name='CenStatus'),
        }
      ](name='AssociatedCen')
      }(name='AssociatedCens'),
      associatedPhysicalConnections?: {
        associatedPhysicalConnection?: [ 
        {
          circuitCode?: string(name='CircuitCode'),
          enableIpv6?: boolean(name='EnableIpv6'),
          localGatewayIp?: string(name='LocalGatewayIp'),
          localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
          peerGatewayIp?: string(name='PeerGatewayIp'),
          peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
          peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
          peeringSubnetMask?: string(name='PeeringSubnetMask'),
          physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
          physicalConnectionId?: string(name='PhysicalConnectionId'),
          physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
          physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
          status?: string(name='Status'),
          vlanId?: string(name='VlanId'),
          vlanInterfaceId?: string(name='VlanInterfaceId'),
        }
      ](name='AssociatedPhysicalConnection')
      }(name='AssociatedPhysicalConnections'),
      circuitCode?: string(name='CircuitCode'),
      cloudBoxInstanceId?: string(name='CloudBoxInstanceId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      detectMultiplier?: long(name='DetectMultiplier'),
      eccId?: string(name='EccId'),
      enableIpv6?: boolean(name='EnableIpv6'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
      minRxInterval?: long(name='MinRxInterval'),
      minTxInterval?: long(name='MinTxInterval'),
      name?: string(name='Name'),
      PConnVbrChargeType?: string(name='PConnVbrChargeType'),
      PConnVbrExpireTime?: string(name='PConnVbrExpireTime'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
      peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
      physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
      recoveryTime?: string(name='RecoveryTime'),
      routeTableId?: string(name='RouteTableId'),
      status?: string(name='Status'),
      terminationTime?: string(name='TerminationTime'),
      type?: string(name='Type'),
      vbrId?: string(name='VbrId'),
      vlanId?: int32(name='VlanId'),
      vlanInterfaceId?: string(name='VlanInterfaceId'),
    }
  ](name='VirtualBorderRouterType')
  }(name='VirtualBorderRouterSet'),
}

model DescribeVirtualBorderRoutersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVirtualBorderRoutersResponseBody(name='body'),
}

async function describeVirtualBorderRoutersWithOptions(request: DescribeVirtualBorderRoutersRequest, runtime: Util.RuntimeOptions): DescribeVirtualBorderRoutersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVirtualBorderRouters',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVirtualBorderRouters(request: DescribeVirtualBorderRoutersRequest): DescribeVirtualBorderRoutersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualBorderRoutersWithOptions(request, runtime);
}

model DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterForPhysicalConnectionSet?: {
    virtualBorderRouterForPhysicalConnectionType?: [ 
    {
      activationTime?: string(name='ActivationTime'),
      bandwidth?: string(name='Bandwidth'),
      bandwidthStatus?: string(name='BandwidthStatus'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      eccId?: string(name='EccId'),
      enableIpv6?: boolean(name='EnableIpv6'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
      PConnVbrBussinessStatus?: string(name='PConnVbrBussinessStatus'),
      PConnVbrChargeType?: string(name='PConnVbrChargeType'),
      PConnVbrExpireTime?: string(name='PConnVbrExpireTime'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
      peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      recoveryTime?: string(name='RecoveryTime'),
      status?: string(name='Status'),
      terminationTime?: string(name='TerminationTime'),
      type?: string(name='Type'),
      vbrId?: string(name='VbrId'),
      vbrOwnerUid?: long(name='VbrOwnerUid'),
      vlanId?: int32(name='VlanId'),
    }
  ](name='VirtualBorderRouterForPhysicalConnectionType')
  }(name='VirtualBorderRouterForPhysicalConnectionSet'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody(name='body'),
}

async function describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest, runtime: Util.RuntimeOptions): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVirtualBorderRoutersForPhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVirtualBorderRoutersForPhysicalConnection(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request, runtime);
}

model DescribeVpcAttributeRequest {
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DescribeVpcAttributeResponseBody = {
  associatedCens?: {
    associatedCen?: [ 
    {
      cenId?: string(name='CenId'),
      cenOwnerId?: long(name='CenOwnerId'),
      cenStatus?: string(name='CenStatus'),
    }
  ](name='AssociatedCen')
  }(name='AssociatedCens'),
  cidrBlock?: string(name='CidrBlock'),
  classicLinkEnabled?: boolean(name='ClassicLinkEnabled'),
  cloudResources?: {
    cloudResourceSetType?: [ 
    {
      resourceCount?: int32(name='ResourceCount'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='CloudResourceSetType')
  }(name='CloudResources'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dhcpOptionsSetStatus?: string(name='DhcpOptionsSetStatus'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  ipv6CidrBlocks?: {
    ipv6CidrBlock?: [ 
    {
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      ipv6Isp?: string(name='Ipv6Isp'),
    }
  ](name='Ipv6CidrBlock')
  }(name='Ipv6CidrBlocks'),
  isDefault?: boolean(name='IsDefault'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  secondaryCidrBlocks?: {
    secondaryCidrBlock?: [ string ](name='SecondaryCidrBlock')
  }(name='SecondaryCidrBlocks'),
  status?: string(name='Status'),
  supportIpv4Gateway?: boolean(name='SupportIpv4Gateway'),
  userCidrs?: {
    userCidr?: [ string ](name='UserCidr')
  }(name='UserCidrs'),
  VRouterId?: string(name='VRouterId'),
  vSwitchIds?: {
    vSwitchId?: [ string ](name='VSwitchId')
  }(name='VSwitchIds'),
  vpcId?: string(name='VpcId'),
  vpcName?: string(name='VpcName'),
}

model DescribeVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpcAttributeResponseBody(name='body'),
}

async function describeVpcAttributeWithOptions(request: DescribeVpcAttributeRequest, runtime: Util.RuntimeOptions): DescribeVpcAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.isDefault)) {
    query['IsDefault'] = request.isDefault;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpcAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpcAttribute(request: DescribeVpcAttributeRequest): DescribeVpcAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcAttributeWithOptions(request, runtime);
}

model DescribeVpcsRequest {
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
  vpcName?: string(name='VpcName'),
  vpcOwnerId?: long(name='VpcOwnerId'),
}

model DescribeVpcsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpcs?: {
    vpc?: [ 
    {
      cenStatus?: string(name='CenStatus'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
      dhcpOptionsSetStatus?: string(name='DhcpOptionsSetStatus'),
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      ipv6CidrBlocks?: {
        ipv6CidrBlock?: [ 
        {
          ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
          ipv6Isp?: string(name='Ipv6Isp'),
        }
      ](name='Ipv6CidrBlock')
      }(name='Ipv6CidrBlocks'),
      isDefault?: boolean(name='IsDefault'),
      natGatewayIds?: {
        natGatewayIds?: [ string ](name='NatGatewayIds')
      }(name='NatGatewayIds'),
      ownerId?: long(name='OwnerId'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routerTableIds?: {
        routerTableIds?: [ string ](name='RouterTableIds')
      }(name='RouterTableIds'),
      secondaryCidrBlocks?: {
        secondaryCidrBlock?: [ string ](name='SecondaryCidrBlock')
      }(name='SecondaryCidrBlocks'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      userCidrs?: {
        userCidr?: [ string ](name='UserCidr')
      }(name='UserCidrs'),
      VRouterId?: string(name='VRouterId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Vpc')
  }(name='Vpcs'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: Util.RuntimeOptions): DescribeVpcsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dhcpOptionsSetId)) {
    query['DhcpOptionsSetId'] = request.dhcpOptionsSetId;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.isDefault)) {
    query['IsDefault'] = request.isDefault;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vpcName)) {
    query['VpcName'] = request.vpcName;
  }
  if (!Util.isUnset(request.vpcOwnerId)) {
    query['VpcOwnerId'] = request.vpcOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpcs',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcsWithOptions(request, runtime);
}

model DescribeVpnAttachmentsRequest {
  attachType?: string(name='AttachType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DescribeVpnAttachmentsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnAttachments?: [ 
    {
      attachType?: string(name='AttachType'),
      crossAccountAuthorized?: boolean(name='CrossAccountAuthorized'),
      description?: string(name='Description'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      transitRouterId?: string(name='TransitRouterId'),
      transitRouterName?: string(name='TransitRouterName'),
    }
  ](name='VpnAttachments'),
}

model DescribeVpnAttachmentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpnAttachmentsResponseBody(name='body'),
}

async function describeVpnAttachmentsWithOptions(request: DescribeVpnAttachmentsRequest, runtime: Util.RuntimeOptions): DescribeVpnAttachmentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.attachType)) {
    query['AttachType'] = request.attachType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpnAttachments',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpnAttachments(request: DescribeVpnAttachmentsRequest): DescribeVpnAttachmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnAttachmentsWithOptions(request, runtime);
}

model DescribeVpnConnectionRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DescribeVpnConnectionResponseBody = {
  attachInstanceId?: string(name='AttachInstanceId'),
  attachType?: string(name='AttachType'),
  createTime?: long(name='CreateTime'),
  crossAccountAuthorized?: boolean(name='CrossAccountAuthorized'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  ikeConfig?: {
    ikeAuthAlg?: string(name='IkeAuthAlg'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeMode?: string(name='IkeMode'),
    ikePfs?: string(name='IkePfs'),
    ikeVersion?: string(name='IkeVersion'),
    localId?: string(name='LocalId'),
    psk?: string(name='Psk'),
    remoteId?: string(name='RemoteId'),
  }(name='IkeConfig'),
  internetIp?: string(name='InternetIp'),
  ipsecConfig?: {
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecPfs?: string(name='IpsecPfs'),
  }(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
  remoteSubnet?: string(name='RemoteSubnet'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  state?: string(name='State'),
  status?: string(name='Status'),
  transitRouterId?: string(name='TransitRouterId'),
  transitRouterName?: string(name='TransitRouterName'),
  vcoHealthCheck?: {
    dip?: string(name='Dip'),
    enable?: string(name='Enable'),
    interval?: int32(name='Interval'),
    policy?: string(name='Policy'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
    status?: string(name='Status'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig?: {
    authKey?: string(name='AuthKey'),
    enableBgp?: string(name='EnableBgp'),
    localAsn?: long(name='LocalAsn'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: long(name='PeerAsn'),
    peerBgpIp?: string(name='PeerBgpIp'),
    status?: string(name='Status'),
    tunnelCidr?: string(name='TunnelCidr'),
  }(name='VpnBgpConfig'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  zoneNo?: string(name='ZoneNo'),
}

model DescribeVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpnConnectionResponseBody(name='body'),
}

async function describeVpnConnectionWithOptions(request: DescribeVpnConnectionRequest, runtime: Util.RuntimeOptions): DescribeVpnConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpnConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpnConnection(request: DescribeVpnConnectionRequest): DescribeVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnConnectionWithOptions(request, runtime);
}

model DescribeVpnConnectionsRequest {
  customerGatewayId?: string(name='CustomerGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnConnectionsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnConnections?: {
    vpnConnection?: [ 
    {
      attachInstanceId?: string(name='AttachInstanceId'),
      attachType?: string(name='AttachType'),
      createTime?: long(name='CreateTime'),
      crossAccountAuthorized?: boolean(name='CrossAccountAuthorized'),
      customerGatewayId?: string(name='CustomerGatewayId'),
      effectImmediately?: boolean(name='EffectImmediately'),
      enableDpd?: boolean(name='EnableDpd'),
      enableNatTraversal?: boolean(name='EnableNatTraversal'),
      ikeConfig?: {
        ikeAuthAlg?: string(name='IkeAuthAlg'),
        ikeEncAlg?: string(name='IkeEncAlg'),
        ikeLifetime?: long(name='IkeLifetime'),
        ikeMode?: string(name='IkeMode'),
        ikePfs?: string(name='IkePfs'),
        ikeVersion?: string(name='IkeVersion'),
        localId?: string(name='LocalId'),
        psk?: string(name='Psk'),
        remoteId?: string(name='RemoteId'),
      }(name='IkeConfig'),
      ipsecConfig?: {
        ipsecAuthAlg?: string(name='IpsecAuthAlg'),
        ipsecEncAlg?: string(name='IpsecEncAlg'),
        ipsecLifetime?: long(name='IpsecLifetime'),
        ipsecPfs?: string(name='IpsecPfs'),
      }(name='IpsecConfig'),
      localSubnet?: string(name='LocalSubnet'),
      name?: string(name='Name'),
      networkType?: string(name='NetworkType'),
      remoteCaCertificate?: string(name='RemoteCaCertificate'),
      remoteSubnet?: string(name='RemoteSubnet'),
      spec?: string(name='Spec'),
      state?: string(name='State'),
      status?: string(name='Status'),
      transitRouterId?: string(name='TransitRouterId'),
      transitRouterName?: string(name='TransitRouterName'),
      vcoHealthCheck?: {
        dip?: string(name='Dip'),
        enable?: string(name='Enable'),
        interval?: int32(name='Interval'),
        policy?: string(name='Policy'),
        retry?: int32(name='Retry'),
        sip?: string(name='Sip'),
        status?: string(name='Status'),
      }(name='VcoHealthCheck'),
      vpnBgpConfig?: {
        authKey?: string(name='AuthKey'),
        localAsn?: long(name='LocalAsn'),
        localBgpIp?: string(name='LocalBgpIp'),
        peerAsn?: long(name='PeerAsn'),
        peerBgpIp?: string(name='PeerBgpIp'),
        status?: string(name='Status'),
        tunnelCidr?: string(name='TunnelCidr'),
      }(name='VpnBgpConfig'),
      vpnConnectionId?: string(name='VpnConnectionId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='VpnConnection')
  }(name='VpnConnections'),
}

model DescribeVpnConnectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpnConnectionsResponseBody(name='body'),
}

async function describeVpnConnectionsWithOptions(request: DescribeVpnConnectionsRequest, runtime: Util.RuntimeOptions): DescribeVpnConnectionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customerGatewayId)) {
    query['CustomerGatewayId'] = request.customerGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpnConnections',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpnConnections(request: DescribeVpnConnectionsRequest): DescribeVpnConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnConnectionsWithOptions(request, runtime);
}

model DescribeVpnCrossAccountAuthorizationsRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DescribeVpnCrossAccountAuthorizationsResponseBody = {
  crossAccountAuthorizations?: [ 
    {
      aliUid?: long(name='AliUid'),
      bindInstance?: string(name='BindInstance'),
      bindProduct?: string(name='BindProduct'),
      bindUid?: long(name='BindUid'),
      creationTime?: long(name='CreationTime'),
      vpnConnectionId?: string(name='VpnConnectionId'),
    }
  ](name='CrossAccountAuthorizations'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeVpnCrossAccountAuthorizationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpnCrossAccountAuthorizationsResponseBody(name='body'),
}

async function describeVpnCrossAccountAuthorizationsWithOptions(request: DescribeVpnCrossAccountAuthorizationsRequest, runtime: Util.RuntimeOptions): DescribeVpnCrossAccountAuthorizationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpnCrossAccountAuthorizations',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpnCrossAccountAuthorizations(request: DescribeVpnCrossAccountAuthorizationsRequest): DescribeVpnCrossAccountAuthorizationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnCrossAccountAuthorizationsWithOptions(request, runtime);
}

model DescribeVpnGatewayRequest {
  includeReservationData?: boolean(name='IncludeReservationData'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnGatewayResponseBody = {
  autoPropagate?: boolean(name='AutoPropagate'),
  businessStatus?: string(name='BusinessStatus'),
  chargeType?: string(name='ChargeType'),
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  enableBgp?: boolean(name='EnableBgp'),
  endTime?: long(name='EndTime'),
  internetIp?: string(name='InternetIp'),
  ipsecVpn?: string(name='IpsecVpn'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  reservationData?: {
    reservationEndTime?: string(name='ReservationEndTime'),
    reservationIpsec?: string(name='ReservationIpsec'),
    reservationMaxConnections?: int32(name='ReservationMaxConnections'),
    reservationOrderType?: string(name='ReservationOrderType'),
    reservationSpec?: string(name='ReservationSpec'),
    reservationSsl?: string(name='ReservationSsl'),
    status?: string(name='Status'),
  }(name='ReservationData'),
  spec?: string(name='Spec'),
  sslMaxConnections?: long(name='SslMaxConnections'),
  sslVpn?: string(name='SslVpn'),
  status?: string(name='Status'),
  tag?: string(name='Tag'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  vpnType?: string(name='VpnType'),
}

model DescribeVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpnGatewayResponseBody(name='body'),
}

async function describeVpnGatewayWithOptions(request: DescribeVpnGatewayRequest, runtime: Util.RuntimeOptions): DescribeVpnGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeReservationData)) {
    query['IncludeReservationData'] = request.includeReservationData;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpnGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpnGateway(request: DescribeVpnGatewayRequest): DescribeVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnGatewayWithOptions(request, runtime);
}

model DescribeVpnGatewaysRequest {
  businessStatus?: string(name='BusinessStatus'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: string(name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnGatewaysResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnGateways?: {
    vpnGateway?: [ 
    {
      autoPropagate?: boolean(name='AutoPropagate'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      enableBgp?: boolean(name='EnableBgp'),
      endTime?: long(name='EndTime'),
      internetIp?: string(name='InternetIp'),
      ipsecVpn?: string(name='IpsecVpn'),
      name?: string(name='Name'),
      networkType?: string(name='NetworkType'),
      reservationData?: {
        reservationEndTime?: string(name='ReservationEndTime'),
        reservationIpsec?: string(name='ReservationIpsec'),
        reservationMaxConnections?: int32(name='ReservationMaxConnections'),
        reservationOrderType?: string(name='ReservationOrderType'),
        reservationSpec?: string(name='ReservationSpec'),
        reservationSsl?: string(name='ReservationSsl'),
        status?: string(name='Status'),
      }(name='ReservationData'),
      spec?: string(name='Spec'),
      sslMaxConnections?: long(name='SslMaxConnections'),
      sslVpn?: string(name='SslVpn'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
      vpnType?: string(name='VpnType'),
    }
  ](name='VpnGateway')
  }(name='VpnGateways'),
}

model DescribeVpnGatewaysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpnGatewaysResponseBody(name='body'),
}

async function describeVpnGatewaysWithOptions(request: DescribeVpnGatewaysRequest, runtime: Util.RuntimeOptions): DescribeVpnGatewaysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessStatus)) {
    query['BusinessStatus'] = request.businessStatus;
  }
  if (!Util.isUnset(request.includeReservationData)) {
    query['IncludeReservationData'] = request.includeReservationData;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpnGateways',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpnGateways(request: DescribeVpnGatewaysRequest): DescribeVpnGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnGatewaysWithOptions(request, runtime);
}

model DescribeVpnPbrRouteEntriesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnPbrRouteEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnPbrRouteEntries?: {
    vpnPbrRouteEntry?: [ 
    {
      createTime?: long(name='CreateTime'),
      nextHop?: string(name='NextHop'),
      routeDest?: string(name='RouteDest'),
      routeSource?: string(name='RouteSource'),
      state?: string(name='State'),
      vpnInstanceId?: string(name='VpnInstanceId'),
      weight?: int32(name='Weight'),
    }
  ](name='VpnPbrRouteEntry')
  }(name='VpnPbrRouteEntries'),
}

model DescribeVpnPbrRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpnPbrRouteEntriesResponseBody(name='body'),
}

async function describeVpnPbrRouteEntriesWithOptions(request: DescribeVpnPbrRouteEntriesRequest, runtime: Util.RuntimeOptions): DescribeVpnPbrRouteEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpnPbrRouteEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpnPbrRouteEntries(request: DescribeVpnPbrRouteEntriesRequest): DescribeVpnPbrRouteEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnPbrRouteEntriesWithOptions(request, runtime);
}

model DescribeVpnRouteEntriesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryType?: string(name='RouteEntryType'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DescribeVpnRouteEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnRouteEntries?: {
    vpnRouteEntry?: [ 
    {
      asPath?: string(name='AsPath'),
      community?: string(name='Community'),
      createTime?: long(name='CreateTime'),
      nextHop?: string(name='NextHop'),
      routeDest?: string(name='RouteDest'),
      routeEntryType?: string(name='RouteEntryType'),
      source?: string(name='Source'),
      state?: string(name='State'),
      vpnInstanceId?: string(name='VpnInstanceId'),
      weight?: int32(name='Weight'),
    }
  ](name='VpnRouteEntry')
  }(name='VpnRouteEntries'),
}

model DescribeVpnRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpnRouteEntriesResponseBody(name='body'),
}

async function describeVpnRouteEntriesWithOptions(request: DescribeVpnRouteEntriesRequest, runtime: Util.RuntimeOptions): DescribeVpnRouteEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeEntryType)) {
    query['RouteEntryType'] = request.routeEntryType;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpnRouteEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpnRouteEntries(request: DescribeVpnRouteEntriesRequest): DescribeVpnRouteEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnRouteEntriesWithOptions(request, runtime);
}

model DescribeVpnSslServerLogsRequest {
  from?: int32(name='From'),
  minutePeriod?: int32(name='MinutePeriod'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  to?: int32(name='To'),
  vpnSslServerId?: string(name='VpnSslServerId'),
}

model DescribeVpnSslServerLogsResponseBody = {
  count?: int32(name='Count'),
  data?: {
    logs?: [ string ](name='Logs')
  }(name='Data'),
  isCompleted?: boolean(name='IsCompleted'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
}

model DescribeVpnSslServerLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVpnSslServerLogsResponseBody(name='body'),
}

async function describeVpnSslServerLogsWithOptions(request: DescribeVpnSslServerLogsRequest, runtime: Util.RuntimeOptions): DescribeVpnSslServerLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.minutePeriod)) {
    query['MinutePeriod'] = request.minutePeriod;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslVpnClientCertId)) {
    query['SslVpnClientCertId'] = request.sslVpnClientCertId;
  }
  if (!Util.isUnset(request.to)) {
    query['To'] = request.to;
  }
  if (!Util.isUnset(request.vpnSslServerId)) {
    query['VpnSslServerId'] = request.vpnSslServerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVpnSslServerLogs',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVpnSslServerLogs(request: DescribeVpnSslServerLogsRequest): DescribeVpnSslServerLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnSslServerLogsWithOptions(request, runtime);
}

model DescribeZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneType?: string(name='ZoneType'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
      zoneType?: string(name='ZoneType'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneType)) {
    query['ZoneType'] = request.zoneType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeZones',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model DetachDhcpOptionsSetFromVpcRequest {
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DetachDhcpOptionsSetFromVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachDhcpOptionsSetFromVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachDhcpOptionsSetFromVpcResponseBody(name='body'),
}

async function detachDhcpOptionsSetFromVpcWithOptions(request: DetachDhcpOptionsSetFromVpcRequest, runtime: Util.RuntimeOptions): DetachDhcpOptionsSetFromVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dhcpOptionsSetId)) {
    query['DhcpOptionsSetId'] = request.dhcpOptionsSetId;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachDhcpOptionsSetFromVpc',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachDhcpOptionsSetFromVpc(request: DetachDhcpOptionsSetFromVpcRequest): DetachDhcpOptionsSetFromVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDhcpOptionsSetFromVpcWithOptions(request, runtime);
}

model DisableNatGatewayEcsMetricRequest {
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  regionId?: string(name='RegionId'),
}

model DisableNatGatewayEcsMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableNatGatewayEcsMetricResponseBody(name='body'),
}

async function disableNatGatewayEcsMetricWithOptions(request: DisableNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): DisableNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableNatGatewayEcsMetric',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableNatGatewayEcsMetric(request: DisableNatGatewayEcsMetricRequest): DisableNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableNatGatewayEcsMetricWithOptions(request, runtime);
}

model DisableVpcClassicLinkRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model DisableVpcClassicLinkResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableVpcClassicLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableVpcClassicLinkResponseBody(name='body'),
}

async function disableVpcClassicLinkWithOptions(request: DisableVpcClassicLinkRequest, runtime: Util.RuntimeOptions): DisableVpcClassicLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableVpcClassicLink',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableVpcClassicLink(request: DisableVpcClassicLinkRequest): DisableVpcClassicLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableVpcClassicLinkWithOptions(request, runtime);
}

model DissociateRouteTableFromGatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  gatewayId?: string(name='GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
}

model DissociateRouteTableFromGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateRouteTableFromGatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateRouteTableFromGatewayResponseBody(name='body'),
}

async function dissociateRouteTableFromGatewayWithOptions(request: DissociateRouteTableFromGatewayRequest, runtime: Util.RuntimeOptions): DissociateRouteTableFromGatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.gatewayId)) {
    query['GatewayId'] = request.gatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateRouteTableFromGateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dissociateRouteTableFromGateway(request: DissociateRouteTableFromGatewayRequest): DissociateRouteTableFromGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateRouteTableFromGatewayWithOptions(request, runtime);
}

model DissociateRouteTablesFromVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointId?: string(name='EndpointId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableIds?: [ string ](name='RouteTableIds'),
}

model DissociateRouteTablesFromVpcGatewayEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateRouteTablesFromVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateRouteTablesFromVpcGatewayEndpointResponseBody(name='body'),
}

async function dissociateRouteTablesFromVpcGatewayEndpointWithOptions(request: DissociateRouteTablesFromVpcGatewayEndpointRequest, runtime: Util.RuntimeOptions): DissociateRouteTablesFromVpcGatewayEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endpointId)) {
    query['EndpointId'] = request.endpointId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableIds)) {
    query['RouteTableIds'] = request.routeTableIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateRouteTablesFromVpcGatewayEndpoint',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dissociateRouteTablesFromVpcGatewayEndpoint(request: DissociateRouteTablesFromVpcGatewayEndpointRequest): DissociateRouteTablesFromVpcGatewayEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateRouteTablesFromVpcGatewayEndpointWithOptions(request, runtime);
}

model DissociateVpnGatewayWithCertificateRequest {
  certificateId?: string(name='CertificateId'),
  certificateType?: string(name='CertificateType'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model DissociateVpnGatewayWithCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateVpnGatewayWithCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateVpnGatewayWithCertificateResponseBody(name='body'),
}

async function dissociateVpnGatewayWithCertificateWithOptions(request: DissociateVpnGatewayWithCertificateRequest, runtime: Util.RuntimeOptions): DissociateVpnGatewayWithCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.certificateType)) {
    query['CertificateType'] = request.certificateType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateVpnGatewayWithCertificate',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dissociateVpnGatewayWithCertificate(request: DissociateVpnGatewayWithCertificateRequest): DissociateVpnGatewayWithCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateVpnGatewayWithCertificateWithOptions(request, runtime);
}

model DownloadVpnConnectionConfigRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DownloadVpnConnectionConfigResponseBody = {
  requestId?: string(name='RequestId'),
  vpnConnectionConfig?: {
    ikeConfig?: {
      ikeAuthAlg?: string(name='IkeAuthAlg'),
      ikeEncAlg?: string(name='IkeEncAlg'),
      ikeLifetime?: long(name='IkeLifetime'),
      ikeMode?: string(name='IkeMode'),
      ikePfs?: string(name='IkePfs'),
      ikeVersion?: string(name='IkeVersion'),
      localId?: string(name='LocalId'),
      psk?: string(name='Psk'),
      remoteId?: string(name='RemoteId'),
    }(name='IkeConfig'),
    ipsecConfig?: {
      ipsecAuthAlg?: string(name='IpsecAuthAlg'),
      ipsecEncAlg?: string(name='IpsecEncAlg'),
      ipsecLifetime?: long(name='IpsecLifetime'),
      ipsecPfs?: string(name='IpsecPfs'),
    }(name='IpsecConfig'),
    local?: string(name='Local'),
    localSubnet?: string(name='LocalSubnet'),
    remote?: string(name='Remote'),
    remoteSubnet?: string(name='RemoteSubnet'),
  }(name='VpnConnectionConfig'),
}

model DownloadVpnConnectionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DownloadVpnConnectionConfigResponseBody(name='body'),
}

async function downloadVpnConnectionConfigWithOptions(request: DownloadVpnConnectionConfigRequest, runtime: Util.RuntimeOptions): DownloadVpnConnectionConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DownloadVpnConnectionConfig',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function downloadVpnConnectionConfig(request: DownloadVpnConnectionConfigRequest): DownloadVpnConnectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadVpnConnectionConfigWithOptions(request, runtime);
}

model EnableNatGatewayEcsMetricRequest {
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  regionId?: string(name='RegionId'),
}

model EnableNatGatewayEcsMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableNatGatewayEcsMetricResponseBody(name='body'),
}

async function enableNatGatewayEcsMetricWithOptions(request: EnableNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): EnableNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableNatGatewayEcsMetric',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableNatGatewayEcsMetric(request: EnableNatGatewayEcsMetricRequest): EnableNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableNatGatewayEcsMetricWithOptions(request, runtime);
}

model EnablePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model EnablePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnablePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnablePhysicalConnectionResponseBody(name='body'),
}

async function enablePhysicalConnectionWithOptions(request: EnablePhysicalConnectionRequest, runtime: Util.RuntimeOptions): EnablePhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnablePhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enablePhysicalConnection(request: EnablePhysicalConnectionRequest): EnablePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enablePhysicalConnectionWithOptions(request, runtime);
}

model EnableVpcClassicLinkRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model EnableVpcClassicLinkResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableVpcClassicLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableVpcClassicLinkResponseBody(name='body'),
}

async function enableVpcClassicLinkWithOptions(request: EnableVpcClassicLinkRequest, runtime: Util.RuntimeOptions): EnableVpcClassicLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableVpcClassicLink',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableVpcClassicLink(request: EnableVpcClassicLinkRequest): EnableVpcClassicLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableVpcClassicLinkWithOptions(request, runtime);
}

model EnableVpcIpv4GatewayRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableList?: [ string ](name='RouteTableList'),
}

model EnableVpcIpv4GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableVpcIpv4GatewayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableVpcIpv4GatewayResponseBody(name='body'),
}

async function enableVpcIpv4GatewayWithOptions(request: EnableVpcIpv4GatewayRequest, runtime: Util.RuntimeOptions): EnableVpcIpv4GatewayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ipv4GatewayId)) {
    query['Ipv4GatewayId'] = request.ipv4GatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableList)) {
    query['RouteTableList'] = request.routeTableList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableVpcIpv4Gateway',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableVpcIpv4Gateway(request: EnableVpcIpv4GatewayRequest): EnableVpcIpv4GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableVpcIpv4GatewayWithOptions(request, runtime);
}

model GetDhcpOptionsSetRequest {
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetDhcpOptionsSetResponseBody = {
  associateVpcs?: [ 
    {
      associateStatus?: string(name='AssociateStatus'),
      vpcId?: string(name='VpcId'),
    }
  ](name='AssociateVpcs'),
  dhcpOptions?: {
    bootFileName?: string(name='BootFileName'),
    domainName?: string(name='DomainName'),
    domainNameServers?: string(name='DomainNameServers'),
    ipv6LeaseTime?: string(name='Ipv6LeaseTime'),
    leaseTime?: string(name='LeaseTime'),
    TFTPServerName?: string(name='TFTPServerName'),
  }(name='DhcpOptions'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  ownerId?: long(name='OwnerId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDhcpOptionsSetResponseBody(name='body'),
}

async function getDhcpOptionsSetWithOptions(request: GetDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): GetDhcpOptionsSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dhcpOptionsSetId)) {
    query['DhcpOptionsSetId'] = request.dhcpOptionsSetId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDhcpOptionsSet',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDhcpOptionsSet(request: GetDhcpOptionsSetRequest): GetDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDhcpOptionsSetWithOptions(request, runtime);
}

model GetFlowLogServiceStatusRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetFlowLogServiceStatusResponseBody = {
  enabled?: boolean(name='Enabled'),
  requestId?: string(name='RequestId'),
}

model GetFlowLogServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFlowLogServiceStatusResponseBody(name='body'),
}

async function getFlowLogServiceStatusWithOptions(request: GetFlowLogServiceStatusRequest, runtime: Util.RuntimeOptions): GetFlowLogServiceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFlowLogServiceStatus',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFlowLogServiceStatus(request: GetFlowLogServiceStatusRequest): GetFlowLogServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFlowLogServiceStatusWithOptions(request, runtime);
}

model GetIpv4GatewayAttributeRequest {
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetIpv4GatewayAttributeResponseBody = {
  createTime?: string(name='CreateTime'),
  enabled?: boolean(name='Enabled'),
  ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ipv4GatewayName?: string(name='Ipv4GatewayName'),
  ipv4GatewayRouteTableId?: string(name='Ipv4GatewayRouteTableId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
}

model GetIpv4GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIpv4GatewayAttributeResponseBody(name='body'),
}

async function getIpv4GatewayAttributeWithOptions(request: GetIpv4GatewayAttributeRequest, runtime: Util.RuntimeOptions): GetIpv4GatewayAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipv4GatewayId)) {
    query['Ipv4GatewayId'] = request.ipv4GatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIpv4GatewayAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIpv4GatewayAttribute(request: GetIpv4GatewayAttributeRequest): GetIpv4GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIpv4GatewayAttributeWithOptions(request, runtime);
}

model GetNatGatewayAttributeRequest {
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetNatGatewayAttributeResponseBody = {
  billingConfig?: {
    autoPay?: string(name='AutoPay'),
    instanceChargeType?: string(name='InstanceChargeType'),
    internetChargeType?: string(name='InternetChargeType'),
    spec?: string(name='Spec'),
  }(name='BillingConfig'),
  businessStatus?: string(name='BusinessStatus'),
  creationTime?: string(name='CreationTime'),
  deletionProtectionInfo?: {
    enabled?: boolean(name='Enabled'),
  }(name='DeletionProtectionInfo'),
  description?: string(name='Description'),
  ecsMetricEnabled?: boolean(name='EcsMetricEnabled'),
  expiredTime?: string(name='ExpiredTime'),
  forwardTable?: {
    forwardEntryCount?: int32(name='ForwardEntryCount'),
    forwardTableId?: string(name='ForwardTableId'),
  }(name='ForwardTable'),
  fullNatTable?: {
    fullNatEntryCount?: long(name='FullNatEntryCount'),
    fullNatTableId?: string(name='FullNatTableId'),
  }(name='FullNatTable'),
  ipList?: [ 
    {
      allocationId?: string(name='AllocationId'),
      ipAddress?: string(name='IpAddress'),
      usingStatus?: string(name='UsingStatus'),
    }
  ](name='IpList'),
  name?: string(name='Name'),
  natGatewayId?: string(name='NatGatewayId'),
  natType?: string(name='NatType'),
  networkType?: string(name='NetworkType'),
  privateInfo?: {
    eniInstanceId?: string(name='EniInstanceId'),
    izNo?: string(name='IzNo'),
    maxBandwidth?: int32(name='MaxBandwidth'),
    privateIpAddress?: string(name='PrivateIpAddress'),
    vswitchId?: string(name='VswitchId'),
  }(name='PrivateInfo'),
  privateLinkEnabled?: boolean(name='PrivateLinkEnabled'),
  privateLinkMode?: string(name='PrivateLinkMode'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  snatTable?: {
    snatEntryCount?: int32(name='SnatEntryCount'),
    snatTableId?: string(name='SnatTableId'),
  }(name='SnatTable'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
}

model GetNatGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNatGatewayAttributeResponseBody(name='body'),
}

async function getNatGatewayAttributeWithOptions(request: GetNatGatewayAttributeRequest, runtime: Util.RuntimeOptions): GetNatGatewayAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNatGatewayAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNatGatewayAttribute(request: GetNatGatewayAttributeRequest): GetNatGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNatGatewayAttributeWithOptions(request, runtime);
}

model GetNatGatewayConvertStatusRequest {
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetNatGatewayConvertStatusResponseBody = {
  convertSteps?: [ 
    {
      stepName?: string(name='StepName'),
      stepStartTime?: string(name='StepStartTime'),
      stepStatus?: string(name='StepStatus'),
    }
  ](name='ConvertSteps'),
  dstNatType?: string(name='DstNatType'),
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId'),
}

model GetNatGatewayConvertStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNatGatewayConvertStatusResponseBody(name='body'),
}

async function getNatGatewayConvertStatusWithOptions(request: GetNatGatewayConvertStatusRequest, runtime: Util.RuntimeOptions): GetNatGatewayConvertStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNatGatewayConvertStatus',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNatGatewayConvertStatus(request: GetNatGatewayConvertStatusRequest): GetNatGatewayConvertStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNatGatewayConvertStatusWithOptions(request, runtime);
}

model GetPhysicalConnectionServiceStatusRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetPhysicalConnectionServiceStatusResponseBody = {
  enabled?: boolean(name='Enabled'),
  requestId?: string(name='RequestId'),
}

model GetPhysicalConnectionServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPhysicalConnectionServiceStatusResponseBody(name='body'),
}

async function getPhysicalConnectionServiceStatusWithOptions(request: GetPhysicalConnectionServiceStatusRequest, runtime: Util.RuntimeOptions): GetPhysicalConnectionServiceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPhysicalConnectionServiceStatus',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPhysicalConnectionServiceStatus(request: GetPhysicalConnectionServiceStatusRequest): GetPhysicalConnectionServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPhysicalConnectionServiceStatusWithOptions(request, runtime);
}

model GetTrafficMirrorServiceStatusRequest {
  ownerId?: long(name='OwnerId'),
}

model GetTrafficMirrorServiceStatusResponseBody = {
  enabled?: boolean(name='Enabled'),
  requestId?: string(name='RequestId'),
}

model GetTrafficMirrorServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTrafficMirrorServiceStatusResponseBody(name='body'),
}

async function getTrafficMirrorServiceStatusWithOptions(request: GetTrafficMirrorServiceStatusRequest, runtime: Util.RuntimeOptions): GetTrafficMirrorServiceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTrafficMirrorServiceStatus',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTrafficMirrorServiceStatus(request: GetTrafficMirrorServiceStatusRequest): GetTrafficMirrorServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTrafficMirrorServiceStatusWithOptions(request, runtime);
}

model GetVpcGatewayEndpointAttributeRequest {
  endpointId?: string(name='EndpointId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetVpcGatewayEndpointAttributeResponseBody = {
  creationTime?: string(name='CreationTime'),
  endpointDescription?: string(name='EndpointDescription'),
  endpointId?: string(name='EndpointId'),
  endpointName?: string(name='EndpointName'),
  endpointStatus?: string(name='EndpointStatus'),
  policyDocument?: string(name='PolicyDocument'),
  requestId?: string(name='RequestId'),
  routeTables?: [ string ](name='RouteTables'),
  serviceName?: string(name='ServiceName'),
  vpcId?: string(name='VpcId'),
}

model GetVpcGatewayEndpointAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVpcGatewayEndpointAttributeResponseBody(name='body'),
}

async function getVpcGatewayEndpointAttributeWithOptions(request: GetVpcGatewayEndpointAttributeRequest, runtime: Util.RuntimeOptions): GetVpcGatewayEndpointAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endpointId)) {
    query['EndpointId'] = request.endpointId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVpcGatewayEndpointAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVpcGatewayEndpointAttribute(request: GetVpcGatewayEndpointAttributeRequest): GetVpcGatewayEndpointAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVpcGatewayEndpointAttributeWithOptions(request, runtime);
}

model GetVpcPrefixListAssociationsRequest {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  prefixListId?: string(name='PrefixListId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetVpcPrefixListAssociationsResponseBody = {
  count?: long(name='Count'),
  nextToken?: string(name='NextToken'),
  prefixListAssociation?: [ 
    {
      ownerId?: string(name='OwnerId'),
      prefixListId?: string(name='PrefixListId'),
      reason?: string(name='Reason'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      status?: string(name='Status'),
    }
  ](name='PrefixListAssociation'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model GetVpcPrefixListAssociationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVpcPrefixListAssociationsResponseBody(name='body'),
}

async function getVpcPrefixListAssociationsWithOptions(request: GetVpcPrefixListAssociationsRequest, runtime: Util.RuntimeOptions): GetVpcPrefixListAssociationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.prefixListId)) {
    query['PrefixListId'] = request.prefixListId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVpcPrefixListAssociations',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVpcPrefixListAssociations(request: GetVpcPrefixListAssociationsRequest): GetVpcPrefixListAssociationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVpcPrefixListAssociationsWithOptions(request, runtime);
}

model GetVpcPrefixListEntriesRequest {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  prefixListId?: string(name='PrefixListId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetVpcPrefixListEntriesResponseBody = {
  count?: long(name='Count'),
  nextToken?: string(name='NextToken'),
  prefixListEntry?: [ 
    {
      cidr?: string(name='Cidr'),
      description?: string(name='Description'),
      prefixListId?: string(name='PrefixListId'),
    }
  ](name='PrefixListEntry'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model GetVpcPrefixListEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVpcPrefixListEntriesResponseBody(name='body'),
}

async function getVpcPrefixListEntriesWithOptions(request: GetVpcPrefixListEntriesRequest, runtime: Util.RuntimeOptions): GetVpcPrefixListEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.prefixListId)) {
    query['PrefixListId'] = request.prefixListId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVpcPrefixListEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVpcPrefixListEntries(request: GetVpcPrefixListEntriesRequest): GetVpcPrefixListEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVpcPrefixListEntriesWithOptions(request, runtime);
}

model GrantInstanceToCenRequest {
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GrantInstanceToCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model GrantInstanceToCenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantInstanceToCenResponseBody(name='body'),
}

async function grantInstanceToCenWithOptions(request: GrantInstanceToCenRequest, runtime: Util.RuntimeOptions): GrantInstanceToCenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cenId)) {
    query['CenId'] = request.cenId;
  }
  if (!Util.isUnset(request.cenOwnerId)) {
    query['CenOwnerId'] = request.cenOwnerId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantInstanceToCen',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function grantInstanceToCen(request: GrantInstanceToCenRequest): GrantInstanceToCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantInstanceToCenWithOptions(request, runtime);
}

model ListDhcpOptionsSetsRequest {
  dhcpOptionsSetId?: [ string ](name='DhcpOptionsSetId'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  domainName?: string(name='DomainName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListDhcpOptionsSetsResponseBody = {
  dhcpOptionsSets?: [ 
    {
      associateVpcCount?: int32(name='AssociateVpcCount'),
      dhcpOptions?: {
        domainName?: string(name='DomainName'),
        domainNameServers?: string(name='DomainNameServers'),
        ipv6LeaseTime?: string(name='Ipv6LeaseTime'),
        leaseTime?: string(name='LeaseTime'),
      }(name='DhcpOptions'),
      dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
      dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
      dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
      ownerId?: long(name='OwnerId'),
      status?: string(name='Status'),
    }
  ](name='DhcpOptionsSets'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListDhcpOptionsSetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDhcpOptionsSetsResponseBody(name='body'),
}

async function listDhcpOptionsSetsWithOptions(request: ListDhcpOptionsSetsRequest, runtime: Util.RuntimeOptions): ListDhcpOptionsSetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dhcpOptionsSetId)) {
    query['DhcpOptionsSetId'] = request.dhcpOptionsSetId;
  }
  if (!Util.isUnset(request.dhcpOptionsSetName)) {
    query['DhcpOptionsSetName'] = request.dhcpOptionsSetName;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDhcpOptionsSets',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDhcpOptionsSets(request: ListDhcpOptionsSetsRequest): ListDhcpOptionsSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDhcpOptionsSetsWithOptions(request, runtime);
}

model ListEnhanhcedNatGatewayAvailableZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListEnhanhcedNatGatewayAvailableZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zones'),
}

model ListEnhanhcedNatGatewayAvailableZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEnhanhcedNatGatewayAvailableZonesResponseBody(name='body'),
}

async function listEnhanhcedNatGatewayAvailableZonesWithOptions(request: ListEnhanhcedNatGatewayAvailableZonesRequest, runtime: Util.RuntimeOptions): ListEnhanhcedNatGatewayAvailableZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnhanhcedNatGatewayAvailableZones',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEnhanhcedNatGatewayAvailableZones(request: ListEnhanhcedNatGatewayAvailableZonesRequest): ListEnhanhcedNatGatewayAvailableZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEnhanhcedNatGatewayAvailableZonesWithOptions(request, runtime);
}

model ListFullNatEntriesRequest {
  clientToken?: string(name='ClientToken'),
  fullNatEntryId?: string(name='FullNatEntryId'),
  fullNatEntryNames?: [ string ](name='FullNatEntryNames'),
  fullNatTableId?: string(name='FullNatTableId'),
  ipProtocol?: string(name='IpProtocol'),
  maxResults?: long(name='MaxResults'),
  natGatewayId?: string(name='NatGatewayId'),
  networkInterfaceIds?: [ string ](name='NetworkInterfaceIds'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListFullNatEntriesResponseBody = {
  fullNatEntries?: [ 
    {
      accessIp?: string(name='AccessIp'),
      accessPort?: string(name='AccessPort'),
      creationTime?: string(name='CreationTime'),
      fullNatEntryDescription?: string(name='FullNatEntryDescription'),
      fullNatEntryId?: string(name='FullNatEntryId'),
      fullNatEntryName?: string(name='FullNatEntryName'),
      fullNatEntryStatus?: string(name='FullNatEntryStatus'),
      ipProtocol?: string(name='IpProtocol'),
      natIp?: string(name='NatIp'),
      natIpPort?: string(name='NatIpPort'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      networkInterfaceType?: string(name='NetworkInterfaceType'),
    }
  ](name='FullNatEntries'),
  fullNatTableId?: string(name='FullNatTableId'),
  maxResults?: long(name='MaxResults'),
  natGatewayId?: string(name='NatGatewayId'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListFullNatEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFullNatEntriesResponseBody(name='body'),
}

async function listFullNatEntriesWithOptions(request: ListFullNatEntriesRequest, runtime: Util.RuntimeOptions): ListFullNatEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.fullNatEntryId)) {
    query['FullNatEntryId'] = request.fullNatEntryId;
  }
  if (!Util.isUnset(request.fullNatEntryNames)) {
    query['FullNatEntryNames'] = request.fullNatEntryNames;
  }
  if (!Util.isUnset(request.fullNatTableId)) {
    query['FullNatTableId'] = request.fullNatTableId;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.networkInterfaceIds)) {
    query['NetworkInterfaceIds'] = request.networkInterfaceIds;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFullNatEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFullNatEntries(request: ListFullNatEntriesRequest): ListFullNatEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFullNatEntriesWithOptions(request, runtime);
}

model ListGatewayRouteTableEntriesRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  gatewayRouteTableId?: string(name='GatewayRouteTableId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListGatewayRouteTableEntriesResponseBody = {
  gatewayRouteEntryModels?: [ 
    {
      description?: string(name='Description'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      name?: string(name='Name'),
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
      status?: string(name='Status'),
    }
  ](name='GatewayRouteEntryModels'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListGatewayRouteTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGatewayRouteTableEntriesResponseBody(name='body'),
}

async function listGatewayRouteTableEntriesWithOptions(request: ListGatewayRouteTableEntriesRequest, runtime: Util.RuntimeOptions): ListGatewayRouteTableEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationCidrBlock)) {
    query['DestinationCidrBlock'] = request.destinationCidrBlock;
  }
  if (!Util.isUnset(request.gatewayRouteTableId)) {
    query['GatewayRouteTableId'] = request.gatewayRouteTableId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGatewayRouteTableEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGatewayRouteTableEntries(request: ListGatewayRouteTableEntriesRequest): ListGatewayRouteTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGatewayRouteTableEntriesWithOptions(request, runtime);
}

model ListIpsecServersRequest {
  ipsecServerId?: [ string ](name='IpsecServerId'),
  ipsecServerName?: string(name='IpsecServerName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ListIpsecServersResponseBody = {
  ipsecServers?: [ 
    {
      clientIpPool?: string(name='ClientIpPool'),
      creationTime?: string(name='CreationTime'),
      effectImmediately?: boolean(name='EffectImmediately'),
      IDaaSInstanceId?: string(name='IDaaSInstanceId'),
      ikeConfig?: {
        ikeAuthAlg?: string(name='IkeAuthAlg'),
        ikeEncAlg?: string(name='IkeEncAlg'),
        ikeLifetime?: long(name='IkeLifetime'),
        ikeMode?: string(name='IkeMode'),
        ikePfs?: string(name='IkePfs'),
        ikeVersion?: string(name='IkeVersion'),
        localId?: string(name='LocalId'),
        remoteId?: string(name='RemoteId'),
      }(name='IkeConfig'),
      internetIp?: string(name='InternetIp'),
      ipsecConfig?: {
        ipsecAuthAlg?: string(name='IpsecAuthAlg'),
        ipsecEncAlg?: string(name='IpsecEncAlg'),
        ipsecLifetime?: long(name='IpsecLifetime'),
        ipsecPfs?: string(name='IpsecPfs'),
      }(name='IpsecConfig'),
      ipsecServerId?: string(name='IpsecServerId'),
      ipsecServerName?: string(name='IpsecServerName'),
      localSubnet?: string(name='LocalSubnet'),
      maxConnections?: int32(name='MaxConnections'),
      multiFactorAuthEnabled?: boolean(name='MultiFactorAuthEnabled'),
      onlineClientCount?: int32(name='OnlineClientCount'),
      psk?: string(name='Psk'),
      pskEnabled?: boolean(name='PskEnabled'),
      regionId?: string(name='RegionId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='IpsecServers'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIpsecServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIpsecServersResponseBody(name='body'),
}

async function listIpsecServersWithOptions(request: ListIpsecServersRequest, runtime: Util.RuntimeOptions): ListIpsecServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipsecServerId)) {
    query['IpsecServerId'] = request.ipsecServerId;
  }
  if (!Util.isUnset(request.ipsecServerName)) {
    query['IpsecServerName'] = request.ipsecServerName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIpsecServers',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIpsecServers(request: ListIpsecServersRequest): ListIpsecServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpsecServersWithOptions(request, runtime);
}

model ListIpv4GatewaysRequest {
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ipv4GatewayName?: string(name='Ipv4GatewayName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model ListIpv4GatewaysResponseBody = {
  ipv4GatewayModels?: [ 
    {
      enabled?: boolean(name='Enabled'),
      gmtCreate?: string(name='GmtCreate'),
      ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
      ipv4GatewayId?: string(name='Ipv4GatewayId'),
      ipv4GatewayName?: string(name='Ipv4GatewayName'),
      ipv4GatewayRouteTableId?: string(name='Ipv4GatewayRouteTableId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Ipv4GatewayModels'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListIpv4GatewaysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIpv4GatewaysResponseBody(name='body'),
}

async function listIpv4GatewaysWithOptions(request: ListIpv4GatewaysRequest, runtime: Util.RuntimeOptions): ListIpv4GatewaysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipv4GatewayId)) {
    query['Ipv4GatewayId'] = request.ipv4GatewayId;
  }
  if (!Util.isUnset(request.ipv4GatewayName)) {
    query['Ipv4GatewayName'] = request.ipv4GatewayName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIpv4Gateways',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIpv4Gateways(request: ListIpv4GatewaysRequest): ListIpv4GatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpv4GatewaysWithOptions(request, runtime);
}

model ListNatIpCidrsRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  maxResults?: string(name='MaxResults'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpCidrName?: [ string ](name='NatIpCidrName'),
  natIpCidrStatus?: string(name='NatIpCidrStatus'),
  natIpCidrs?: [ string ](name='NatIpCidrs'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListNatIpCidrsResponseBody = {
  natIpCidrs?: [ 
    {
      creationTime?: string(name='CreationTime'),
      isDefault?: boolean(name='IsDefault'),
      natGatewayId?: string(name='NatGatewayId'),
      natIpCidr?: string(name='NatIpCidr'),
      natIpCidrDescription?: string(name='NatIpCidrDescription'),
      natIpCidrId?: string(name='NatIpCidrId'),
      natIpCidrName?: string(name='NatIpCidrName'),
      natIpCidrStatus?: string(name='NatIpCidrStatus'),
    }
  ](name='NatIpCidrs'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListNatIpCidrsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNatIpCidrsResponseBody(name='body'),
}

async function listNatIpCidrsWithOptions(request: ListNatIpCidrsRequest, runtime: Util.RuntimeOptions): ListNatIpCidrsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.natIpCidr)) {
    query['NatIpCidr'] = request.natIpCidr;
  }
  if (!Util.isUnset(request.natIpCidrName)) {
    query['NatIpCidrName'] = request.natIpCidrName;
  }
  if (!Util.isUnset(request.natIpCidrStatus)) {
    query['NatIpCidrStatus'] = request.natIpCidrStatus;
  }
  if (!Util.isUnset(request.natIpCidrs)) {
    query['NatIpCidrs'] = request.natIpCidrs;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNatIpCidrs',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNatIpCidrs(request: ListNatIpCidrsRequest): ListNatIpCidrsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNatIpCidrsWithOptions(request, runtime);
}

model ListNatIpsRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  maxResults?: string(name='MaxResults'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpIds?: [ string ](name='NatIpIds'),
  natIpName?: [ string ](name='NatIpName'),
  natIpStatus?: string(name='NatIpStatus'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListNatIpsResponseBody = {
  natIps?: [ 
    {
      isDefault?: boolean(name='IsDefault'),
      natGatewayId?: string(name='NatGatewayId'),
      natIp?: string(name='NatIp'),
      natIpCidr?: string(name='NatIpCidr'),
      natIpDescription?: string(name='NatIpDescription'),
      natIpId?: string(name='NatIpId'),
      natIpName?: string(name='NatIpName'),
      natIpStatus?: string(name='NatIpStatus'),
    }
  ](name='NatIps'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListNatIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNatIpsResponseBody(name='body'),
}

async function listNatIpsWithOptions(request: ListNatIpsRequest, runtime: Util.RuntimeOptions): ListNatIpsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.natIpCidr)) {
    query['NatIpCidr'] = request.natIpCidr;
  }
  if (!Util.isUnset(request.natIpIds)) {
    query['NatIpIds'] = request.natIpIds;
  }
  if (!Util.isUnset(request.natIpName)) {
    query['NatIpName'] = request.natIpName;
  }
  if (!Util.isUnset(request.natIpStatus)) {
    query['NatIpStatus'] = request.natIpStatus;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNatIps',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNatIps(request: ListNatIpsRequest): ListNatIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNatIpsWithOptions(request, runtime);
}

model ListPrefixListsRequest {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  prefixListIds?: [ string ](name='PrefixListIds'),
  prefixListName?: string(name='PrefixListName'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListPrefixListsResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  prefixLists?: [ 
    {
      cidrBlocks?: [ string ](name='CidrBlocks'),
      creationTime?: string(name='CreationTime'),
      ipVersion?: string(name='IpVersion'),
      maxEntries?: int32(name='MaxEntries'),
      ownerId?: string(name='OwnerId'),
      prefixListDescription?: string(name='PrefixListDescription'),
      prefixListId?: string(name='PrefixListId'),
      prefixListName?: string(name='PrefixListName'),
      prefixListStatus?: string(name='PrefixListStatus'),
      shareType?: string(name='ShareType'),
      status?: string(name='Status'),
    }
  ](name='PrefixLists'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListPrefixListsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrefixListsResponseBody(name='body'),
}

async function listPrefixListsWithOptions(request: ListPrefixListsRequest, runtime: Util.RuntimeOptions): ListPrefixListsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.prefixListIds)) {
    query['PrefixListIds'] = request.prefixListIds;
  }
  if (!Util.isUnset(request.prefixListName)) {
    query['PrefixListName'] = request.prefixListName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrefixLists',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrefixLists(request: ListPrefixListsRequest): ListPrefixListsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrefixListsWithOptions(request, runtime);
}

model ListPublicIpAddressPoolCidrBlocksRequest {
  cidrBlock?: string(name='CidrBlock'),
  dryRun?: boolean(name='DryRun'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListPublicIpAddressPoolCidrBlocksResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  publicIpPoolCidrBlockList?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
      status?: string(name='Status'),
      totalIpNum?: int32(name='TotalIpNum'),
      usedIpNum?: int32(name='UsedIpNum'),
    }
  ](name='PublicIpPoolCidrBlockList'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListPublicIpAddressPoolCidrBlocksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublicIpAddressPoolCidrBlocksResponseBody(name='body'),
}

async function listPublicIpAddressPoolCidrBlocksWithOptions(request: ListPublicIpAddressPoolCidrBlocksRequest, runtime: Util.RuntimeOptions): ListPublicIpAddressPoolCidrBlocksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publicIpAddressPoolId)) {
    query['PublicIpAddressPoolId'] = request.publicIpAddressPoolId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublicIpAddressPoolCidrBlocks',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublicIpAddressPoolCidrBlocks(request: ListPublicIpAddressPoolCidrBlocksRequest): ListPublicIpAddressPoolCidrBlocksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublicIpAddressPoolCidrBlocksWithOptions(request, runtime);
}

model ListPublicIpAddressPoolsRequest {
  dryRun?: boolean(name='DryRun'),
  isp?: string(name='Isp'),
  maxResults?: int32(name='MaxResults'),
  name?: string(name='Name'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publicIpAddressPoolIds?: [ string ](name='PublicIpAddressPoolIds'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: string(name='Status'),
}

model ListPublicIpAddressPoolsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  publicIpAddressPoolList?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ipAddressRemaining?: boolean(name='IpAddressRemaining'),
      isp?: string(name='Isp'),
      name?: string(name='Name'),
      publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
      publicIpCidrBlockList?: [ 
        {
          cidrBlock?: string(name='CidrBlock'),
          creationTime?: string(name='CreationTime'),
          status?: string(name='Status'),
          totalIpNum?: int32(name='TotalIpNum'),
          usedIpNum?: int32(name='UsedIpNum'),
        }
      ](name='PublicIpCidrBlockList'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      totalIpNum?: int32(name='TotalIpNum'),
      usedIpNum?: int32(name='UsedIpNum'),
      userType?: boolean(name='UserType'),
    }
  ](name='PublicIpAddressPoolList'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListPublicIpAddressPoolsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublicIpAddressPoolsResponseBody(name='body'),
}

async function listPublicIpAddressPoolsWithOptions(request: ListPublicIpAddressPoolsRequest, runtime: Util.RuntimeOptions): ListPublicIpAddressPoolsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publicIpAddressPoolIds)) {
    query['PublicIpAddressPoolIds'] = request.publicIpAddressPoolIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublicIpAddressPools',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublicIpAddressPools(request: ListPublicIpAddressPoolsRequest): ListPublicIpAddressPoolsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublicIpAddressPoolsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagResourcesForExpressConnectRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesForExpressConnectResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesForExpressConnectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesForExpressConnectResponseBody(name='body'),
}

async function listTagResourcesForExpressConnectWithOptions(request: ListTagResourcesForExpressConnectRequest, runtime: Util.RuntimeOptions): ListTagResourcesForExpressConnectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResourcesForExpressConnect',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResourcesForExpressConnect(request: ListTagResourcesForExpressConnectRequest): ListTagResourcesForExpressConnectResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesForExpressConnectWithOptions(request, runtime);
}

model ListTrafficMirrorFiltersRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterIds?: [ string ](name='TrafficMirrorFilterIds'),
  trafficMirrorFilterName?: string(name='TrafficMirrorFilterName'),
}

model ListTrafficMirrorFiltersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
  trafficMirrorFilters?: [ 
    {
      egressRules?: [ 
        {
          action?: string(name='Action'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          destinationPortRange?: string(name='DestinationPortRange'),
          priority?: int32(name='Priority'),
          protocol?: string(name='Protocol'),
          sourceCidrBlock?: string(name='SourceCidrBlock'),
          sourcePortRange?: string(name='SourcePortRange'),
          trafficDirection?: string(name='TrafficDirection'),
          trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
          trafficMirrorFilterRuleId?: string(name='TrafficMirrorFilterRuleId'),
          trafficMirrorFilterRuleStatus?: string(name='TrafficMirrorFilterRuleStatus'),
        }
      ](name='EgressRules'),
      ingressRules?: [ 
        {
          action?: string(name='Action'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          destinationPortRange?: string(name='DestinationPortRange'),
          priority?: int32(name='Priority'),
          protocol?: string(name='Protocol'),
          sourceCidrBlock?: string(name='SourceCidrBlock'),
          sourcePortRange?: string(name='SourcePortRange'),
          trafficDirection?: string(name='TrafficDirection'),
          trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
          trafficMirrorFilterRuleId?: string(name='TrafficMirrorFilterRuleId'),
          trafficMirrorFilterRuleStatus?: string(name='TrafficMirrorFilterRuleStatus'),
        }
      ](name='IngressRules'),
      trafficMirrorFilterDescription?: string(name='TrafficMirrorFilterDescription'),
      trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
      trafficMirrorFilterName?: string(name='TrafficMirrorFilterName'),
      trafficMirrorFilterStatus?: string(name='TrafficMirrorFilterStatus'),
    }
  ](name='TrafficMirrorFilters'),
}

model ListTrafficMirrorFiltersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrafficMirrorFiltersResponseBody(name='body'),
}

async function listTrafficMirrorFiltersWithOptions(request: ListTrafficMirrorFiltersRequest, runtime: Util.RuntimeOptions): ListTrafficMirrorFiltersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterIds)) {
    query['TrafficMirrorFilterIds'] = request.trafficMirrorFilterIds;
  }
  if (!Util.isUnset(request.trafficMirrorFilterName)) {
    query['TrafficMirrorFilterName'] = request.trafficMirrorFilterName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTrafficMirrorFilters',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTrafficMirrorFilters(request: ListTrafficMirrorFiltersRequest): ListTrafficMirrorFiltersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTrafficMirrorFiltersWithOptions(request, runtime);
}

model ListTrafficMirrorSessionsRequest {
  enabled?: boolean(name='Enabled'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorSessionIds?: [ string ](name='TrafficMirrorSessionIds'),
  trafficMirrorSessionName?: string(name='TrafficMirrorSessionName'),
  trafficMirrorSourceId?: string(name='TrafficMirrorSourceId'),
  trafficMirrorTargetId?: string(name='TrafficMirrorTargetId'),
  virtualNetworkId?: int32(name='VirtualNetworkId'),
}

model ListTrafficMirrorSessionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
  trafficMirrorSessions?: [ 
    {
      enabled?: boolean(name='Enabled'),
      packetLength?: int32(name='PacketLength'),
      priority?: int32(name='Priority'),
      trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
      trafficMirrorSessionBusinessStatus?: string(name='TrafficMirrorSessionBusinessStatus'),
      trafficMirrorSessionDescription?: string(name='TrafficMirrorSessionDescription'),
      trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
      trafficMirrorSessionName?: string(name='TrafficMirrorSessionName'),
      trafficMirrorSessionStatus?: string(name='TrafficMirrorSessionStatus'),
      trafficMirrorSourceIds?: [ string ](name='TrafficMirrorSourceIds'),
      trafficMirrorTargetId?: string(name='TrafficMirrorTargetId'),
      trafficMirrorTargetType?: string(name='TrafficMirrorTargetType'),
      virtualNetworkId?: int32(name='VirtualNetworkId'),
    }
  ](name='TrafficMirrorSessions'),
}

model ListTrafficMirrorSessionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrafficMirrorSessionsResponseBody(name='body'),
}

async function listTrafficMirrorSessionsWithOptions(request: ListTrafficMirrorSessionsRequest, runtime: Util.RuntimeOptions): ListTrafficMirrorSessionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterId)) {
    query['TrafficMirrorFilterId'] = request.trafficMirrorFilterId;
  }
  if (!Util.isUnset(request.trafficMirrorSessionIds)) {
    query['TrafficMirrorSessionIds'] = request.trafficMirrorSessionIds;
  }
  if (!Util.isUnset(request.trafficMirrorSessionName)) {
    query['TrafficMirrorSessionName'] = request.trafficMirrorSessionName;
  }
  if (!Util.isUnset(request.trafficMirrorSourceId)) {
    query['TrafficMirrorSourceId'] = request.trafficMirrorSourceId;
  }
  if (!Util.isUnset(request.trafficMirrorTargetId)) {
    query['TrafficMirrorTargetId'] = request.trafficMirrorTargetId;
  }
  if (!Util.isUnset(request.virtualNetworkId)) {
    query['VirtualNetworkId'] = request.virtualNetworkId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTrafficMirrorSessions',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTrafficMirrorSessions(request: ListTrafficMirrorSessionsRequest): ListTrafficMirrorSessionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTrafficMirrorSessionsWithOptions(request, runtime);
}

model ListVirtualPhysicalConnectionsRequest {
  isConfirmed?: boolean(name='IsConfirmed'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  virtualPhysicalConnectionAliUids?: [ string ](name='VirtualPhysicalConnectionAliUids'),
  virtualPhysicalConnectionBusinessStatus?: string(name='VirtualPhysicalConnectionBusinessStatus'),
  virtualPhysicalConnectionIds?: [ string ](name='VirtualPhysicalConnectionIds'),
  virtualPhysicalConnectionStatuses?: [ string ](name='VirtualPhysicalConnectionStatuses'),
  vlanIds?: [ string ](name='VlanIds'),
}

model ListVirtualPhysicalConnectionsResponseBody = {
  count?: int32(name='Count'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualPhysicalConnections?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      adLocation?: string(name='AdLocation'),
      aliUid?: string(name='AliUid'),
      bandwidth?: long(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      enabledTime?: string(name='EnabledTime'),
      endTime?: string(name='EndTime'),
      expectSpec?: string(name='ExpectSpec'),
      lineOperator?: string(name='LineOperator'),
      loaStatus?: string(name='LoaStatus'),
      name?: string(name='Name'),
      orderMode?: string(name='OrderMode'),
      parentPhysicalConnectionAliUid?: string(name='ParentPhysicalConnectionAliUid'),
      parentPhysicalConnectionId?: string(name='ParentPhysicalConnectionId'),
      peerLocation?: string(name='PeerLocation'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      portNumber?: string(name='PortNumber'),
      portType?: string(name='PortType'),
      productType?: string(name='ProductType'),
      redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      virtualPhysicalConnectionStatus?: string(name='VirtualPhysicalConnectionStatus'),
      vlanId?: string(name='VlanId'),
    }
  ](name='VirtualPhysicalConnections'),
}

model ListVirtualPhysicalConnectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVirtualPhysicalConnectionsResponseBody(name='body'),
}

async function listVirtualPhysicalConnectionsWithOptions(request: ListVirtualPhysicalConnectionsRequest, runtime: Util.RuntimeOptions): ListVirtualPhysicalConnectionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isConfirmed)) {
    query['IsConfirmed'] = request.isConfirmed;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.virtualPhysicalConnectionAliUids)) {
    query['VirtualPhysicalConnectionAliUids'] = request.virtualPhysicalConnectionAliUids;
  }
  if (!Util.isUnset(request.virtualPhysicalConnectionBusinessStatus)) {
    query['VirtualPhysicalConnectionBusinessStatus'] = request.virtualPhysicalConnectionBusinessStatus;
  }
  if (!Util.isUnset(request.virtualPhysicalConnectionIds)) {
    query['VirtualPhysicalConnectionIds'] = request.virtualPhysicalConnectionIds;
  }
  if (!Util.isUnset(request.virtualPhysicalConnectionStatuses)) {
    query['VirtualPhysicalConnectionStatuses'] = request.virtualPhysicalConnectionStatuses;
  }
  if (!Util.isUnset(request.vlanIds)) {
    query['VlanIds'] = request.vlanIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVirtualPhysicalConnections',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVirtualPhysicalConnections(request: ListVirtualPhysicalConnectionsRequest): ListVirtualPhysicalConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirtualPhysicalConnectionsWithOptions(request, runtime);
}

model ListVpcEndpointServicesByEndUserRequest {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceName?: string(name='ServiceName'),
}

model ListVpcEndpointServicesByEndUserResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  services?: [ 
    {
      defaultPolicyDocument?: string(name='DefaultPolicyDocument'),
      serviceDomain?: string(name='ServiceDomain'),
      serviceId?: string(name='ServiceId'),
      serviceName?: string(name='ServiceName'),
      supportPolicy?: boolean(name='SupportPolicy'),
    }
  ](name='Services'),
}

model ListVpcEndpointServicesByEndUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcEndpointServicesByEndUserResponseBody(name='body'),
}

async function listVpcEndpointServicesByEndUserWithOptions(request: ListVpcEndpointServicesByEndUserRequest, runtime: Util.RuntimeOptions): ListVpcEndpointServicesByEndUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVpcEndpointServicesByEndUser',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVpcEndpointServicesByEndUser(request: ListVpcEndpointServicesByEndUserRequest): ListVpcEndpointServicesByEndUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcEndpointServicesByEndUserWithOptions(request, runtime);
}

model ListVpcGatewayEndpointsRequest {
  endpointId?: string(name='EndpointId'),
  endpointName?: string(name='EndpointName'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceName?: string(name='ServiceName'),
}

model ListVpcGatewayEndpointsResponseBody = {
  endpoints?: [ 
    {
      associatedRouteTables?: [ string ](name='AssociatedRouteTables'),
      creationTime?: string(name='CreationTime'),
      endpointDescription?: string(name='EndpointDescription'),
      endpointId?: string(name='EndpointId'),
      endpointName?: string(name='EndpointName'),
      endpointStatus?: string(name='EndpointStatus'),
      policyDocument?: string(name='PolicyDocument'),
      serviceName?: string(name='ServiceName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Endpoints'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListVpcGatewayEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcGatewayEndpointsResponseBody(name='body'),
}

async function listVpcGatewayEndpointsWithOptions(request: ListVpcGatewayEndpointsRequest, runtime: Util.RuntimeOptions): ListVpcGatewayEndpointsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endpointId)) {
    query['EndpointId'] = request.endpointId;
  }
  if (!Util.isUnset(request.endpointName)) {
    query['EndpointName'] = request.endpointName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVpcGatewayEndpoints',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVpcGatewayEndpoints(request: ListVpcGatewayEndpointsRequest): ListVpcGatewayEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpcGatewayEndpointsWithOptions(request, runtime);
}

model ListVpnCertificateAssociationsRequest {
  certificateId?: [ string ](name='CertificateId'),
  certificateType?: string(name='CertificateType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  vpnGatewayId?: [ string ](name='VpnGatewayId'),
}

model ListVpnCertificateAssociationsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnCertificateRelations?: [ 
    {
      associationTime?: string(name='AssociationTime'),
      certificateId?: string(name='CertificateId'),
      certificateType?: string(name='CertificateType'),
      regionId?: string(name='RegionId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='VpnCertificateRelations'),
}

model ListVpnCertificateAssociationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpnCertificateAssociationsResponseBody(name='body'),
}

async function listVpnCertificateAssociationsWithOptions(request: ListVpnCertificateAssociationsRequest, runtime: Util.RuntimeOptions): ListVpnCertificateAssociationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateId)) {
    query['CertificateId'] = request.certificateId;
  }
  if (!Util.isUnset(request.certificateType)) {
    query['CertificateType'] = request.certificateType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVpnCertificateAssociations',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVpnCertificateAssociations(request: ListVpnCertificateAssociationsRequest): ListVpnCertificateAssociationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVpnCertificateAssociationsWithOptions(request, runtime);
}

model ModifyBgpGroupAttributeRequest {
  authKey?: string(name='AuthKey'),
  bgpGroupId?: string(name='BgpGroupId'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  isFakeAsn?: boolean(name='IsFakeAsn'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerAsn?: long(name='PeerAsn'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyBgpGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBgpGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBgpGroupAttributeResponseBody(name='body'),
}

async function modifyBgpGroupAttributeWithOptions(request: ModifyBgpGroupAttributeRequest, runtime: Util.RuntimeOptions): ModifyBgpGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authKey)) {
    query['AuthKey'] = request.authKey;
  }
  if (!Util.isUnset(request.bgpGroupId)) {
    query['BgpGroupId'] = request.bgpGroupId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.isFakeAsn)) {
    query['IsFakeAsn'] = request.isFakeAsn;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerAsn)) {
    query['PeerAsn'] = request.peerAsn;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBgpGroupAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBgpGroupAttribute(request: ModifyBgpGroupAttributeRequest): ModifyBgpGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBgpGroupAttributeWithOptions(request, runtime);
}

model ModifyBgpPeerAttributeRequest {
  bfdMultiHop?: int32(name='BfdMultiHop'),
  bgpGroupId?: string(name='BgpGroupId'),
  bgpPeerId?: string(name='BgpPeerId'),
  clientToken?: string(name='ClientToken'),
  enableBfd?: boolean(name='EnableBfd'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerIpAddress?: string(name='PeerIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyBgpPeerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBgpPeerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBgpPeerAttributeResponseBody(name='body'),
}

async function modifyBgpPeerAttributeWithOptions(request: ModifyBgpPeerAttributeRequest, runtime: Util.RuntimeOptions): ModifyBgpPeerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bfdMultiHop)) {
    query['BfdMultiHop'] = request.bfdMultiHop;
  }
  if (!Util.isUnset(request.bgpGroupId)) {
    query['BgpGroupId'] = request.bgpGroupId;
  }
  if (!Util.isUnset(request.bgpPeerId)) {
    query['BgpPeerId'] = request.bgpPeerId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enableBfd)) {
    query['EnableBfd'] = request.enableBfd;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerIpAddress)) {
    query['PeerIpAddress'] = request.peerIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBgpPeerAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBgpPeerAttribute(request: ModifyBgpPeerAttributeRequest): ModifyBgpPeerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBgpPeerAttributeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageAttributeRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyCommonBandwidthPackageAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCommonBandwidthPackageAttributeResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageAttributeWithOptions(request: ModifyCommonBandwidthPackageAttributeRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCommonBandwidthPackageAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCommonBandwidthPackageAttribute(request: ModifyCommonBandwidthPackageAttributeRequest): ModifyCommonBandwidthPackageAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageAttributeWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageIpBandwidthRequest {
  bandwidth?: string(name='Bandwidth'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  eipId?: string(name='EipId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyCommonBandwidthPackageIpBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageIpBandwidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCommonBandwidthPackageIpBandwidthResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageIpBandwidthWithOptions(request: ModifyCommonBandwidthPackageIpBandwidthRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageIpBandwidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.eipId)) {
    query['EipId'] = request.eipId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCommonBandwidthPackageIpBandwidth',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCommonBandwidthPackageIpBandwidth(request: ModifyCommonBandwidthPackageIpBandwidthRequest): ModifyCommonBandwidthPackageIpBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageSpecRequest {
  bandwidth?: string(name='Bandwidth'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyCommonBandwidthPackageSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCommonBandwidthPackageSpecResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageSpecWithOptions(request: ModifyCommonBandwidthPackageSpecRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCommonBandwidthPackageSpec',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCommonBandwidthPackageSpec(request: ModifyCommonBandwidthPackageSpecRequest): ModifyCommonBandwidthPackageSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageSpecWithOptions(request, runtime);
}

model ModifyCustomerGatewayAttributeRequest {
  authKey?: string(name='AuthKey'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyCustomerGatewayAttributeResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model ModifyCustomerGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCustomerGatewayAttributeResponseBody(name='body'),
}

async function modifyCustomerGatewayAttributeWithOptions(request: ModifyCustomerGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyCustomerGatewayAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authKey)) {
    query['AuthKey'] = request.authKey;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.customerGatewayId)) {
    query['CustomerGatewayId'] = request.customerGatewayId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCustomerGatewayAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCustomerGatewayAttribute(request: ModifyCustomerGatewayAttributeRequest): ModifyCustomerGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCustomerGatewayAttributeWithOptions(request, runtime);
}

model ModifyEipAddressAttributeRequest {
  allocationId?: string(name='AllocationId'),
  bandwidth?: string(name='Bandwidth'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyEipAddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEipAddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyEipAddressAttributeResponseBody(name='body'),
}

async function modifyEipAddressAttributeWithOptions(request: ModifyEipAddressAttributeRequest, runtime: Util.RuntimeOptions): ModifyEipAddressAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyEipAddressAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyEipAddressAttribute(request: ModifyEipAddressAttributeRequest): ModifyEipAddressAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEipAddressAttributeWithOptions(request, runtime);
}

model ModifyExpressCloudConnectionAttributeRequest {
  bgpAs?: string(name='BgpAs'),
  ceIp?: string(name='CeIp'),
  description?: string(name='Description'),
  eccId?: string(name='EccId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peIp?: string(name='PeIp'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyExpressCloudConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExpressCloudConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyExpressCloudConnectionAttributeResponseBody(name='body'),
}

async function modifyExpressCloudConnectionAttributeWithOptions(request: ModifyExpressCloudConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyExpressCloudConnectionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bgpAs)) {
    query['BgpAs'] = request.bgpAs;
  }
  if (!Util.isUnset(request.ceIp)) {
    query['CeIp'] = request.ceIp;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eccId)) {
    query['EccId'] = request.eccId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peIp)) {
    query['PeIp'] = request.peIp;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyExpressCloudConnectionAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyExpressCloudConnectionAttribute(request: ModifyExpressCloudConnectionAttributeRequest): ModifyExpressCloudConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyExpressCloudConnectionAttributeWithOptions(request, runtime);
}

model ModifyExpressCloudConnectionBandwidthRequest {
  bandwidth?: string(name='Bandwidth'),
  eccId?: string(name='EccId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyExpressCloudConnectionBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExpressCloudConnectionBandwidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyExpressCloudConnectionBandwidthResponseBody(name='body'),
}

async function modifyExpressCloudConnectionBandwidthWithOptions(request: ModifyExpressCloudConnectionBandwidthRequest, runtime: Util.RuntimeOptions): ModifyExpressCloudConnectionBandwidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.eccId)) {
    query['EccId'] = request.eccId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyExpressCloudConnectionBandwidth',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyExpressCloudConnectionBandwidth(request: ModifyExpressCloudConnectionBandwidthRequest): ModifyExpressCloudConnectionBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyExpressCloudConnectionBandwidthWithOptions(request, runtime);
}

model ModifyFlowLogAttributeRequest {
  aggregationInterval?: int32(name='AggregationInterval'),
  description?: string(name='Description'),
  flowLogId?: string(name='FlowLogId'),
  flowLogName?: string(name='FlowLogName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyFlowLogAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ModifyFlowLogAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyFlowLogAttributeResponseBody(name='body'),
}

async function modifyFlowLogAttributeWithOptions(request: ModifyFlowLogAttributeRequest, runtime: Util.RuntimeOptions): ModifyFlowLogAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregationInterval)) {
    query['AggregationInterval'] = request.aggregationInterval;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.flowLogId)) {
    query['FlowLogId'] = request.flowLogId;
  }
  if (!Util.isUnset(request.flowLogName)) {
    query['FlowLogName'] = request.flowLogName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlowLogAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlowLogAttribute(request: ModifyFlowLogAttributeRequest): ModifyFlowLogAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowLogAttributeWithOptions(request, runtime);
}

model ModifyForwardEntryRequest {
  clientToken?: string(name='ClientToken'),
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  forwardEntryId?: string(name='ForwardEntryId'),
  forwardEntryName?: string(name='ForwardEntryName'),
  forwardTableId?: string(name='ForwardTableId'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  portBreak?: boolean(name='PortBreak'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyForwardEntryResponseBody(name='body'),
}

async function modifyForwardEntryWithOptions(request: ModifyForwardEntryRequest, runtime: Util.RuntimeOptions): ModifyForwardEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.externalIp)) {
    query['ExternalIp'] = request.externalIp;
  }
  if (!Util.isUnset(request.externalPort)) {
    query['ExternalPort'] = request.externalPort;
  }
  if (!Util.isUnset(request.forwardEntryId)) {
    query['ForwardEntryId'] = request.forwardEntryId;
  }
  if (!Util.isUnset(request.forwardEntryName)) {
    query['ForwardEntryName'] = request.forwardEntryName;
  }
  if (!Util.isUnset(request.forwardTableId)) {
    query['ForwardTableId'] = request.forwardTableId;
  }
  if (!Util.isUnset(request.internalIp)) {
    query['InternalIp'] = request.internalIp;
  }
  if (!Util.isUnset(request.internalPort)) {
    query['InternalPort'] = request.internalPort;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.portBreak)) {
    query['PortBreak'] = request.portBreak;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyForwardEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyForwardEntry(request: ModifyForwardEntryRequest): ModifyForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyForwardEntryWithOptions(request, runtime);
}

model ModifyFullNatEntryAttributeRequest {
  accessIp?: string(name='AccessIp'),
  accessPort?: string(name='AccessPort'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  fullNatEntryDescription?: string(name='FullNatEntryDescription'),
  fullNatEntryId?: string(name='FullNatEntryId'),
  fullNatEntryName?: string(name='FullNatEntryName'),
  fullNatTableId?: string(name='FullNatTableId'),
  ipProtocol?: string(name='IpProtocol'),
  natIp?: string(name='NatIp'),
  natIpPort?: string(name='NatIpPort'),
  networkInterfaceId?: string(name='NetworkInterfaceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyFullNatEntryAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyFullNatEntryAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyFullNatEntryAttributeResponseBody(name='body'),
}

async function modifyFullNatEntryAttributeWithOptions(request: ModifyFullNatEntryAttributeRequest, runtime: Util.RuntimeOptions): ModifyFullNatEntryAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessIp)) {
    query['AccessIp'] = request.accessIp;
  }
  if (!Util.isUnset(request.accessPort)) {
    query['AccessPort'] = request.accessPort;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.fullNatEntryDescription)) {
    query['FullNatEntryDescription'] = request.fullNatEntryDescription;
  }
  if (!Util.isUnset(request.fullNatEntryId)) {
    query['FullNatEntryId'] = request.fullNatEntryId;
  }
  if (!Util.isUnset(request.fullNatEntryName)) {
    query['FullNatEntryName'] = request.fullNatEntryName;
  }
  if (!Util.isUnset(request.fullNatTableId)) {
    query['FullNatTableId'] = request.fullNatTableId;
  }
  if (!Util.isUnset(request.ipProtocol)) {
    query['IpProtocol'] = request.ipProtocol;
  }
  if (!Util.isUnset(request.natIp)) {
    query['NatIp'] = request.natIp;
  }
  if (!Util.isUnset(request.natIpPort)) {
    query['NatIpPort'] = request.natIpPort;
  }
  if (!Util.isUnset(request.networkInterfaceId)) {
    query['NetworkInterfaceId'] = request.networkInterfaceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFullNatEntryAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFullNatEntryAttribute(request: ModifyFullNatEntryAttributeRequest): ModifyFullNatEntryAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFullNatEntryAttributeWithOptions(request, runtime);
}

model ModifyGlobalAccelerationInstanceAttributesRequest {
  description?: string(name='Description'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyGlobalAccelerationInstanceAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyGlobalAccelerationInstanceAttributesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalAccelerationInstanceAttributesResponseBody(name='body'),
}

async function modifyGlobalAccelerationInstanceAttributesWithOptions(request: ModifyGlobalAccelerationInstanceAttributesRequest, runtime: Util.RuntimeOptions): ModifyGlobalAccelerationInstanceAttributesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.globalAccelerationInstanceId)) {
    query['GlobalAccelerationInstanceId'] = request.globalAccelerationInstanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalAccelerationInstanceAttributes',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalAccelerationInstanceAttributes(request: ModifyGlobalAccelerationInstanceAttributesRequest): ModifyGlobalAccelerationInstanceAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalAccelerationInstanceAttributesWithOptions(request, runtime);
}

model ModifyGlobalAccelerationInstanceSpecRequest {
  bandwidth?: string(name='Bandwidth'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyGlobalAccelerationInstanceSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyGlobalAccelerationInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGlobalAccelerationInstanceSpecResponseBody(name='body'),
}

async function modifyGlobalAccelerationInstanceSpecWithOptions(request: ModifyGlobalAccelerationInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyGlobalAccelerationInstanceSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.globalAccelerationInstanceId)) {
    query['GlobalAccelerationInstanceId'] = request.globalAccelerationInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGlobalAccelerationInstanceSpec',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGlobalAccelerationInstanceSpec(request: ModifyGlobalAccelerationInstanceSpecRequest): ModifyGlobalAccelerationInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalAccelerationInstanceSpecWithOptions(request, runtime);
}

model ModifyHaVipAttributeRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  haVipId?: string(name='HaVipId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyHaVipAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHaVipAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHaVipAttributeResponseBody(name='body'),
}

async function modifyHaVipAttributeWithOptions(request: ModifyHaVipAttributeRequest, runtime: Util.RuntimeOptions): ModifyHaVipAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.haVipId)) {
    query['HaVipId'] = request.haVipId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHaVipAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHaVipAttribute(request: ModifyHaVipAttributeRequest): ModifyHaVipAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHaVipAttributeWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAclAttributeRequest {
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIPv6TranslatorAclAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAclAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIPv6TranslatorAclAttributeResponseBody(name='body'),
}

async function modifyIPv6TranslatorAclAttributeWithOptions(request: ModifyIPv6TranslatorAclAttributeRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAclAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIPv6TranslatorAclAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIPv6TranslatorAclAttribute(request: ModifyIPv6TranslatorAclAttributeRequest): ModifyIPv6TranslatorAclAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAclAttributeWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAclListEntryRequest {
  aclEntryComment?: string(name='AclEntryComment'),
  aclEntryId?: string(name='AclEntryId'),
  aclId?: string(name='AclId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIPv6TranslatorAclListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function modifyIPv6TranslatorAclListEntryWithOptions(request: ModifyIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntryComment)) {
    query['AclEntryComment'] = request.aclEntryComment;
  }
  if (!Util.isUnset(request.aclEntryId)) {
    query['AclEntryId'] = request.aclEntryId;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIPv6TranslatorAclListEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIPv6TranslatorAclListEntry(request: ModifyIPv6TranslatorAclListEntryRequest): ModifyIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAttributeRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIPv6TranslatorAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIPv6TranslatorAttributeResponseBody(name='body'),
}

async function modifyIPv6TranslatorAttributeWithOptions(request: ModifyIPv6TranslatorAttributeRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ipv6TranslatorId)) {
    query['Ipv6TranslatorId'] = request.ipv6TranslatorId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIPv6TranslatorAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIPv6TranslatorAttribute(request: ModifyIPv6TranslatorAttributeRequest): ModifyIPv6TranslatorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAttributeWithOptions(request, runtime);
}

model ModifyIPv6TranslatorBandwidthRequest {
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIPv6TranslatorBandwidthResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorBandwidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIPv6TranslatorBandwidthResponseBody(name='body'),
}

async function modifyIPv6TranslatorBandwidthWithOptions(request: ModifyIPv6TranslatorBandwidthRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorBandwidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipv6TranslatorId)) {
    query['Ipv6TranslatorId'] = request.ipv6TranslatorId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIPv6TranslatorBandwidth',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIPv6TranslatorBandwidth(request: ModifyIPv6TranslatorBandwidthRequest): ModifyIPv6TranslatorBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorBandwidthWithOptions(request, runtime);
}

model ModifyIPv6TranslatorEntryRequest {
  aclId?: string(name='AclId'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: int32(name='BackendIpv4Port'),
  entryBandwidth?: int32(name='EntryBandwidth'),
  entryDescription?: string(name='EntryDescription'),
  entryName?: string(name='EntryName'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  transProtocol?: string(name='TransProtocol'),
}

model ModifyIPv6TranslatorEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIPv6TranslatorEntryResponseBody(name='body'),
}

async function modifyIPv6TranslatorEntryWithOptions(request: ModifyIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclStatus)) {
    query['AclStatus'] = request.aclStatus;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.allocateIpv6Port)) {
    query['AllocateIpv6Port'] = request.allocateIpv6Port;
  }
  if (!Util.isUnset(request.backendIpv4Addr)) {
    query['BackendIpv4Addr'] = request.backendIpv4Addr;
  }
  if (!Util.isUnset(request.backendIpv4Port)) {
    query['BackendIpv4Port'] = request.backendIpv4Port;
  }
  if (!Util.isUnset(request.entryBandwidth)) {
    query['EntryBandwidth'] = request.entryBandwidth;
  }
  if (!Util.isUnset(request.entryDescription)) {
    query['EntryDescription'] = request.entryDescription;
  }
  if (!Util.isUnset(request.entryName)) {
    query['EntryName'] = request.entryName;
  }
  if (!Util.isUnset(request.ipv6TranslatorEntryId)) {
    query['Ipv6TranslatorEntryId'] = request.ipv6TranslatorEntryId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.transProtocol)) {
    query['TransProtocol'] = request.transProtocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIPv6TranslatorEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIPv6TranslatorEntry(request: ModifyIPv6TranslatorEntryRequest): ModifyIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorEntryWithOptions(request, runtime);
}

model ModifyIpv6AddressAttributeRequest {
  description?: string(name='Description'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIpv6AddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6AddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIpv6AddressAttributeResponseBody(name='body'),
}

async function modifyIpv6AddressAttributeWithOptions(request: ModifyIpv6AddressAttributeRequest, runtime: Util.RuntimeOptions): ModifyIpv6AddressAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ipv6AddressId)) {
    query['Ipv6AddressId'] = request.ipv6AddressId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIpv6AddressAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIpv6AddressAttribute(request: ModifyIpv6AddressAttributeRequest): ModifyIpv6AddressAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6AddressAttributeWithOptions(request, runtime);
}

model ModifyIpv6GatewayAttributeRequest {
  description?: string(name='Description'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIpv6GatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIpv6GatewayAttributeResponseBody(name='body'),
}

async function modifyIpv6GatewayAttributeWithOptions(request: ModifyIpv6GatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyIpv6GatewayAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ipv6GatewayId)) {
    query['Ipv6GatewayId'] = request.ipv6GatewayId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIpv6GatewayAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIpv6GatewayAttribute(request: ModifyIpv6GatewayAttributeRequest): ModifyIpv6GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6GatewayAttributeWithOptions(request, runtime);
}

model ModifyIpv6GatewaySpecRequest {
  clientToken?: string(name='ClientToken'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
}

model ModifyIpv6GatewaySpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6GatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIpv6GatewaySpecResponseBody(name='body'),
}

async function modifyIpv6GatewaySpecWithOptions(request: ModifyIpv6GatewaySpecRequest, runtime: Util.RuntimeOptions): ModifyIpv6GatewaySpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipv6GatewayId)) {
    query['Ipv6GatewayId'] = request.ipv6GatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIpv6GatewaySpec',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIpv6GatewaySpec(request: ModifyIpv6GatewaySpecRequest): ModifyIpv6GatewaySpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6GatewaySpecWithOptions(request, runtime);
}

model ModifyIpv6InternetBandwidthRequest {
  bandwidth?: long(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyIpv6InternetBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyIpv6InternetBandwidthResponseBody(name='body'),
}

async function modifyIpv6InternetBandwidthWithOptions(request: ModifyIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): ModifyIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipv6AddressId)) {
    query['Ipv6AddressId'] = request.ipv6AddressId;
  }
  if (!Util.isUnset(request.ipv6InternetBandwidthId)) {
    query['Ipv6InternetBandwidthId'] = request.ipv6InternetBandwidthId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyIpv6InternetBandwidth',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyIpv6InternetBandwidth(request: ModifyIpv6InternetBandwidthRequest): ModifyIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6InternetBandwidthWithOptions(request, runtime);
}

model ModifyNatGatewayAttributeRequest {
  description?: string(name='Description'),
  icmpReplyEnabled?: boolean(name='IcmpReplyEnabled'),
  name?: string(name='Name'),
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyNatGatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNatGatewayAttributeResponseBody(name='body'),
}

async function modifyNatGatewayAttributeWithOptions(request: ModifyNatGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyNatGatewayAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.icmpReplyEnabled)) {
    query['IcmpReplyEnabled'] = request.icmpReplyEnabled;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNatGatewayAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNatGatewayAttribute(request: ModifyNatGatewayAttributeRequest): ModifyNatGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatGatewayAttributeWithOptions(request, runtime);
}

model ModifyNatGatewaySpecRequest {
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  natGatewayId?: string(name='NatGatewayId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spec?: string(name='Spec'),
}

model ModifyNatGatewaySpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatGatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNatGatewaySpecResponseBody(name='body'),
}

async function modifyNatGatewaySpecWithOptions(request: ModifyNatGatewaySpecRequest, runtime: Util.RuntimeOptions): ModifyNatGatewaySpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNatGatewaySpec',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNatGatewaySpec(request: ModifyNatGatewaySpecRequest): ModifyNatGatewaySpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatGatewaySpecWithOptions(request, runtime);
}

model ModifyNatIpAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natIpDescription?: string(name='NatIpDescription'),
  natIpId?: string(name='NatIpId'),
  natIpName?: string(name='NatIpName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyNatIpAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatIpAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNatIpAttributeResponseBody(name='body'),
}

async function modifyNatIpAttributeWithOptions(request: ModifyNatIpAttributeRequest, runtime: Util.RuntimeOptions): ModifyNatIpAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.natIpDescription)) {
    query['NatIpDescription'] = request.natIpDescription;
  }
  if (!Util.isUnset(request.natIpId)) {
    query['NatIpId'] = request.natIpId;
  }
  if (!Util.isUnset(request.natIpName)) {
    query['NatIpName'] = request.natIpName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNatIpAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNatIpAttribute(request: ModifyNatIpAttributeRequest): ModifyNatIpAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatIpAttributeWithOptions(request, runtime);
}

model ModifyNatIpCidrAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natIpCidr?: string(name='NatIpCidr'),
  natIpCidrDescription?: string(name='NatIpCidrDescription'),
  natIpCidrName?: string(name='NatIpCidrName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyNatIpCidrAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatIpCidrAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNatIpCidrAttributeResponseBody(name='body'),
}

async function modifyNatIpCidrAttributeWithOptions(request: ModifyNatIpCidrAttributeRequest, runtime: Util.RuntimeOptions): ModifyNatIpCidrAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.natIpCidr)) {
    query['NatIpCidr'] = request.natIpCidr;
  }
  if (!Util.isUnset(request.natIpCidrDescription)) {
    query['NatIpCidrDescription'] = request.natIpCidrDescription;
  }
  if (!Util.isUnset(request.natIpCidrName)) {
    query['NatIpCidrName'] = request.natIpCidrName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNatIpCidrAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNatIpCidrAttribute(request: ModifyNatIpCidrAttributeRequest): ModifyNatIpCidrAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatIpCidrAttributeWithOptions(request, runtime);
}

model ModifyNetworkAclAttributesRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  networkAclId?: string(name='NetworkAclId'),
  networkAclName?: string(name='NetworkAclName'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyNetworkAclAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkAclAttributesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNetworkAclAttributesResponseBody(name='body'),
}

async function modifyNetworkAclAttributesWithOptions(request: ModifyNetworkAclAttributesRequest, runtime: Util.RuntimeOptions): ModifyNetworkAclAttributesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.networkAclId)) {
    query['NetworkAclId'] = request.networkAclId;
  }
  if (!Util.isUnset(request.networkAclName)) {
    query['NetworkAclName'] = request.networkAclName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNetworkAclAttributes',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNetworkAclAttributes(request: ModifyNetworkAclAttributesRequest): ModifyNetworkAclAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNetworkAclAttributesWithOptions(request, runtime);
}

model ModifyPhysicalConnectionAttributeRequest {
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  lineOperator?: string(name='LineOperator'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerLocation?: string(name='PeerLocation'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  portType?: string(name='PortType'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bandwidth?: int32(name='bandwidth'),
}

model ModifyPhysicalConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPhysicalConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPhysicalConnectionAttributeResponseBody(name='body'),
}

async function modifyPhysicalConnectionAttributeWithOptions(request: ModifyPhysicalConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyPhysicalConnectionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.circuitCode)) {
    query['CircuitCode'] = request.circuitCode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.lineOperator)) {
    query['LineOperator'] = request.lineOperator;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerLocation)) {
    query['PeerLocation'] = request.peerLocation;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.portType)) {
    query['PortType'] = request.portType;
  }
  if (!Util.isUnset(request.redundantPhysicalConnectionId)) {
    query['RedundantPhysicalConnectionId'] = request.redundantPhysicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['bandwidth'] = request.bandwidth;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPhysicalConnectionAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPhysicalConnectionAttribute(request: ModifyPhysicalConnectionAttributeRequest): ModifyPhysicalConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPhysicalConnectionAttributeWithOptions(request, runtime);
}

model ModifyRouteEntryRequest {
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeEntryId?: string(name='RouteEntryId'),
  routeEntryName?: string(name='RouteEntryName'),
}

model ModifyRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyRouteEntryResponseBody(name='body'),
}

async function modifyRouteEntryWithOptions(request: ModifyRouteEntryRequest, runtime: Util.RuntimeOptions): ModifyRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeEntryId)) {
    query['RouteEntryId'] = request.routeEntryId;
  }
  if (!Util.isUnset(request.routeEntryName)) {
    query['RouteEntryName'] = request.routeEntryName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyRouteEntry(request: ModifyRouteEntryRequest): ModifyRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouteEntryWithOptions(request, runtime);
}

model ModifyRouteTableAttributesRequest {
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
}

model ModifyRouteTableAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouteTableAttributesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyRouteTableAttributesResponseBody(name='body'),
}

async function modifyRouteTableAttributesWithOptions(request: ModifyRouteTableAttributesRequest, runtime: Util.RuntimeOptions): ModifyRouteTableAttributesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  if (!Util.isUnset(request.routeTableName)) {
    query['RouteTableName'] = request.routeTableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRouteTableAttributes',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyRouteTableAttributes(request: ModifyRouteTableAttributesRequest): ModifyRouteTableAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouteTableAttributesWithOptions(request, runtime);
}

model ModifyRouterInterfaceAttributeRequest {
  deleteHealthCheckIp?: boolean(name='DeleteHealthCheckIp'),
  description?: string(name='Description'),
  hcRate?: int32(name='HcRate'),
  hcThreshold?: int32(name='HcThreshold'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  name?: string(name='Name'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeInterfaceOwnerId?: long(name='OppositeInterfaceOwnerId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model ModifyRouterInterfaceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyRouterInterfaceAttributeResponseBody(name='body'),
}

async function modifyRouterInterfaceAttributeWithOptions(request: ModifyRouterInterfaceAttributeRequest, runtime: Util.RuntimeOptions): ModifyRouterInterfaceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deleteHealthCheckIp)) {
    query['DeleteHealthCheckIp'] = request.deleteHealthCheckIp;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.hcRate)) {
    query['HcRate'] = request.hcRate;
  }
  if (!Util.isUnset(request.hcThreshold)) {
    query['HcThreshold'] = request.hcThreshold;
  }
  if (!Util.isUnset(request.healthCheckSourceIp)) {
    query['HealthCheckSourceIp'] = request.healthCheckSourceIp;
  }
  if (!Util.isUnset(request.healthCheckTargetIp)) {
    query['HealthCheckTargetIp'] = request.healthCheckTargetIp;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.oppositeInterfaceId)) {
    query['OppositeInterfaceId'] = request.oppositeInterfaceId;
  }
  if (!Util.isUnset(request.oppositeInterfaceOwnerId)) {
    query['OppositeInterfaceOwnerId'] = request.oppositeInterfaceOwnerId;
  }
  if (!Util.isUnset(request.oppositeRouterId)) {
    query['OppositeRouterId'] = request.oppositeRouterId;
  }
  if (!Util.isUnset(request.oppositeRouterType)) {
    query['OppositeRouterType'] = request.oppositeRouterType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerInterfaceId)) {
    query['RouterInterfaceId'] = request.routerInterfaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRouterInterfaceAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyRouterInterfaceAttribute(request: ModifyRouterInterfaceAttributeRequest): ModifyRouterInterfaceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouterInterfaceAttributeWithOptions(request, runtime);
}

model ModifyRouterInterfaceSpecRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
  spec?: string(name='Spec'),
}

model ModifyRouterInterfaceSpecResponseBody = {
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
}

model ModifyRouterInterfaceSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyRouterInterfaceSpecResponseBody(name='body'),
}

async function modifyRouterInterfaceSpecWithOptions(request: ModifyRouterInterfaceSpecRequest, runtime: Util.RuntimeOptions): ModifyRouterInterfaceSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routerInterfaceId)) {
    query['RouterInterfaceId'] = request.routerInterfaceId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRouterInterfaceSpec',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyRouterInterfaceSpec(request: ModifyRouterInterfaceSpecRequest): ModifyRouterInterfaceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouterInterfaceSpecWithOptions(request, runtime);
}

model ModifySnatEntryRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snatEntryId?: string(name='SnatEntryId'),
  snatEntryName?: string(name='SnatEntryName'),
  snatIp?: string(name='SnatIp'),
  snatTableId?: string(name='SnatTableId'),
}

model ModifySnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySnatEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySnatEntryResponseBody(name='body'),
}

async function modifySnatEntryWithOptions(request: ModifySnatEntryRequest, runtime: Util.RuntimeOptions): ModifySnatEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.snatEntryId)) {
    query['SnatEntryId'] = request.snatEntryId;
  }
  if (!Util.isUnset(request.snatEntryName)) {
    query['SnatEntryName'] = request.snatEntryName;
  }
  if (!Util.isUnset(request.snatIp)) {
    query['SnatIp'] = request.snatIp;
  }
  if (!Util.isUnset(request.snatTableId)) {
    query['SnatTableId'] = request.snatTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySnatEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySnatEntry(request: ModifySnatEntryRequest): ModifySnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySnatEntryWithOptions(request, runtime);
}

model ModifySslVpnClientCertRequest {
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model ModifySslVpnClientCertResponseBody = {
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model ModifySslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySslVpnClientCertResponseBody(name='body'),
}

async function modifySslVpnClientCertWithOptions(request: ModifySslVpnClientCertRequest, runtime: Util.RuntimeOptions): ModifySslVpnClientCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslVpnClientCertId)) {
    query['SslVpnClientCertId'] = request.sslVpnClientCertId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySslVpnClientCert',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySslVpnClientCert(request: ModifySslVpnClientCertRequest): ModifySslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySslVpnClientCertWithOptions(request, runtime);
}

model ModifySslVpnServerRequest {
  cipher?: string(name='Cipher'),
  clientIpPool?: string(name='ClientIpPool'),
  clientToken?: string(name='ClientToken'),
  compress?: boolean(name='Compress'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
  IDaaSRegionId?: string(name='IDaaSRegionId'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: int32(name='Port'),
  proto?: string(name='Proto'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model ModifySslVpnServerResponseBody = {
  cipher?: string(name='Cipher'),
  clientIpPool?: string(name='ClientIpPool'),
  compress?: boolean(name='Compress'),
  connections?: int32(name='Connections'),
  createTime?: long(name='CreateTime'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
  internetIp?: string(name='InternetIp'),
  localSubnet?: string(name='LocalSubnet'),
  maxConnections?: int32(name='MaxConnections'),
  name?: string(name='Name'),
  port?: int32(name='Port'),
  proto?: string(name='Proto'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifySslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySslVpnServerResponseBody(name='body'),
}

async function modifySslVpnServerWithOptions(request: ModifySslVpnServerRequest, runtime: Util.RuntimeOptions): ModifySslVpnServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cipher)) {
    query['Cipher'] = request.cipher;
  }
  if (!Util.isUnset(request.clientIpPool)) {
    query['ClientIpPool'] = request.clientIpPool;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.compress)) {
    query['Compress'] = request.compress;
  }
  if (!Util.isUnset(request.enableMultiFactorAuth)) {
    query['EnableMultiFactorAuth'] = request.enableMultiFactorAuth;
  }
  if (!Util.isUnset(request.IDaaSInstanceId)) {
    query['IDaaSInstanceId'] = request.IDaaSInstanceId;
  }
  if (!Util.isUnset(request.IDaaSRegionId)) {
    query['IDaaSRegionId'] = request.IDaaSRegionId;
  }
  if (!Util.isUnset(request.localSubnet)) {
    query['LocalSubnet'] = request.localSubnet;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.proto)) {
    query['Proto'] = request.proto;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sslVpnServerId)) {
    query['SslVpnServerId'] = request.sslVpnServerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySslVpnServer',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySslVpnServer(request: ModifySslVpnServerRequest): ModifySslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySslVpnServerWithOptions(request, runtime);
}

model ModifyVRouterAttributeRequest {
  description?: string(name='Description'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VRouterId?: string(name='VRouterId'),
  VRouterName?: string(name='VRouterName'),
}

model ModifyVRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVRouterAttributeResponseBody(name='body'),
}

async function modifyVRouterAttributeWithOptions(request: ModifyVRouterAttributeRequest, runtime: Util.RuntimeOptions): ModifyVRouterAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VRouterId)) {
    query['VRouterId'] = request.VRouterId;
  }
  if (!Util.isUnset(request.VRouterName)) {
    query['VRouterName'] = request.VRouterName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVRouterAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVRouterAttribute(request: ModifyVRouterAttributeRequest): ModifyVRouterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVRouterAttributeWithOptions(request, runtime);
}

model ModifyVSwitchAttributeRequest {
  description?: string(name='Description'),
  enableIPv6?: boolean(name='EnableIPv6'),
  ipv6CidrBlock?: int32(name='Ipv6CidrBlock'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  vpcIpv6CidrBlock?: string(name='VpcIpv6CidrBlock'),
}

model ModifyVSwitchAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVSwitchAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVSwitchAttributeResponseBody(name='body'),
}

async function modifyVSwitchAttributeWithOptions(request: ModifyVSwitchAttributeRequest, runtime: Util.RuntimeOptions): ModifyVSwitchAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableIPv6)) {
    query['EnableIPv6'] = request.enableIPv6;
  }
  if (!Util.isUnset(request.ipv6CidrBlock)) {
    query['Ipv6CidrBlock'] = request.ipv6CidrBlock;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vSwitchName)) {
    query['VSwitchName'] = request.vSwitchName;
  }
  if (!Util.isUnset(request.vpcIpv6CidrBlock)) {
    query['VpcIpv6CidrBlock'] = request.vpcIpv6CidrBlock;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVSwitchAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): ModifyVSwitchAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVSwitchAttributeWithOptions(request, runtime);
}

model ModifyVcoRouteEntryWeightRequest {
  clientToken?: string(name='ClientToken'),
  newWeight?: int32(name='NewWeight'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  weight?: int32(name='Weight'),
}

model ModifyVcoRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVcoRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVcoRouteEntryWeightResponseBody(name='body'),
}

async function modifyVcoRouteEntryWeightWithOptions(request: ModifyVcoRouteEntryWeightRequest, runtime: Util.RuntimeOptions): ModifyVcoRouteEntryWeightResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.newWeight)) {
    query['NewWeight'] = request.newWeight;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.overlayMode)) {
    query['OverlayMode'] = request.overlayMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVcoRouteEntryWeight',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVcoRouteEntryWeight(request: ModifyVcoRouteEntryWeightRequest): ModifyVcoRouteEntryWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVcoRouteEntryWeightWithOptions(request, runtime);
}

model ModifyVirtualBorderRouterAttributeRequest {
  associatedPhysicalConnections?: string(name='AssociatedPhysicalConnections'),
  bandwidth?: int32(name='Bandwidth'),
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  detectMultiplier?: long(name='DetectMultiplier'),
  enableIpv6?: boolean(name='EnableIpv6'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  minRxInterval?: long(name='MinRxInterval'),
  minTxInterval?: long(name='MinTxInterval'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
  vlanId?: int32(name='VlanId'),
}

model ModifyVirtualBorderRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVirtualBorderRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVirtualBorderRouterAttributeResponseBody(name='body'),
}

async function modifyVirtualBorderRouterAttributeWithOptions(request: ModifyVirtualBorderRouterAttributeRequest, runtime: Util.RuntimeOptions): ModifyVirtualBorderRouterAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.associatedPhysicalConnections)) {
    query['AssociatedPhysicalConnections'] = request.associatedPhysicalConnections;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.circuitCode)) {
    query['CircuitCode'] = request.circuitCode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.detectMultiplier)) {
    query['DetectMultiplier'] = request.detectMultiplier;
  }
  if (!Util.isUnset(request.enableIpv6)) {
    query['EnableIpv6'] = request.enableIpv6;
  }
  if (!Util.isUnset(request.localGatewayIp)) {
    query['LocalGatewayIp'] = request.localGatewayIp;
  }
  if (!Util.isUnset(request.localIpv6GatewayIp)) {
    query['LocalIpv6GatewayIp'] = request.localIpv6GatewayIp;
  }
  if (!Util.isUnset(request.minRxInterval)) {
    query['MinRxInterval'] = request.minRxInterval;
  }
  if (!Util.isUnset(request.minTxInterval)) {
    query['MinTxInterval'] = request.minTxInterval;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.peerGatewayIp)) {
    query['PeerGatewayIp'] = request.peerGatewayIp;
  }
  if (!Util.isUnset(request.peerIpv6GatewayIp)) {
    query['PeerIpv6GatewayIp'] = request.peerIpv6GatewayIp;
  }
  if (!Util.isUnset(request.peeringIpv6SubnetMask)) {
    query['PeeringIpv6SubnetMask'] = request.peeringIpv6SubnetMask;
  }
  if (!Util.isUnset(request.peeringSubnetMask)) {
    query['PeeringSubnetMask'] = request.peeringSubnetMask;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  if (!Util.isUnset(request.vlanId)) {
    query['VlanId'] = request.vlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVirtualBorderRouterAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVirtualBorderRouterAttribute(request: ModifyVirtualBorderRouterAttributeRequest): ModifyVirtualBorderRouterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVirtualBorderRouterAttributeWithOptions(request, runtime);
}

model ModifyVpcAttributeRequest {
  cidrBlock?: string(name='CidrBlock'),
  description?: string(name='Description'),
  enableIPv6?: boolean(name='EnableIPv6'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  ipv6Isp?: string(name='Ipv6Isp'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
  vpcName?: string(name='VpcName'),
}

model ModifyVpcAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVpcAttributeResponseBody(name='body'),
}

async function modifyVpcAttributeWithOptions(request: ModifyVpcAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpcAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cidrBlock)) {
    query['CidrBlock'] = request.cidrBlock;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.enableIPv6)) {
    query['EnableIPv6'] = request.enableIPv6;
  }
  if (!Util.isUnset(request.ipv6CidrBlock)) {
    query['Ipv6CidrBlock'] = request.ipv6CidrBlock;
  }
  if (!Util.isUnset(request.ipv6Isp)) {
    query['Ipv6Isp'] = request.ipv6Isp;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vpcName)) {
    query['VpcName'] = request.vpcName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpcAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVpcAttribute(request: ModifyVpcAttributeRequest): ModifyVpcAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpcAttributeWithOptions(request, runtime);
}

model ModifyVpcPrefixListRequest {
  addPrefixListEntry?: [ 
    {
      cidr?: string(name='Cidr'),
      description?: string(name='Description'),
    }
  ](name='AddPrefixListEntry'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  maxEntries?: int32(name='MaxEntries'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  prefixListDescription?: string(name='PrefixListDescription'),
  prefixListId?: string(name='PrefixListId'),
  prefixListName?: string(name='PrefixListName'),
  regionId?: string(name='RegionId'),
  removePrefixListEntry?: [ 
    {
      cidr?: string(name='Cidr'),
      description?: string(name='Description'),
    }
  ](name='RemovePrefixListEntry'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyVpcPrefixListResponseBody = {
  prefixListId?: string(name='PrefixListId'),
  requestId?: string(name='RequestId'),
}

model ModifyVpcPrefixListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVpcPrefixListResponseBody(name='body'),
}

async function modifyVpcPrefixListWithOptions(request: ModifyVpcPrefixListRequest, runtime: Util.RuntimeOptions): ModifyVpcPrefixListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addPrefixListEntry)) {
    query['AddPrefixListEntry'] = request.addPrefixListEntry;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.maxEntries)) {
    query['MaxEntries'] = request.maxEntries;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.prefixListDescription)) {
    query['PrefixListDescription'] = request.prefixListDescription;
  }
  if (!Util.isUnset(request.prefixListId)) {
    query['PrefixListId'] = request.prefixListId;
  }
  if (!Util.isUnset(request.prefixListName)) {
    query['PrefixListName'] = request.prefixListName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.removePrefixListEntry)) {
    query['RemovePrefixListEntry'] = request.removePrefixListEntry;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpcPrefixList',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVpcPrefixList(request: ModifyVpcPrefixListRequest): ModifyVpcPrefixListResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpcPrefixListWithOptions(request, runtime);
}

model ModifyVpnAttachmentAttributeRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  bgpConfig?: string(name='BgpConfig'),
  clientToken?: string(name='ClientToken'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  remoteCaCert?: string(name='RemoteCaCert'),
  remoteSubnet?: string(name='RemoteSubnet'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model ModifyVpnAttachmentAttributeResponseBody = {
  attachInstanceId?: string(name='AttachInstanceId'),
  attachType?: string(name='AttachType'),
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  ikeConfig?: {
    ikeAuthAlg?: string(name='IkeAuthAlg'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeMode?: string(name='IkeMode'),
    ikePfs?: string(name='IkePfs'),
    ikeVersion?: string(name='IkeVersion'),
    localId?: string(name='LocalId'),
    psk?: string(name='Psk'),
    remoteId?: string(name='RemoteId'),
  }(name='IkeConfig'),
  ipsecConfig?: {
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecPfs?: string(name='IpsecPfs'),
  }(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
  remoteSubnet?: string(name='RemoteSubnet'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  vcoHealthCheck?: {
    dip?: string(name='Dip'),
    enable?: string(name='Enable'),
    interval?: int32(name='Interval'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig?: {
    enableBgp?: string(name='EnableBgp'),
    localAsn?: long(name='LocalAsn'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: long(name='PeerAsn'),
    peerBgpIp?: string(name='PeerBgpIp'),
    status?: string(name='Status'),
    tunnelCidr?: string(name='TunnelCidr'),
  }(name='VpnBgpConfig'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnAttachmentAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVpnAttachmentAttributeResponseBody(name='body'),
}

async function modifyVpnAttachmentAttributeWithOptions(request: ModifyVpnAttachmentAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpnAttachmentAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoConfigRoute)) {
    query['AutoConfigRoute'] = request.autoConfigRoute;
  }
  if (!Util.isUnset(request.bgpConfig)) {
    query['BgpConfig'] = request.bgpConfig;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.effectImmediately)) {
    query['EffectImmediately'] = request.effectImmediately;
  }
  if (!Util.isUnset(request.enableDpd)) {
    query['EnableDpd'] = request.enableDpd;
  }
  if (!Util.isUnset(request.enableNatTraversal)) {
    query['EnableNatTraversal'] = request.enableNatTraversal;
  }
  if (!Util.isUnset(request.healthCheckConfig)) {
    query['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.ikeConfig)) {
    query['IkeConfig'] = request.ikeConfig;
  }
  if (!Util.isUnset(request.ipsecConfig)) {
    query['IpsecConfig'] = request.ipsecConfig;
  }
  if (!Util.isUnset(request.localSubnet)) {
    query['LocalSubnet'] = request.localSubnet;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remoteCaCert)) {
    query['RemoteCaCert'] = request.remoteCaCert;
  }
  if (!Util.isUnset(request.remoteSubnet)) {
    query['RemoteSubnet'] = request.remoteSubnet;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpnAttachmentAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVpnAttachmentAttribute(request: ModifyVpnAttachmentAttributeRequest): ModifyVpnAttachmentAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnAttachmentAttributeWithOptions(request, runtime);
}

model ModifyVpnConnectionAttributeRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  bgpConfig?: string(name='BgpConfig'),
  clientToken?: string(name='ClientToken'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
  remoteSubnet?: string(name='RemoteSubnet'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model ModifyVpnConnectionAttributeResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  ikeConfig?: {
    ikeAuthAlg?: string(name='IkeAuthAlg'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeMode?: string(name='IkeMode'),
    ikePfs?: string(name='IkePfs'),
    ikeVersion?: string(name='IkeVersion'),
    localId?: string(name='LocalId'),
    psk?: string(name='Psk'),
    remoteId?: string(name='RemoteId'),
  }(name='IkeConfig'),
  ipsecConfig?: {
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecPfs?: string(name='IpsecPfs'),
  }(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  remoteSubnet?: string(name='RemoteSubnet'),
  requestId?: string(name='RequestId'),
  vcoHealthCheck?: {
    dip?: string(name='Dip'),
    enable?: string(name='Enable'),
    interval?: int32(name='Interval'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig?: {
    enableBgp?: string(name='EnableBgp'),
    localAsn?: int32(name='LocalAsn'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: int32(name='PeerAsn'),
    peerBgpIp?: string(name='PeerBgpIp'),
    status?: string(name='Status'),
    tunnelCidr?: string(name='TunnelCidr'),
  }(name='VpnBgpConfig'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVpnConnectionAttributeResponseBody(name='body'),
}

async function modifyVpnConnectionAttributeWithOptions(request: ModifyVpnConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpnConnectionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoConfigRoute)) {
    query['AutoConfigRoute'] = request.autoConfigRoute;
  }
  if (!Util.isUnset(request.bgpConfig)) {
    query['BgpConfig'] = request.bgpConfig;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.effectImmediately)) {
    query['EffectImmediately'] = request.effectImmediately;
  }
  if (!Util.isUnset(request.enableDpd)) {
    query['EnableDpd'] = request.enableDpd;
  }
  if (!Util.isUnset(request.enableNatTraversal)) {
    query['EnableNatTraversal'] = request.enableNatTraversal;
  }
  if (!Util.isUnset(request.healthCheckConfig)) {
    query['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.ikeConfig)) {
    query['IkeConfig'] = request.ikeConfig;
  }
  if (!Util.isUnset(request.ipsecConfig)) {
    query['IpsecConfig'] = request.ipsecConfig;
  }
  if (!Util.isUnset(request.localSubnet)) {
    query['LocalSubnet'] = request.localSubnet;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.remoteCaCertificate)) {
    query['RemoteCaCertificate'] = request.remoteCaCertificate;
  }
  if (!Util.isUnset(request.remoteSubnet)) {
    query['RemoteSubnet'] = request.remoteSubnet;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnConnectionId)) {
    query['VpnConnectionId'] = request.vpnConnectionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpnConnectionAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVpnConnectionAttribute(request: ModifyVpnConnectionAttributeRequest): ModifyVpnConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnConnectionAttributeWithOptions(request, runtime);
}

model ModifyVpnGatewayAttributeRequest {
  autoPropagate?: boolean(name='AutoPropagate'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnGatewayAttributeResponseBody = {
  autoPropagate?: boolean(name='AutoPropagate'),
  businessStatus?: string(name='BusinessStatus'),
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  enableBgp?: boolean(name='EnableBgp'),
  endTime?: long(name='EndTime'),
  internetIp?: string(name='InternetIp'),
  intranetIp?: string(name='IntranetIp'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVpnGatewayAttributeResponseBody(name='body'),
}

async function modifyVpnGatewayAttributeWithOptions(request: ModifyVpnGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpnGatewayAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPropagate)) {
    query['AutoPropagate'] = request.autoPropagate;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpnGatewayAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVpnGatewayAttribute(request: ModifyVpnGatewayAttributeRequest): ModifyVpnGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnGatewayAttributeWithOptions(request, runtime);
}

model ModifyVpnPbrRouteEntryWeightRequest {
  clientToken?: string(name='ClientToken'),
  newWeight?: int32(name='NewWeight'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  routeSource?: string(name='RouteSource'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model ModifyVpnPbrRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpnPbrRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVpnPbrRouteEntryWeightResponseBody(name='body'),
}

async function modifyVpnPbrRouteEntryWeightWithOptions(request: ModifyVpnPbrRouteEntryWeightRequest, runtime: Util.RuntimeOptions): ModifyVpnPbrRouteEntryWeightResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.newWeight)) {
    query['NewWeight'] = request.newWeight;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.overlayMode)) {
    query['OverlayMode'] = request.overlayMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.routeSource)) {
    query['RouteSource'] = request.routeSource;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpnPbrRouteEntryWeight',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVpnPbrRouteEntryWeight(request: ModifyVpnPbrRouteEntryWeightRequest): ModifyVpnPbrRouteEntryWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnPbrRouteEntryWeightWithOptions(request, runtime);
}

model ModifyVpnRouteEntryWeightRequest {
  clientToken?: string(name='ClientToken'),
  newWeight?: int32(name='NewWeight'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  weight?: int32(name='Weight'),
}

model ModifyVpnRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpnRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyVpnRouteEntryWeightResponseBody(name='body'),
}

async function modifyVpnRouteEntryWeightWithOptions(request: ModifyVpnRouteEntryWeightRequest, runtime: Util.RuntimeOptions): ModifyVpnRouteEntryWeightResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.newWeight)) {
    query['NewWeight'] = request.newWeight;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.overlayMode)) {
    query['OverlayMode'] = request.overlayMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyVpnRouteEntryWeight',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyVpnRouteEntryWeight(request: ModifyVpnRouteEntryWeightRequest): ModifyVpnRouteEntryWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnRouteEntryWeightWithOptions(request, runtime);
}

model MoveResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveResourceGroup',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model OpenFlowLogServiceRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model OpenFlowLogServiceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model OpenFlowLogServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenFlowLogServiceResponseBody(name='body'),
}

async function openFlowLogServiceWithOptions(request: OpenFlowLogServiceRequest, runtime: Util.RuntimeOptions): OpenFlowLogServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenFlowLogService',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openFlowLogService(request: OpenFlowLogServiceRequest): OpenFlowLogServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openFlowLogServiceWithOptions(request, runtime);
}

model OpenPhysicalConnectionServiceRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model OpenPhysicalConnectionServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenPhysicalConnectionServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenPhysicalConnectionServiceResponseBody(name='body'),
}

async function openPhysicalConnectionServiceWithOptions(request: OpenPhysicalConnectionServiceRequest, runtime: Util.RuntimeOptions): OpenPhysicalConnectionServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenPhysicalConnectionService',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openPhysicalConnectionService(request: OpenPhysicalConnectionServiceRequest): OpenPhysicalConnectionServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openPhysicalConnectionServiceWithOptions(request, runtime);
}

model OpenTrafficMirrorServiceRequest {
  ownerId?: long(name='OwnerId'),
}

model OpenTrafficMirrorServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenTrafficMirrorServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenTrafficMirrorServiceResponseBody(name='body'),
}

async function openTrafficMirrorServiceWithOptions(request: OpenTrafficMirrorServiceRequest, runtime: Util.RuntimeOptions): OpenTrafficMirrorServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenTrafficMirrorService',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openTrafficMirrorService(request: OpenTrafficMirrorServiceRequest): OpenTrafficMirrorServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openTrafficMirrorServiceWithOptions(request, runtime);
}

model PublishVpnRouteEntryRequest {
  clientToken?: string(name='ClientToken'),
  nextHop?: string(name='NextHop'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publishVpc?: boolean(name='PublishVpc'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeDest?: string(name='RouteDest'),
  routeType?: string(name='RouteType'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model PublishVpnRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model PublishVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishVpnRouteEntryResponseBody(name='body'),
}

async function publishVpnRouteEntryWithOptions(request: PublishVpnRouteEntryRequest, runtime: Util.RuntimeOptions): PublishVpnRouteEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.nextHop)) {
    query['NextHop'] = request.nextHop;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publishVpc)) {
    query['PublishVpc'] = request.publishVpc;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeDest)) {
    query['RouteDest'] = request.routeDest;
  }
  if (!Util.isUnset(request.routeType)) {
    query['RouteType'] = request.routeType;
  }
  if (!Util.isUnset(request.vpnGatewayId)) {
    query['VpnGatewayId'] = request.vpnGatewayId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishVpnRouteEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishVpnRouteEntry(request: PublishVpnRouteEntryRequest): PublishVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishVpnRouteEntryWithOptions(request, runtime);
}

model RecoverPhysicalConnectionRequest {
  dryRun?: boolean(name='DryRun'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  token?: string(name='Token'),
}

model RecoverPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RecoverPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecoverPhysicalConnectionResponseBody(name='body'),
}

async function recoverPhysicalConnectionWithOptions(request: RecoverPhysicalConnectionRequest, runtime: Util.RuntimeOptions): RecoverPhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecoverPhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recoverPhysicalConnection(request: RecoverPhysicalConnectionRequest): RecoverPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoverPhysicalConnectionWithOptions(request, runtime);
}

model RecoverVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model RecoverVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model RecoverVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecoverVirtualBorderRouterResponseBody(name='body'),
}

async function recoverVirtualBorderRouterWithOptions(request: RecoverVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): RecoverVirtualBorderRouterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecoverVirtualBorderRouter',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recoverVirtualBorderRouter(request: RecoverVirtualBorderRouterRequest): RecoverVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoverVirtualBorderRouterWithOptions(request, runtime);
}

model ReleaseEipAddressRequest {
  allocationId?: string(name='AllocationId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReleaseEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseEipAddressResponseBody(name='body'),
}

async function releaseEipAddressWithOptions(request: ReleaseEipAddressRequest, runtime: Util.RuntimeOptions): ReleaseEipAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseEipAddress',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseEipAddress(request: ReleaseEipAddressRequest): ReleaseEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseEipAddressWithOptions(request, runtime);
}

model ReleaseEipSegmentAddressRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
}

model ReleaseEipSegmentAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipSegmentAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseEipSegmentAddressResponseBody(name='body'),
}

async function releaseEipSegmentAddressWithOptions(request: ReleaseEipSegmentAddressRequest, runtime: Util.RuntimeOptions): ReleaseEipSegmentAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.segmentInstanceId)) {
    query['SegmentInstanceId'] = request.segmentInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseEipSegmentAddress',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseEipSegmentAddress(request: ReleaseEipSegmentAddressRequest): ReleaseEipSegmentAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseEipSegmentAddressWithOptions(request, runtime);
}

model RemoveCommonBandwidthPackageIpRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  ipInstanceId?: string(name='IpInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RemoveCommonBandwidthPackageIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveCommonBandwidthPackageIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveCommonBandwidthPackageIpResponseBody(name='body'),
}

async function removeCommonBandwidthPackageIpWithOptions(request: RemoveCommonBandwidthPackageIpRequest, runtime: Util.RuntimeOptions): RemoveCommonBandwidthPackageIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipInstanceId)) {
    query['IpInstanceId'] = request.ipInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveCommonBandwidthPackageIp',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeCommonBandwidthPackageIp(request: RemoveCommonBandwidthPackageIpRequest): RemoveCommonBandwidthPackageIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCommonBandwidthPackageIpWithOptions(request, runtime);
}

model RemoveGlobalAccelerationInstanceIpRequest {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipInstanceId?: string(name='IpInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RemoveGlobalAccelerationInstanceIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveGlobalAccelerationInstanceIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveGlobalAccelerationInstanceIpResponseBody(name='body'),
}

async function removeGlobalAccelerationInstanceIpWithOptions(request: RemoveGlobalAccelerationInstanceIpRequest, runtime: Util.RuntimeOptions): RemoveGlobalAccelerationInstanceIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalAccelerationInstanceId)) {
    query['GlobalAccelerationInstanceId'] = request.globalAccelerationInstanceId;
  }
  if (!Util.isUnset(request.ipInstanceId)) {
    query['IpInstanceId'] = request.ipInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveGlobalAccelerationInstanceIp',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeGlobalAccelerationInstanceIp(request: RemoveGlobalAccelerationInstanceIpRequest): RemoveGlobalAccelerationInstanceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

model RemoveIPv6TranslatorAclListEntryRequest {
  aclEntryId?: string(name='AclEntryId'),
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RemoveIPv6TranslatorAclListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function removeIPv6TranslatorAclListEntryWithOptions(request: RemoveIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): RemoveIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntryId)) {
    query['AclEntryId'] = request.aclEntryId;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveIPv6TranslatorAclListEntry',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeIPv6TranslatorAclListEntry(request: RemoveIPv6TranslatorAclListEntryRequest): RemoveIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model RemoveSourcesFromTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
  trafficMirrorSourceIds?: [ string ](name='TrafficMirrorSourceIds'),
}

model RemoveSourcesFromTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveSourcesFromTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveSourcesFromTrafficMirrorSessionResponseBody(name='body'),
}

async function removeSourcesFromTrafficMirrorSessionWithOptions(request: RemoveSourcesFromTrafficMirrorSessionRequest, runtime: Util.RuntimeOptions): RemoveSourcesFromTrafficMirrorSessionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorSessionId)) {
    query['TrafficMirrorSessionId'] = request.trafficMirrorSessionId;
  }
  if (!Util.isUnset(request.trafficMirrorSourceIds)) {
    query['TrafficMirrorSourceIds'] = request.trafficMirrorSourceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveSourcesFromTrafficMirrorSession',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeSourcesFromTrafficMirrorSession(request: RemoveSourcesFromTrafficMirrorSessionRequest): RemoveSourcesFromTrafficMirrorSessionResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeSourcesFromTrafficMirrorSessionWithOptions(request, runtime);
}

model ReplaceVpcDhcpOptionsSetRequest {
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vpcId?: string(name='VpcId'),
}

model ReplaceVpcDhcpOptionsSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReplaceVpcDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReplaceVpcDhcpOptionsSetResponseBody(name='body'),
}

async function replaceVpcDhcpOptionsSetWithOptions(request: ReplaceVpcDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): ReplaceVpcDhcpOptionsSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dhcpOptionsSetId)) {
    query['DhcpOptionsSetId'] = request.dhcpOptionsSetId;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReplaceVpcDhcpOptionsSet',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function replaceVpcDhcpOptionsSet(request: ReplaceVpcDhcpOptionsSetRequest): ReplaceVpcDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceVpcDhcpOptionsSetWithOptions(request, runtime);
}

model RetryVpcPrefixListAssociationRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  prefixListId?: string(name='PrefixListId'),
  regionId?: string(name='RegionId'),
  resourceId?: string(name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
}

model RetryVpcPrefixListAssociationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RetryVpcPrefixListAssociationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetryVpcPrefixListAssociationResponseBody(name='body'),
}

async function retryVpcPrefixListAssociationWithOptions(request: RetryVpcPrefixListAssociationRequest, runtime: Util.RuntimeOptions): RetryVpcPrefixListAssociationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.prefixListId)) {
    query['PrefixListId'] = request.prefixListId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetryVpcPrefixListAssociation',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retryVpcPrefixListAssociation(request: RetryVpcPrefixListAssociationRequest): RetryVpcPrefixListAssociationResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryVpcPrefixListAssociationWithOptions(request, runtime);
}

model RevokeInstanceFromCenRequest {
  cenId?: string(name='CenId'),
  cenOwnerId?: long(name='CenOwnerId'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RevokeInstanceFromCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeInstanceFromCenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeInstanceFromCenResponseBody(name='body'),
}

async function revokeInstanceFromCenWithOptions(request: RevokeInstanceFromCenRequest, runtime: Util.RuntimeOptions): RevokeInstanceFromCenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cenId)) {
    query['CenId'] = request.cenId;
  }
  if (!Util.isUnset(request.cenOwnerId)) {
    query['CenOwnerId'] = request.cenOwnerId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeInstanceFromCen',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeInstanceFromCen(request: RevokeInstanceFromCenRequest): RevokeInstanceFromCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeInstanceFromCenWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TagResourcesForExpressConnectRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesForExpressConnectResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesForExpressConnectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesForExpressConnectResponseBody(name='body'),
}

async function tagResourcesForExpressConnectWithOptions(request: TagResourcesForExpressConnectRequest, runtime: Util.RuntimeOptions): TagResourcesForExpressConnectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResourcesForExpressConnect',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResourcesForExpressConnect(request: TagResourcesForExpressConnectRequest): TagResourcesForExpressConnectResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesForExpressConnectWithOptions(request, runtime);
}

model TerminatePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model TerminatePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TerminatePhysicalConnectionResponseBody(name='body'),
}

async function terminatePhysicalConnectionWithOptions(request: TerminatePhysicalConnectionRequest, runtime: Util.RuntimeOptions): TerminatePhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TerminatePhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function terminatePhysicalConnection(request: TerminatePhysicalConnectionRequest): TerminatePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminatePhysicalConnectionWithOptions(request, runtime);
}

model TerminateVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model TerminateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TerminateVirtualBorderRouterResponseBody(name='body'),
}

async function terminateVirtualBorderRouterWithOptions(request: TerminateVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): TerminateVirtualBorderRouterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TerminateVirtualBorderRouter',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function terminateVirtualBorderRouter(request: TerminateVirtualBorderRouterRequest): TerminateVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateVirtualBorderRouterWithOptions(request, runtime);
}

model UnTagResourcesRequest {
  all?: boolean(name='All'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResourcesWithOptions(request: UnTagResourcesRequest, runtime: Util.RuntimeOptions): UnTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnTagResources',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return unTagResourcesWithOptions(request, runtime);
}

model UnassociateEipAddressRequest {
  allocationId?: string(name='AllocationId'),
  clientToken?: string(name='ClientToken'),
  force?: boolean(name='Force'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnassociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnassociateEipAddressResponseBody(name='body'),
}

async function unassociateEipAddressWithOptions(request: UnassociateEipAddressRequest, runtime: Util.RuntimeOptions): UnassociateEipAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationId)) {
    query['AllocationId'] = request.allocationId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnassociateEipAddress',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unassociateEipAddress(request: UnassociateEipAddressRequest): UnassociateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateEipAddressWithOptions(request, runtime);
}

model UnassociateGlobalAccelerationInstanceRequest {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnassociateGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnassociateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function unassociateGlobalAccelerationInstanceWithOptions(request: UnassociateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): UnassociateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.globalAccelerationInstanceId)) {
    query['GlobalAccelerationInstanceId'] = request.globalAccelerationInstanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnassociateGlobalAccelerationInstance',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unassociateGlobalAccelerationInstance(request: UnassociateGlobalAccelerationInstanceRequest): UnassociateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateGlobalAccelerationInstanceWithOptions(request, runtime);
}

model UnassociateHaVipRequest {
  clientToken?: string(name='ClientToken'),
  force?: string(name='Force'),
  haVipId?: string(name='HaVipId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnassociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnassociateHaVipResponseBody(name='body'),
}

async function unassociateHaVipWithOptions(request: UnassociateHaVipRequest, runtime: Util.RuntimeOptions): UnassociateHaVipResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.haVipId)) {
    query['HaVipId'] = request.haVipId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnassociateHaVip',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unassociateHaVip(request: UnassociateHaVipRequest): UnassociateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateHaVipWithOptions(request, runtime);
}

model UnassociateNetworkAclRequest {
  clientToken?: string(name='ClientToken'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resource'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnassociateNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnassociateNetworkAclResponseBody(name='body'),
}

async function unassociateNetworkAclWithOptions(request: UnassociateNetworkAclRequest, runtime: Util.RuntimeOptions): UnassociateNetworkAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.networkAclId)) {
    query['NetworkAclId'] = request.networkAclId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resource)) {
    query['Resource'] = request.resource;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnassociateNetworkAcl',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unassociateNetworkAcl(request: UnassociateNetworkAclRequest): UnassociateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateNetworkAclWithOptions(request, runtime);
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vbrId?: string(name='VbrId'),
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody(name='body'),
}

async function unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.physicalConnectionId)) {
    query['PhysicalConnectionId'] = request.physicalConnectionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vbrId)) {
    query['VbrId'] = request.vbrId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnassociatePhysicalConnectionFromVirtualBorderRouter',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unassociatePhysicalConnectionFromVirtualBorderRouter(request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest): UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request, runtime);
}

model UnassociateRouteTableRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  routeTableId?: string(name='RouteTableId'),
  vSwitchId?: string(name='VSwitchId'),
}

model UnassociateRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnassociateRouteTableResponseBody(name='body'),
}

async function unassociateRouteTableWithOptions(request: UnassociateRouteTableRequest, runtime: Util.RuntimeOptions): UnassociateRouteTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.routeTableId)) {
    query['RouteTableId'] = request.routeTableId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnassociateRouteTable',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unassociateRouteTable(request: UnassociateRouteTableRequest): UnassociateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateRouteTableWithOptions(request, runtime);
}

model UnassociateVpcCidrBlockRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock'),
  vpcId?: string(name='VpcId'),
}

model UnassociateVpcCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateVpcCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnassociateVpcCidrBlockResponseBody(name='body'),
}

async function unassociateVpcCidrBlockWithOptions(request: UnassociateVpcCidrBlockRequest, runtime: Util.RuntimeOptions): UnassociateVpcCidrBlockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.secondaryCidrBlock)) {
    query['SecondaryCidrBlock'] = request.secondaryCidrBlock;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnassociateVpcCidrBlock',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unassociateVpcCidrBlock(request: UnassociateVpcCidrBlockRequest): UnassociateVpcCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateVpcCidrBlockWithOptions(request, runtime);
}

model UntagResourcesForExpressConnectRequest {
  all?: boolean(name='All'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesForExpressConnectResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesForExpressConnectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesForExpressConnectResponseBody(name='body'),
}

async function untagResourcesForExpressConnectWithOptions(request: UntagResourcesForExpressConnectRequest, runtime: Util.RuntimeOptions): UntagResourcesForExpressConnectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResourcesForExpressConnect',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResourcesForExpressConnect(request: UntagResourcesForExpressConnectRequest): UntagResourcesForExpressConnectResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesForExpressConnectWithOptions(request, runtime);
}

model UpdateDhcpOptionsSetAttributeRequest {
  bootFileName?: string(name='BootFileName'),
  clientToken?: string(name='ClientToken'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  domainName?: string(name='DomainName'),
  domainNameServers?: string(name='DomainNameServers'),
  dryRun?: boolean(name='DryRun'),
  ipv6LeaseTime?: string(name='Ipv6LeaseTime'),
  leaseTime?: string(name='LeaseTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  TFTPServerName?: string(name='TFTPServerName'),
}

model UpdateDhcpOptionsSetAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDhcpOptionsSetAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDhcpOptionsSetAttributeResponseBody(name='body'),
}

async function updateDhcpOptionsSetAttributeWithOptions(request: UpdateDhcpOptionsSetAttributeRequest, runtime: Util.RuntimeOptions): UpdateDhcpOptionsSetAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bootFileName)) {
    query['BootFileName'] = request.bootFileName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dhcpOptionsSetDescription)) {
    query['DhcpOptionsSetDescription'] = request.dhcpOptionsSetDescription;
  }
  if (!Util.isUnset(request.dhcpOptionsSetId)) {
    query['DhcpOptionsSetId'] = request.dhcpOptionsSetId;
  }
  if (!Util.isUnset(request.dhcpOptionsSetName)) {
    query['DhcpOptionsSetName'] = request.dhcpOptionsSetName;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainNameServers)) {
    query['DomainNameServers'] = request.domainNameServers;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ipv6LeaseTime)) {
    query['Ipv6LeaseTime'] = request.ipv6LeaseTime;
  }
  if (!Util.isUnset(request.leaseTime)) {
    query['LeaseTime'] = request.leaseTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.TFTPServerName)) {
    query['TFTPServerName'] = request.TFTPServerName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDhcpOptionsSetAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDhcpOptionsSetAttribute(request: UpdateDhcpOptionsSetAttributeRequest): UpdateDhcpOptionsSetAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDhcpOptionsSetAttributeWithOptions(request, runtime);
}

model UpdateGatewayRouteTableEntryAttributeRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  dryRun?: boolean(name='DryRun'),
  IPv4GatewayRouteTableId?: string(name='IPv4GatewayRouteTableId'),
  name?: string(name='Name'),
  nextHopId?: string(name='NextHopId'),
  nextHopType?: string(name='NextHopType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateGatewayRouteTableEntryAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGatewayRouteTableEntryAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGatewayRouteTableEntryAttributeResponseBody(name='body'),
}

async function updateGatewayRouteTableEntryAttributeWithOptions(request: UpdateGatewayRouteTableEntryAttributeRequest, runtime: Util.RuntimeOptions): UpdateGatewayRouteTableEntryAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.destinationCidrBlock)) {
    query['DestinationCidrBlock'] = request.destinationCidrBlock;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.IPv4GatewayRouteTableId)) {
    query['IPv4GatewayRouteTableId'] = request.IPv4GatewayRouteTableId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.nextHopId)) {
    query['NextHopId'] = request.nextHopId;
  }
  if (!Util.isUnset(request.nextHopType)) {
    query['NextHopType'] = request.nextHopType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGatewayRouteTableEntryAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGatewayRouteTableEntryAttribute(request: UpdateGatewayRouteTableEntryAttributeRequest): UpdateGatewayRouteTableEntryAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGatewayRouteTableEntryAttributeWithOptions(request, runtime);
}

model UpdateIpsecServerRequest {
  clientIpPool?: string(name='ClientIpPool'),
  clientToken?: string(name='ClientToken'),
  dryRun?: string(name='DryRun'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  ipsecServerId?: string(name='IpsecServerId'),
  ipsecServerName?: string(name='IpsecServerName'),
  localSubnet?: string(name='LocalSubnet'),
  psk?: string(name='Psk'),
  pskEnabled?: boolean(name='PskEnabled'),
  regionId?: string(name='RegionId'),
}

model UpdateIpsecServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIpsecServerResponseBody(name='body'),
}

async function updateIpsecServerWithOptions(request: UpdateIpsecServerRequest, runtime: Util.RuntimeOptions): UpdateIpsecServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientIpPool)) {
    query['ClientIpPool'] = request.clientIpPool;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.effectImmediately)) {
    query['EffectImmediately'] = request.effectImmediately;
  }
  if (!Util.isUnset(request.ikeConfig)) {
    query['IkeConfig'] = request.ikeConfig;
  }
  if (!Util.isUnset(request.ipsecConfig)) {
    query['IpsecConfig'] = request.ipsecConfig;
  }
  if (!Util.isUnset(request.ipsecServerId)) {
    query['IpsecServerId'] = request.ipsecServerId;
  }
  if (!Util.isUnset(request.ipsecServerName)) {
    query['IpsecServerName'] = request.ipsecServerName;
  }
  if (!Util.isUnset(request.localSubnet)) {
    query['LocalSubnet'] = request.localSubnet;
  }
  if (!Util.isUnset(request.psk)) {
    query['Psk'] = request.psk;
  }
  if (!Util.isUnset(request.pskEnabled)) {
    query['PskEnabled'] = request.pskEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIpsecServer',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIpsecServer(request: UpdateIpsecServerRequest): UpdateIpsecServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpsecServerWithOptions(request, runtime);
}

model UpdateIpv4GatewayAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ipv4GatewayName?: string(name='Ipv4GatewayName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateIpv4GatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpv4GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIpv4GatewayAttributeResponseBody(name='body'),
}

async function updateIpv4GatewayAttributeWithOptions(request: UpdateIpv4GatewayAttributeRequest, runtime: Util.RuntimeOptions): UpdateIpv4GatewayAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ipv4GatewayDescription)) {
    query['Ipv4GatewayDescription'] = request.ipv4GatewayDescription;
  }
  if (!Util.isUnset(request.ipv4GatewayId)) {
    query['Ipv4GatewayId'] = request.ipv4GatewayId;
  }
  if (!Util.isUnset(request.ipv4GatewayName)) {
    query['Ipv4GatewayName'] = request.ipv4GatewayName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIpv4GatewayAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIpv4GatewayAttribute(request: UpdateIpv4GatewayAttributeRequest): UpdateIpv4GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpv4GatewayAttributeWithOptions(request, runtime);
}

model UpdateNatGatewayNatTypeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId?: string(name='NatGatewayId'),
  natType?: string(name='NatType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  vSwitchId?: string(name='VSwitchId'),
}

model UpdateNatGatewayNatTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNatGatewayNatTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNatGatewayNatTypeResponseBody(name='body'),
}

async function updateNatGatewayNatTypeWithOptions(request: UpdateNatGatewayNatTypeRequest, runtime: Util.RuntimeOptions): UpdateNatGatewayNatTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.natGatewayId)) {
    query['NatGatewayId'] = request.natGatewayId;
  }
  if (!Util.isUnset(request.natType)) {
    query['NatType'] = request.natType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNatGatewayNatType',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNatGatewayNatType(request: UpdateNatGatewayNatTypeRequest): UpdateNatGatewayNatTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNatGatewayNatTypeWithOptions(request, runtime);
}

model UpdateNetworkAclEntriesRequest {
  clientToken?: string(name='ClientToken'),
  egressAclEntries?: [ 
    {
      description?: string(name='Description'),
      destinationCidrIp?: string(name='DestinationCidrIp'),
      entryType?: string(name='EntryType'),
      networkAclEntryId?: string(name='NetworkAclEntryId'),
      networkAclEntryName?: string(name='NetworkAclEntryName'),
      policy?: string(name='Policy'),
      port?: string(name='Port'),
      protocol?: string(name='Protocol'),
    }
  ](name='EgressAclEntries'),
  ingressAclEntries?: [ 
    {
      description?: string(name='Description'),
      entryType?: string(name='EntryType'),
      networkAclEntryId?: string(name='NetworkAclEntryId'),
      networkAclEntryName?: string(name='NetworkAclEntryName'),
      policy?: string(name='Policy'),
      port?: string(name='Port'),
      protocol?: string(name='Protocol'),
      sourceCidrIp?: string(name='SourceCidrIp'),
    }
  ](name='IngressAclEntries'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  updateEgressAclEntries?: boolean(name='UpdateEgressAclEntries'),
  updateIngressAclEntries?: boolean(name='UpdateIngressAclEntries'),
}

model UpdateNetworkAclEntriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNetworkAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNetworkAclEntriesResponseBody(name='body'),
}

async function updateNetworkAclEntriesWithOptions(request: UpdateNetworkAclEntriesRequest, runtime: Util.RuntimeOptions): UpdateNetworkAclEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.egressAclEntries)) {
    query['EgressAclEntries'] = request.egressAclEntries;
  }
  if (!Util.isUnset(request.ingressAclEntries)) {
    query['IngressAclEntries'] = request.ingressAclEntries;
  }
  if (!Util.isUnset(request.networkAclId)) {
    query['NetworkAclId'] = request.networkAclId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.updateEgressAclEntries)) {
    query['UpdateEgressAclEntries'] = request.updateEgressAclEntries;
  }
  if (!Util.isUnset(request.updateIngressAclEntries)) {
    query['UpdateIngressAclEntries'] = request.updateIngressAclEntries;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNetworkAclEntries',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNetworkAclEntries(request: UpdateNetworkAclEntriesRequest): UpdateNetworkAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNetworkAclEntriesWithOptions(request, runtime);
}

model UpdatePublicIpAddressPoolAttributeRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  dryRun?: boolean(name='DryRun'),
  name?: string(name='Name'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdatePublicIpAddressPoolAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdatePublicIpAddressPoolAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicIpAddressPoolAttributeResponseBody(name='body'),
}

async function updatePublicIpAddressPoolAttributeWithOptions(request: UpdatePublicIpAddressPoolAttributeRequest, runtime: Util.RuntimeOptions): UpdatePublicIpAddressPoolAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.publicIpAddressPoolId)) {
    query['PublicIpAddressPoolId'] = request.publicIpAddressPoolId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicIpAddressPoolAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePublicIpAddressPoolAttribute(request: UpdatePublicIpAddressPoolAttributeRequest): UpdatePublicIpAddressPoolAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePublicIpAddressPoolAttributeWithOptions(request, runtime);
}

model UpdateTrafficMirrorFilterAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterDescription?: string(name='TrafficMirrorFilterDescription'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorFilterName?: string(name='TrafficMirrorFilterName'),
}

model UpdateTrafficMirrorFilterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrafficMirrorFilterAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrafficMirrorFilterAttributeResponseBody(name='body'),
}

async function updateTrafficMirrorFilterAttributeWithOptions(request: UpdateTrafficMirrorFilterAttributeRequest, runtime: Util.RuntimeOptions): UpdateTrafficMirrorFilterAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterDescription)) {
    query['TrafficMirrorFilterDescription'] = request.trafficMirrorFilterDescription;
  }
  if (!Util.isUnset(request.trafficMirrorFilterId)) {
    query['TrafficMirrorFilterId'] = request.trafficMirrorFilterId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterName)) {
    query['TrafficMirrorFilterName'] = request.trafficMirrorFilterName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrafficMirrorFilterAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrafficMirrorFilterAttribute(request: UpdateTrafficMirrorFilterAttributeRequest): UpdateTrafficMirrorFilterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrafficMirrorFilterAttributeWithOptions(request, runtime);
}

model UpdateTrafficMirrorFilterRuleAttributeRequest {
  clientToken?: string(name='ClientToken'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  destinationPortRange?: string(name='DestinationPortRange'),
  dryRun?: boolean(name='DryRun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  protocol?: string(name='Protocol'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleAction?: string(name='RuleAction'),
  sourceCidrBlock?: string(name='SourceCidrBlock'),
  sourcePortRange?: string(name='SourcePortRange'),
  trafficMirrorFilterRuleId?: string(name='TrafficMirrorFilterRuleId'),
}

model UpdateTrafficMirrorFilterRuleAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrafficMirrorFilterRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrafficMirrorFilterRuleAttributeResponseBody(name='body'),
}

async function updateTrafficMirrorFilterRuleAttributeWithOptions(request: UpdateTrafficMirrorFilterRuleAttributeRequest, runtime: Util.RuntimeOptions): UpdateTrafficMirrorFilterRuleAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.destinationCidrBlock)) {
    query['DestinationCidrBlock'] = request.destinationCidrBlock;
  }
  if (!Util.isUnset(request.destinationPortRange)) {
    query['DestinationPortRange'] = request.destinationPortRange;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleAction)) {
    query['RuleAction'] = request.ruleAction;
  }
  if (!Util.isUnset(request.sourceCidrBlock)) {
    query['SourceCidrBlock'] = request.sourceCidrBlock;
  }
  if (!Util.isUnset(request.sourcePortRange)) {
    query['SourcePortRange'] = request.sourcePortRange;
  }
  if (!Util.isUnset(request.trafficMirrorFilterRuleId)) {
    query['TrafficMirrorFilterRuleId'] = request.trafficMirrorFilterRuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrafficMirrorFilterRuleAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrafficMirrorFilterRuleAttribute(request: UpdateTrafficMirrorFilterRuleAttributeRequest): UpdateTrafficMirrorFilterRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrafficMirrorFilterRuleAttributeWithOptions(request, runtime);
}

model UpdateTrafficMirrorSessionAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  enabled?: boolean(name='Enabled'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  priority?: int32(name='Priority'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
  trafficMirrorSessionDescription?: string(name='TrafficMirrorSessionDescription'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
  trafficMirrorSessionName?: string(name='TrafficMirrorSessionName'),
  trafficMirrorTargetId?: string(name='TrafficMirrorTargetId'),
  trafficMirrorTargetType?: string(name='TrafficMirrorTargetType'),
  virtualNetworkId?: int32(name='VirtualNetworkId'),
}

model UpdateTrafficMirrorSessionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrafficMirrorSessionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrafficMirrorSessionAttributeResponseBody(name='body'),
}

async function updateTrafficMirrorSessionAttributeWithOptions(request: UpdateTrafficMirrorSessionAttributeRequest, runtime: Util.RuntimeOptions): UpdateTrafficMirrorSessionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.trafficMirrorFilterId)) {
    query['TrafficMirrorFilterId'] = request.trafficMirrorFilterId;
  }
  if (!Util.isUnset(request.trafficMirrorSessionDescription)) {
    query['TrafficMirrorSessionDescription'] = request.trafficMirrorSessionDescription;
  }
  if (!Util.isUnset(request.trafficMirrorSessionId)) {
    query['TrafficMirrorSessionId'] = request.trafficMirrorSessionId;
  }
  if (!Util.isUnset(request.trafficMirrorSessionName)) {
    query['TrafficMirrorSessionName'] = request.trafficMirrorSessionName;
  }
  if (!Util.isUnset(request.trafficMirrorTargetId)) {
    query['TrafficMirrorTargetId'] = request.trafficMirrorTargetId;
  }
  if (!Util.isUnset(request.trafficMirrorTargetType)) {
    query['TrafficMirrorTargetType'] = request.trafficMirrorTargetType;
  }
  if (!Util.isUnset(request.virtualNetworkId)) {
    query['VirtualNetworkId'] = request.virtualNetworkId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrafficMirrorSessionAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrafficMirrorSessionAttribute(request: UpdateTrafficMirrorSessionAttributeRequest): UpdateTrafficMirrorSessionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrafficMirrorSessionAttributeWithOptions(request, runtime);
}

model UpdateVirtualBorderBandwidthRequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  virtualBorderRouterId?: string(name='VirtualBorderRouterId'),
}

model UpdateVirtualBorderBandwidthResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateVirtualBorderBandwidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVirtualBorderBandwidthResponseBody(name='body'),
}

async function updateVirtualBorderBandwidthWithOptions(request: UpdateVirtualBorderBandwidthRequest, runtime: Util.RuntimeOptions): UpdateVirtualBorderBandwidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.virtualBorderRouterId)) {
    query['VirtualBorderRouterId'] = request.virtualBorderRouterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVirtualBorderBandwidth',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateVirtualBorderBandwidth(request: UpdateVirtualBorderBandwidthRequest): UpdateVirtualBorderBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVirtualBorderBandwidthWithOptions(request, runtime);
}

model UpdateVirtualPhysicalConnectionRequest {
  dryRun?: boolean(name='DryRun'),
  expectSpec?: string(name='ExpectSpec'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  token?: string(name='Token'),
  vlanId?: long(name='VlanId'),
}

model UpdateVirtualPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model UpdateVirtualPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVirtualPhysicalConnectionResponseBody(name='body'),
}

async function updateVirtualPhysicalConnectionWithOptions(request: UpdateVirtualPhysicalConnectionRequest, runtime: Util.RuntimeOptions): UpdateVirtualPhysicalConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.expectSpec)) {
    query['ExpectSpec'] = request.expectSpec;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.vlanId)) {
    query['VlanId'] = request.vlanId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVirtualPhysicalConnection',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateVirtualPhysicalConnection(request: UpdateVirtualPhysicalConnectionRequest): UpdateVirtualPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVirtualPhysicalConnectionWithOptions(request, runtime);
}

model UpdateVpcGatewayEndpointAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointDescription?: string(name='EndpointDescription'),
  endpointId?: string(name='EndpointId'),
  endpointName?: string(name='EndpointName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  policyDocument?: string(name='PolicyDocument'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpdateVpcGatewayEndpointAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateVpcGatewayEndpointAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVpcGatewayEndpointAttributeResponseBody(name='body'),
}

async function updateVpcGatewayEndpointAttributeWithOptions(request: UpdateVpcGatewayEndpointAttributeRequest, runtime: Util.RuntimeOptions): UpdateVpcGatewayEndpointAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endpointDescription)) {
    query['EndpointDescription'] = request.endpointDescription;
  }
  if (!Util.isUnset(request.endpointId)) {
    query['EndpointId'] = request.endpointId;
  }
  if (!Util.isUnset(request.endpointName)) {
    query['EndpointName'] = request.endpointName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.policyDocument)) {
    query['PolicyDocument'] = request.policyDocument;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVpcGatewayEndpointAttribute',
    version = '2016-04-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateVpcGatewayEndpointAttribute(request: UpdateVpcGatewayEndpointAttributeRequest): UpdateVpcGatewayEndpointAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVpcGatewayEndpointAttributeWithOptions(request, runtime);
}

