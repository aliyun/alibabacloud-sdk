import Util;
import RPC;
import EndpointUtil;

extends RPC;

init(config: RPC.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'vpc.aliyuncs.com',
    cn-beijing = 'vpc.aliyuncs.com',
    cn-hangzhou = 'vpc.aliyuncs.com',
    cn-shanghai = 'vpc.aliyuncs.com',
    cn-shenzhen = 'vpc.aliyuncs.com',
    cn-hongkong = 'vpc.aliyuncs.com',
    ap-southeast-1 = 'vpc.aliyuncs.com',
    us-west-1 = 'vpc.aliyuncs.com',
    us-east-1 = 'vpc.aliyuncs.com',
    cn-shanghai-finance-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-finance-1 = 'vpc.aliyuncs.com',
    cn-north-2-gov-1 = 'vpc.aliyuncs.com',
    ap-northeast-2-pop = 'vpc.aliyuncs.com',
    cn-beijing-finance-1 = 'vpc.aliyuncs.com',
    cn-beijing-finance-pop = 'vpc.aliyuncs.com',
    cn-beijing-gov-1 = 'vpc.aliyuncs.com',
    cn-beijing-nu16-b01 = 'vpc.aliyuncs.com',
    cn-edge-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-fujian = 'vpc.aliyuncs.com',
    cn-haidian-cm12-c01 = 'vpc.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'vpc.aliyuncs.com',
    cn-hangzhou-finance = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'vpc.aliyuncs.com',
    cn-hangzhou-test-306 = 'vpc.aliyuncs.com',
    cn-hongkong-finance-pop = 'vpc.aliyuncs.com',
    cn-qingdao-nebula = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-shanghai-et15-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-et2-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-inner = 'vpc.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-inner = 'vpc.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'vpc.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'vpc.aliyuncs.com',
    cn-wuhan = 'vpc.aliyuncs.com',
    cn-yushanfang = 'vpc.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'vpc.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'vpc.cn-zhangjiakou.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    eu-west-1-oxs = 'vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com',
    rus-west-1-pop = 'vpc.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('vpc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

model ListNatGatewayEcsMetricRequest = {
  regionId: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId: string(name='NatGatewayId'),
  timePoint: long(name='TimePoint'),
  orderKey?: string(name='OrderKey'),
  orderType?: string(name='OrderType'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  nextToken?: string(name='NextToken'),
  maxResults?: string(name='MaxResults'),
}

model ListNatGatewayEcsMetricResponse = {
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  maxResults: integer(name='MaxResults'),
  metricDataList: [
    {
      natGatewayId: string(name='NatGatewayId'),
      privateIpAddress: string(name='PrivateIpAddress'),
      timestamp: long(name='Timestamp'),
      activeSessionNum: long(name='ActiveSessionNum'),
      newSessionRate: long(name='NewSessionRate'),
      rxBps: long(name='RxBps'),
      txBps: long(name='TxBps'),
      rxPps: long(name='RxPps'),
      txPps: long(name='TxPps'),
    }
  ](name='MetricDataList'),
}

async function listNatGatewayEcsMetricWithOptions(request: ListNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): ListNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  return doRequest('ListNatGatewayEcsMetric', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function listNatGatewayEcsMetric(request: ListNatGatewayEcsMetricRequest): ListNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNatGatewayEcsMetricWithOptions(request, runtime);
}

model DisableNatGatewayEcsMetricRequest = {
  regionId: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId: string(name='NatGatewayId'),
}

model DisableNatGatewayEcsMetricResponse = {
  requestId: string(name='RequestId'),
}

async function disableNatGatewayEcsMetricWithOptions(request: DisableNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): DisableNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  return doRequest('DisableNatGatewayEcsMetric', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function disableNatGatewayEcsMetric(request: DisableNatGatewayEcsMetricRequest): DisableNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableNatGatewayEcsMetricWithOptions(request, runtime);
}

model EnableNatGatewayEcsMetricRequest = {
  regionId: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
  natGatewayId: string(name='NatGatewayId'),
}

model EnableNatGatewayEcsMetricResponse = {
  requestId: string(name='RequestId'),
}

async function enableNatGatewayEcsMetricWithOptions(request: EnableNatGatewayEcsMetricRequest, runtime: Util.RuntimeOptions): EnableNatGatewayEcsMetricResponse {
  Util.validateModel(request);
  return doRequest('EnableNatGatewayEcsMetric', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function enableNatGatewayEcsMetric(request: EnableNatGatewayEcsMetricRequest): EnableNatGatewayEcsMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableNatGatewayEcsMetricWithOptions(request, runtime);
}

model CreateDhcpOptionsSetRequest = {
  regionId: string(name='RegionId'),
  domainNameServers?: string(name='DomainNameServers'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  domainName?: string(name='DomainName'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model CreateDhcpOptionsSetResponse = {
  requestId: string(name='RequestId'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
}

async function createDhcpOptionsSetWithOptions(request: CreateDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): CreateDhcpOptionsSetResponse {
  Util.validateModel(request);
  return doRequest('CreateDhcpOptionsSet', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createDhcpOptionsSet(request: CreateDhcpOptionsSetRequest): CreateDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDhcpOptionsSetWithOptions(request, runtime);
}

model ReplaceVpcDhcpOptionsSetRequest = {
  regionId: string(name='RegionId'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
  vpcId: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model ReplaceVpcDhcpOptionsSetResponse = {
  requestId: string(name='RequestId'),
}

async function replaceVpcDhcpOptionsSetWithOptions(request: ReplaceVpcDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): ReplaceVpcDhcpOptionsSetResponse {
  Util.validateModel(request);
  return doRequest('ReplaceVpcDhcpOptionsSet', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function replaceVpcDhcpOptionsSet(request: ReplaceVpcDhcpOptionsSetRequest): ReplaceVpcDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceVpcDhcpOptionsSetWithOptions(request, runtime);
}

model UpdateDhcpOptionsSetAttributeRequest = {
  regionId: string(name='RegionId'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
  domainNameServers?: string(name='DomainNameServers'),
  domainName?: string(name='DomainName'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model UpdateDhcpOptionsSetAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function updateDhcpOptionsSetAttributeWithOptions(request: UpdateDhcpOptionsSetAttributeRequest, runtime: Util.RuntimeOptions): UpdateDhcpOptionsSetAttributeResponse {
  Util.validateModel(request);
  return doRequest('UpdateDhcpOptionsSetAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function updateDhcpOptionsSetAttribute(request: UpdateDhcpOptionsSetAttributeRequest): UpdateDhcpOptionsSetAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDhcpOptionsSetAttributeWithOptions(request, runtime);
}

model GetDhcpOptionsSetRequest = {
  regionId: string(name='RegionId'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
}

model GetDhcpOptionsSetResponse = {
  requestId: string(name='RequestId'),
  dhcpOptionsSetName: string(name='DhcpOptionsSetName'),
  dhcpOptionsSetDescription: string(name='DhcpOptionsSetDescription'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
  ownerId: long(name='OwnerId'),
  status: string(name='Status'),
  associateVpcs: [
    {
      vpcId: string(name='VpcId'),
      associateStatus: string(name='AssociateStatus'),
    }
  ](name='AssociateVpcs'),
  dhcpOptions: {
    domainNameServers: string(name='DomainNameServers'),
    domainName: string(name='DomainName'),
  }(name='DhcpOptions'),
}

async function getDhcpOptionsSetWithOptions(request: GetDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): GetDhcpOptionsSetResponse {
  Util.validateModel(request);
  return doRequest('GetDhcpOptionsSet', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function getDhcpOptionsSet(request: GetDhcpOptionsSetRequest): GetDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDhcpOptionsSetWithOptions(request, runtime);
}

model ListDhcpOptionsSetsRequest = {
  regionId: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: integer(name='MaxResults'),
  domainName?: string(name='DomainName'),
  dhcpOptionsSetId?: [ string ](name='DhcpOptionsSetId'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
}

model ListDhcpOptionsSetsResponse = {
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  dhcpOptionsSets: [
    {
      dhcpOptionsSetName: string(name='DhcpOptionsSetName'),
      dhcpOptionsSetDescription: string(name='DhcpOptionsSetDescription'),
      ownerId: long(name='OwnerId'),
      status: string(name='Status'),
      dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
      associateVpcCount: integer(name='AssociateVpcCount'),
      dhcpOptions: {
        domainNameServers: string(name='DomainNameServers'),
        domainName: string(name='DomainName'),
      }(name='DhcpOptions'),
    }
  ](name='DhcpOptionsSets'),
}

async function listDhcpOptionsSetsWithOptions(request: ListDhcpOptionsSetsRequest, runtime: Util.RuntimeOptions): ListDhcpOptionsSetsResponse {
  Util.validateModel(request);
  return doRequest('ListDhcpOptionsSets', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function listDhcpOptionsSets(request: ListDhcpOptionsSetsRequest): ListDhcpOptionsSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDhcpOptionsSetsWithOptions(request, runtime);
}

model DetachDhcpOptionsSetFromVpcRequest = {
  regionId: string(name='RegionId'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
  vpcId: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model DetachDhcpOptionsSetFromVpcResponse = {
  requestId: string(name='RequestId'),
}

async function detachDhcpOptionsSetFromVpcWithOptions(request: DetachDhcpOptionsSetFromVpcRequest, runtime: Util.RuntimeOptions): DetachDhcpOptionsSetFromVpcResponse {
  Util.validateModel(request);
  return doRequest('DetachDhcpOptionsSetFromVpc', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function detachDhcpOptionsSetFromVpc(request: DetachDhcpOptionsSetFromVpcRequest): DetachDhcpOptionsSetFromVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDhcpOptionsSetFromVpcWithOptions(request, runtime);
}

model AttachDhcpOptionsSetToVpcRequest = {
  regionId: string(name='RegionId'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
  vpcId: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model AttachDhcpOptionsSetToVpcResponse = {
  requestId: string(name='RequestId'),
}

async function attachDhcpOptionsSetToVpcWithOptions(request: AttachDhcpOptionsSetToVpcRequest, runtime: Util.RuntimeOptions): AttachDhcpOptionsSetToVpcResponse {
  Util.validateModel(request);
  return doRequest('AttachDhcpOptionsSetToVpc', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function attachDhcpOptionsSetToVpc(request: AttachDhcpOptionsSetToVpcRequest): AttachDhcpOptionsSetToVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDhcpOptionsSetToVpcWithOptions(request, runtime);
}

model DeleteDhcpOptionsSetRequest = {
  regionId: string(name='RegionId'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model DeleteDhcpOptionsSetResponse = {
  requestId: string(name='RequestId'),
}

async function deleteDhcpOptionsSetWithOptions(request: DeleteDhcpOptionsSetRequest, runtime: Util.RuntimeOptions): DeleteDhcpOptionsSetResponse {
  Util.validateModel(request);
  return doRequest('DeleteDhcpOptionsSet', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteDhcpOptionsSet(request: DeleteDhcpOptionsSetRequest): DeleteDhcpOptionsSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDhcpOptionsSetWithOptions(request, runtime);
}

model RenewInstanceRequest = {
  regionId: string(name='RegionId'),
  instanceId: string(name='InstanceId'),
  pricingCycle: string(name='PricingCycle'),
  duration: integer(name='Duration'),
  instanceType: string(name='InstanceType'),
}

model RenewInstanceResponse = {
  requestId: string(name='RequestId'),
  orderId: string(name='OrderId'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  return doRequest('RenewInstance', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstanceWithOptions(request, runtime);
}

model DescribeInstanceAutoRenewAttributeRequest = {
  regionId: string(name='RegionId'),
  instanceId?: string(name='InstanceId'),
  instanceType: string(name='InstanceType'),
  renewalStatus?: string(name='RenewalStatus'),
  pageSize?: integer(name='PageSize'),
  pageNumber?: integer(name='PageNumber'),
}

model DescribeInstanceAutoRenewAttributeResponse = {
  requestId: string(name='RequestId'),
  totalCount: string(name='TotalCount'),
  pageSize: string(name='PageSize'),
  pageNumber: string(name='PageNumber'),
  instanceRenewAttributes: {
    instanceRenewAttribute: [
      {
        instanceId: string(name='InstanceId'),
        renewalStatus: string(name='RenewalStatus'),
        duration: integer(name='Duration'),
        pricingCycle: string(name='PricingCycle'),
      }
    ](name='InstanceRenewAttribute'),
  }(name='InstanceRenewAttributes'),
}

async function describeInstanceAutoRenewAttributeWithOptions(request: DescribeInstanceAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): DescribeInstanceAutoRenewAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeInstanceAutoRenewAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeInstanceAutoRenewAttribute(request: DescribeInstanceAutoRenewAttributeRequest): DescribeInstanceAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAutoRenewAttributeWithOptions(request, runtime);
}

model ModifyInstanceAutoRenewalAttributeRequest = {
  regionId: string(name='RegionId'),
  instanceId: string(name='InstanceId'),
  pricingCycle: string(name='PricingCycle'),
  duration: integer(name='Duration'),
  instanceType: string(name='InstanceType'),
  clientToken?: string(name='ClientToken'),
  renewalStatus?: string(name='RenewalStatus'),
}

model ModifyInstanceAutoRenewalAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyInstanceAutoRenewalAttributeWithOptions(request: ModifyInstanceAutoRenewalAttributeRequest, runtime: Util.RuntimeOptions): ModifyInstanceAutoRenewalAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyInstanceAutoRenewalAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyInstanceAutoRenewalAttribute(request: ModifyInstanceAutoRenewalAttributeRequest): ModifyInstanceAutoRenewalAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAutoRenewalAttributeWithOptions(request, runtime);
}

model ReleaseEipSegmentAddressRequest = {
  regionId: string(name='RegionId'),
  segmentInstanceId: string(name='SegmentInstanceId'),
  clientToken?: string(name='ClientToken'),
}

model ReleaseEipSegmentAddressResponse = {
  requestId: string(name='RequestId'),
}

async function releaseEipSegmentAddressWithOptions(request: ReleaseEipSegmentAddressRequest, runtime: Util.RuntimeOptions): ReleaseEipSegmentAddressResponse {
  Util.validateModel(request);
  return doRequest('ReleaseEipSegmentAddress', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function releaseEipSegmentAddress(request: ReleaseEipSegmentAddressRequest): ReleaseEipSegmentAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseEipSegmentAddressWithOptions(request, runtime);
}

model DescribeEipSegmentRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeEipSegmentResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  eipSegments: {
    eipSegment: [
      {
        instanceId: string(name='InstanceId'),
        segment: string(name='Segment'),
        status: string(name='Status'),
        regionId: string(name='RegionId'),
        ipCount: string(name='IpCount'),
        name: string(name='Name'),
        descritpion: string(name='Descritpion'),
        creationTime: string(name='CreationTime'),
      }
    ](name='EipSegment'),
  }(name='EipSegments'),
}

async function describeEipSegmentWithOptions(request: DescribeEipSegmentRequest, runtime: Util.RuntimeOptions): DescribeEipSegmentResponse {
  Util.validateModel(request);
  return doRequest('DescribeEipSegment', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeEipSegment(request: DescribeEipSegmentRequest): DescribeEipSegmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipSegmentWithOptions(request, runtime);
}

model AllocateEipSegmentAddressRequest = {
  clientToken?: string(name='ClientToken'),
  bandwidth?: string(name='Bandwidth'),
  regionId: string(name='RegionId'),
  eipMask: string(name='EipMask'),
  netmode?: string(name='Netmode'),
  internetChargeType?: string(name='InternetChargeType'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model AllocateEipSegmentAddressResponse = {
  requestId: string(name='RequestId'),
  eipSegmentInstanceId: string(name='EipSegmentInstanceId'),
  orderId: long(name='OrderId'),
}

async function allocateEipSegmentAddressWithOptions(request: AllocateEipSegmentAddressRequest, runtime: Util.RuntimeOptions): AllocateEipSegmentAddressResponse {
  Util.validateModel(request);
  return doRequest('AllocateEipSegmentAddress', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function allocateEipSegmentAddress(request: AllocateEipSegmentAddressRequest): AllocateEipSegmentAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipSegmentAddressWithOptions(request, runtime);
}

model UnassociateVpcCidrBlockRequest = {
  regionId: string(name='RegionId'),
  vpcId: string(name='VpcId'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock'),
}

model UnassociateVpcCidrBlockResponse = {
  requestId: string(name='RequestId'),
}

async function unassociateVpcCidrBlockWithOptions(request: UnassociateVpcCidrBlockRequest, runtime: Util.RuntimeOptions): UnassociateVpcCidrBlockResponse {
  Util.validateModel(request);
  return doRequest('UnassociateVpcCidrBlock', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function unassociateVpcCidrBlock(request: UnassociateVpcCidrBlockRequest): UnassociateVpcCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateVpcCidrBlockWithOptions(request, runtime);
}

model AssociateVpcCidrBlockRequest = {
  regionId: string(name='RegionId'),
  vpcId: string(name='VpcId'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock'),
}

model AssociateVpcCidrBlockResponse = {
  requestId: string(name='RequestId'),
}

async function associateVpcCidrBlockWithOptions(request: AssociateVpcCidrBlockRequest, runtime: Util.RuntimeOptions): AssociateVpcCidrBlockResponse {
  Util.validateModel(request);
  return doRequest('AssociateVpcCidrBlock', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function associateVpcCidrBlock(request: AssociateVpcCidrBlockRequest): AssociateVpcCidrBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateVpcCidrBlockWithOptions(request, runtime);
}

model DescribeRouterInterfaceAttributeRequest = {
  regionId: string(name='RegionId'),
  instanceId: string(name='InstanceId'),
}

model DescribeRouterInterfaceAttributeResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  routerInterfaceId: string(name='RouterInterfaceId'),
  oppositeRegionId: string(name='OppositeRegionId'),
  role: string(name='Role'),
  spec: string(name='Spec'),
  name: string(name='Name'),
  description: string(name='Description'),
  routerId: string(name='RouterId'),
  routerType: string(name='RouterType'),
  creationTime: string(name='CreationTime'),
  gmtModified: string(name='GmtModified'),
  endTime: string(name='EndTime'),
  chargeType: string(name='ChargeType'),
  status: string(name='Status'),
  businessStatus: string(name='BusinessStatus'),
  connectedTime: string(name='ConnectedTime'),
  oppositeInterfaceId: string(name='OppositeInterfaceId'),
  oppositeInterfaceSpec: string(name='OppositeInterfaceSpec'),
  oppositeInterfaceStatus: string(name='OppositeInterfaceStatus'),
  oppositeInterfaceBusinessStatus: string(name='OppositeInterfaceBusinessStatus'),
  oppositeRouterId: string(name='OppositeRouterId'),
  oppositeRouterType: string(name='OppositeRouterType'),
  oppositeInterfaceOwnerId: string(name='OppositeInterfaceOwnerId'),
  accessPointId: string(name='AccessPointId'),
  oppositeAccessPointId: string(name='OppositeAccessPointId'),
  healthCheckSourceIp: string(name='HealthCheckSourceIp'),
  healthCheckTargetIp: string(name='HealthCheckTargetIp'),
  oppositeVpcInstanceId: string(name='OppositeVpcInstanceId'),
  bandwidth: integer(name='Bandwidth'),
  vpcInstanceId: string(name='VpcInstanceId'),
  oppositeBandwidth: integer(name='OppositeBandwidth'),
  hasReservationData: string(name='HasReservationData'),
  reservationBandwidth: string(name='ReservationBandwidth'),
  reservationInternetChargeType: string(name='ReservationInternetChargeType'),
  reservationActiveTime: string(name='ReservationActiveTime'),
  reservationOrderType: string(name='ReservationOrderType'),
  crossBorder: boolean(name='CrossBorder'),
  hcThreshold: integer(name='HcThreshold'),
  hcRate: integer(name='HcRate'),
  healthCheckStatus: string(name='HealthCheckStatus'),
}

async function describeRouterInterfaceAttributeWithOptions(request: DescribeRouterInterfaceAttributeRequest, runtime: Util.RuntimeOptions): DescribeRouterInterfaceAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeRouterInterfaceAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeRouterInterfaceAttribute(request: DescribeRouterInterfaceAttributeRequest): DescribeRouterInterfaceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouterInterfaceAttributeWithOptions(request, runtime);
}

model DeleteExpressCloudConnectionRequest = {
  regionId: string(name='RegionId'),
  eccId: string(name='EccId'),
}

model DeleteExpressCloudConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function deleteExpressCloudConnectionWithOptions(request: DeleteExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): DeleteExpressCloudConnectionResponse {
  Util.validateModel(request);
  return doRequest('DeleteExpressCloudConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteExpressCloudConnection(request: DeleteExpressCloudConnectionRequest): DeleteExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExpressCloudConnectionWithOptions(request, runtime);
}

model CancelExpressCloudConnectionRequest = {
  regionId: string(name='RegionId'),
  eccId: string(name='EccId'),
}

model CancelExpressCloudConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function cancelExpressCloudConnectionWithOptions(request: CancelExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): CancelExpressCloudConnectionResponse {
  Util.validateModel(request);
  return doRequest('CancelExpressCloudConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function cancelExpressCloudConnection(request: CancelExpressCloudConnectionRequest): CancelExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelExpressCloudConnectionWithOptions(request, runtime);
}

model DeletionProtectionRequest = {
  protectionEnable: boolean(name='ProtectionEnable'),
  type: string(name='Type'),
  instanceId: string(name='InstanceId'),
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
}

model DeletionProtectionResponse = {
  requestId: string(name='RequestId'),
}

async function deletionProtectionWithOptions(request: DeletionProtectionRequest, runtime: Util.RuntimeOptions): DeletionProtectionResponse {
  Util.validateModel(request);
  return doRequest('DeletionProtection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deletionProtection(request: DeletionProtectionRequest): DeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletionProtectionWithOptions(request, runtime);
}

model DescribeEipGatewayInfoRequest = {
  instanceId: string(name='InstanceId'),
  regionId: string(name='RegionId'),
}

model DescribeEipGatewayInfoResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  eipInfos: {
    eipInfo: [
      {
        ip: string(name='Ip'),
        ipGw: string(name='IpGw'),
        ipMask: string(name='IpMask'),
      }
    ](name='EipInfo'),
  }(name='EipInfos'),
}

async function describeEipGatewayInfoWithOptions(request: DescribeEipGatewayInfoRequest, runtime: Util.RuntimeOptions): DescribeEipGatewayInfoResponse {
  Util.validateModel(request);
  return doRequest('DescribeEipGatewayInfo', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeEipGatewayInfo(request: DescribeEipGatewayInfoRequest): DescribeEipGatewayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipGatewayInfoWithOptions(request, runtime);
}

model ModifyBgpPeerAttributeRequest = {
  regionId: string(name='RegionId'),
  bgpPeerId: string(name='BgpPeerId'),
  bgpGroupId?: string(name='BgpGroupId'),
  peerIpAddress?: string(name='PeerIpAddress'),
  enableBfd?: boolean(name='EnableBfd'),
  clientToken?: string(name='ClientToken'),
  bfdMultiHop?: integer(name='BfdMultiHop'),
}

model ModifyBgpPeerAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyBgpPeerAttributeWithOptions(request: ModifyBgpPeerAttributeRequest, runtime: Util.RuntimeOptions): ModifyBgpPeerAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyBgpPeerAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyBgpPeerAttribute(request: ModifyBgpPeerAttributeRequest): ModifyBgpPeerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBgpPeerAttributeWithOptions(request, runtime);
}

model DescribeVpnSslServerLogsRequest = {
  regionId: string(name='RegionId'),
  vpnSslServerId: string(name='VpnSslServerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  from?: integer(name='From'),
  to?: integer(name='To'),
  minutePeriod?: integer(name='MinutePeriod'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeVpnSslServerLogsResponse = {
  requestId: string(name='RequestId'),
  count: integer(name='Count'),
  isCompleted: boolean(name='IsCompleted'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  data: {
    logs: [ string ](name='Logs'),
  }(name='Data'),
}

async function describeVpnSslServerLogsWithOptions(request: DescribeVpnSslServerLogsRequest, runtime: Util.RuntimeOptions): DescribeVpnSslServerLogsResponse {
  Util.validateModel(request);
  return doRequest('DescribeVpnSslServerLogs', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVpnSslServerLogs(request: DescribeVpnSslServerLogsRequest): DescribeVpnSslServerLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnSslServerLogsWithOptions(request, runtime);
}

model ModifyExpressCloudConnectionBandwidthRequest = {
  regionId: string(name='RegionId'),
  bandwidth?: string(name='Bandwidth'),
  eccId: string(name='EccId'),
}

model ModifyExpressCloudConnectionBandwidthResponse = {
  requestId: string(name='RequestId'),
}

async function modifyExpressCloudConnectionBandwidthWithOptions(request: ModifyExpressCloudConnectionBandwidthRequest, runtime: Util.RuntimeOptions): ModifyExpressCloudConnectionBandwidthResponse {
  Util.validateModel(request);
  return doRequest('ModifyExpressCloudConnectionBandwidth', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyExpressCloudConnectionBandwidth(request: ModifyExpressCloudConnectionBandwidthRequest): ModifyExpressCloudConnectionBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyExpressCloudConnectionBandwidthWithOptions(request, runtime);
}

model ModifyExpressCloudConnectionAttributeRequest = {
  description?: string(name='Description'),
  regionId: string(name='RegionId'),
  name?: string(name='Name'),
  eccId: string(name='EccId'),
  bgpAs?: string(name='BgpAs'),
  peIp?: string(name='PeIp'),
  ceIp?: string(name='CeIp'),
}

model ModifyExpressCloudConnectionAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyExpressCloudConnectionAttributeWithOptions(request: ModifyExpressCloudConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyExpressCloudConnectionAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyExpressCloudConnectionAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyExpressCloudConnectionAttribute(request: ModifyExpressCloudConnectionAttributeRequest): ModifyExpressCloudConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyExpressCloudConnectionAttributeWithOptions(request, runtime);
}

model DescribeExpressCloudConnectionsRequest = {
  regionId: string(name='RegionId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  filter?: [
    {
      key: string(name='Key'),
      value: [ string ](name='Value'),
    }
  ](name='Filter'),
}

model DescribeExpressCloudConnectionsResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  expressCloudConnectionSet: {
    expressCloudConnectionType: [
      {
        instanceId: string(name='InstanceId'),
        status: string(name='Status'),
        name: string(name='Name'),
        description: string(name='Description'),
        gmtCreate: string(name='GmtCreate'),
        gmtModify: string(name='GmtModify'),
        peerCity: string(name='PeerCity'),
        peerLocation: string(name='PeerLocation'),
        portType: string(name='PortType'),
        bandwidth: integer(name='Bandwidth'),
        distance: integer(name='Distance'),
        redundantEccId: string(name='RedundantEccId'),
        circuitCode: string(name='CircuitCode'),
        isp: string(name='Isp'),
        type: string(name='Type'),
        idcSP: string(name='IdcSP'),
        businessStatus: string(name='BusinessStatus'),
        hasReservationData: string(name='HasReservationData'),
        reservationBandwidth: string(name='ReservationBandwidth'),
        reservationInternetChargeType: string(name='ReservationInternetChargeType'),
        reservationActiveTime: string(name='ReservationActiveTime'),
        reservationOrderType: string(name='ReservationOrderType'),
        applicationType: string(name='ApplicationType'),
        applicationId: string(name='ApplicationId'),
        applicationStatus: string(name='ApplicationStatus'),
        applicationBandwidth: string(name='ApplicationBandwidth'),
        endTime: string(name='EndTime'),
        chargeType: string(name='ChargeType'),
        contactTel: string(name='ContactTel'),
        contactMail: string(name='ContactMail'),
        IDCardNo: string(name='IDCardNo'),
        estimatedTime: string(name='EstimatedTime'),
        bgpAs: string(name='BgpAs'),
        peIp: string(name='PeIp'),
        ceIp: string(name='CeIp'),
        constructionPeriod: string(name='ConstructionPeriod'),
        virtualBorderRouterModels: {
          virtualBorderRouterModel: [
            {
              instanceId: string(name='InstanceId'),
              accessPointId: string(name='AccessPointId'),
              physicalConnectionId: string(name='PhysicalConnectionId'),
            }
          ](name='VirtualBorderRouterModel'),
        }(name='VirtualBorderRouterModels'),
      }
    ](name='ExpressCloudConnectionType'),
  }(name='ExpressCloudConnectionSet'),
}

async function describeExpressCloudConnectionsWithOptions(request: DescribeExpressCloudConnectionsRequest, runtime: Util.RuntimeOptions): DescribeExpressCloudConnectionsResponse {
  Util.validateModel(request);
  return doRequest('DescribeExpressCloudConnections', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeExpressCloudConnections(request: DescribeExpressCloudConnectionsRequest): DescribeExpressCloudConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExpressCloudConnectionsWithOptions(request, runtime);
}

model CreateExpressCloudConnectionRequest = {
  regionId: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  peerCity?: string(name='PeerCity'),
  peerLocation: string(name='PeerLocation'),
  idcSP: string(name='IdcSP'),
  portType?: string(name='PortType'),
  bandwidth: integer(name='Bandwidth'),
  contactTel?: string(name='ContactTel'),
  contactMail?: string(name='ContactMail'),
  IDCardNo?: string(name='IDCardNo'),
  redundantEccId?: string(name='RedundantEccId'),
}

model CreateExpressCloudConnectionResponse = {
  requestId: string(name='RequestId'),
  eccId: string(name='EccId'),
}

async function createExpressCloudConnectionWithOptions(request: CreateExpressCloudConnectionRequest, runtime: Util.RuntimeOptions): CreateExpressCloudConnectionResponse {
  Util.validateModel(request);
  return doRequest('CreateExpressCloudConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createExpressCloudConnection(request: CreateExpressCloudConnectionRequest): CreateExpressCloudConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExpressCloudConnectionWithOptions(request, runtime);
}

model UpdateNetworkAclEntriesRequest = {
  ingressAclEntries?: [
    {
      networkAclEntryName: string(name='NetworkAclEntryName'),
      networkAclEntryId: string(name='NetworkAclEntryId'),
      policy: string(name='Policy'),
      protocol: string(name='Protocol'),
      sourceCidrIp: string(name='SourceCidrIp'),
      port: string(name='Port'),
      entryType: string(name='EntryType'),
      description: string(name='Description'),
    }
  ](name='IngressAclEntries'),
  egressAclEntries?: [
    {
      networkAclEntryName: string(name='NetworkAclEntryName'),
      networkAclEntryId: string(name='NetworkAclEntryId'),
      policy: string(name='Policy'),
      protocol: string(name='Protocol'),
      destinationCidrIp: string(name='DestinationCidrIp'),
      port: string(name='Port'),
      entryType: string(name='EntryType'),
      description: string(name='Description'),
    }
  ](name='EgressAclEntries'),
  updateIngressAclEntries?: boolean(name='UpdateIngressAclEntries'),
  updateEgressAclEntries?: boolean(name='UpdateEgressAclEntries'),
  networkAclId: string(name='NetworkAclId'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model UpdateNetworkAclEntriesResponse = {
  requestId: string(name='RequestId'),
}

async function updateNetworkAclEntriesWithOptions(request: UpdateNetworkAclEntriesRequest, runtime: Util.RuntimeOptions): UpdateNetworkAclEntriesResponse {
  Util.validateModel(request);
  return doRequest('UpdateNetworkAclEntries', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function updateNetworkAclEntries(request: UpdateNetworkAclEntriesRequest): UpdateNetworkAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNetworkAclEntriesWithOptions(request, runtime);
}

model UnassociateNetworkAclRequest = {
  resource?: [
    {
      resourceType: string(name='ResourceType'),
      resourceId: string(name='ResourceId'),
    }
  ](name='Resource'),
  networkAclId: string(name='NetworkAclId'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model UnassociateNetworkAclResponse = {
  requestId: string(name='RequestId'),
}

async function unassociateNetworkAclWithOptions(request: UnassociateNetworkAclRequest, runtime: Util.RuntimeOptions): UnassociateNetworkAclResponse {
  Util.validateModel(request);
  return doRequest('UnassociateNetworkAcl', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function unassociateNetworkAcl(request: UnassociateNetworkAclRequest): UnassociateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateNetworkAclWithOptions(request, runtime);
}

model ModifyNetworkAclAttributesRequest = {
  networkAclId: string(name='NetworkAclId'),
  networkAclName?: string(name='NetworkAclName'),
  description?: string(name='Description'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model ModifyNetworkAclAttributesResponse = {
  requestId: string(name='RequestId'),
}

async function modifyNetworkAclAttributesWithOptions(request: ModifyNetworkAclAttributesRequest, runtime: Util.RuntimeOptions): ModifyNetworkAclAttributesResponse {
  Util.validateModel(request);
  return doRequest('ModifyNetworkAclAttributes', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyNetworkAclAttributes(request: ModifyNetworkAclAttributesRequest): ModifyNetworkAclAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNetworkAclAttributesWithOptions(request, runtime);
}

model DescribeNetworkAclsRequest = {
  networkAclId?: string(name='NetworkAclId'),
  networkAclName?: string(name='NetworkAclName'),
  vpcId?: string(name='VpcId'),
  resourceType?: string(name='ResourceType'),
  resourceId?: string(name='ResourceId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model DescribeNetworkAclsResponse = {
  requestId: string(name='RequestId'),
  totalCount: string(name='TotalCount'),
  pageNumber: string(name='PageNumber'),
  pageSize: string(name='PageSize'),
  networkAcls: {
    networkAcl: [
      {
        networkAclId: string(name='NetworkAclId'),
        regionId: string(name='RegionId'),
        networkAclName: string(name='NetworkAclName'),
        description: string(name='Description'),
        vpcId: string(name='VpcId'),
        creationTime: string(name='CreationTime'),
        status: string(name='Status'),
        ownerId: long(name='OwnerId'),
        ingressAclEntries: {
          ingressAclEntry: [
            {
              networkAclEntryId: string(name='NetworkAclEntryId'),
              policy: string(name='Policy'),
              protocol: string(name='Protocol'),
              sourceCidrIp: string(name='SourceCidrIp'),
              port: string(name='Port'),
              entryType: string(name='EntryType'),
              networkAclEntryName: string(name='NetworkAclEntryName'),
              description: string(name='Description'),
            }
          ](name='IngressAclEntry'),
        }(name='IngressAclEntries'),
        egressAclEntries: {
          egressAclEntry: [
            {
              networkAclEntryId: string(name='NetworkAclEntryId'),
              policy: string(name='Policy'),
              protocol: string(name='Protocol'),
              destinationCidrIp: string(name='DestinationCidrIp'),
              port: string(name='Port'),
              entryType: string(name='EntryType'),
              description: string(name='Description'),
              networkAclEntryName: string(name='NetworkAclEntryName'),
            }
          ](name='EgressAclEntry'),
        }(name='EgressAclEntries'),
        resources: {
          resource: [
            {
              resourceId: string(name='ResourceId'),
              resourceType: string(name='ResourceType'),
              status: string(name='Status'),
            }
          ](name='Resource'),
        }(name='Resources'),
      }
    ](name='NetworkAcl'),
  }(name='NetworkAcls'),
}

async function describeNetworkAclsWithOptions(request: DescribeNetworkAclsRequest, runtime: Util.RuntimeOptions): DescribeNetworkAclsResponse {
  Util.validateModel(request);
  return doRequest('DescribeNetworkAcls', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeNetworkAcls(request: DescribeNetworkAclsRequest): DescribeNetworkAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkAclsWithOptions(request, runtime);
}

model DescribeNetworkAclAttributesRequest = {
  networkAclId: string(name='NetworkAclId'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model DescribeNetworkAclAttributesResponse = {
  requestId: string(name='RequestId'),
  networkAclAttribute: {
    networkAclId: string(name='NetworkAclId'),
    regionId: string(name='RegionId'),
    networkAclName: string(name='NetworkAclName'),
    description: string(name='Description'),
    vpcId: string(name='VpcId'),
    creationTime: string(name='CreationTime'),
    status: string(name='Status'),
    ownerId: long(name='OwnerId'),
    ingressAclEntries: {
      ingressAclEntry: [
        {
          networkAclEntryId: string(name='NetworkAclEntryId'),
          policy: string(name='Policy'),
          protocol: string(name='Protocol'),
          sourceCidrIp: string(name='SourceCidrIp'),
          port: string(name='Port'),
          entryType: string(name='EntryType'),
          networkAclEntryName: string(name='NetworkAclEntryName'),
          description: string(name='Description'),
        }
      ](name='IngressAclEntry'),
    }(name='IngressAclEntries'),
    egressAclEntries: {
      egressAclEntry: [
        {
          networkAclEntryId: string(name='NetworkAclEntryId'),
          policy: string(name='Policy'),
          protocol: string(name='Protocol'),
          destinationCidrIp: string(name='DestinationCidrIp'),
          port: string(name='Port'),
          entryType: string(name='EntryType'),
          description: string(name='Description'),
          networkAclEntryName: string(name='NetworkAclEntryName'),
        }
      ](name='EgressAclEntry'),
    }(name='EgressAclEntries'),
    resources: {
      resource: [
        {
          resourceId: string(name='ResourceId'),
          resourceType: string(name='ResourceType'),
          status: string(name='Status'),
        }
      ](name='Resource'),
    }(name='Resources'),
  }(name='NetworkAclAttribute'),
}

async function describeNetworkAclAttributesWithOptions(request: DescribeNetworkAclAttributesRequest, runtime: Util.RuntimeOptions): DescribeNetworkAclAttributesResponse {
  Util.validateModel(request);
  return doRequest('DescribeNetworkAclAttributes', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeNetworkAclAttributes(request: DescribeNetworkAclAttributesRequest): DescribeNetworkAclAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkAclAttributesWithOptions(request, runtime);
}

model DeleteNetworkAclRequest = {
  networkAclId: string(name='NetworkAclId'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteNetworkAclResponse = {
  requestId: string(name='RequestId'),
}

async function deleteNetworkAclWithOptions(request: DeleteNetworkAclRequest, runtime: Util.RuntimeOptions): DeleteNetworkAclResponse {
  Util.validateModel(request);
  return doRequest('DeleteNetworkAcl', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteNetworkAcl(request: DeleteNetworkAclRequest): DeleteNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNetworkAclWithOptions(request, runtime);
}

model CreateNetworkAclRequest = {
  vpcId: string(name='VpcId'),
  networkAclName?: string(name='NetworkAclName'),
  description?: string(name='Description'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model CreateNetworkAclResponse = {
  requestId: string(name='RequestId'),
  networkAclId: string(name='NetworkAclId'),
  networkAclAttribute: {
    networkAclId: string(name='NetworkAclId'),
    regionId: string(name='RegionId'),
    networkAclName: string(name='NetworkAclName'),
    description: string(name='Description'),
    vpcId: string(name='VpcId'),
    creationTime: string(name='CreationTime'),
    status: string(name='Status'),
    ingressAclEntries: {
      ingressAclEntry: [
        {
          networkAclEntryId: string(name='NetworkAclEntryId'),
          policy: string(name='Policy'),
          protocol: string(name='Protocol'),
          sourceCidrIp: string(name='SourceCidrIp'),
          port: string(name='Port'),
          entryType: string(name='EntryType'),
          networkAclEntryName: string(name='NetworkAclEntryName'),
          description: string(name='Description'),
        }
      ](name='IngressAclEntry'),
    }(name='IngressAclEntries'),
    egressAclEntries: {
      egressAclEntry: [
        {
          networkAclEntryId: string(name='NetworkAclEntryId'),
          policy: string(name='Policy'),
          protocol: string(name='Protocol'),
          destinationCidrIp: string(name='DestinationCidrIp'),
          port: string(name='Port'),
          entryType: string(name='EntryType'),
          description: string(name='Description'),
          networkAclEntryName: string(name='NetworkAclEntryName'),
        }
      ](name='EgressAclEntry'),
    }(name='EgressAclEntries'),
    resources: {
      resource: [
        {
          resourceId: string(name='ResourceId'),
          resourceType: string(name='ResourceType'),
          status: string(name='Status'),
        }
      ](name='Resource'),
    }(name='Resources'),
  }(name='NetworkAclAttribute'),
}

async function createNetworkAclWithOptions(request: CreateNetworkAclRequest, runtime: Util.RuntimeOptions): CreateNetworkAclResponse {
  Util.validateModel(request);
  return doRequest('CreateNetworkAcl', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createNetworkAcl(request: CreateNetworkAclRequest): CreateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNetworkAclWithOptions(request, runtime);
}

model CopyNetworkAclEntriesRequest = {
  regionId: string(name='RegionId'),
  networkAclId: string(name='NetworkAclId'),
  sourceNetworkAclId: string(name='SourceNetworkAclId'),
  clientToken?: string(name='ClientToken'),
}

model CopyNetworkAclEntriesResponse = {
  requestId: string(name='RequestId'),
}

async function copyNetworkAclEntriesWithOptions(request: CopyNetworkAclEntriesRequest, runtime: Util.RuntimeOptions): CopyNetworkAclEntriesResponse {
  Util.validateModel(request);
  return doRequest('CopyNetworkAclEntries', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function copyNetworkAclEntries(request: CopyNetworkAclEntriesRequest): CopyNetworkAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyNetworkAclEntriesWithOptions(request, runtime);
}

model AssociateNetworkAclRequest = {
  resource?: [
    {
      resourceType: string(name='ResourceType'),
      resourceId: string(name='ResourceId'),
    }
  ](name='Resource'),
  networkAclId: string(name='NetworkAclId'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model AssociateNetworkAclResponse = {
  requestId: string(name='RequestId'),
}

async function associateNetworkAclWithOptions(request: AssociateNetworkAclRequest, runtime: Util.RuntimeOptions): AssociateNetworkAclResponse {
  Util.validateModel(request);
  return doRequest('AssociateNetworkAcl', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function associateNetworkAcl(request: AssociateNetworkAclRequest): AssociateNetworkAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateNetworkAclWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageIpBandwidthRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  eipId: string(name='EipId'),
  bandwidth: string(name='Bandwidth'),
}

model ModifyCommonBandwidthPackageIpBandwidthResponse = {
  requestId: string(name='RequestId'),
}

async function modifyCommonBandwidthPackageIpBandwidthWithOptions(request: ModifyCommonBandwidthPackageIpBandwidthRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageIpBandwidthResponse {
  Util.validateModel(request);
  return doRequest('ModifyCommonBandwidthPackageIpBandwidth', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyCommonBandwidthPackageIpBandwidth(request: ModifyCommonBandwidthPackageIpBandwidthRequest): ModifyCommonBandwidthPackageIpBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

model CancelCommonBandwidthPackageIpBandwidthRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  eipId: string(name='EipId'),
}

model CancelCommonBandwidthPackageIpBandwidthResponse = {
  requestId: string(name='RequestId'),
}

async function cancelCommonBandwidthPackageIpBandwidthWithOptions(request: CancelCommonBandwidthPackageIpBandwidthRequest, runtime: Util.RuntimeOptions): CancelCommonBandwidthPackageIpBandwidthResponse {
  Util.validateModel(request);
  return doRequest('CancelCommonBandwidthPackageIpBandwidth', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function cancelCommonBandwidthPackageIpBandwidth(request: CancelCommonBandwidthPackageIpBandwidthRequest): CancelCommonBandwidthPackageIpBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCommonBandwidthPackageIpBandwidthWithOptions(request, runtime);
}

model CreateVpnPbrRouteEntryRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId: string(name='VpnGatewayId'),
  routeSource: string(name='RouteSource'),
  routeDest: string(name='RouteDest'),
  nextHop: string(name='NextHop'),
  weight: integer(name='Weight'),
  publishVpc: boolean(name='PublishVpc'),
  description?: string(name='Description'),
  overlayMode?: string(name='OverlayMode'),
}

model CreateVpnPbrRouteEntryResponse = {
  requestId: string(name='RequestId'),
  vpnInstanceId: string(name='VpnInstanceId'),
  routeSource: string(name='RouteSource'),
  routeDest: string(name='RouteDest'),
  nextHop: string(name='NextHop'),
  weight: integer(name='Weight'),
  overlayMode: string(name='OverlayMode'),
  description: string(name='Description'),
  state: string(name='State'),
  createTime: long(name='CreateTime'),
}

async function createVpnPbrRouteEntryWithOptions(request: CreateVpnPbrRouteEntryRequest, runtime: Util.RuntimeOptions): CreateVpnPbrRouteEntryResponse {
  Util.validateModel(request);
  return doRequest('CreateVpnPbrRouteEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createVpnPbrRouteEntry(request: CreateVpnPbrRouteEntryRequest): CreateVpnPbrRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnPbrRouteEntryWithOptions(request, runtime);
}

model CreateVpnRouteEntryRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId: string(name='VpnGatewayId'),
  routeDest: string(name='RouteDest'),
  nextHop: string(name='NextHop'),
  weight: integer(name='Weight'),
  publishVpc: boolean(name='PublishVpc'),
  description?: string(name='Description'),
  overlayMode?: string(name='OverlayMode'),
}

model CreateVpnRouteEntryResponse = {
  requestId: string(name='RequestId'),
  vpnInstanceId: string(name='VpnInstanceId'),
  routeDest: string(name='RouteDest'),
  nextHop: string(name='NextHop'),
  weight: integer(name='Weight'),
  overlayMode: string(name='OverlayMode'),
  description: string(name='Description'),
  state: string(name='State'),
  createTime: long(name='CreateTime'),
}

async function createVpnRouteEntryWithOptions(request: CreateVpnRouteEntryRequest, runtime: Util.RuntimeOptions): CreateVpnRouteEntryResponse {
  Util.validateModel(request);
  return doRequest('CreateVpnRouteEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createVpnRouteEntry(request: CreateVpnRouteEntryRequest): CreateVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnRouteEntryWithOptions(request, runtime);
}

model DeleteVpnPbrRouteEntryRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId: string(name='VpnGatewayId'),
  routeSource: string(name='RouteSource'),
  routeDest: string(name='RouteDest'),
  nextHop: string(name='NextHop'),
  weight: integer(name='Weight'),
  overlayMode?: string(name='OverlayMode'),
}

model DeleteVpnPbrRouteEntryResponse = {
  requestId: string(name='RequestId'),
}

async function deleteVpnPbrRouteEntryWithOptions(request: DeleteVpnPbrRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteVpnPbrRouteEntryResponse {
  Util.validateModel(request);
  return doRequest('DeleteVpnPbrRouteEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteVpnPbrRouteEntry(request: DeleteVpnPbrRouteEntryRequest): DeleteVpnPbrRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnPbrRouteEntryWithOptions(request, runtime);
}

model DeleteVpnRouteEntryRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId: string(name='VpnGatewayId'),
  routeDest: string(name='RouteDest'),
  nextHop: string(name='NextHop'),
  weight: integer(name='Weight'),
  overlayMode?: string(name='OverlayMode'),
}

model DeleteVpnRouteEntryResponse = {
  requestId: string(name='RequestId'),
}

async function deleteVpnRouteEntryWithOptions(request: DeleteVpnRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteVpnRouteEntryResponse {
  Util.validateModel(request);
  return doRequest('DeleteVpnRouteEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteVpnRouteEntry(request: DeleteVpnRouteEntryRequest): DeleteVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnRouteEntryWithOptions(request, runtime);
}

model DescribeVpnRouteEntriesRequest = {
  regionId: string(name='RegionId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  routeEntryType?: string(name='RouteEntryType'),
}

model DescribeVpnRouteEntriesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  vpnRouteEntries: {
    vpnRouteEntry: [
      {
        vpnInstanceId: string(name='VpnInstanceId'),
        routeDest: string(name='RouteDest'),
        nextHop: string(name='NextHop'),
        weight: integer(name='Weight'),
        createTime: long(name='CreateTime'),
        state: string(name='State'),
        asPath: string(name='AsPath'),
        community: string(name='Community'),
        source: string(name='Source'),
        routeEntryType: string(name='RouteEntryType'),
      }
    ](name='VpnRouteEntry'),
  }(name='VpnRouteEntries'),
}

async function describeVpnRouteEntriesWithOptions(request: DescribeVpnRouteEntriesRequest, runtime: Util.RuntimeOptions): DescribeVpnRouteEntriesResponse {
  Util.validateModel(request);
  return doRequest('DescribeVpnRouteEntries', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVpnRouteEntries(request: DescribeVpnRouteEntriesRequest): DescribeVpnRouteEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnRouteEntriesWithOptions(request, runtime);
}

model DescribeVpnPbrRouteEntriesRequest = {
  regionId: string(name='RegionId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeVpnPbrRouteEntriesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  vpnPbrRouteEntries: {
    vpnPbrRouteEntry: [
      {
        vpnInstanceId: string(name='VpnInstanceId'),
        routeSource: string(name='RouteSource'),
        routeDest: string(name='RouteDest'),
        nextHop: string(name='NextHop'),
        weight: integer(name='Weight'),
        createTime: long(name='CreateTime'),
        state: string(name='State'),
      }
    ](name='VpnPbrRouteEntry'),
  }(name='VpnPbrRouteEntries'),
}

async function describeVpnPbrRouteEntriesWithOptions(request: DescribeVpnPbrRouteEntriesRequest, runtime: Util.RuntimeOptions): DescribeVpnPbrRouteEntriesResponse {
  Util.validateModel(request);
  return doRequest('DescribeVpnPbrRouteEntries', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVpnPbrRouteEntries(request: DescribeVpnPbrRouteEntriesRequest): DescribeVpnPbrRouteEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnPbrRouteEntriesWithOptions(request, runtime);
}

model PublishVpnRouteEntryRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId: string(name='VpnGatewayId'),
  routeDest: string(name='RouteDest'),
  nextHop: string(name='NextHop'),
  routeType: string(name='RouteType'),
  publishVpc: boolean(name='PublishVpc'),
}

model PublishVpnRouteEntryResponse = {
  requestId: string(name='RequestId'),
}

async function publishVpnRouteEntryWithOptions(request: PublishVpnRouteEntryRequest, runtime: Util.RuntimeOptions): PublishVpnRouteEntryResponse {
  Util.validateModel(request);
  return doRequest('PublishVpnRouteEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function publishVpnRouteEntry(request: PublishVpnRouteEntryRequest): PublishVpnRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishVpnRouteEntryWithOptions(request, runtime);
}

model ModifyVpnRouteEntryWeightRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId: string(name='VpnGatewayId'),
  routeDest: string(name='RouteDest'),
  nextHop: string(name='NextHop'),
  weight: integer(name='Weight'),
  newWeight: integer(name='NewWeight'),
  overlayMode?: string(name='OverlayMode'),
}

model ModifyVpnRouteEntryWeightResponse = {
  requestId: string(name='RequestId'),
}

async function modifyVpnRouteEntryWeightWithOptions(request: ModifyVpnRouteEntryWeightRequest, runtime: Util.RuntimeOptions): ModifyVpnRouteEntryWeightResponse {
  Util.validateModel(request);
  return doRequest('ModifyVpnRouteEntryWeight', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyVpnRouteEntryWeight(request: ModifyVpnRouteEntryWeightRequest): ModifyVpnRouteEntryWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnRouteEntryWeightWithOptions(request, runtime);
}

model ModifyVpnPbrRouteEntryWeightRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId: string(name='VpnGatewayId'),
  routeSource: string(name='RouteSource'),
  routeDest: string(name='RouteDest'),
  nextHop: string(name='NextHop'),
  weight: integer(name='Weight'),
  newWeight: integer(name='NewWeight'),
  overlayMode?: string(name='OverlayMode'),
}

model ModifyVpnPbrRouteEntryWeightResponse = {
  requestId: string(name='RequestId'),
}

async function modifyVpnPbrRouteEntryWeightWithOptions(request: ModifyVpnPbrRouteEntryWeightRequest, runtime: Util.RuntimeOptions): ModifyVpnPbrRouteEntryWeightResponse {
  Util.validateModel(request);
  return doRequest('ModifyVpnPbrRouteEntryWeight', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyVpnPbrRouteEntryWeight(request: ModifyVpnPbrRouteEntryWeightRequest): ModifyVpnPbrRouteEntryWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnPbrRouteEntryWeightWithOptions(request, runtime);
}

model DescribePhysicalConnectionLOARequest = {
  regionId: string(name='RegionId', description='description: The ID of the region where the leased line is deployed. ; '),
  clientToken?: string(name='ClientToken', description='description: Optional. The token used for client authentication. ; '),
  instanceId: string(name='InstanceId', description='description: The instance ID of the physical connection interface. ; '),
}

model DescribePhysicalConnectionLOAResponse = {
  requestId: string(name='RequestId', description='description: The ID of the request. ; '),
  physicalConnectionLOAType: {
    instanceId: string(name='InstanceId', description='description: The instance ID of the physical connection interface. ; '),
    companyName: string(name='CompanyName', description='description: The name of the company that requires the leased line. ; '),
    companyLocalizedName: string(name='CompanyLocalizedName', description='description: The company name that you set when you registered your account.; '),
    lineType: string(name='LineType', description='description: The type of the physical connection.Valid values:* MSTP* Other * SDH* MPLSVPN * FIBRE; '),
    lineCode: string(name='LineCode', description='description: The number of leased line.; '),
    lineLabel: string(name='LineLabel', description='description: The label numbers of the cables at the installation site.; '),
    constructionTime: string(name='ConstructionTime', description='description: The time when the the data center cable installation technician or representative will go to the installation site.; '),
    status: string(name='Status', description='description: The status of the physical connection interface. ; '),
    loaUrl: string(name='LoaUrl', description='description: The URL to use to download the LOA file.; '),
    SI: string(name='SI', description='description: The name of the data center cable installation company. ; '),
    PMInfo: {
      PMInfo: [
        {
          PMName: string(name='PMName', description='description: The name of the data center cable installation technician or representative. ; '),
          PMContactInfo: string(name='PMContactInfo', description='description: The contact information of the data center cable installation technician or representative. ; '),
          PMCertificateType: string(name='PMCertificateType', description='description: The type of certificate or licence held by the data center cable installation technician or representative. ; '),
          PMCertificateNo: string(name='PMCertificateNo', description='description: The certificate or licence number of the data center cable installation technician or representative.; '),
          PMGender: string(name='PMGender', description='description: The gender of the data center cable installation technician or representative.; '),
        }
      ](name='PMInfo'),
    }(name='PMInfo', description='description: The information about the data center cable installation technician or representative.'),
  }(name='PhysicalConnectionLOAType', description='description: The LOA information of the physical connection. '),
}

/**
 * DescribePhysicalConnectionLOA Query LOA information about the physical connection.
  * request demo:   * http(s)://[Endpoint]/?InstanceId=pc-bp1ca4wca27exxxxxxxx
  * &RegionId=cn-hangzhou
  * &<CommonParameters>
  * description: 
 */
async function describePhysicalConnectionLOAWithOptions(request: DescribePhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): DescribePhysicalConnectionLOAResponse {
  Util.validateModel(request);
  return doRequest('DescribePhysicalConnectionLOA', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

/**
 * DescribePhysicalConnectionLOA Query LOA information about the physical connection.
  * request demo:   * http(s)://[Endpoint]/?InstanceId=pc-bp1ca4wca27exxxxxxxx
  * &RegionId=cn-hangzhou
  * &<CommonParameters>
  * description: 
 */
async function describePhysicalConnectionLOA(request: DescribePhysicalConnectionLOARequest): DescribePhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePhysicalConnectionLOAWithOptions(request, runtime);
}

model CreatePhysicalConnectionSetupOrderRequest = {
  regionId: string(name='RegionId', description='description: The ID of the region where the leased line is deployed. You can get the region ID by calling the DescribeRegions API.; '),
  accessPointId: string(name='AccessPointId', description='description: The ID of the access point.; '),
  lineOperator: string(name='LineOperator', description='description: The service provider that provides the leased line. Valid values:* CT: China Telecom* CU: China Unicom* CM: China Mobile* CO: Other Chinese service providers* Equinix: Equinix* Other: Other service providers outside Mainland China; '),
  portType?: string(name='PortType', description='description: Optional. The type of the leased line connection port. Valid values:* **100Base-T**: 100M electrical ports* **1000Base-T **(default value): Gigabit electrical ports* **1000Base-LX**: 1000M single-mode optical ports (10 km)* **10GBase-T**: 10GE electrical ports* **10GBase-LR**: 10GE single-mode optical ports (10km) ; '),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId', description='description: The ID of the redundant physical connection. Its status must be **Allocated**,**Confirmed**or** Enabled**. ; '),
  autoPay?: boolean(name='AutoPay', description='description: Optional. Indicates whether to pay the fee automatically.Valid values: **true | false**; '),
  clientToken?: string(name='ClientToken', description='description: Optional. The token used for client authentication.; '),
}

model CreatePhysicalConnectionSetupOrderResponse = {
  requestId: string(name='RequestId', description='description: ; '),
  orderId: string(name='OrderId', description='description: The ID of the order.; '),
  physicalConnectionId: string(name='PhysicalConnectionId'),
}

/**
 * CreatePhysicalConnectionSetupOrder Create an order for the resource fee.
  * request demo:   * http(s)://[Endpoint]/?AccessPointId=ap-cn-beijing-ft-A
  * &LineOperator=CT
  * &RegionId=cn-shanghai
  * &<CommonParameters>
  * description: 
 */
async function createPhysicalConnectionSetupOrderWithOptions(request: CreatePhysicalConnectionSetupOrderRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionSetupOrderResponse {
  Util.validateModel(request);
  return doRequest('CreatePhysicalConnectionSetupOrder', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

/**
 * CreatePhysicalConnectionSetupOrder Create an order for the resource fee.
  * request demo:   * http(s)://[Endpoint]/?AccessPointId=ap-cn-beijing-ft-A
  * &LineOperator=CT
  * &RegionId=cn-shanghai
  * &<CommonParameters>
  * description: 
 */
async function createPhysicalConnectionSetupOrder(request: CreatePhysicalConnectionSetupOrderRequest): CreatePhysicalConnectionSetupOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionSetupOrderWithOptions(request, runtime);
}

model CreatePhysicalConnectionOccupancyOrderRequest = {
  regionId: string(name='RegionId', description='description: The ID of the region where the leased line is deployed.; '),
  physicalConnectionId: string(name='PhysicalConnectionId', description='description: The instance ID of the physical connection interface.; '),
  period?: integer(name='Period', description='description: Optional. The validity period of a Subscription.; '),
  instanceChargeType?: string(name='InstanceChargeType', description='description: Optional. The billing method of the instance. Valid values:* PrePaid: Subscription. If you select this value, you must make sure that your account has enough available funds.* PostPaid (default value): Pay-As-You-Go; '),
  autoPay?: boolean(name='AutoPay', description='description: Optional. Indicates whether to pay automatically. Valid values:* true (default value): Pay automatically. If you select this value, you must ensure that your account has enough available funds. Otherwise, the order that is generated is invalid.* false: Generates the order only. No fee is deducted from your account.; '),
  pricingCycle?: string(name='PricingCycle', description='description: Optional. The Subscription cycle. Valid values:* Month* Year; '),
  clientToken?: string(name='ClientToken', description='description: Optional. The token used for client authentication.; '),
}

model CreatePhysicalConnectionOccupancyOrderResponse = {
  requestId: string(name='RequestId', description='description: The ID of the request.; '),
}

/**
 * CreatePhysicalConnectionOccupancyOrder Create an order for the initial installation fee.
  * request demo:   * http(s)://[Endpoint]/?PhysicalConnectionId=pc-bp1hp0wr072f6ambni141
  * &RegionId=cn-hangzhou
  * &<CommonParameters>
  * description: 
 */
async function createPhysicalConnectionOccupancyOrderWithOptions(request: CreatePhysicalConnectionOccupancyOrderRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionOccupancyOrderResponse {
  Util.validateModel(request);
  return doRequest('CreatePhysicalConnectionOccupancyOrder', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

/**
 * CreatePhysicalConnectionOccupancyOrder Create an order for the initial installation fee.
  * request demo:   * http(s)://[Endpoint]/?PhysicalConnectionId=pc-bp1hp0wr072f6ambni141
  * &RegionId=cn-hangzhou
  * &<CommonParameters>
  * description: 
 */
async function createPhysicalConnectionOccupancyOrder(request: CreatePhysicalConnectionOccupancyOrderRequest): CreatePhysicalConnectionOccupancyOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionOccupancyOrderWithOptions(request, runtime);
}

model CompletePhysicalConnectionLOARequest = {
  clientToken?: string(name='ClientToken', description='description: Optional. The token used for client authentication.; '),
  regionId: string(name='RegionId', description='description: The ID of the region where the leased line is deployed.; '),
  instanceId: string(name='InstanceId', description='description: The instance ID of the physical connection interface.; '),
  lineCode: string(name='LineCode', description='description: The number of the leased line.; '),
  lineLabel: string(name='LineLabel', description='description: The label numbers of cables at the installation site.; '),
}

model CompletePhysicalConnectionLOAResponse = {
  requestId: string(name='RequestId', description='description: The ID of the request.; '),
}

/**
 * CompletePhysicalConnectionLOA Report information about the completed installation of the leased line.
  * request demo:   * http(s)://[Endpoint]/?InstanceId=pc-bp10tvlhnwkwxxxxxxxxxx
  * &LineCode=aaa111
  * &LineLabel=bbb222
  * &RegionId=cn-hangzhou
  * &<CommonParameters>
  * description: 
 */
async function completePhysicalConnectionLOAWithOptions(request: CompletePhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): CompletePhysicalConnectionLOAResponse {
  Util.validateModel(request);
  return doRequest('CompletePhysicalConnectionLOA', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

/**
 * CompletePhysicalConnectionLOA Report information about the completed installation of the leased line.
  * request demo:   * http(s)://[Endpoint]/?InstanceId=pc-bp10tvlhnwkwxxxxxxxxxx
  * &LineCode=aaa111
  * &LineLabel=bbb222
  * &RegionId=cn-hangzhou
  * &<CommonParameters>
  * description: 
 */
async function completePhysicalConnectionLOA(request: CompletePhysicalConnectionLOARequest): CompletePhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return completePhysicalConnectionLOAWithOptions(request, runtime);
}

model ApplyPhysicalConnectionLOARequest = {
  clientToken?: string(name='ClientToken', description='description: Optional. The token used for client authentication.; '),
  regionId: string(name='RegionId', description='description: The ID of the region to which the physical connection interface belongs.; '),
  bandwidth?: integer(name='Bandwidth', description='description: Optional. The bandwidth value of the physical connection.; '),
  peerLocation?: string(name='PeerLocation', description='description: The location where the leased line is deployed.; '),
  instanceId: string(name='InstanceId', description='description: The instance ID of the physical connection interface.; '),
  companyName: string(name='CompanyName', description='description: The name of the company that requires the physical connection.; '),
  lineType: string(name='LineType', description='description: The type of leased line. ; '),
  si: string(name='Si', description='description: The name of the installation company.; '),
  constructionTime: string(name='ConstructionTime', description='description: The date and time when the data cable installation technician or representative will go to the installation site.; '),
  PMInfo?: [
    {
      PMName: string(name='PMName'),
      PMContactInfo: string(name='PMContactInfo'),
      PMCertificateType: string(name='PMCertificateType'),
      PMCertificateNo: string(name='PMCertificateNo'),
      PMGender: string(name='PMGender'),
    }
  ](name='PMInfo'),
}

model ApplyPhysicalConnectionLOAResponse = {
  requestId: string(name='RequestId', description='description: The ID of the request.; '),
}

/**
 * ApplyPhysicalConnectionLOA Apply for the LOA.
  * request demo:   * http(s)://[Endpoint]/?CompanyName=company
  * &ConstructionTime=2019-02-28T16:00:00.000Z
  * &InstanceId=pc-bp1qrb3044eqixxxxxxxx
  * &LineType=SDH
  * &PeerLocation=Hangzhou
  * &RegionId=cn-hangzhou
  * &Si=Alibaba Cloud
  * &<CommonParameters>
  * description: 
 */
async function applyPhysicalConnectionLOAWithOptions(request: ApplyPhysicalConnectionLOARequest, runtime: Util.RuntimeOptions): ApplyPhysicalConnectionLOAResponse {
  Util.validateModel(request);
  return doRequest('ApplyPhysicalConnectionLOA', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

/**
 * ApplyPhysicalConnectionLOA Apply for the LOA.
  * request demo:   * http(s)://[Endpoint]/?CompanyName=company
  * &ConstructionTime=2019-02-28T16:00:00.000Z
  * &InstanceId=pc-bp1qrb3044eqixxxxxxxx
  * &LineType=SDH
  * &PeerLocation=Hangzhou
  * &RegionId=cn-hangzhou
  * &Si=Alibaba Cloud
  * &<CommonParameters>
  * description: 
 */
async function applyPhysicalConnectionLOA(request: ApplyPhysicalConnectionLOARequest): ApplyPhysicalConnectionLOAResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyPhysicalConnectionLOAWithOptions(request, runtime);
}

model ConvertBandwidthPackageRequest = {
  bandwidthPackageId: string(name='BandwidthPackageId'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model ConvertBandwidthPackageResponse = {
  requestId: string(name='RequestId'),
  convertInstanceId: string(name='ConvertInstanceId'),
}

async function convertBandwidthPackageWithOptions(request: ConvertBandwidthPackageRequest, runtime: Util.RuntimeOptions): ConvertBandwidthPackageResponse {
  Util.validateModel(request);
  return doRequest('ConvertBandwidthPackage', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function convertBandwidthPackage(request: ConvertBandwidthPackageRequest): ConvertBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertBandwidthPackageWithOptions(request, runtime);
}

model ModifyRouteEntryRequest = {
  regionId: string(name='RegionId'),
  routeEntryName?: string(name='RouteEntryName'),
  routeEntryId: string(name='RouteEntryId'),
  description?: string(name='Description'),
}

model ModifyRouteEntryResponse = {
  requestId: string(name='RequestId'),
}

async function modifyRouteEntryWithOptions(request: ModifyRouteEntryRequest, runtime: Util.RuntimeOptions): ModifyRouteEntryResponse {
  Util.validateModel(request);
  return doRequest('ModifyRouteEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyRouteEntry(request: ModifyRouteEntryRequest): ModifyRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouteEntryWithOptions(request, runtime);
}

model DescribeRouteEntryListRequest = {
  regionId: string(name='RegionId'),
  routeTableId: string(name='RouteTableId'),
  routeEntryId?: string(name='RouteEntryId'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  routeEntryName?: string(name='RouteEntryName'),
  ipVersion?: string(name='IpVersion'),
  routeEntryType?: string(name='RouteEntryType'),
  nextHopId?: string(name='NextHopId'),
  nextHopType?: string(name='NextHopType'),
  maxResult?: integer(name='MaxResult'),
  nextToken?: string(name='NextToken'),
}

model DescribeRouteEntryListResponse = {
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  routeEntrys: {
    routeEntry: [
      {
        routeTableId: string(name='RouteTableId'),
        destinationCidrBlock: string(name='DestinationCidrBlock'),
        type: string(name='Type'),
        routeEntryId: string(name='RouteEntryId'),
        routeEntryName: string(name='RouteEntryName'),
        description: string(name='Description'),
        status: string(name='Status'),
        ipVersion: string(name='IpVersion'),
        nextHops: {
          nextHop: [
            {
              nextHopType: string(name='NextHopType'),
              nextHopId: string(name='NextHopId'),
              enabled: integer(name='Enabled'),
              weight: integer(name='Weight'),
              nextHopRegionId: string(name='NextHopRegionId'),
              nextHopRelatedInfo: {
                instanceType: string(name='InstanceType'),
                regionId: string(name='RegionId'),
                instanceId: string(name='InstanceId'),
              }(name='NextHopRelatedInfo'),
            }
          ](name='NextHop'),
        }(name='NextHops'),
      }
    ](name='RouteEntry'),
  }(name='RouteEntrys'),
}

async function describeRouteEntryListWithOptions(request: DescribeRouteEntryListRequest, runtime: Util.RuntimeOptions): DescribeRouteEntryListResponse {
  Util.validateModel(request);
  return doRequest('DescribeRouteEntryList', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeRouteEntryList(request: DescribeRouteEntryListRequest): DescribeRouteEntryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteEntryListWithOptions(request, runtime);
}

model CreateIPv6TranslatorAclListRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  aclName: string(name='AclName'),
}

model CreateIPv6TranslatorAclListResponse = {
  requestId: string(name='RequestId'),
  aclId: string(name='AclId'),
}

async function createIPv6TranslatorAclListWithOptions(request: CreateIPv6TranslatorAclListRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorAclListResponse {
  Util.validateModel(request);
  return doRequest('CreateIPv6TranslatorAclList', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createIPv6TranslatorAclList(request: CreateIPv6TranslatorAclListRequest): CreateIPv6TranslatorAclListResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorAclListWithOptions(request, runtime);
}

model DeleteIPv6TranslatorAclListRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  aclId: string(name='AclId'),
}

model DeleteIPv6TranslatorAclListResponse = {
  requestId: string(name='RequestId'),
}

async function deleteIPv6TranslatorAclListWithOptions(request: DeleteIPv6TranslatorAclListRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorAclListResponse {
  Util.validateModel(request);
  return doRequest('DeleteIPv6TranslatorAclList', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteIPv6TranslatorAclList(request: DeleteIPv6TranslatorAclListRequest): DeleteIPv6TranslatorAclListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorAclListWithOptions(request, runtime);
}

model AddIPv6TranslatorAclListEntryRequest = {
  regionId: string(name='RegionId'),
  aclId: string(name='AclId'),
  aclEntryIp: string(name='AclEntryIp'),
  aclEntryComment?: string(name='AclEntryComment'),
}

model AddIPv6TranslatorAclListEntryResponse = {
  requestId: string(name='RequestId'),
  aclEntryId: string(name='AclEntryId'),
}

async function addIPv6TranslatorAclListEntryWithOptions(request: AddIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): AddIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  return doRequest('AddIPv6TranslatorAclListEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function addIPv6TranslatorAclListEntry(request: AddIPv6TranslatorAclListEntryRequest): AddIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model DescribeIPv6TranslatorAclListsRequest = {
  regionId: string(name='RegionId'),
  aclId?: string(name='AclId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  aclName?: string(name='AclName'),
}

model DescribeIPv6TranslatorAclListsResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  ipv6TranslatorAcls: {
    IPv6TranslatorAcl: [
      {
        aclId: string(name='AclId'),
        aclName: string(name='AclName'),
      }
    ](name='IPv6TranslatorAcl'),
  }(name='Ipv6TranslatorAcls'),
}

async function describeIPv6TranslatorAclListsWithOptions(request: DescribeIPv6TranslatorAclListsRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorAclListsResponse {
  Util.validateModel(request);
  return doRequest('DescribeIPv6TranslatorAclLists', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeIPv6TranslatorAclLists(request: DescribeIPv6TranslatorAclListsRequest): DescribeIPv6TranslatorAclListsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorAclListsWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAclAttributeRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  aclId: string(name='AclId'),
  aclName: string(name='AclName'),
}

model ModifyIPv6TranslatorAclAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyIPv6TranslatorAclAttributeWithOptions(request: ModifyIPv6TranslatorAclAttributeRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAclAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyIPv6TranslatorAclAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyIPv6TranslatorAclAttribute(request: ModifyIPv6TranslatorAclAttributeRequest): ModifyIPv6TranslatorAclAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAclAttributeWithOptions(request, runtime);
}

model RemoveIPv6TranslatorAclListEntryRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  aclId: string(name='AclId'),
  aclEntryId: string(name='AclEntryId'),
}

model RemoveIPv6TranslatorAclListEntryResponse = {
  requestId: string(name='RequestId'),
}

async function removeIPv6TranslatorAclListEntryWithOptions(request: RemoveIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): RemoveIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  return doRequest('RemoveIPv6TranslatorAclListEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function removeIPv6TranslatorAclListEntry(request: RemoveIPv6TranslatorAclListEntryRequest): RemoveIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model DescribeIPv6TranslatorAclListAttributesRequest = {
  regionId: string(name='RegionId'),
  aclId: string(name='AclId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeIPv6TranslatorAclListAttributesResponse = {
  requestId: string(name='RequestId'),
  aclId: string(name='AclId'),
  aclName: string(name='AclName'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  aclEntries: {
    aclEntry: [
      {
        aclEntryId: string(name='AclEntryId'),
        aclEntryIp: string(name='AclEntryIp'),
        aclEntryComment: string(name='AclEntryComment'),
      }
    ](name='AclEntry'),
  }(name='AclEntries'),
}

async function describeIPv6TranslatorAclListAttributesWithOptions(request: DescribeIPv6TranslatorAclListAttributesRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorAclListAttributesResponse {
  Util.validateModel(request);
  return doRequest('DescribeIPv6TranslatorAclListAttributes', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeIPv6TranslatorAclListAttributes(request: DescribeIPv6TranslatorAclListAttributesRequest): DescribeIPv6TranslatorAclListAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorAclListAttributesWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAclListEntryRequest = {
  regionId: string(name='RegionId'),
  aclId: string(name='AclId'),
  aclEntryId: string(name='AclEntryId'),
  aclEntryComment: string(name='AclEntryComment'),
}

model ModifyIPv6TranslatorAclListEntryResponse = {
  requestId: string(name='RequestId'),
}

async function modifyIPv6TranslatorAclListEntryWithOptions(request: ModifyIPv6TranslatorAclListEntryRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAclListEntryResponse {
  Util.validateModel(request);
  return doRequest('ModifyIPv6TranslatorAclListEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyIPv6TranslatorAclListEntry(request: ModifyIPv6TranslatorAclListEntryRequest): ModifyIPv6TranslatorAclListEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAclListEntryWithOptions(request, runtime);
}

model UnTagResourcesRequest = {
  resourceType: string(name='ResourceType'),
  resourceId: [ string ](name='ResourceId'),
  tagKey?: [ string ](name='TagKey'),
  regionId: string(name='RegionId'),
  all?: boolean(name='All'),
}

model UnTagResourcesResponse = {
  requestId: string(name='RequestId'),
}

async function unTagResourcesWithOptions(request: UnTagResourcesRequest, runtime: Util.RuntimeOptions): UnTagResourcesResponse {
  Util.validateModel(request);
  return doRequest('UnTagResources', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return unTagResourcesWithOptions(request, runtime);
}

model TagResourcesRequest = {
  resourceType: string(name='ResourceType'),
  resourceId: [ string ](name='ResourceId'),
  tag: [
    {
      key: string(name='Key'),
      value: string(name='Value'),
    }
  ](name='Tag'),
  regionId: string(name='RegionId'),
}

model TagResourcesResponse = {
  requestId: string(name='RequestId'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  return doRequest('TagResources', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model ListTagResourcesRequest = {
  resourceType: string(name='ResourceType'),
  resourceId?: [ string ](name='ResourceId'),
  tag?: [
    {
      key: string(name='Key'),
      value: string(name='Value'),
    }
  ](name='Tag'),
  regionId: string(name='RegionId'),
  nextToken?: string(name='NextToken'),
  maxResults?: integer(name='MaxResults'),
}

model ListTagResourcesResponse = {
  requestId: string(name='RequestId'),
  nextToken: string(name='NextToken'),
  tagResources: {
    tagResource: [
      {
        tagKey: string(name='TagKey'),
        tagValue: string(name='TagValue'),
        resourcId: string(name='ResourcId'),
        resourceType: string(name='ResourceType'),
        resourceId: string(name='ResourceId'),
      }
    ](name='TagResource'),
  }(name='TagResources'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  return doRequest('ListTagResources', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyIpv6InternetBandwidthRequest = {
  regionId: string(name='RegionId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  bandwidth: long(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
}

model ModifyIpv6InternetBandwidthResponse = {
  requestId: string(name='RequestId'),
}

async function modifyIpv6InternetBandwidthWithOptions(request: ModifyIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): ModifyIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  return doRequest('ModifyIpv6InternetBandwidth', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyIpv6InternetBandwidth(request: ModifyIpv6InternetBandwidthRequest): ModifyIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6InternetBandwidthWithOptions(request, runtime);
}

model ModifyIpv6GatewaySpecRequest = {
  regionId: string(name='RegionId'),
  ipv6GatewayId: string(name='Ipv6GatewayId'),
  spec: string(name='Spec'),
  clientToken?: string(name='ClientToken'),
}

model ModifyIpv6GatewaySpecResponse = {
  requestId: string(name='RequestId'),
}

async function modifyIpv6GatewaySpecWithOptions(request: ModifyIpv6GatewaySpecRequest, runtime: Util.RuntimeOptions): ModifyIpv6GatewaySpecResponse {
  Util.validateModel(request);
  return doRequest('ModifyIpv6GatewaySpec', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyIpv6GatewaySpec(request: ModifyIpv6GatewaySpecRequest): ModifyIpv6GatewaySpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6GatewaySpecWithOptions(request, runtime);
}

model ModifyIpv6GatewayAttributeRequest = {
  regionId: string(name='RegionId'),
  ipv6GatewayId: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyIpv6GatewayAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyIpv6GatewayAttributeWithOptions(request: ModifyIpv6GatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyIpv6GatewayAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyIpv6GatewayAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyIpv6GatewayAttribute(request: ModifyIpv6GatewayAttributeRequest): ModifyIpv6GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6GatewayAttributeWithOptions(request, runtime);
}

model ModifyIpv6AddressAttributeRequest = {
  regionId: string(name='RegionId'),
  ipv6AddressId: string(name='Ipv6AddressId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyIpv6AddressAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyIpv6AddressAttributeWithOptions(request: ModifyIpv6AddressAttributeRequest, runtime: Util.RuntimeOptions): ModifyIpv6AddressAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyIpv6AddressAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyIpv6AddressAttribute(request: ModifyIpv6AddressAttributeRequest): ModifyIpv6AddressAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIpv6AddressAttributeWithOptions(request, runtime);
}

model DescribeIpv6GatewaysRequest = {
  regionId: string(name='RegionId'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  vpcId?: string(name='VpcId'),
  name?: string(name='Name'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeIpv6GatewaysResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  ipv6Gateways: {
    ipv6Gateway: [
      {
        regionId: string(name='RegionId'),
        ipv6GatewayId: string(name='Ipv6GatewayId'),
        vpcId: string(name='VpcId'),
        status: string(name='Status'),
        name: string(name='Name'),
        description: string(name='Description'),
        spec: string(name='Spec'),
        instanceChargeType: string(name='InstanceChargeType'),
        businessStatus: string(name='BusinessStatus'),
        expiredTime: string(name='ExpiredTime'),
        creationTime: string(name='CreationTime'),
      }
    ](name='Ipv6Gateway'),
  }(name='Ipv6Gateways'),
}

async function describeIpv6GatewaysWithOptions(request: DescribeIpv6GatewaysRequest, runtime: Util.RuntimeOptions): DescribeIpv6GatewaysResponse {
  Util.validateModel(request);
  return doRequest('DescribeIpv6Gateways', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeIpv6Gateways(request: DescribeIpv6GatewaysRequest): DescribeIpv6GatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6GatewaysWithOptions(request, runtime);
}

model DescribeIpv6GatewayAttributeRequest = {
  regionId: string(name='RegionId'),
  ipv6GatewayId: string(name='Ipv6GatewayId'),
}

model DescribeIpv6GatewayAttributeResponse = {
  requestId: string(name='RequestId'),
  regionId: string(name='RegionId'),
  ipv6GatewayId: string(name='Ipv6GatewayId'),
  vpcId: string(name='VpcId'),
  status: string(name='Status'),
  businessStatus: string(name='BusinessStatus'),
  name: string(name='Name'),
  description: string(name='Description'),
  spec: string(name='Spec'),
  instanceChargeType: string(name='InstanceChargeType'),
  expiredTime: string(name='ExpiredTime'),
  creationTime: string(name='CreationTime'),
}

async function describeIpv6GatewayAttributeWithOptions(request: DescribeIpv6GatewayAttributeRequest, runtime: Util.RuntimeOptions): DescribeIpv6GatewayAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeIpv6GatewayAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeIpv6GatewayAttribute(request: DescribeIpv6GatewayAttributeRequest): DescribeIpv6GatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6GatewayAttributeWithOptions(request, runtime);
}

model DescribeIpv6EgressOnlyRulesRequest = {
  regionId: string(name='RegionId'),
  ipv6GatewayId: string(name='Ipv6GatewayId'),
  ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
  name?: string(name='Name'),
  instanceType?: string(name='InstanceType'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeIpv6EgressOnlyRulesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  ipv6EgressOnlyRules: {
    ipv6EgressOnlyRule: [
      {
        ipv6EgressOnlyRuleId: string(name='Ipv6EgressOnlyRuleId'),
        instanceType: string(name='InstanceType'),
        instanceId: string(name='InstanceId'),
        status: string(name='Status'),
        name: string(name='Name'),
        description: string(name='Description'),
      }
    ](name='Ipv6EgressOnlyRule'),
  }(name='Ipv6EgressOnlyRules'),
}

async function describeIpv6EgressOnlyRulesWithOptions(request: DescribeIpv6EgressOnlyRulesRequest, runtime: Util.RuntimeOptions): DescribeIpv6EgressOnlyRulesResponse {
  Util.validateModel(request);
  return doRequest('DescribeIpv6EgressOnlyRules', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeIpv6EgressOnlyRules(request: DescribeIpv6EgressOnlyRulesRequest): DescribeIpv6EgressOnlyRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6EgressOnlyRulesWithOptions(request, runtime);
}

model DescribeIpv6AddressesRequest = {
  regionId: string(name='RegionId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6Address?: string(name='Ipv6Address'),
  name?: string(name='Name'),
  associatedInstanceId?: string(name='AssociatedInstanceId'),
  associatedInstanceType?: string(name='AssociatedInstanceType'),
  networkType?: string(name='NetworkType'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeIpv6AddressesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  ipv6Addresses: {
    ipv6Address: [
      {
        ipv6AddressId: string(name='Ipv6AddressId'),
        ipv6AddressName: string(name='Ipv6AddressName'),
        vSwitchId: string(name='VSwitchId'),
        vpcId: string(name='VpcId'),
        ipv6GatewayId: string(name='Ipv6GatewayId'),
        ipv6Address: string(name='Ipv6Address'),
        associatedInstanceId: string(name='AssociatedInstanceId'),
        associatedInstanceType: string(name='AssociatedInstanceType'),
        status: string(name='Status'),
        networkType: string(name='NetworkType'),
        realBandwidth: integer(name='RealBandwidth'),
        allocationTime: string(name='AllocationTime'),
        ipv6InternetBandwidth: {
          bandwidth: integer(name='Bandwidth'),
          instanceChargeType: string(name='InstanceChargeType'),
          internetChargeType: string(name='InternetChargeType'),
          businessStatus: string(name='BusinessStatus'),
          ipv6InternetBandwidthId: string(name='Ipv6InternetBandwidthId'),
        }(name='Ipv6InternetBandwidth'),
      }
    ](name='Ipv6Address'),
  }(name='Ipv6Addresses'),
}

async function describeIpv6AddressesWithOptions(request: DescribeIpv6AddressesRequest, runtime: Util.RuntimeOptions): DescribeIpv6AddressesResponse {
  Util.validateModel(request);
  return doRequest('DescribeIpv6Addresses', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeIpv6Addresses(request: DescribeIpv6AddressesRequest): DescribeIpv6AddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpv6AddressesWithOptions(request, runtime);
}

model DeleteIpv6InternetBandwidthRequest = {
  regionId: string(name='RegionId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
}

model DeleteIpv6InternetBandwidthResponse = {
  requestId: string(name='RequestId'),
}

async function deleteIpv6InternetBandwidthWithOptions(request: DeleteIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): DeleteIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  return doRequest('DeleteIpv6InternetBandwidth', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteIpv6InternetBandwidth(request: DeleteIpv6InternetBandwidthRequest): DeleteIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6InternetBandwidthWithOptions(request, runtime);
}

model DeleteIpv6GatewayRequest = {
  regionId: string(name='RegionId'),
  ipv6GatewayId: string(name='Ipv6GatewayId'),
}

model DeleteIpv6GatewayResponse = {
  requestId: string(name='RequestId'),
}

async function deleteIpv6GatewayWithOptions(request: DeleteIpv6GatewayRequest, runtime: Util.RuntimeOptions): DeleteIpv6GatewayResponse {
  Util.validateModel(request);
  return doRequest('DeleteIpv6Gateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteIpv6Gateway(request: DeleteIpv6GatewayRequest): DeleteIpv6GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6GatewayWithOptions(request, runtime);
}

model DeleteIpv6EgressOnlyRuleRequest = {
  regionId: string(name='RegionId'),
  ipv6EgressOnlyRuleId: string(name='Ipv6EgressOnlyRuleId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteIpv6EgressOnlyRuleResponse = {
  requestId: string(name='RequestId'),
}

async function deleteIpv6EgressOnlyRuleWithOptions(request: DeleteIpv6EgressOnlyRuleRequest, runtime: Util.RuntimeOptions): DeleteIpv6EgressOnlyRuleResponse {
  Util.validateModel(request);
  return doRequest('DeleteIpv6EgressOnlyRule', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteIpv6EgressOnlyRule(request: DeleteIpv6EgressOnlyRuleRequest): DeleteIpv6EgressOnlyRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpv6EgressOnlyRuleWithOptions(request, runtime);
}

model CreateIpv6GatewayRequest = {
  regionId: string(name='RegionId'),
  vpcId: string(name='VpcId'),
  spec?: string(name='Spec'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
}

model CreateIpv6GatewayResponse = {
  requestId: string(name='RequestId'),
  ipv6GatewayId: string(name='Ipv6GatewayId'),
}

async function createIpv6GatewayWithOptions(request: CreateIpv6GatewayRequest, runtime: Util.RuntimeOptions): CreateIpv6GatewayResponse {
  Util.validateModel(request);
  return doRequest('CreateIpv6Gateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createIpv6Gateway(request: CreateIpv6GatewayRequest): CreateIpv6GatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv6GatewayWithOptions(request, runtime);
}

model CreateIpv6EgressOnlyRuleRequest = {
  regionId: string(name='RegionId'),
  ipv6GatewayId: string(name='Ipv6GatewayId'),
  instanceId: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
}

model CreateIpv6EgressOnlyRuleResponse = {
  requestId: string(name='RequestId'),
  ipv6EgressRuleId: string(name='Ipv6EgressRuleId'),
}

async function createIpv6EgressOnlyRuleWithOptions(request: CreateIpv6EgressOnlyRuleRequest, runtime: Util.RuntimeOptions): CreateIpv6EgressOnlyRuleResponse {
  Util.validateModel(request);
  return doRequest('CreateIpv6EgressOnlyRule', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createIpv6EgressOnlyRule(request: CreateIpv6EgressOnlyRuleRequest): CreateIpv6EgressOnlyRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpv6EgressOnlyRuleWithOptions(request, runtime);
}

model AllocateIpv6InternetBandwidthRequest = {
  regionId: string(name='RegionId'),
  ipv6GatewayId: string(name='Ipv6GatewayId'),
  ipv6AddressId: string(name='Ipv6AddressId'),
  internetChargeType?: string(name='InternetChargeType'),
  bandwidth: integer(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
}

model AllocateIpv6InternetBandwidthResponse = {
  requestId: string(name='RequestId'),
  ipv6AddressId: string(name='Ipv6AddressId'),
  internetBandwidthId: string(name='InternetBandwidthId'),
}

async function allocateIpv6InternetBandwidthWithOptions(request: AllocateIpv6InternetBandwidthRequest, runtime: Util.RuntimeOptions): AllocateIpv6InternetBandwidthResponse {
  Util.validateModel(request);
  return doRequest('AllocateIpv6InternetBandwidth', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function allocateIpv6InternetBandwidth(request: AllocateIpv6InternetBandwidthRequest): AllocateIpv6InternetBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateIpv6InternetBandwidthWithOptions(request, runtime);
}

model DeleteExpressConnectRequest = {
  regionId: string(name='RegionId'),
  routerInterfaceId: string(name='RouterInterfaceId'),
  force?: boolean(name='Force'),
  clientToken?: string(name='ClientToken'),
}

model DeleteExpressConnectResponse = {
  requestId: string(name='RequestId'),
}

async function deleteExpressConnectWithOptions(request: DeleteExpressConnectRequest, runtime: Util.RuntimeOptions): DeleteExpressConnectResponse {
  Util.validateModel(request);
  return doRequest('DeleteExpressConnect', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteExpressConnect(request: DeleteExpressConnectRequest): DeleteExpressConnectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExpressConnectWithOptions(request, runtime);
}

model CreateIPv6TranslatorRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  spec?: string(name='Spec'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: integer(name='Duration'),
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: integer(name='Bandwidth'),
}

model CreateIPv6TranslatorResponse = {
  requestId: string(name='RequestId'),
  ipv6TranslatorId: string(name='Ipv6TranslatorId'),
  name: string(name='Name'),
  spec: string(name='Spec'),
  orderId: long(name='OrderId'),
}

async function createIPv6TranslatorWithOptions(request: CreateIPv6TranslatorRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorResponse {
  Util.validateModel(request);
  return doRequest('CreateIPv6Translator', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createIPv6Translator(request: CreateIPv6TranslatorRequest): CreateIPv6TranslatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorWithOptions(request, runtime);
}

model DescribeIPv6TranslatorsRequest = {
  regionId: string(name='RegionId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
  allocateIpv4Addr?: string(name='AllocateIpv4Addr'),
  payType?: string(name='PayType'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  businessStatus?: string(name='BusinessStatus'),
}

model DescribeIPv6TranslatorsResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  ipv6Translators: {
    ipv6Translator: [
      {
        ipv6TranslatorId: string(name='Ipv6TranslatorId'),
        createTime: long(name='CreateTime'),
        endTime: long(name='EndTime'),
        spec: string(name='Spec'),
        name: string(name='Name'),
        description: string(name='Description'),
        status: string(name='Status'),
        businessStatus: string(name='BusinessStatus'),
        payType: string(name='PayType'),
        bandwidth: integer(name='Bandwidth'),
        allocateIpv6Addr: string(name='AllocateIpv6Addr'),
        allocateIpv4Addr: string(name='AllocateIpv4Addr'),
        availableBandwidth: string(name='AvailableBandwidth'),
        regionId: string(name='RegionId'),
        ipv6TranslatorEntryIds: {
          ipv6TranslatorEntryId: [ string ](name='Ipv6TranslatorEntryId', description='Ipv6TranslatorEntryId'),
        }(name='Ipv6TranslatorEntryIds'),
      }
    ](name='Ipv6Translator'),
  }(name='Ipv6Translators'),
}

async function describeIPv6TranslatorsWithOptions(request: DescribeIPv6TranslatorsRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorsResponse {
  Util.validateModel(request);
  return doRequest('DescribeIPv6Translators', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeIPv6Translators(request: DescribeIPv6TranslatorsRequest): DescribeIPv6TranslatorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorsWithOptions(request, runtime);
}

model ModifyIPv6TranslatorAttributeRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorId: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyIPv6TranslatorAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyIPv6TranslatorAttributeWithOptions(request: ModifyIPv6TranslatorAttributeRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyIPv6TranslatorAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyIPv6TranslatorAttribute(request: ModifyIPv6TranslatorAttributeRequest): ModifyIPv6TranslatorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorAttributeWithOptions(request, runtime);
}

model ModifyIPv6TranslatorBandwidthRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  ipv6TranslatorId: string(name='Ipv6TranslatorId'),
  bandwidth: integer(name='Bandwidth'),
  autoPay?: boolean(name='AutoPay'),
}

model ModifyIPv6TranslatorBandwidthResponse = {
  requestId: string(name='RequestId'),
  orderId: string(name='OrderId'),
}

async function modifyIPv6TranslatorBandwidthWithOptions(request: ModifyIPv6TranslatorBandwidthRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorBandwidthResponse {
  Util.validateModel(request);
  return doRequest('ModifyIPv6TranslatorBandwidth', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyIPv6TranslatorBandwidth(request: ModifyIPv6TranslatorBandwidthRequest): ModifyIPv6TranslatorBandwidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorBandwidthWithOptions(request, runtime);
}

model CreateIPv6TranslatorEntryRequest = {
  regionId: string(name='RegionId'),
  ipv6TranslatorId: string(name='Ipv6TranslatorId'),
  entryName?: string(name='EntryName'),
  entryDescription?: string(name='EntryDescription'),
  allocateIpv6Port: integer(name='AllocateIpv6Port'),
  backendIpv4Addr: string(name='BackendIpv4Addr'),
  backendIpv4Port: integer(name='BackendIpv4Port'),
  transProtocol: string(name='TransProtocol'),
  entryBandwidth?: integer(name='EntryBandwidth'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  aclId?: string(name='AclId'),
}

model CreateIPv6TranslatorEntryResponse = {
  requestId: string(name='RequestId'),
  ipv6TranslatorEntryId: string(name='Ipv6TranslatorEntryId'),
}

async function createIPv6TranslatorEntryWithOptions(request: CreateIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): CreateIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  return doRequest('CreateIPv6TranslatorEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createIPv6TranslatorEntry(request: CreateIPv6TranslatorEntryRequest): CreateIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIPv6TranslatorEntryWithOptions(request, runtime);
}

model DeleteIPv6TranslatorEntryRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
}

model DeleteIPv6TranslatorEntryResponse = {
  requestId: string(name='RequestId'),
}

async function deleteIPv6TranslatorEntryWithOptions(request: DeleteIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  return doRequest('DeleteIPv6TranslatorEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteIPv6TranslatorEntry(request: DeleteIPv6TranslatorEntryRequest): DeleteIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorEntryWithOptions(request, runtime);
}

model ModifyIPv6TranslatorEntryRequest = {
  regionId: string(name='RegionId'),
  ipv6TranslatorEntryId: string(name='Ipv6TranslatorEntryId'),
  entryName?: string(name='EntryName'),
  entryDescription?: string(name='EntryDescription'),
  allocateIpv6Port?: integer(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: integer(name='BackendIpv4Port'),
  transProtocol?: string(name='TransProtocol'),
  entryBandwidth?: integer(name='EntryBandwidth'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  aclId?: string(name='AclId'),
}

model ModifyIPv6TranslatorEntryResponse = {
  requestId: string(name='RequestId'),
}

async function modifyIPv6TranslatorEntryWithOptions(request: ModifyIPv6TranslatorEntryRequest, runtime: Util.RuntimeOptions): ModifyIPv6TranslatorEntryResponse {
  Util.validateModel(request);
  return doRequest('ModifyIPv6TranslatorEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyIPv6TranslatorEntry(request: ModifyIPv6TranslatorEntryRequest): ModifyIPv6TranslatorEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyIPv6TranslatorEntryWithOptions(request, runtime);
}

model DescribeIPv6TranslatorEntriesRequest = {
  regionId: string(name='RegionId'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  entryName?: string(name='EntryName'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
  allocateIpv6Port?: integer(name='AllocateIpv6Port'),
  backendIpv4Addr?: string(name='BackendIpv4Addr'),
  backendIpv4Port?: integer(name='BackendIpv4Port'),
  transProtocol?: string(name='TransProtocol'),
  aclStatus?: string(name='AclStatus'),
  aclType?: string(name='AclType'),
  aclId?: string(name='AclId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  clientToken?: string(name='ClientToken'),
}

model DescribeIPv6TranslatorEntriesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  ipv6TranslatorEntries: {
    ipv6TranslatorEntry: [
      {
        ipv6TranslatorId: string(name='Ipv6TranslatorId'),
        ipv6TranslatorEntryId: string(name='Ipv6TranslatorEntryId'),
        allocateIpv6Addr: string(name='AllocateIpv6Addr'),
        allocateIpv6Port: integer(name='AllocateIpv6Port'),
        backendIpv4Addr: string(name='BackendIpv4Addr'),
        backendIpv4Port: string(name='BackendIpv4Port'),
        transProtocol: string(name='TransProtocol'),
        entryBandwidth: string(name='EntryBandwidth'),
        entryDescription: string(name='EntryDescription'),
        entryName: string(name='EntryName'),
        entryStatus: string(name='EntryStatus'),
        aclStatus: string(name='AclStatus'),
        aclType: string(name='AclType'),
        aclId: string(name='AclId'),
        regionId: string(name='RegionId'),
      }
    ](name='Ipv6TranslatorEntry'),
  }(name='Ipv6TranslatorEntries'),
}

async function describeIPv6TranslatorEntriesWithOptions(request: DescribeIPv6TranslatorEntriesRequest, runtime: Util.RuntimeOptions): DescribeIPv6TranslatorEntriesResponse {
  Util.validateModel(request);
  return doRequest('DescribeIPv6TranslatorEntries', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeIPv6TranslatorEntries(request: DescribeIPv6TranslatorEntriesRequest): DescribeIPv6TranslatorEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIPv6TranslatorEntriesWithOptions(request, runtime);
}

model DeleteIPv6TranslatorRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  ipv6TranslatorId: string(name='Ipv6TranslatorId'),
}

model DeleteIPv6TranslatorResponse = {
  requestId: string(name='RequestId'),
}

async function deleteIPv6TranslatorWithOptions(request: DeleteIPv6TranslatorRequest, runtime: Util.RuntimeOptions): DeleteIPv6TranslatorResponse {
  Util.validateModel(request);
  return doRequest('DeleteIPv6Translator', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteIPv6Translator(request: DeleteIPv6TranslatorRequest): DeleteIPv6TranslatorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPv6TranslatorWithOptions(request, runtime);
}

model AllocateEipAddressProRequest = {
  regionId: string(name='RegionId'),
  ipAddress?: string(name='IpAddress'),
  instanceId?: string(name='InstanceId'),
  bandwidth?: string(name='Bandwidth'),
  period?: integer(name='Period'),
  ISP?: string(name='ISP'),
  netmode?: string(name='Netmode'),
  autoPay?: boolean(name='AutoPay'),
  pricingCycle?: string(name='PricingCycle'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
}

model AllocateEipAddressProResponse = {
  requestId: string(name='RequestId'),
  allocationId: string(name='AllocationId'),
  eipAddress: string(name='EipAddress'),
  orderId: long(name='OrderId'),
  resourceGroupId: string(name='ResourceGroupId'),
}

async function allocateEipAddressProWithOptions(request: AllocateEipAddressProRequest, runtime: Util.RuntimeOptions): AllocateEipAddressProResponse {
  Util.validateModel(request);
  return doRequest('AllocateEipAddressPro', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function allocateEipAddressPro(request: AllocateEipAddressProRequest): AllocateEipAddressProResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipAddressProWithOptions(request, runtime);
}

model DescribeHighDefinitionMonitorLogAttributeRequest = {
  regionId: string(name='RegionId'),
  instanceId: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
}

model DescribeHighDefinitionMonitorLogAttributeResponse = {
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  instanceId: string(name='InstanceId'),
  instanceType: string(name='InstanceType'),
  logProject: string(name='LogProject'),
  logStore: string(name='LogStore'),
}

async function describeHighDefinitionMonitorLogAttributeWithOptions(request: DescribeHighDefinitionMonitorLogAttributeRequest, runtime: Util.RuntimeOptions): DescribeHighDefinitionMonitorLogAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeHighDefinitionMonitorLogAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeHighDefinitionMonitorLogAttribute(request: DescribeHighDefinitionMonitorLogAttributeRequest): DescribeHighDefinitionMonitorLogAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHighDefinitionMonitorLogAttributeWithOptions(request, runtime);
}

model ModifyFlowLogAttributeRequest = {
  regionId: string(name='RegionId'),
  flowLogId: string(name='FlowLogId'),
  flowLogName?: string(name='FlowLogName'),
  description?: string(name='Description'),
}

model ModifyFlowLogAttributeResponse = {
  requestId: string(name='RequestId'),
  success: string(name='Success'),
}

async function modifyFlowLogAttributeWithOptions(request: ModifyFlowLogAttributeRequest, runtime: Util.RuntimeOptions): ModifyFlowLogAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyFlowLogAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyFlowLogAttribute(request: ModifyFlowLogAttributeRequest): ModifyFlowLogAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowLogAttributeWithOptions(request, runtime);
}

model DescribeFlowLogsRequest = {
  regionId: string(name='RegionId'),
  flowLogName?: string(name='FlowLogName'),
  flowLogId?: string(name='FlowLogId'),
  description?: string(name='Description'),
  resourceType?: string(name='ResourceType'),
  resourceId?: string(name='ResourceId'),
  trafficType?: string(name='TrafficType'),
  projectName?: string(name='ProjectName'),
  logStoreName?: string(name='LogStoreName'),
  status?: string(name='Status'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  vpcId?: string(name='VpcId'),
}

model DescribeFlowLogsResponse = {
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  totalCount: string(name='TotalCount'),
  pageNumber: string(name='PageNumber'),
  pageSize: string(name='PageSize'),
  flowLogs: {
    flowLog: [
      {
        flowLogId: string(name='FlowLogId'),
        flowLogName: string(name='FlowLogName'),
        description: string(name='Description'),
        creationTime: string(name='CreationTime'),
        resourceType: string(name='ResourceType'),
        resourceId: string(name='ResourceId'),
        projectName: string(name='ProjectName'),
        logStoreName: string(name='LogStoreName'),
        status: string(name='Status'),
        trafficType: string(name='TrafficType'),
        regionId: string(name='RegionId'),
      }
    ](name='FlowLog'),
  }(name='FlowLogs'),
}

async function describeFlowLogsWithOptions(request: DescribeFlowLogsRequest, runtime: Util.RuntimeOptions): DescribeFlowLogsResponse {
  Util.validateModel(request);
  return doRequest('DescribeFlowLogs', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeFlowLogs(request: DescribeFlowLogsRequest): DescribeFlowLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowLogsWithOptions(request, runtime);
}

model DeleteFlowLogRequest = {
  regionId: string(name='RegionId'),
  flowLogId: string(name='FlowLogId'),
}

model DeleteFlowLogResponse = {
  requestId: string(name='RequestId'),
  success: string(name='Success'),
}

async function deleteFlowLogWithOptions(request: DeleteFlowLogRequest, runtime: Util.RuntimeOptions): DeleteFlowLogResponse {
  Util.validateModel(request);
  return doRequest('DeleteFlowLog', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteFlowLog(request: DeleteFlowLogRequest): DeleteFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowLogWithOptions(request, runtime);
}

model DeactiveFlowLogRequest = {
  regionId: string(name='RegionId'),
  flowLogId: string(name='FlowLogId'),
}

model DeactiveFlowLogResponse = {
  requestId: string(name='RequestId'),
  success: string(name='Success'),
}

async function deactiveFlowLogWithOptions(request: DeactiveFlowLogRequest, runtime: Util.RuntimeOptions): DeactiveFlowLogResponse {
  Util.validateModel(request);
  return doRequest('DeactiveFlowLog', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deactiveFlowLog(request: DeactiveFlowLogRequest): DeactiveFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactiveFlowLogWithOptions(request, runtime);
}

model CreateFlowLogRequest = {
  regionId: string(name='RegionId'),
  flowLogName?: string(name='FlowLogName'),
  description?: string(name='Description'),
  resourceType: string(name='ResourceType'),
  resourceId: string(name='ResourceId'),
  trafficType: string(name='TrafficType'),
  projectName: string(name='ProjectName'),
  logStoreName: string(name='LogStoreName'),
}

model CreateFlowLogResponse = {
  requestId: string(name='RequestId'),
  success: string(name='Success'),
  flowLogId: string(name='FlowLogId'),
}

async function createFlowLogWithOptions(request: CreateFlowLogRequest, runtime: Util.RuntimeOptions): CreateFlowLogResponse {
  Util.validateModel(request);
  return doRequest('CreateFlowLog', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createFlowLog(request: CreateFlowLogRequest): CreateFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowLogWithOptions(request, runtime);
}

model ActiveFlowLogRequest = {
  regionId: string(name='RegionId'),
  flowLogId: string(name='FlowLogId'),
}

model ActiveFlowLogResponse = {
  requestId: string(name='RequestId'),
  success: string(name='Success'),
}

async function activeFlowLogWithOptions(request: ActiveFlowLogRequest, runtime: Util.RuntimeOptions): ActiveFlowLogResponse {
  Util.validateModel(request);
  return doRequest('ActiveFlowLog', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function activeFlowLog(request: ActiveFlowLogRequest): ActiveFlowLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return activeFlowLogWithOptions(request, runtime);
}

model UnassociateRouteTableRequest = {
  regionId: string(name='RegionId'),
  routeTableId: string(name='RouteTableId'),
  vSwitchId: string(name='VSwitchId'),
  clientToken?: string(name='ClientToken'),
}

model UnassociateRouteTableResponse = {
  requestId: string(name='RequestId'),
}

async function unassociateRouteTableWithOptions(request: UnassociateRouteTableRequest, runtime: Util.RuntimeOptions): UnassociateRouteTableResponse {
  Util.validateModel(request);
  return doRequest('UnassociateRouteTable', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function unassociateRouteTable(request: UnassociateRouteTableRequest): UnassociateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateRouteTableWithOptions(request, runtime);
}

model DeleteRouteTableRequest = {
  regionId: string(name='RegionId'),
  routeTableId: string(name='RouteTableId'),
}

model DeleteRouteTableResponse = {
  requestId: string(name='RequestId'),
}

async function deleteRouteTableWithOptions(request: DeleteRouteTableRequest, runtime: Util.RuntimeOptions): DeleteRouteTableResponse {
  Util.validateModel(request);
  return doRequest('DeleteRouteTable', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteRouteTable(request: DeleteRouteTableRequest): DeleteRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouteTableWithOptions(request, runtime);
}

model CreateRouteTableRequest = {
  regionId: string(name='RegionId'),
  vpcId: string(name='VpcId'),
  routeTableName?: string(name='RouteTableName'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
}

model CreateRouteTableResponse = {
  requestId: string(name='RequestId'),
  routeTableId: string(name='RouteTableId'),
}

async function createRouteTableWithOptions(request: CreateRouteTableRequest, runtime: Util.RuntimeOptions): CreateRouteTableResponse {
  Util.validateModel(request);
  return doRequest('CreateRouteTable', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createRouteTable(request: CreateRouteTableRequest): CreateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouteTableWithOptions(request, runtime);
}

model AssociateRouteTableRequest = {
  regionId: string(name='RegionId'),
  routeTableId: string(name='RouteTableId'),
  vSwitchId: string(name='VSwitchId'),
  clientToken?: string(name='ClientToken'),
}

model AssociateRouteTableResponse = {
  requestId: string(name='RequestId'),
}

async function associateRouteTableWithOptions(request: AssociateRouteTableRequest, runtime: Util.RuntimeOptions): AssociateRouteTableResponse {
  Util.validateModel(request);
  return doRequest('AssociateRouteTable', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function associateRouteTable(request: AssociateRouteTableRequest): AssociateRouteTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateRouteTableWithOptions(request, runtime);
}

model CreateVpnGatewayRequest = {
  regionId: string(name='RegionId'),
  name?: string(name='Name'),
  vpcId: string(name='VpcId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  period?: integer(name='Period'),
  autoPay?: boolean(name='AutoPay'),
  bandwidth: integer(name='Bandwidth'),
  enableIpsec?: boolean(name='EnableIpsec'),
  enableSsl?: boolean(name='EnableSsl'),
  sslConnections?: integer(name='SslConnections'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateVpnGatewayResponse = {
  requestId: string(name='RequestId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  name: string(name='Name'),
  orderId: long(name='OrderId'),
}

async function createVpnGatewayWithOptions(request: CreateVpnGatewayRequest, runtime: Util.RuntimeOptions): CreateVpnGatewayResponse {
  Util.validateModel(request);
  return doRequest('CreateVpnGateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createVpnGateway(request: CreateVpnGatewayRequest): CreateVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnGatewayWithOptions(request, runtime);
}

model MoveResourceGroupRequest = {
  resourceId: string(name='ResourceId'),
  resourceType: string(name='ResourceType'),
  newResourceGroupId: string(name='NewResourceGroupId'),
  regionId: string(name='RegionId'),
}

model MoveResourceGroupResponse = {
  requestId: string(name='RequestId'),
}

async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  return doRequest('MoveResourceGroup', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model RevokeInstanceFromCenRequest = {
  regionId: string(name='RegionId'),
  instanceId: string(name='InstanceId'),
  instanceType: string(name='InstanceType'),
  cenId: string(name='CenId'),
  cenOwnerId: long(name='CenOwnerId'),
  clientToken?: string(name='ClientToken'),
}

model RevokeInstanceFromCenResponse = {
  requestId: string(name='RequestId'),
}

async function revokeInstanceFromCenWithOptions(request: RevokeInstanceFromCenRequest, runtime: Util.RuntimeOptions): RevokeInstanceFromCenResponse {
  Util.validateModel(request);
  return doRequest('RevokeInstanceFromCen', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function revokeInstanceFromCen(request: RevokeInstanceFromCenRequest): RevokeInstanceFromCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeInstanceFromCenWithOptions(request, runtime);
}

model GrantInstanceToCenRequest = {
  regionId: string(name='RegionId'),
  instanceId: string(name='InstanceId'),
  instanceType: string(name='InstanceType'),
  cenId: string(name='CenId'),
  cenOwnerId: long(name='CenOwnerId'),
  clientToken?: string(name='ClientToken'),
}

model GrantInstanceToCenResponse = {
  requestId: string(name='RequestId'),
}

async function grantInstanceToCenWithOptions(request: GrantInstanceToCenRequest, runtime: Util.RuntimeOptions): GrantInstanceToCenResponse {
  Util.validateModel(request);
  return doRequest('GrantInstanceToCen', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function grantInstanceToCen(request: GrantInstanceToCenRequest): GrantInstanceToCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantInstanceToCenWithOptions(request, runtime);
}

model DescribeGrantRulesToCenRequest = {
  regionId: string(name='RegionId'),
  instanceId: string(name='InstanceId'),
  instanceType: string(name='InstanceType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
}

model DescribeGrantRulesToCenResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  cenGrantRules: {
    cbnGrantRule: [
      {
        cenInstanceId: string(name='CenInstanceId'),
        cenOwnerId: long(name='CenOwnerId'),
        creationTime: string(name='CreationTime'),
      }
    ](name='CbnGrantRule'),
  }(name='CenGrantRules'),
}

async function describeGrantRulesToCenWithOptions(request: DescribeGrantRulesToCenRequest, runtime: Util.RuntimeOptions): DescribeGrantRulesToCenResponse {
  Util.validateModel(request);
  return doRequest('DescribeGrantRulesToCen', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeGrantRulesToCen(request: DescribeGrantRulesToCenRequest): DescribeGrantRulesToCenResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGrantRulesToCenWithOptions(request, runtime);
}

model ModifySslVpnServerRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  sslVpnServerId: string(name='SslVpnServerId'),
  name?: string(name='Name'),
  clientIpPool?: string(name='ClientIpPool'),
  localSubnet?: string(name='LocalSubnet'),
  proto?: string(name='Proto'),
  cipher?: string(name='Cipher'),
  port?: integer(name='Port'),
  compress?: boolean(name='Compress'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
}

model ModifySslVpnServerResponse = {
  requestId: string(name='RequestId'),
  regionId: string(name='RegionId'),
  sslVpnServerId: string(name='SslVpnServerId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  name: string(name='Name'),
  localSubnet: string(name='LocalSubnet'),
  clientIpPool: string(name='ClientIpPool'),
  createTime: long(name='CreateTime'),
  cipher: string(name='Cipher'),
  proto: string(name='Proto'),
  port: integer(name='Port'),
  compress: boolean(name='Compress'),
  connections: integer(name='Connections'),
  maxConnections: integer(name='MaxConnections'),
  internetIp: string(name='InternetIp'),
  enableMultiFactorAuth: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId: string(name='IDaaSInstanceId'),
}

async function modifySslVpnServerWithOptions(request: ModifySslVpnServerRequest, runtime: Util.RuntimeOptions): ModifySslVpnServerResponse {
  Util.validateModel(request);
  return doRequest('ModifySslVpnServer', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifySslVpnServer(request: ModifySslVpnServerRequest): ModifySslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySslVpnServerWithOptions(request, runtime);
}

model ModifySslVpnClientCertRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  sslVpnClientCertId: string(name='SslVpnClientCertId'),
  name?: string(name='Name'),
}

model ModifySslVpnClientCertResponse = {
  requestId: string(name='RequestId'),
  name: string(name='Name'),
  sslVpnClientCertId: string(name='SslVpnClientCertId'),
}

async function modifySslVpnClientCertWithOptions(request: ModifySslVpnClientCertRequest, runtime: Util.RuntimeOptions): ModifySslVpnClientCertResponse {
  Util.validateModel(request);
  return doRequest('ModifySslVpnClientCert', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifySslVpnClientCert(request: ModifySslVpnClientCertRequest): ModifySslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySslVpnClientCertWithOptions(request, runtime);
}

model DescribeSslVpnServersRequest = {
  regionId: string(name='RegionId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  name?: string(name='Name'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeSslVpnServersResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  sslVpnServers: {
    sslVpnServer: [
      {
        regionId: string(name='RegionId'),
        sslVpnServerId: string(name='SslVpnServerId'),
        vpnGatewayId: string(name='VpnGatewayId'),
        name: string(name='Name'),
        localSubnet: string(name='LocalSubnet'),
        clientIpPool: string(name='ClientIpPool'),
        createTime: long(name='CreateTime'),
        cipher: string(name='Cipher'),
        proto: string(name='Proto'),
        port: integer(name='Port'),
        compress: boolean(name='Compress'),
        connections: integer(name='Connections'),
        maxConnections: integer(name='MaxConnections'),
        internetIp: string(name='InternetIp'),
        enableMultiFactorAuth: boolean(name='EnableMultiFactorAuth'),
        IDaaSInstanceId: string(name='IDaaSInstanceId'),
      }
    ](name='SslVpnServer'),
  }(name='SslVpnServers'),
}

async function describeSslVpnServersWithOptions(request: DescribeSslVpnServersRequest, runtime: Util.RuntimeOptions): DescribeSslVpnServersResponse {
  Util.validateModel(request);
  return doRequest('DescribeSslVpnServers', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeSslVpnServers(request: DescribeSslVpnServersRequest): DescribeSslVpnServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnServersWithOptions(request, runtime);
}

model DescribeSslVpnClientCertsRequest = {
  regionId: string(name='RegionId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  name?: string(name='Name'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeSslVpnClientCertsResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  sslVpnClientCertKeys: {
    sslVpnClientCertKey: [
      {
        regionId: string(name='RegionId'),
        sslVpnClientCertId: string(name='SslVpnClientCertId'),
        name: string(name='Name'),
        sslVpnServerId: string(name='SslVpnServerId'),
        createTime: long(name='CreateTime'),
        endTime: long(name='EndTime'),
        status: string(name='Status'),
      }
    ](name='SslVpnClientCertKey'),
  }(name='SslVpnClientCertKeys'),
}

async function describeSslVpnClientCertsWithOptions(request: DescribeSslVpnClientCertsRequest, runtime: Util.RuntimeOptions): DescribeSslVpnClientCertsResponse {
  Util.validateModel(request);
  return doRequest('DescribeSslVpnClientCerts', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeSslVpnClientCerts(request: DescribeSslVpnClientCertsRequest): DescribeSslVpnClientCertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnClientCertsWithOptions(request, runtime);
}

model DescribeSslVpnClientCertRequest = {
  regionId: string(name='RegionId'),
  sslVpnClientCertId: string(name='SslVpnClientCertId'),
}

model DescribeSslVpnClientCertResponse = {
  requestId: string(name='RequestId'),
  regionId: string(name='RegionId'),
  sslVpnClientCertId: string(name='SslVpnClientCertId'),
  name: string(name='Name'),
  sslVpnServerId: string(name='SslVpnServerId'),
  caCert: string(name='CaCert'),
  clientCert: string(name='ClientCert'),
  clientKey: string(name='ClientKey'),
  clientConfig: string(name='ClientConfig'),
  createTime: long(name='CreateTime'),
  endTime: long(name='EndTime'),
  status: string(name='Status'),
}

async function describeSslVpnClientCertWithOptions(request: DescribeSslVpnClientCertRequest, runtime: Util.RuntimeOptions): DescribeSslVpnClientCertResponse {
  Util.validateModel(request);
  return doRequest('DescribeSslVpnClientCert', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeSslVpnClientCert(request: DescribeSslVpnClientCertRequest): DescribeSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSslVpnClientCertWithOptions(request, runtime);
}

model DeleteSslVpnServerRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  sslVpnServerId: string(name='SslVpnServerId'),
}

model DeleteSslVpnServerResponse = {
  requestId: string(name='RequestId'),
}

async function deleteSslVpnServerWithOptions(request: DeleteSslVpnServerRequest, runtime: Util.RuntimeOptions): DeleteSslVpnServerResponse {
  Util.validateModel(request);
  return doRequest('DeleteSslVpnServer', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteSslVpnServer(request: DeleteSslVpnServerRequest): DeleteSslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSslVpnServerWithOptions(request, runtime);
}

model DeleteSslVpnClientCertRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  sslVpnClientCertId: string(name='SslVpnClientCertId'),
}

model DeleteSslVpnClientCertResponse = {
  requestId: string(name='RequestId'),
}

async function deleteSslVpnClientCertWithOptions(request: DeleteSslVpnClientCertRequest, runtime: Util.RuntimeOptions): DeleteSslVpnClientCertResponse {
  Util.validateModel(request);
  return doRequest('DeleteSslVpnClientCert', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteSslVpnClientCert(request: DeleteSslVpnClientCertRequest): DeleteSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSslVpnClientCertWithOptions(request, runtime);
}

model CreateSslVpnServerRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  name?: string(name='Name'),
  clientIpPool: string(name='ClientIpPool'),
  localSubnet: string(name='LocalSubnet'),
  proto?: string(name='Proto'),
  cipher?: string(name='Cipher'),
  port?: integer(name='Port'),
  compress?: boolean(name='Compress'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  IDaaSInstanceId?: string(name='IDaaSInstanceId'),
}

model CreateSslVpnServerResponse = {
  requestId: string(name='RequestId'),
  sslVpnServerId: string(name='SslVpnServerId'),
  name: string(name='Name'),
}

async function createSslVpnServerWithOptions(request: CreateSslVpnServerRequest, runtime: Util.RuntimeOptions): CreateSslVpnServerResponse {
  Util.validateModel(request);
  return doRequest('CreateSslVpnServer', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createSslVpnServer(request: CreateSslVpnServerRequest): CreateSslVpnServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSslVpnServerWithOptions(request, runtime);
}

model CreateSslVpnClientCertRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  sslVpnServerId: string(name='SslVpnServerId'),
  name?: string(name='Name'),
}

model CreateSslVpnClientCertResponse = {
  requestId: string(name='RequestId'),
  name: string(name='Name'),
  sslVpnClientCertId: string(name='SslVpnClientCertId'),
}

async function createSslVpnClientCertWithOptions(request: CreateSslVpnClientCertRequest, runtime: Util.RuntimeOptions): CreateSslVpnClientCertResponse {
  Util.validateModel(request);
  return doRequest('CreateSslVpnClientCert', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createSslVpnClientCert(request: CreateSslVpnClientCertRequest): CreateSslVpnClientCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSslVpnClientCertWithOptions(request, runtime);
}

model RemoveGlobalAccelerationInstanceIpRequest = {
  regionId: string(name='RegionId'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
  ipInstanceId: string(name='IpInstanceId'),
}

model RemoveGlobalAccelerationInstanceIpResponse = {
  requestId: string(name='RequestId'),
}

async function removeGlobalAccelerationInstanceIpWithOptions(request: RemoveGlobalAccelerationInstanceIpRequest, runtime: Util.RuntimeOptions): RemoveGlobalAccelerationInstanceIpResponse {
  Util.validateModel(request);
  return doRequest('RemoveGlobalAccelerationInstanceIp', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function removeGlobalAccelerationInstanceIp(request: RemoveGlobalAccelerationInstanceIpRequest): RemoveGlobalAccelerationInstanceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

model AddGlobalAccelerationInstanceIpRequest = {
  regionId: string(name='RegionId'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
  ipInstanceId: string(name='IpInstanceId'),
}

model AddGlobalAccelerationInstanceIpResponse = {
  requestId: string(name='RequestId'),
}

async function addGlobalAccelerationInstanceIpWithOptions(request: AddGlobalAccelerationInstanceIpRequest, runtime: Util.RuntimeOptions): AddGlobalAccelerationInstanceIpResponse {
  Util.validateModel(request);
  return doRequest('AddGlobalAccelerationInstanceIp', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function addGlobalAccelerationInstanceIp(request: AddGlobalAccelerationInstanceIpRequest): AddGlobalAccelerationInstanceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return addGlobalAccelerationInstanceIpWithOptions(request, runtime);
}

model DescribeRouteTableListRequest = {
  routerType?: string(name='RouterType'),
  routerId?: string(name='RouterId'),
  vpcId?: string(name='VpcId'),
  routeTableId?: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  regionId: string(name='RegionId'),
}

model DescribeRouteTableListResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
  pageSize: integer(name='PageSize'),
  pageNumber: integer(name='PageNumber'),
  totalCount: integer(name='TotalCount'),
  routerTableList: {
    routerTableListType: [
      {
        vpcId: string(name='VpcId'),
        routerType: string(name='RouterType'),
        routerId: string(name='RouterId'),
        routeTableId: string(name='RouteTableId'),
        routeTableName: string(name='RouteTableName'),
        routeTableType: string(name='RouteTableType'),
        description: string(name='Description'),
        resourceGroupId: string(name='ResourceGroupId'),
        creationTime: string(name='CreationTime'),
        status: string(name='Status'),
        ownerId: long(name='OwnerId'),
        tags: {
          tag: [
            {
              key: string(name='Key'),
              value: string(name='Value'),
            }
          ](name='Tag'),
        }(name='Tags'),
        vSwitchIds: {
          vSwitchId: [ string ](name='VSwitchId', description='VSwitchId'),
        }(name='VSwitchIds'),
      }
    ](name='RouterTableListType'),
  }(name='RouterTableList'),
}

async function describeRouteTableListWithOptions(request: DescribeRouteTableListRequest, runtime: Util.RuntimeOptions): DescribeRouteTableListResponse {
  Util.validateModel(request);
  return doRequest('DescribeRouteTableList', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeRouteTableList(request: DescribeRouteTableListRequest): DescribeRouteTableListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteTableListWithOptions(request, runtime);
}

model ModifyRouteTableAttributesRequest = {
  routeTableId: string(name='RouteTableId'),
  routeTableName?: string(name='RouteTableName'),
  description?: string(name='Description'),
  regionId: string(name='RegionId'),
}

model ModifyRouteTableAttributesResponse = {
  requestId: string(name='RequestId'),
  code: string(name='Code'),
  message: string(name='Message'),
  success: boolean(name='Success'),
}

async function modifyRouteTableAttributesWithOptions(request: ModifyRouteTableAttributesRequest, runtime: Util.RuntimeOptions): ModifyRouteTableAttributesResponse {
  Util.validateModel(request);
  return doRequest('ModifyRouteTableAttributes', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyRouteTableAttributes(request: ModifyRouteTableAttributesRequest): ModifyRouteTableAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouteTableAttributesWithOptions(request, runtime);
}

model DescribeBgpNetworksRequest = {
  routerId?: string(name='RouterId'),
  regionId: string(name='RegionId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeBgpNetworksResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  bgpNetworks: {
    bgpNetwork: [
      {
        vpcId: string(name='VpcId'),
        dstCidrBlock: string(name='DstCidrBlock'),
        routerId: string(name='RouterId'),
        status: string(name='Status'),
      }
    ](name='BgpNetwork'),
  }(name='BgpNetworks'),
}

async function describeBgpNetworksWithOptions(request: DescribeBgpNetworksRequest, runtime: Util.RuntimeOptions): DescribeBgpNetworksResponse {
  Util.validateModel(request);
  return doRequest('DescribeBgpNetworks', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeBgpNetworks(request: DescribeBgpNetworksRequest): DescribeBgpNetworksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpNetworksWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackagePayTypeRequest = {
  bandwidthPackageId: string(name='BandwidthPackageId'),
  payType?: string(name='PayType'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: integer(name='Duration'),
  autoPay?: boolean(name='AutoPay'),
  bandwidth?: string(name='Bandwidth'),
  kbpsBandwidth?: string(name='KbpsBandwidth'),
  resourceBid?: string(name='ResourceBid'),
  resourceUid?: long(name='ResourceUid'),
  regionId: string(name='RegionId'),
}

model ModifyCommonBandwidthPackagePayTypeResponse = {
  requestId: string(name='RequestId'),
  orderId: long(name='OrderId'),
  code: string(name='Code'),
  message: string(name='Message'),
}

async function modifyCommonBandwidthPackagePayTypeWithOptions(request: ModifyCommonBandwidthPackagePayTypeRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackagePayTypeResponse {
  Util.validateModel(request);
  return doRequest('ModifyCommonBandwidthPackagePayType', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyCommonBandwidthPackagePayType(request: ModifyCommonBandwidthPackagePayTypeRequest): ModifyCommonBandwidthPackagePayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackagePayTypeWithOptions(request, runtime);
}

model UnassociateGlobalAccelerationInstanceRequest = {
  regionId: string(name='RegionId'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
  instanceType?: string(name='InstanceType'),
}

model UnassociateGlobalAccelerationInstanceResponse = {
  requestId: string(name='RequestId'),
}

async function unassociateGlobalAccelerationInstanceWithOptions(request: UnassociateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): UnassociateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  return doRequest('UnassociateGlobalAccelerationInstance', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function unassociateGlobalAccelerationInstance(request: UnassociateGlobalAccelerationInstanceRequest): UnassociateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateGlobalAccelerationInstanceWithOptions(request, runtime);
}

model ModifyGlobalAccelerationInstanceSpecRequest = {
  regionId: string(name='RegionId'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
  bandwidth: string(name='Bandwidth'),
}

model ModifyGlobalAccelerationInstanceSpecResponse = {
  requestId: string(name='RequestId'),
}

async function modifyGlobalAccelerationInstanceSpecWithOptions(request: ModifyGlobalAccelerationInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyGlobalAccelerationInstanceSpecResponse {
  Util.validateModel(request);
  return doRequest('ModifyGlobalAccelerationInstanceSpec', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyGlobalAccelerationInstanceSpec(request: ModifyGlobalAccelerationInstanceSpecRequest): ModifyGlobalAccelerationInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalAccelerationInstanceSpecWithOptions(request, runtime);
}

model ModifyGlobalAccelerationInstanceAttributesRequest = {
  regionId: string(name='RegionId'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyGlobalAccelerationInstanceAttributesResponse = {
  requestId: string(name='RequestId'),
}

async function modifyGlobalAccelerationInstanceAttributesWithOptions(request: ModifyGlobalAccelerationInstanceAttributesRequest, runtime: Util.RuntimeOptions): ModifyGlobalAccelerationInstanceAttributesResponse {
  Util.validateModel(request);
  return doRequest('ModifyGlobalAccelerationInstanceAttributes', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyGlobalAccelerationInstanceAttributes(request: ModifyGlobalAccelerationInstanceAttributesRequest): ModifyGlobalAccelerationInstanceAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGlobalAccelerationInstanceAttributesWithOptions(request, runtime);
}

model DescribeServerRelatedGlobalAccelerationInstancesRequest = {
  regionId: string(name='RegionId'),
  serverId: string(name='ServerId'),
  serverType?: string(name='ServerType'),
}

model DescribeServerRelatedGlobalAccelerationInstancesResponse = {
  requestId: string(name='RequestId'),
  globalAccelerationInstances: {
    globalAccelerationInstance: [
      {
        regionId: string(name='RegionId'),
        globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
        ipAddress: string(name='IpAddress'),
        serverIpAddress: string(name='ServerIpAddress'),
      }
    ](name='GlobalAccelerationInstance'),
  }(name='GlobalAccelerationInstances'),
}

async function describeServerRelatedGlobalAccelerationInstancesWithOptions(request: DescribeServerRelatedGlobalAccelerationInstancesRequest, runtime: Util.RuntimeOptions): DescribeServerRelatedGlobalAccelerationInstancesResponse {
  Util.validateModel(request);
  return doRequest('DescribeServerRelatedGlobalAccelerationInstances', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeServerRelatedGlobalAccelerationInstances(request: DescribeServerRelatedGlobalAccelerationInstancesRequest): DescribeServerRelatedGlobalAccelerationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServerRelatedGlobalAccelerationInstancesWithOptions(request, runtime);
}

model DescribeGlobalAccelerationInstancesRequest = {
  regionId: string(name='RegionId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  status?: string(name='Status'),
  bandwidthType?: string(name='BandwidthType'),
  serviceLocation?: string(name='ServiceLocation'),
  serverId?: string(name='ServerId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeGlobalAccelerationInstancesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  globalAccelerationInstances: {
    globalAccelerationInstance: [
      {
        regionId: string(name='RegionId'),
        globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
        ipAddress: string(name='IpAddress'),
        status: string(name='Status'),
        bandwidth: string(name='Bandwidth'),
        internetChargeType: string(name='InternetChargeType'),
        chargeType: string(name='ChargeType'),
        bandwidthType: string(name='BandwidthType'),
        accelerationLocation: string(name='AccelerationLocation'),
        serviceLocation: string(name='ServiceLocation'),
        name: string(name='Name'),
        description: string(name='Description'),
        expiredTime: string(name='ExpiredTime'),
        creationTime: string(name='CreationTime'),
        hasReservationData: string(name='HasReservationData'),
        reservationBandwidth: string(name='ReservationBandwidth'),
        reservationInternetChargeType: string(name='ReservationInternetChargeType'),
        reservationActiveTime: string(name='ReservationActiveTime'),
        reservationOrderType: string(name='ReservationOrderType'),
        backendServers: {
          backendServer: [
            {
              regionId: string(name='RegionId'),
              serverId: string(name='ServerId'),
              serverIpAddress: string(name='ServerIpAddress'),
              serverType: string(name='ServerType'),
            }
          ](name='BackendServer'),
        }(name='BackendServers'),
        publicIpAddresses: {
          publicIpAddress: [
            {
              allocationId: string(name='AllocationId'),
              ipAddress: string(name='IpAddress'),
            }
          ](name='PublicIpAddress'),
        }(name='PublicIpAddresses'),
      }
    ](name='GlobalAccelerationInstance'),
  }(name='GlobalAccelerationInstances'),
}

async function describeGlobalAccelerationInstancesWithOptions(request: DescribeGlobalAccelerationInstancesRequest, runtime: Util.RuntimeOptions): DescribeGlobalAccelerationInstancesResponse {
  Util.validateModel(request);
  return doRequest('DescribeGlobalAccelerationInstances', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeGlobalAccelerationInstances(request: DescribeGlobalAccelerationInstancesRequest): DescribeGlobalAccelerationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalAccelerationInstancesWithOptions(request, runtime);
}

model DeleteGlobalAccelerationInstanceRequest = {
  regionId: string(name='RegionId'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
}

model DeleteGlobalAccelerationInstanceResponse = {
  requestId: string(name='RequestId'),
}

async function deleteGlobalAccelerationInstanceWithOptions(request: DeleteGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): DeleteGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  return doRequest('DeleteGlobalAccelerationInstance', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteGlobalAccelerationInstance(request: DeleteGlobalAccelerationInstanceRequest): DeleteGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGlobalAccelerationInstanceWithOptions(request, runtime);
}

model CreateGlobalAccelerationInstanceRequest = {
  regionId: string(name='RegionId'),
  serviceLocation: string(name='ServiceLocation'),
  bandwidth: string(name='Bandwidth'),
  bandwidthType?: string(name='BandwidthType'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
}

model CreateGlobalAccelerationInstanceResponse = {
  requestId: string(name='RequestId'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
  ipAddress: string(name='IpAddress'),
}

async function createGlobalAccelerationInstanceWithOptions(request: CreateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): CreateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  return doRequest('CreateGlobalAccelerationInstance', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createGlobalAccelerationInstance(request: CreateGlobalAccelerationInstanceRequest): CreateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGlobalAccelerationInstanceWithOptions(request, runtime);
}

model AssociateGlobalAccelerationInstanceRequest = {
  regionId: string(name='RegionId'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId'),
  backendServerId: string(name='BackendServerId'),
  backendServerRegionId: string(name='BackendServerRegionId'),
  backendServerType?: string(name='BackendServerType'),
}

model AssociateGlobalAccelerationInstanceResponse = {
  requestId: string(name='RequestId'),
}

async function associateGlobalAccelerationInstanceWithOptions(request: AssociateGlobalAccelerationInstanceRequest, runtime: Util.RuntimeOptions): AssociateGlobalAccelerationInstanceResponse {
  Util.validateModel(request);
  return doRequest('AssociateGlobalAccelerationInstance', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function associateGlobalAccelerationInstance(request: AssociateGlobalAccelerationInstanceRequest): AssociateGlobalAccelerationInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateGlobalAccelerationInstanceWithOptions(request, runtime);
}

model DescribeVSwitchAttributesRequest = {
  vSwitchId: string(name='VSwitchId'),
  regionId?: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
}

model DescribeVSwitchAttributesResponse = {
  requestId: string(name='RequestId'),
  vSwitchId: string(name='VSwitchId'),
  vpcId: string(name='VpcId'),
  status: string(name='Status'),
  cidrBlock: string(name='CidrBlock'),
  ipv6CidrBlock: string(name='Ipv6CidrBlock'),
  zoneId: string(name='ZoneId'),
  availableIpAddressCount: long(name='AvailableIpAddressCount'),
  description: string(name='Description'),
  vSwitchName: string(name='VSwitchName'),
  creationTime: string(name='CreationTime'),
  isDefault: boolean(name='IsDefault'),
  resourceGroupId: string(name='ResourceGroupId'),
  networkAclId: string(name='NetworkAclId'),
  ownerId: long(name='OwnerId'),
  shareType: string(name='ShareType'),
  routeTable: {
    routeTableId: string(name='RouteTableId'),
    routeTableType: string(name='RouteTableType'),
  }(name='RouteTable'),
}

async function describeVSwitchAttributesWithOptions(request: DescribeVSwitchAttributesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchAttributesResponse {
  Util.validateModel(request);
  return doRequest('DescribeVSwitchAttributes', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVSwitchAttributes(request: DescribeVSwitchAttributesRequest): DescribeVSwitchAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchAttributesWithOptions(request, runtime);
}

model RemoveCommonBandwidthPackageIpRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  ipInstanceId: string(name='IpInstanceId'),
}

model RemoveCommonBandwidthPackageIpResponse = {
  requestId: string(name='RequestId'),
}

async function removeCommonBandwidthPackageIpWithOptions(request: RemoveCommonBandwidthPackageIpRequest, runtime: Util.RuntimeOptions): RemoveCommonBandwidthPackageIpResponse {
  Util.validateModel(request);
  return doRequest('RemoveCommonBandwidthPackageIp', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function removeCommonBandwidthPackageIp(request: RemoveCommonBandwidthPackageIpRequest): RemoveCommonBandwidthPackageIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCommonBandwidthPackageIpWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageSpecRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  bandwidth: string(name='Bandwidth'),
}

model ModifyCommonBandwidthPackageSpecResponse = {
  requestId: string(name='RequestId'),
}

async function modifyCommonBandwidthPackageSpecWithOptions(request: ModifyCommonBandwidthPackageSpecRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageSpecResponse {
  Util.validateModel(request);
  return doRequest('ModifyCommonBandwidthPackageSpec', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyCommonBandwidthPackageSpec(request: ModifyCommonBandwidthPackageSpecRequest): ModifyCommonBandwidthPackageSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageSpecWithOptions(request, runtime);
}

model ModifyCommonBandwidthPackageAttributeRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyCommonBandwidthPackageAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyCommonBandwidthPackageAttributeWithOptions(request: ModifyCommonBandwidthPackageAttributeRequest, runtime: Util.RuntimeOptions): ModifyCommonBandwidthPackageAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyCommonBandwidthPackageAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyCommonBandwidthPackageAttribute(request: ModifyCommonBandwidthPackageAttributeRequest): ModifyCommonBandwidthPackageAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCommonBandwidthPackageAttributeWithOptions(request, runtime);
}

model DescribeCommonBandwidthPackagesRequest = {
  includeReservationData?: boolean(name='IncludeReservationData'),
  regionId: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  name?: string(name='Name'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  dryRun?: boolean(name='DryRun'),
}

model DescribeCommonBandwidthPackagesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  commonBandwidthPackages: {
    commonBandwidthPackage: [
      {
        bandwidthPackageId: string(name='BandwidthPackageId'),
        regionId: string(name='RegionId'),
        name: string(name='Name'),
        description: string(name='Description'),
        bandwidth: string(name='Bandwidth'),
        instanceChargeType: string(name='InstanceChargeType'),
        internetChargeType: string(name='InternetChargeType'),
        businessStatus: string(name='BusinessStatus'),
        creationTime: string(name='CreationTime'),
        expiredTime: string(name='ExpiredTime'),
        status: string(name='Status'),
        ratio: integer(name='Ratio'),
        resourceGroupId: string(name='ResourceGroupId'),
        hasReservationData: string(name='HasReservationData'),
        reservationBandwidth: string(name='ReservationBandwidth'),
        reservationInternetChargeType: string(name='ReservationInternetChargeType'),
        reservationActiveTime: string(name='ReservationActiveTime'),
        reservationOrderType: string(name='ReservationOrderType'),
        ISP: string(name='ISP'),
        deletionProtection: boolean(name='DeletionProtection'),
        publicIpAddresses: {
          publicIpAddresse: [
            {
              allocationId: string(name='AllocationId'),
              ipAddress: string(name='IpAddress'),
            }
          ](name='PublicIpAddresse'),
        }(name='PublicIpAddresses'),
      }
    ](name='CommonBandwidthPackage'),
  }(name='CommonBandwidthPackages'),
}

async function describeCommonBandwidthPackagesWithOptions(request: DescribeCommonBandwidthPackagesRequest, runtime: Util.RuntimeOptions): DescribeCommonBandwidthPackagesResponse {
  Util.validateModel(request);
  return doRequest('DescribeCommonBandwidthPackages', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeCommonBandwidthPackages(request: DescribeCommonBandwidthPackagesRequest): DescribeCommonBandwidthPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCommonBandwidthPackagesWithOptions(request, runtime);
}

model DeleteCommonBandwidthPackageRequest = {
  regionId: string(name='RegionId'),
  force?: string(name='Force'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
}

model DeleteCommonBandwidthPackageResponse = {
  requestId: string(name='RequestId'),
}

async function deleteCommonBandwidthPackageWithOptions(request: DeleteCommonBandwidthPackageRequest, runtime: Util.RuntimeOptions): DeleteCommonBandwidthPackageResponse {
  Util.validateModel(request);
  return doRequest('DeleteCommonBandwidthPackage', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteCommonBandwidthPackage(request: DeleteCommonBandwidthPackageRequest): DeleteCommonBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCommonBandwidthPackageWithOptions(request, runtime);
}

model CreateCommonBandwidthPackageRequest = {
  regionId: string(name='RegionId'),
  zone?: string(name='Zone'),
  ISP?: string(name='ISP'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  resourceGroupId?: string(name='ResourceGroupId'),
  bandwidth: integer(name='Bandwidth'),
  ratio?: integer(name='Ratio'),
  internetChargeType?: string(name='InternetChargeType'),
}

model CreateCommonBandwidthPackageResponse = {
  requestId: string(name='RequestId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  resourceGroupId: string(name='ResourceGroupId'),
}

async function createCommonBandwidthPackageWithOptions(request: CreateCommonBandwidthPackageRequest, runtime: Util.RuntimeOptions): CreateCommonBandwidthPackageResponse {
  Util.validateModel(request);
  return doRequest('CreateCommonBandwidthPackage', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createCommonBandwidthPackage(request: CreateCommonBandwidthPackageRequest): CreateCommonBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCommonBandwidthPackageWithOptions(request, runtime);
}

model AddCommonBandwidthPackageIpRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  ipInstanceId: string(name='IpInstanceId'),
  ipType?: string(name='IpType'),
}

model AddCommonBandwidthPackageIpResponse = {
  requestId: string(name='RequestId'),
}

async function addCommonBandwidthPackageIpWithOptions(request: AddCommonBandwidthPackageIpRequest, runtime: Util.RuntimeOptions): AddCommonBandwidthPackageIpResponse {
  Util.validateModel(request);
  return doRequest('AddCommonBandwidthPackageIp', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function addCommonBandwidthPackageIp(request: AddCommonBandwidthPackageIpRequest): AddCommonBandwidthPackageIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCommonBandwidthPackageIpWithOptions(request, runtime);
}

model ModifyVpnGatewayAttributeRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId: string(name='VpnGatewayId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  autoPropagate?: boolean(name='AutoPropagate'),
}

model ModifyVpnGatewayAttributeResponse = {
  requestId: string(name='RequestId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  vpcId: string(name='VpcId'),
  vSwitchId: string(name='VSwitchId'),
  internetIp: string(name='InternetIp'),
  intranetIp: string(name='IntranetIp'),
  createTime: long(name='CreateTime'),
  endTime: long(name='EndTime'),
  spec: string(name='Spec'),
  name: string(name='Name'),
  description: string(name='Description'),
  status: string(name='Status'),
  businessStatus: string(name='BusinessStatus'),
  enableBgp: boolean(name='EnableBgp'),
  autoPropagate: boolean(name='AutoPropagate'),
}

async function modifyVpnGatewayAttributeWithOptions(request: ModifyVpnGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpnGatewayAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyVpnGatewayAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyVpnGatewayAttribute(request: ModifyVpnGatewayAttributeRequest): ModifyVpnGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnGatewayAttributeWithOptions(request, runtime);
}

model ModifyVpnConnectionAttributeRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnConnectionId: string(name='VpnConnectionId'),
  name?: string(name='Name'),
  localSubnet?: string(name='LocalSubnet'),
  remoteSubnet?: string(name='RemoteSubnet'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  bgpConfig?: string(name='BgpConfig'),
}

model ModifyVpnConnectionAttributeResponse = {
  requestId: string(name='RequestId'),
  vpnConnectionId: string(name='VpnConnectionId'),
  customerGatewayId: string(name='CustomerGatewayId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  name: string(name='Name'),
  description: string(name='Description'),
  localSubnet: string(name='LocalSubnet'),
  remoteSubnet: string(name='RemoteSubnet'),
  createTime: long(name='CreateTime'),
  effectImmediately: boolean(name='EffectImmediately'),
  enableDpd: boolean(name='EnableDpd'),
  enableNatTraversal: boolean(name='EnableNatTraversal'),
  ikeConfig: {
    psk: string(name='Psk'),
    ikeVersion: string(name='IkeVersion'),
    ikeMode: string(name='IkeMode'),
    ikeEncAlg: string(name='IkeEncAlg'),
    ikeAuthAlg: string(name='IkeAuthAlg'),
    ikePfs: string(name='IkePfs'),
    ikeLifetime: long(name='IkeLifetime'),
    localId: string(name='LocalId'),
    remoteId: string(name='RemoteId'),
  }(name='IkeConfig'),
  ipsecConfig: {
    ipsecEncAlg: string(name='IpsecEncAlg'),
    ipsecAuthAlg: string(name='IpsecAuthAlg'),
    ipsecPfs: string(name='IpsecPfs'),
    ipsecLifetime: long(name='IpsecLifetime'),
  }(name='IpsecConfig'),
  vcoHealthCheck: {
    enable: string(name='Enable'),
    sip: string(name='Sip'),
    dip: string(name='Dip'),
    interval: integer(name='Interval'),
    retry: integer(name='Retry'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig: {
    enableBgp: string(name='EnableBgp'),
    tunnelCidr: string(name='TunnelCidr'),
    localBgpIp: string(name='LocalBgpIp'),
    peerBgpIp: string(name='PeerBgpIp'),
    localAsn: integer(name='LocalAsn'),
    peerAsn: integer(name='PeerAsn'),
    status: string(name='Status'),
  }(name='VpnBgpConfig'),
}

async function modifyVpnConnectionAttributeWithOptions(request: ModifyVpnConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpnConnectionAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyVpnConnectionAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyVpnConnectionAttribute(request: ModifyVpnConnectionAttributeRequest): ModifyVpnConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpnConnectionAttributeWithOptions(request, runtime);
}

model ModifyCustomerGatewayAttributeRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId: string(name='CustomerGatewayId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyCustomerGatewayAttributeResponse = {
  requestId: string(name='RequestId'),
  customerGatewayId: string(name='CustomerGatewayId'),
  ipAddress: string(name='IpAddress'),
  name: string(name='Name'),
  description: string(name='Description'),
  createTime: long(name='CreateTime'),
}

async function modifyCustomerGatewayAttributeWithOptions(request: ModifyCustomerGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyCustomerGatewayAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyCustomerGatewayAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyCustomerGatewayAttribute(request: ModifyCustomerGatewayAttributeRequest): ModifyCustomerGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCustomerGatewayAttributeWithOptions(request, runtime);
}

model DownloadVpnConnectionConfigRequest = {
  regionId: string(name='RegionId'),
  vpnConnectionId: string(name='VpnConnectionId'),
}

model DownloadVpnConnectionConfigResponse = {
  requestId: string(name='RequestId'),
  vpnConnectionConfig: {
    localSubnet: string(name='LocalSubnet'),
    remoteSubnet: string(name='RemoteSubnet'),
    local: string(name='Local'),
    remote: string(name='Remote'),
    ikeConfig: {
      psk: string(name='Psk'),
      ikeVersion: string(name='IkeVersion'),
      ikeMode: string(name='IkeMode'),
      ikeEncAlg: string(name='IkeEncAlg'),
      ikeAuthAlg: string(name='IkeAuthAlg'),
      ikePfs: string(name='IkePfs'),
      ikeLifetime: long(name='IkeLifetime'),
      localId: string(name='LocalId'),
      remoteId: string(name='RemoteId'),
    }(name='IkeConfig'),
    ipsecConfig: {
      ipsecEncAlg: string(name='IpsecEncAlg'),
      ipsecAuthAlg: string(name='IpsecAuthAlg'),
      ipsecPfs: string(name='IpsecPfs'),
      ipsecLifetime: long(name='IpsecLifetime'),
    }(name='IpsecConfig'),
  }(name='VpnConnectionConfig'),
}

async function downloadVpnConnectionConfigWithOptions(request: DownloadVpnConnectionConfigRequest, runtime: Util.RuntimeOptions): DownloadVpnConnectionConfigResponse {
  Util.validateModel(request);
  return doRequest('DownloadVpnConnectionConfig', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function downloadVpnConnectionConfig(request: DownloadVpnConnectionConfigRequest): DownloadVpnConnectionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadVpnConnectionConfigWithOptions(request, runtime);
}

model DescribeVpnGatewaysRequest = {
  regionId: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  status?: string(name='Status'),
  businessStatus?: string(name='BusinessStatus'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  tag?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  includeReservationData?: boolean(name='IncludeReservationData'),
}

model DescribeVpnGatewaysResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  vpnGateways: {
    vpnGateway: [
      {
        vpnGatewayId: string(name='VpnGatewayId'),
        vpcId: string(name='VpcId'),
        vSwitchId: string(name='VSwitchId'),
        internetIp: string(name='InternetIp'),
        createTime: long(name='CreateTime'),
        endTime: long(name='EndTime'),
        spec: string(name='Spec'),
        name: string(name='Name'),
        description: string(name='Description'),
        status: string(name='Status'),
        businessStatus: string(name='BusinessStatus'),
        chargeType: string(name='ChargeType'),
        ipsecVpn: string(name='IpsecVpn'),
        sslVpn: string(name='SslVpn'),
        sslMaxConnections: long(name='SslMaxConnections'),
        tag: string(name='Tag'),
        enableBgp: boolean(name='EnableBgp'),
        autoPropagate: boolean(name='AutoPropagate'),
        tags: {
          tag: [
            {
              key: string(name='Key'),
              value: string(name='Value'),
            }
          ](name='Tag'),
        }(name='Tags'),
        reservationData: {
          status: string(name='Status'),
          reservationEndTime: string(name='ReservationEndTime'),
          reservationOrderType: string(name='ReservationOrderType'),
          reservationSpec: string(name='ReservationSpec'),
          reservationIpsec: string(name='ReservationIpsec'),
          reservationSsl: string(name='ReservationSsl'),
          reservationMaxConnections: integer(name='ReservationMaxConnections'),
        }(name='ReservationData'),
      }
    ](name='VpnGateway'),
  }(name='VpnGateways'),
}

async function describeVpnGatewaysWithOptions(request: DescribeVpnGatewaysRequest, runtime: Util.RuntimeOptions): DescribeVpnGatewaysResponse {
  Util.validateModel(request);
  return doRequest('DescribeVpnGateways', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVpnGateways(request: DescribeVpnGatewaysRequest): DescribeVpnGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnGatewaysWithOptions(request, runtime);
}

model DescribeVpnGatewayRequest = {
  regionId: string(name='RegionId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
}

model DescribeVpnGatewayResponse = {
  requestId: string(name='RequestId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  vpcId: string(name='VpcId'),
  vSwitchId: string(name='VSwitchId'),
  internetIp: string(name='InternetIp'),
  createTime: long(name='CreateTime'),
  endTime: long(name='EndTime'),
  spec: string(name='Spec'),
  name: string(name='Name'),
  description: string(name='Description'),
  status: string(name='Status'),
  businessStatus: string(name='BusinessStatus'),
  chargeType: string(name='ChargeType'),
  ipsecVpn: string(name='IpsecVpn'),
  sslVpn: string(name='SslVpn'),
  sslMaxConnections: long(name='SslMaxConnections'),
  tag: string(name='Tag'),
  enableBgp: boolean(name='EnableBgp'),
  autoPropagate: boolean(name='AutoPropagate'),
  tags: {
    tag: [
      {
        key: string(name='Key'),
        value: string(name='Value'),
      }
    ](name='Tag'),
  }(name='Tags'),
  reservationData: {
    status: string(name='Status'),
    reservationEndTime: string(name='ReservationEndTime'),
    reservationOrderType: string(name='ReservationOrderType'),
    reservationSpec: string(name='ReservationSpec'),
    reservationIpsec: string(name='ReservationIpsec'),
    reservationSsl: string(name='ReservationSsl'),
    reservationMaxConnections: integer(name='ReservationMaxConnections'),
  }(name='ReservationData'),
}

async function describeVpnGatewayWithOptions(request: DescribeVpnGatewayRequest, runtime: Util.RuntimeOptions): DescribeVpnGatewayResponse {
  Util.validateModel(request);
  return doRequest('DescribeVpnGateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVpnGateway(request: DescribeVpnGatewayRequest): DescribeVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnGatewayWithOptions(request, runtime);
}

model DescribeVpnConnectionsRequest = {
  regionId: string(name='RegionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model DescribeVpnConnectionsResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  vpnConnections: {
    vpnConnection: [
      {
        vpnConnectionId: string(name='VpnConnectionId'),
        customerGatewayId: string(name='CustomerGatewayId'),
        vpnGatewayId: string(name='VpnGatewayId'),
        name: string(name='Name'),
        localSubnet: string(name='LocalSubnet'),
        remoteSubnet: string(name='RemoteSubnet'),
        createTime: long(name='CreateTime'),
        effectImmediately: boolean(name='EffectImmediately'),
        status: string(name='Status'),
        enableDpd: boolean(name='EnableDpd'),
        enableNatTraversal: boolean(name='EnableNatTraversal'),
        ikeConfig: {
          psk: string(name='Psk'),
          ikeVersion: string(name='IkeVersion'),
          ikeMode: string(name='IkeMode'),
          ikeEncAlg: string(name='IkeEncAlg'),
          ikeAuthAlg: string(name='IkeAuthAlg'),
          ikePfs: string(name='IkePfs'),
          ikeLifetime: long(name='IkeLifetime'),
          localId: string(name='LocalId'),
          remoteId: string(name='RemoteId'),
        }(name='IkeConfig'),
        ipsecConfig: {
          ipsecEncAlg: string(name='IpsecEncAlg'),
          ipsecAuthAlg: string(name='IpsecAuthAlg'),
          ipsecPfs: string(name='IpsecPfs'),
          ipsecLifetime: long(name='IpsecLifetime'),
        }(name='IpsecConfig'),
        vcoHealthCheck: {
          enable: string(name='Enable'),
          sip: string(name='Sip'),
          dip: string(name='Dip'),
          interval: integer(name='Interval'),
          retry: integer(name='Retry'),
          status: string(name='Status'),
        }(name='VcoHealthCheck'),
        vpnBgpConfig: {
          tunnelCidr: string(name='TunnelCidr'),
          localBgpIp: string(name='LocalBgpIp'),
          peerBgpIp: string(name='PeerBgpIp'),
          localAsn: string(name='LocalAsn'),
          peerAsn: string(name='PeerAsn'),
          status: string(name='Status'),
        }(name='VpnBgpConfig'),
      }
    ](name='VpnConnection'),
  }(name='VpnConnections'),
}

async function describeVpnConnectionsWithOptions(request: DescribeVpnConnectionsRequest, runtime: Util.RuntimeOptions): DescribeVpnConnectionsResponse {
  Util.validateModel(request);
  return doRequest('DescribeVpnConnections', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVpnConnections(request: DescribeVpnConnectionsRequest): DescribeVpnConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnConnectionsWithOptions(request, runtime);
}

model DescribeVpnConnectionRequest = {
  regionId: string(name='RegionId'),
  vpnConnectionId: string(name='VpnConnectionId'),
}

model DescribeVpnConnectionResponse = {
  requestId: string(name='RequestId'),
  vpnConnectionId: string(name='VpnConnectionId'),
  customerGatewayId: string(name='CustomerGatewayId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  name: string(name='Name'),
  localSubnet: string(name='LocalSubnet'),
  remoteSubnet: string(name='RemoteSubnet'),
  createTime: long(name='CreateTime'),
  effectImmediately: boolean(name='EffectImmediately'),
  status: string(name='Status'),
  enableDpd: boolean(name='EnableDpd'),
  enableNatTraversal: boolean(name='EnableNatTraversal'),
  ikeConfig: {
    psk: string(name='Psk'),
    ikeVersion: string(name='IkeVersion'),
    ikeMode: string(name='IkeMode'),
    ikeEncAlg: string(name='IkeEncAlg'),
    ikeAuthAlg: string(name='IkeAuthAlg'),
    ikePfs: string(name='IkePfs'),
    ikeLifetime: long(name='IkeLifetime'),
    localId: string(name='LocalId'),
    remoteId: string(name='RemoteId'),
  }(name='IkeConfig'),
  ipsecConfig: {
    ipsecEncAlg: string(name='IpsecEncAlg'),
    ipsecAuthAlg: string(name='IpsecAuthAlg'),
    ipsecPfs: string(name='IpsecPfs'),
    ipsecLifetime: long(name='IpsecLifetime'),
  }(name='IpsecConfig'),
  vcoHealthCheck: {
    enable: string(name='Enable'),
    sip: string(name='Sip'),
    dip: string(name='Dip'),
    interval: integer(name='Interval'),
    retry: integer(name='Retry'),
    status: string(name='Status'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig: {
    enableBgp: string(name='EnableBgp'),
    tunnelCidr: string(name='TunnelCidr'),
    localBgpIp: string(name='LocalBgpIp'),
    peerBgpIp: string(name='PeerBgpIp'),
    localAsn: string(name='LocalAsn'),
    peerAsn: string(name='PeerAsn'),
    status: string(name='Status'),
  }(name='VpnBgpConfig'),
}

async function describeVpnConnectionWithOptions(request: DescribeVpnConnectionRequest, runtime: Util.RuntimeOptions): DescribeVpnConnectionResponse {
  Util.validateModel(request);
  return doRequest('DescribeVpnConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVpnConnection(request: DescribeVpnConnectionRequest): DescribeVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpnConnectionWithOptions(request, runtime);
}

model DescribeCustomerGatewaysRequest = {
  regionId: string(name='RegionId'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeCustomerGatewaysResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  customerGateways: {
    customerGateway: [
      {
        customerGatewayId: string(name='CustomerGatewayId'),
        name: string(name='Name'),
        ipAddress: string(name='IpAddress'),
        description: string(name='Description'),
        createTime: long(name='CreateTime'),
        asn: integer(name='Asn'),
      }
    ](name='CustomerGateway'),
  }(name='CustomerGateways'),
}

async function describeCustomerGatewaysWithOptions(request: DescribeCustomerGatewaysRequest, runtime: Util.RuntimeOptions): DescribeCustomerGatewaysResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomerGateways', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeCustomerGateways(request: DescribeCustomerGatewaysRequest): DescribeCustomerGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomerGatewaysWithOptions(request, runtime);
}

model DescribeCustomerGatewayRequest = {
  regionId: string(name='RegionId'),
  customerGatewayId: string(name='CustomerGatewayId'),
}

model DescribeCustomerGatewayResponse = {
  requestId: string(name='RequestId'),
  customerGatewayId: string(name='CustomerGatewayId'),
  ipAddress: string(name='IpAddress'),
  name: string(name='Name'),
  description: string(name='Description'),
  createTime: long(name='CreateTime'),
  asn: integer(name='Asn'),
}

async function describeCustomerGatewayWithOptions(request: DescribeCustomerGatewayRequest, runtime: Util.RuntimeOptions): DescribeCustomerGatewayResponse {
  Util.validateModel(request);
  return doRequest('DescribeCustomerGateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeCustomerGateway(request: DescribeCustomerGatewayRequest): DescribeCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomerGatewayWithOptions(request, runtime);
}

model DeleteVpnGatewayRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnGatewayId: string(name='VpnGatewayId'),
}

model DeleteVpnGatewayResponse = {
  requestId: string(name='RequestId'),
}

async function deleteVpnGatewayWithOptions(request: DeleteVpnGatewayRequest, runtime: Util.RuntimeOptions): DeleteVpnGatewayResponse {
  Util.validateModel(request);
  return doRequest('DeleteVpnGateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteVpnGateway(request: DeleteVpnGatewayRequest): DeleteVpnGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnGatewayWithOptions(request, runtime);
}

model DeleteVpnConnectionRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  vpnConnectionId: string(name='VpnConnectionId'),
}

model DeleteVpnConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function deleteVpnConnectionWithOptions(request: DeleteVpnConnectionRequest, runtime: Util.RuntimeOptions): DeleteVpnConnectionResponse {
  Util.validateModel(request);
  return doRequest('DeleteVpnConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteVpnConnection(request: DeleteVpnConnectionRequest): DeleteVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpnConnectionWithOptions(request, runtime);
}

model DeleteCustomerGatewayRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId: string(name='CustomerGatewayId'),
}

model DeleteCustomerGatewayResponse = {
  requestId: string(name='RequestId'),
}

async function deleteCustomerGatewayWithOptions(request: DeleteCustomerGatewayRequest, runtime: Util.RuntimeOptions): DeleteCustomerGatewayResponse {
  Util.validateModel(request);
  return doRequest('DeleteCustomerGateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteCustomerGateway(request: DeleteCustomerGatewayRequest): DeleteCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomerGatewayWithOptions(request, runtime);
}

model CreateVpnConnectionRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  customerGatewayId: string(name='CustomerGatewayId'),
  vpnGatewayId: string(name='VpnGatewayId'),
  name?: string(name='Name'),
  localSubnet: string(name='LocalSubnet'),
  remoteSubnet: string(name='RemoteSubnet'),
  effectImmediately?: boolean(name='EffectImmediately'),
  ikeConfig?: string(name='IkeConfig'),
  ipsecConfig?: string(name='IpsecConfig'),
  healthCheckConfig?: string(name='HealthCheckConfig'),
  autoConfigRoute?: boolean(name='AutoConfigRoute'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  bgpConfig?: string(name='BgpConfig'),
}

model CreateVpnConnectionResponse = {
  requestId: string(name='RequestId'),
  vpnConnectionId: string(name='VpnConnectionId'),
  name: string(name='Name'),
  createTime: long(name='CreateTime'),
}

async function createVpnConnectionWithOptions(request: CreateVpnConnectionRequest, runtime: Util.RuntimeOptions): CreateVpnConnectionResponse {
  Util.validateModel(request);
  return doRequest('CreateVpnConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createVpnConnection(request: CreateVpnConnectionRequest): CreateVpnConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpnConnectionWithOptions(request, runtime);
}

model CreateCustomerGatewayRequest = {
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  ipAddress: string(name='IpAddress'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  asn?: string(name='Asn'),
}

model CreateCustomerGatewayResponse = {
  requestId: string(name='RequestId'),
  customerGatewayId: string(name='CustomerGatewayId'),
  ipAddress: string(name='IpAddress'),
  name: string(name='Name'),
  description: string(name='Description'),
  createTime: long(name='CreateTime'),
}

async function createCustomerGatewayWithOptions(request: CreateCustomerGatewayRequest, runtime: Util.RuntimeOptions): CreateCustomerGatewayResponse {
  Util.validateModel(request);
  return doRequest('CreateCustomerGateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createCustomerGateway(request: CreateCustomerGatewayRequest): CreateCustomerGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCustomerGatewayWithOptions(request, runtime);
}

model ModifyBgpGroupAttributeRequest = {
  regionId: string(name='RegionId'),
  bgpGroupId: string(name='BgpGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  localAsn?: long(name='LocalAsn'),
  peerAsn?: long(name='PeerAsn'),
  authKey?: string(name='AuthKey'),
  isFakeAsn?: boolean(name='IsFakeAsn'),
  clientToken?: string(name='ClientToken'),
}

model ModifyBgpGroupAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyBgpGroupAttributeWithOptions(request: ModifyBgpGroupAttributeRequest, runtime: Util.RuntimeOptions): ModifyBgpGroupAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyBgpGroupAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyBgpGroupAttribute(request: ModifyBgpGroupAttributeRequest): ModifyBgpGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBgpGroupAttributeWithOptions(request, runtime);
}

model DescribeBgpPeersRequest = {
  routerId?: string(name='RouterId'),
  bgpPeerId?: string(name='BgpPeerId'),
  bgpGroupId?: string(name='BgpGroupId'),
  regionId: string(name='RegionId'),
  isDefault?: boolean(name='IsDefault'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeBgpPeersResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  bgpPeers: {
    bgpPeer: [
      {
        name: string(name='Name'),
        description: string(name='Description'),
        bgpPeerId: string(name='BgpPeerId'),
        bgpGroupId: string(name='BgpGroupId'),
        peerIpAddress: string(name='PeerIpAddress'),
        peerAsn: string(name='PeerAsn'),
        authKey: string(name='AuthKey'),
        routerId: string(name='RouterId'),
        bgpStatus: string(name='BgpStatus'),
        status: string(name='Status'),
        keepalive: string(name='Keepalive'),
        localAsn: string(name='LocalAsn'),
        hold: string(name='Hold'),
        isFake: string(name='IsFake'),
        routeLimit: string(name='RouteLimit'),
        regionId: string(name='RegionId'),
        enableBfd: boolean(name='EnableBfd'),
        ipVersion: string(name='IpVersion'),
        bfdMultiHop: integer(name='BfdMultiHop'),
      }
    ](name='BgpPeer'),
  }(name='BgpPeers'),
}

async function describeBgpPeersWithOptions(request: DescribeBgpPeersRequest, runtime: Util.RuntimeOptions): DescribeBgpPeersResponse {
  Util.validateModel(request);
  return doRequest('DescribeBgpPeers', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeBgpPeers(request: DescribeBgpPeersRequest): DescribeBgpPeersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpPeersWithOptions(request, runtime);
}

model DescribeBgpGroupsRequest = {
  routerId?: string(name='RouterId'),
  bgpGroupId?: string(name='BgpGroupId'),
  regionId: string(name='RegionId'),
  isDefault?: boolean(name='IsDefault'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeBgpGroupsResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  bgpGroups: {
    bgpGroup: [
      {
        name: string(name='Name'),
        description: string(name='Description'),
        bgpGroupId: string(name='BgpGroupId'),
        peerAsn: string(name='PeerAsn'),
        authKey: string(name='AuthKey'),
        routerId: string(name='RouterId'),
        status: string(name='Status'),
        keepalive: string(name='Keepalive'),
        localAsn: string(name='LocalAsn'),
        hold: string(name='Hold'),
        isFake: string(name='IsFake'),
        routeLimit: string(name='RouteLimit'),
        regionId: string(name='RegionId'),
        ipVersion: string(name='IpVersion'),
      }
    ](name='BgpGroup'),
  }(name='BgpGroups'),
}

async function describeBgpGroupsWithOptions(request: DescribeBgpGroupsRequest, runtime: Util.RuntimeOptions): DescribeBgpGroupsResponse {
  Util.validateModel(request);
  return doRequest('DescribeBgpGroups', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeBgpGroups(request: DescribeBgpGroupsRequest): DescribeBgpGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBgpGroupsWithOptions(request, runtime);
}

model DeleteBgpPeerRequest = {
  regionId: string(name='RegionId'),
  bgpPeerId: string(name='BgpPeerId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteBgpPeerResponse = {
  requestId: string(name='RequestId'),
}

async function deleteBgpPeerWithOptions(request: DeleteBgpPeerRequest, runtime: Util.RuntimeOptions): DeleteBgpPeerResponse {
  Util.validateModel(request);
  return doRequest('DeleteBgpPeer', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteBgpPeer(request: DeleteBgpPeerRequest): DeleteBgpPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpPeerWithOptions(request, runtime);
}

model DeleteBgpNetworkRequest = {
  regionId: string(name='RegionId'),
  dstCidrBlock: string(name='DstCidrBlock'),
  routerId: string(name='RouterId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteBgpNetworkResponse = {
  requestId: string(name='RequestId'),
}

async function deleteBgpNetworkWithOptions(request: DeleteBgpNetworkRequest, runtime: Util.RuntimeOptions): DeleteBgpNetworkResponse {
  Util.validateModel(request);
  return doRequest('DeleteBgpNetwork', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteBgpNetwork(request: DeleteBgpNetworkRequest): DeleteBgpNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpNetworkWithOptions(request, runtime);
}

model DeleteBgpGroupRequest = {
  regionId: string(name='RegionId'),
  bgpGroupId: string(name='BgpGroupId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteBgpGroupResponse = {
  requestId: string(name='RequestId'),
}

async function deleteBgpGroupWithOptions(request: DeleteBgpGroupRequest, runtime: Util.RuntimeOptions): DeleteBgpGroupResponse {
  Util.validateModel(request);
  return doRequest('DeleteBgpGroup', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteBgpGroup(request: DeleteBgpGroupRequest): DeleteBgpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBgpGroupWithOptions(request, runtime);
}

model CreateBgpPeerRequest = {
  regionId: string(name='RegionId'),
  bgpGroupId: string(name='BgpGroupId'),
  peerIpAddress?: string(name='PeerIpAddress'),
  enableBfd?: boolean(name='EnableBfd'),
  clientToken?: string(name='ClientToken'),
  ipVersion?: string(name='IpVersion'),
  bfdMultiHop?: integer(name='BfdMultiHop'),
}

model CreateBgpPeerResponse = {
  requestId: string(name='RequestId'),
  bgpPeerId: string(name='BgpPeerId'),
}

async function createBgpPeerWithOptions(request: CreateBgpPeerRequest, runtime: Util.RuntimeOptions): CreateBgpPeerResponse {
  Util.validateModel(request);
  return doRequest('CreateBgpPeer', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createBgpPeer(request: CreateBgpPeerRequest): CreateBgpPeerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBgpPeerWithOptions(request, runtime);
}

model CreateBgpGroupRequest = {
  regionId: string(name='RegionId'),
  routerId: string(name='RouterId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  localAsn?: long(name='LocalAsn'),
  peerAsn: long(name='PeerAsn'),
  authKey?: string(name='AuthKey'),
  isFakeAsn?: boolean(name='IsFakeAsn'),
  clientToken?: string(name='ClientToken'),
  ipVersion?: string(name='IpVersion'),
}

model CreateBgpGroupResponse = {
  requestId: string(name='RequestId'),
  bgpGroupId: string(name='BgpGroupId'),
}

async function createBgpGroupWithOptions(request: CreateBgpGroupRequest, runtime: Util.RuntimeOptions): CreateBgpGroupResponse {
  Util.validateModel(request);
  return doRequest('CreateBgpGroup', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createBgpGroup(request: CreateBgpGroupRequest): CreateBgpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBgpGroupWithOptions(request, runtime);
}

model AddBgpNetworkRequest = {
  regionId: string(name='RegionId'),
  dstCidrBlock: string(name='DstCidrBlock'),
  vpcId?: string(name='VpcId'),
  routerId: string(name='RouterId'),
  clientToken?: string(name='ClientToken'),
}

model AddBgpNetworkResponse = {
  requestId: string(name='RequestId'),
}

async function addBgpNetworkWithOptions(request: AddBgpNetworkRequest, runtime: Util.RuntimeOptions): AddBgpNetworkResponse {
  Util.validateModel(request);
  return doRequest('AddBgpNetwork', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function addBgpNetwork(request: AddBgpNetworkRequest): AddBgpNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBgpNetworkWithOptions(request, runtime);
}

model EnableVpcClassicLinkRequest = {
  regionId: string(name='RegionId'),
  vpcId: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
}

model EnableVpcClassicLinkResponse = {
  requestId: string(name='RequestId'),
}

async function enableVpcClassicLinkWithOptions(request: EnableVpcClassicLinkRequest, runtime: Util.RuntimeOptions): EnableVpcClassicLinkResponse {
  Util.validateModel(request);
  return doRequest('EnableVpcClassicLink', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function enableVpcClassicLink(request: EnableVpcClassicLinkRequest): EnableVpcClassicLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableVpcClassicLinkWithOptions(request, runtime);
}

model DisableVpcClassicLinkRequest = {
  regionId: string(name='RegionId'),
  vpcId: string(name='VpcId'),
  clientToken?: string(name='ClientToken'),
}

model DisableVpcClassicLinkResponse = {
  requestId: string(name='RequestId'),
}

async function disableVpcClassicLinkWithOptions(request: DisableVpcClassicLinkRequest, runtime: Util.RuntimeOptions): DisableVpcClassicLinkResponse {
  Util.validateModel(request);
  return doRequest('DisableVpcClassicLink', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function disableVpcClassicLink(request: DisableVpcClassicLinkRequest): DisableVpcClassicLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableVpcClassicLinkWithOptions(request, runtime);
}

model DescribeVpcAttributeRequest = {
  vpcId: string(name='VpcId'),
  regionId: string(name='RegionId'),
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
}

model DescribeVpcAttributeResponse = {
  requestId: string(name='RequestId'),
  vpcId: string(name='VpcId'),
  regionId: string(name='RegionId'),
  status: string(name='Status'),
  vpcName: string(name='VpcName'),
  creationTime: string(name='CreationTime'),
  cidrBlock: string(name='CidrBlock'),
  ipv6CidrBlock: string(name='Ipv6CidrBlock'),
  VRouterId: string(name='VRouterId'),
  description: string(name='Description'),
  isDefault: boolean(name='IsDefault'),
  classicLinkEnabled: boolean(name='ClassicLinkEnabled'),
  resourceGroupId: string(name='ResourceGroupId'),
  networkAclNum: string(name='NetworkAclNum'),
  ownerId: long(name='OwnerId'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
  dhcpOptionsSetStatus: string(name='DhcpOptionsSetStatus'),
  associatedCens: {
    associatedCen: [
      {
        cenId: string(name='CenId'),
        cenOwnerId: long(name='CenOwnerId'),
        cenStatus: string(name='CenStatus'),
      }
    ](name='AssociatedCen'),
  }(name='AssociatedCens'),
  cloudResources: {
    cloudResourceSetType: [
      {
        resourceType: string(name='ResourceType'),
        resourceCount: integer(name='ResourceCount'),
      }
    ](name='CloudResourceSetType'),
  }(name='CloudResources'),
  vSwitchIds: {
    vSwitchId: [ string ](name='VSwitchId'),
  }(name='VSwitchIds'),
  userCidrs: {
    userCidr: [ string ](name='UserCidr'),
  }(name='UserCidrs'),
  secondaryCidrBlocks: {
    secondaryCidrBlock: [ string ](name='SecondaryCidrBlock'),
  }(name='SecondaryCidrBlocks'),
}

async function describeVpcAttributeWithOptions(request: DescribeVpcAttributeRequest, runtime: Util.RuntimeOptions): DescribeVpcAttributeResponse {
  Util.validateModel(request);
  return doRequest('DescribeVpcAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVpcAttribute(request: DescribeVpcAttributeRequest): DescribeVpcAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcAttributeWithOptions(request, runtime);
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterRequest = {
  regionId: string(name='RegionId'),
  vbrId: string(name='VbrId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
  clientToken?: string(name='ClientToken'),
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterResponse = {
  requestId: string(name='RequestId'),
}

async function unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
  Util.validateModel(request);
  return doRequest('UnassociatePhysicalConnectionFromVirtualBorderRouter', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function unassociatePhysicalConnectionFromVirtualBorderRouter(request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest): UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociatePhysicalConnectionFromVirtualBorderRouterWithOptions(request, runtime);
}

model AssociatePhysicalConnectionToVirtualBorderRouterRequest = {
  regionId: string(name='RegionId'),
  vbrId: string(name='VbrId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
  vlanId: string(name='VlanId'),
  circuitCode?: string(name='CircuitCode'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  clientToken?: string(name='ClientToken'),
}

model AssociatePhysicalConnectionToVirtualBorderRouterResponse = {
  requestId: string(name='RequestId'),
}

async function associatePhysicalConnectionToVirtualBorderRouterWithOptions(request: AssociatePhysicalConnectionToVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): AssociatePhysicalConnectionToVirtualBorderRouterResponse {
  Util.validateModel(request);
  return doRequest('AssociatePhysicalConnectionToVirtualBorderRouter', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function associatePhysicalConnectionToVirtualBorderRouter(request: AssociatePhysicalConnectionToVirtualBorderRouterRequest): AssociatePhysicalConnectionToVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return associatePhysicalConnectionToVirtualBorderRouterWithOptions(request, runtime);
}

model ModifySnatEntryRequest = {
  regionId: string(name='RegionId'),
  snatTableId: string(name='SnatTableId'),
  snatEntryId: string(name='SnatEntryId'),
  snatIp?: string(name='SnatIp'),
  snatEntryName?: string(name='SnatEntryName'),
  clientToken?: string(name='ClientToken'),
}

model ModifySnatEntryResponse = {
  requestId: string(name='RequestId'),
}

async function modifySnatEntryWithOptions(request: ModifySnatEntryRequest, runtime: Util.RuntimeOptions): ModifySnatEntryResponse {
  Util.validateModel(request);
  return doRequest('ModifySnatEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifySnatEntry(request: ModifySnatEntryRequest): ModifySnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySnatEntryWithOptions(request, runtime);
}

model ModifyNatGatewaySpecRequest = {
  regionId: string(name='RegionId'),
  natGatewayId: string(name='NatGatewayId'),
  spec: string(name='Spec'),
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
}

model ModifyNatGatewaySpecResponse = {
  requestId: string(name='RequestId'),
}

async function modifyNatGatewaySpecWithOptions(request: ModifyNatGatewaySpecRequest, runtime: Util.RuntimeOptions): ModifyNatGatewaySpecResponse {
  Util.validateModel(request);
  return doRequest('ModifyNatGatewaySpec', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyNatGatewaySpec(request: ModifyNatGatewaySpecRequest): ModifyNatGatewaySpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatGatewaySpecWithOptions(request, runtime);
}

model ModifyNatGatewayAttributeRequest = {
  regionId: string(name='RegionId'),
  natGatewayId: string(name='NatGatewayId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyNatGatewayAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyNatGatewayAttributeWithOptions(request: ModifyNatGatewayAttributeRequest, runtime: Util.RuntimeOptions): ModifyNatGatewayAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyNatGatewayAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyNatGatewayAttribute(request: ModifyNatGatewayAttributeRequest): ModifyNatGatewayAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNatGatewayAttributeWithOptions(request, runtime);
}

model ModifyBandwidthPackageAttributeRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyBandwidthPackageAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyBandwidthPackageAttributeWithOptions(request: ModifyBandwidthPackageAttributeRequest, runtime: Util.RuntimeOptions): ModifyBandwidthPackageAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyBandwidthPackageAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyBandwidthPackageAttribute(request: ModifyBandwidthPackageAttributeRequest): ModifyBandwidthPackageAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBandwidthPackageAttributeWithOptions(request, runtime);
}

model DescribeSnatTableEntriesRequest = {
  regionId: string(name='RegionId'),
  snatTableId: string(name='SnatTableId'),
  snatEntryId?: string(name='SnatEntryId'),
  sourceVSwitchId?: string(name='SourceVSwitchId'),
  sourceCIDR?: string(name='SourceCIDR'),
  snatIp?: string(name='SnatIp'),
  snatEntryName?: string(name='SnatEntryName'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeSnatTableEntriesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  snatTableEntries: {
    snatTableEntry: [
      {
        snatTableId: string(name='SnatTableId'),
        snatEntryId: string(name='SnatEntryId'),
        sourceVSwitchId: string(name='SourceVSwitchId'),
        sourceCIDR: string(name='SourceCIDR'),
        snatIp: string(name='SnatIp'),
        status: string(name='Status'),
        snatEntryName: string(name='SnatEntryName'),
      }
    ](name='SnatTableEntry'),
  }(name='SnatTableEntries'),
}

async function describeSnatTableEntriesWithOptions(request: DescribeSnatTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeSnatTableEntriesResponse {
  Util.validateModel(request);
  return doRequest('DescribeSnatTableEntries', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeSnatTableEntries(request: DescribeSnatTableEntriesRequest): DescribeSnatTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnatTableEntriesWithOptions(request, runtime);
}

model DeleteSnatEntryRequest = {
  regionId: string(name='RegionId'),
  snatTableId: string(name='SnatTableId'),
  snatEntryId: string(name='SnatEntryId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteSnatEntryResponse = {
  requestId: string(name='RequestId'),
}

async function deleteSnatEntryWithOptions(request: DeleteSnatEntryRequest, runtime: Util.RuntimeOptions): DeleteSnatEntryResponse {
  Util.validateModel(request);
  return doRequest('DeleteSnatEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteSnatEntry(request: DeleteSnatEntryRequest): DeleteSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSnatEntryWithOptions(request, runtime);
}

model CreateSnatEntryRequest = {
  regionId: string(name='RegionId'),
  snatTableId: string(name='SnatTableId'),
  sourceVSwitchId?: string(name='SourceVSwitchId'),
  sourceCIDR?: string(name='SourceCIDR'),
  snatIp: string(name='SnatIp'),
  snatEntryName?: string(name='SnatEntryName'),
  clientToken?: string(name='ClientToken'),
}

model CreateSnatEntryResponse = {
  requestId: string(name='RequestId'),
  snatEntryId: string(name='SnatEntryId'),
}

async function createSnatEntryWithOptions(request: CreateSnatEntryRequest, runtime: Util.RuntimeOptions): CreateSnatEntryResponse {
  Util.validateModel(request);
  return doRequest('CreateSnatEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createSnatEntry(request: CreateSnatEntryRequest): CreateSnatEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSnatEntryWithOptions(request, runtime);
}

model CreateBandwidthPackageRequest = {
  regionId: string(name='RegionId'),
  natGatewayId: string(name='NatGatewayId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  ipCount: integer(name='IpCount'),
  bandwidth: integer(name='Bandwidth'),
  ISP?: string(name='ISP'),
  zone?: string(name='Zone'),
  internetChargeType?: string(name='InternetChargeType'),
}

model CreateBandwidthPackageResponse = {
  requestId: string(name='RequestId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
}

async function createBandwidthPackageWithOptions(request: CreateBandwidthPackageRequest, runtime: Util.RuntimeOptions): CreateBandwidthPackageResponse {
  Util.validateModel(request);
  return doRequest('CreateBandwidthPackage', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createBandwidthPackage(request: CreateBandwidthPackageRequest): CreateBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBandwidthPackageWithOptions(request, runtime);
}

model UnassociateHaVipRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  haVipId: string(name='HaVipId'),
  instanceId: string(name='InstanceId'),
  force?: string(name='Force'),
}

model UnassociateHaVipResponse = {
  requestId: string(name='RequestId'),
}

async function unassociateHaVipWithOptions(request: UnassociateHaVipRequest, runtime: Util.RuntimeOptions): UnassociateHaVipResponse {
  Util.validateModel(request);
  return doRequest('UnassociateHaVip', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function unassociateHaVip(request: UnassociateHaVipRequest): UnassociateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateHaVipWithOptions(request, runtime);
}

model UnassociateEipAddressRequest = {
  force?: boolean(name='Force'),
  regionId?: string(name='RegionId'),
  allocationId: string(name='AllocationId'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  clientToken?: string(name='ClientToken'),
}

model UnassociateEipAddressResponse = {
  requestId: string(name='RequestId'),
}

async function unassociateEipAddressWithOptions(request: UnassociateEipAddressRequest, runtime: Util.RuntimeOptions): UnassociateEipAddressResponse {
  Util.validateModel(request);
  return doRequest('UnassociateEipAddress', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function unassociateEipAddress(request: UnassociateEipAddressRequest): UnassociateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return unassociateEipAddressWithOptions(request, runtime);
}

model TerminateVirtualBorderRouterRequest = {
  regionId: string(name='RegionId'),
  vbrId: string(name='VbrId'),
  clientToken?: string(name='ClientToken'),
}

model TerminateVirtualBorderRouterResponse = {
  requestId: string(name='RequestId'),
}

async function terminateVirtualBorderRouterWithOptions(request: TerminateVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): TerminateVirtualBorderRouterResponse {
  Util.validateModel(request);
  return doRequest('TerminateVirtualBorderRouter', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function terminateVirtualBorderRouter(request: TerminateVirtualBorderRouterRequest): TerminateVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateVirtualBorderRouterWithOptions(request, runtime);
}

model TerminatePhysicalConnectionRequest = {
  regionId: string(name='RegionId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
  clientToken?: string(name='ClientToken'),
}

model TerminatePhysicalConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function terminatePhysicalConnectionWithOptions(request: TerminatePhysicalConnectionRequest, runtime: Util.RuntimeOptions): TerminatePhysicalConnectionResponse {
  Util.validateModel(request);
  return doRequest('TerminatePhysicalConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function terminatePhysicalConnection(request: TerminatePhysicalConnectionRequest): TerminatePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminatePhysicalConnectionWithOptions(request, runtime);
}

model RemoveBandwidthPackageIpsRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  removedIpAddresses: [ string ](name='RemovedIpAddresses'),
}

model RemoveBandwidthPackageIpsResponse = {
  requestId: string(name='RequestId'),
}

async function removeBandwidthPackageIpsWithOptions(request: RemoveBandwidthPackageIpsRequest, runtime: Util.RuntimeOptions): RemoveBandwidthPackageIpsResponse {
  Util.validateModel(request);
  return doRequest('RemoveBandwidthPackageIps', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function removeBandwidthPackageIps(request: RemoveBandwidthPackageIpsRequest): RemoveBandwidthPackageIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeBandwidthPackageIpsWithOptions(request, runtime);
}

model ReleaseEipAddressRequest = {
  regionId?: string(name='RegionId'),
  allocationId: string(name='AllocationId'),
}

model ReleaseEipAddressResponse = {
  requestId: string(name='RequestId'),
}

async function releaseEipAddressWithOptions(request: ReleaseEipAddressRequest, runtime: Util.RuntimeOptions): ReleaseEipAddressResponse {
  Util.validateModel(request);
  return doRequest('ReleaseEipAddress', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function releaseEipAddress(request: ReleaseEipAddressRequest): ReleaseEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseEipAddressWithOptions(request, runtime);
}

model RecoverVirtualBorderRouterRequest = {
  regionId: string(name='RegionId'),
  vbrId: string(name='VbrId'),
  clientToken?: string(name='ClientToken'),
}

model RecoverVirtualBorderRouterResponse = {
  requestId: string(name='RequestId'),
}

async function recoverVirtualBorderRouterWithOptions(request: RecoverVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): RecoverVirtualBorderRouterResponse {
  Util.validateModel(request);
  return doRequest('RecoverVirtualBorderRouter', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function recoverVirtualBorderRouter(request: RecoverVirtualBorderRouterRequest): RecoverVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoverVirtualBorderRouterWithOptions(request, runtime);
}

model ModifyVSwitchAttributeRequest = {
  vSwitchId: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  regionId?: string(name='RegionId'),
  description?: string(name='Description'),
  ipv6CidrBlock?: integer(name='Ipv6CidrBlock'),
}

model ModifyVSwitchAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyVSwitchAttributeWithOptions(request: ModifyVSwitchAttributeRequest, runtime: Util.RuntimeOptions): ModifyVSwitchAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyVSwitchAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): ModifyVSwitchAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVSwitchAttributeWithOptions(request, runtime);
}

model ModifyVRouterAttributeRequest = {
  regionId?: string(name='RegionId'),
  VRouterId: string(name='VRouterId'),
  VRouterName?: string(name='VRouterName'),
  description?: string(name='Description'),
}

model ModifyVRouterAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyVRouterAttributeWithOptions(request: ModifyVRouterAttributeRequest, runtime: Util.RuntimeOptions): ModifyVRouterAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyVRouterAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyVRouterAttribute(request: ModifyVRouterAttributeRequest): ModifyVRouterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVRouterAttributeWithOptions(request, runtime);
}

model ModifyVpcAttributeRequest = {
  vpcId: string(name='VpcId'),
  description?: string(name='Description'),
  vpcName?: string(name='VpcName'),
  cidrBlock?: string(name='CidrBlock'),
  regionId?: string(name='RegionId'),
  enableIPv6?: boolean(name='EnableIPv6'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
}

model ModifyVpcAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyVpcAttributeWithOptions(request: ModifyVpcAttributeRequest, runtime: Util.RuntimeOptions): ModifyVpcAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyVpcAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyVpcAttribute(request: ModifyVpcAttributeRequest): ModifyVpcAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVpcAttributeWithOptions(request, runtime);
}

model ModifyVirtualBorderRouterAttributeRequest = {
  regionId: string(name='RegionId'),
  vbrId: string(name='VbrId'),
  vlanId?: integer(name='VlanId'),
  circuitCode?: string(name='CircuitCode'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  minTxInterval?: long(name='MinTxInterval'),
  minRxInterval?: long(name='MinRxInterval'),
  detectMultiplier?: long(name='DetectMultiplier'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  associatedPhysicalConnections?: string(name='AssociatedPhysicalConnections'),
  clientToken?: string(name='ClientToken'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  enableIpv6?: boolean(name='EnableIpv6'),
}

model ModifyVirtualBorderRouterAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyVirtualBorderRouterAttributeWithOptions(request: ModifyVirtualBorderRouterAttributeRequest, runtime: Util.RuntimeOptions): ModifyVirtualBorderRouterAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyVirtualBorderRouterAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyVirtualBorderRouterAttribute(request: ModifyVirtualBorderRouterAttributeRequest): ModifyVirtualBorderRouterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyVirtualBorderRouterAttributeWithOptions(request, runtime);
}

model ModifyRouterInterfaceSpecRequest = {
  regionId: string(name='RegionId'),
  routerInterfaceId: string(name='RouterInterfaceId'),
  spec: string(name='Spec'),
  clientToken?: string(name='ClientToken'),
}

model ModifyRouterInterfaceSpecResponse = {
  requestId: string(name='RequestId'),
  spec: string(name='Spec'),
}

async function modifyRouterInterfaceSpecWithOptions(request: ModifyRouterInterfaceSpecRequest, runtime: Util.RuntimeOptions): ModifyRouterInterfaceSpecResponse {
  Util.validateModel(request);
  return doRequest('ModifyRouterInterfaceSpec', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyRouterInterfaceSpec(request: ModifyRouterInterfaceSpecRequest): ModifyRouterInterfaceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouterInterfaceSpecWithOptions(request, runtime);
}

model ModifyRouterInterfaceAttributeRequest = {
  regionId: string(name='RegionId'),
  routerInterfaceId: string(name='RouterInterfaceId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  oppositeInterfaceOwnerId?: long(name='OppositeInterfaceOwnerId'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  hcThreshold?: integer(name='HcThreshold'),
  hcRate?: integer(name='HcRate'),
  deleteHealthCheckIp?: boolean(name='DeleteHealthCheckIp'),
}

model ModifyRouterInterfaceAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyRouterInterfaceAttributeWithOptions(request: ModifyRouterInterfaceAttributeRequest, runtime: Util.RuntimeOptions): ModifyRouterInterfaceAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyRouterInterfaceAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyRouterInterfaceAttribute(request: ModifyRouterInterfaceAttributeRequest): ModifyRouterInterfaceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRouterInterfaceAttributeWithOptions(request, runtime);
}

model ModifyPhysicalConnectionAttributeRequest = {
  regionId: string(name='RegionId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
  lineOperator?: string(name='LineOperator'),
  bandwidth?: integer(name='bandwidth'),
  peerLocation?: string(name='PeerLocation'),
  portType?: string(name='PortType'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  clientToken?: string(name='ClientToken'),
  circuitCode?: string(name='CircuitCode'),
}

model ModifyPhysicalConnectionAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyPhysicalConnectionAttributeWithOptions(request: ModifyPhysicalConnectionAttributeRequest, runtime: Util.RuntimeOptions): ModifyPhysicalConnectionAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyPhysicalConnectionAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyPhysicalConnectionAttribute(request: ModifyPhysicalConnectionAttributeRequest): ModifyPhysicalConnectionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPhysicalConnectionAttributeWithOptions(request, runtime);
}

model ModifyHaVipAttributeRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  haVipId: string(name='HaVipId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
}

model ModifyHaVipAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyHaVipAttributeWithOptions(request: ModifyHaVipAttributeRequest, runtime: Util.RuntimeOptions): ModifyHaVipAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyHaVipAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyHaVipAttribute(request: ModifyHaVipAttributeRequest): ModifyHaVipAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHaVipAttributeWithOptions(request, runtime);
}

model ModifyForwardEntryRequest = {
  forwardTableId: string(name='ForwardTableId'),
  forwardEntryId: string(name='ForwardEntryId'),
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  forwardEntryName?: string(name='ForwardEntryName'),
  regionId: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  portBreak?: boolean(name='PortBreak'),
}

model ModifyForwardEntryResponse = {
  requestId: string(name='RequestId'),
}

async function modifyForwardEntryWithOptions(request: ModifyForwardEntryRequest, runtime: Util.RuntimeOptions): ModifyForwardEntryResponse {
  Util.validateModel(request);
  return doRequest('ModifyForwardEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyForwardEntry(request: ModifyForwardEntryRequest): ModifyForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyForwardEntryWithOptions(request, runtime);
}

model ModifyEipAddressAttributeRequest = {
  allocationId: string(name='AllocationId'),
  bandwidth?: string(name='Bandwidth'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyEipAddressAttributeResponse = {
  requestId: string(name='RequestId'),
}

async function modifyEipAddressAttributeWithOptions(request: ModifyEipAddressAttributeRequest, runtime: Util.RuntimeOptions): ModifyEipAddressAttributeResponse {
  Util.validateModel(request);
  return doRequest('ModifyEipAddressAttribute', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyEipAddressAttribute(request: ModifyEipAddressAttributeRequest): ModifyEipAddressAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyEipAddressAttributeWithOptions(request, runtime);
}

model ModifyBandwidthPackageSpecRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  bandwidth: string(name='Bandwidth'),
}

model ModifyBandwidthPackageSpecResponse = {
  requestId: string(name='RequestId'),
}

async function modifyBandwidthPackageSpecWithOptions(request: ModifyBandwidthPackageSpecRequest, runtime: Util.RuntimeOptions): ModifyBandwidthPackageSpecResponse {
  Util.validateModel(request);
  return doRequest('ModifyBandwidthPackageSpec', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function modifyBandwidthPackageSpec(request: ModifyBandwidthPackageSpecRequest): ModifyBandwidthPackageSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBandwidthPackageSpecWithOptions(request, runtime);
}

model EnablePhysicalConnectionRequest = {
  regionId: string(name='RegionId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
  clientToken?: string(name='ClientToken'),
}

model EnablePhysicalConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function enablePhysicalConnectionWithOptions(request: EnablePhysicalConnectionRequest, runtime: Util.RuntimeOptions): EnablePhysicalConnectionResponse {
  Util.validateModel(request);
  return doRequest('EnablePhysicalConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function enablePhysicalConnection(request: EnablePhysicalConnectionRequest): EnablePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enablePhysicalConnectionWithOptions(request, runtime);
}

model DescribeZonesRequest = {
  regionId: string(name='RegionId'),
}

model DescribeZonesResponse = {
  requestId: string(name='RequestId'),
  zones: {
    zone: [
      {
        zoneId: string(name='ZoneId'),
        localName: string(name='LocalName'),
      }
    ](name='Zone'),
  }(name='Zones'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  return doRequest('DescribeZones', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model DescribeVSwitchesRequest = {
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
  regionId?: string(name='RegionId'),
  vSwitchName?: string(name='VSwitchName'),
  dryRun?: boolean(name='DryRun'),
  isDefault?: boolean(name='IsDefault'),
  routeTableId?: string(name='RouteTableId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  vSwitchOwnerId?: long(name='VSwitchOwnerId'),
}

model DescribeVSwitchesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  vSwitches: {
    vSwitch: [
      {
        vSwitchId: string(name='VSwitchId'),
        vpcId: string(name='VpcId'),
        status: string(name='Status'),
        cidrBlock: string(name='CidrBlock'),
        ipv6CidrBlock: string(name='Ipv6CidrBlock'),
        zoneId: string(name='ZoneId'),
        availableIpAddressCount: long(name='AvailableIpAddressCount'),
        description: string(name='Description'),
        vSwitchName: string(name='VSwitchName'),
        creationTime: string(name='CreationTime'),
        isDefault: boolean(name='IsDefault'),
        resourceGroupId: string(name='ResourceGroupId'),
        networkAclId: string(name='NetworkAclId'),
        ownerId: long(name='OwnerId'),
        shareType: string(name='ShareType'),
        tags: {
          tag: [
            {
              key: string(name='Key'),
              value: string(name='Value'),
            }
          ](name='Tag'),
        }(name='Tags'),
        routeTable: {
          routeTableId: string(name='RouteTableId'),
          routeTableType: string(name='RouteTableType'),
        }(name='RouteTable'),
      }
    ](name='VSwitch'),
  }(name='VSwitches'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  return doRequest('DescribeVSwitches', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DescribeVRoutersRequest = {
  VRouterId?: string(name='VRouterId'),
  regionId: string(name='RegionId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeVRoutersResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  VRouters: {
    VRouter: [
      {
        regionId: string(name='RegionId'),
        vpcId: string(name='VpcId'),
        VRouterName: string(name='VRouterName'),
        description: string(name='Description'),
        VRouterId: string(name='VRouterId'),
        creationTime: string(name='CreationTime'),
        routeTableIds: {
          routeTableId: [ string ](name='RouteTableId', description='RouteTableId'),
        }(name='RouteTableIds'),
      }
    ](name='VRouter'),
  }(name='VRouters'),
}

async function describeVRoutersWithOptions(request: DescribeVRoutersRequest, runtime: Util.RuntimeOptions): DescribeVRoutersResponse {
  Util.validateModel(request);
  return doRequest('DescribeVRouters', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVRouters(request: DescribeVRoutersRequest): DescribeVRoutersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVRoutersWithOptions(request, runtime);
}

model DescribeVpcsRequest = {
  vpcId?: string(name='VpcId'),
  regionId: string(name='RegionId'),
  vpcName?: string(name='VpcName'),
  isDefault?: boolean(name='IsDefault'),
  dryRun?: boolean(name='DryRun'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  vpcOwnerId?: long(name='VpcOwnerId'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
}

model DescribeVpcsResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  vpcs: {
    vpc: [
      {
        vpcId: string(name='VpcId'),
        regionId: string(name='RegionId'),
        status: string(name='Status'),
        vpcName: string(name='VpcName'),
        creationTime: string(name='CreationTime'),
        cidrBlock: string(name='CidrBlock'),
        ipv6CidrBlock: string(name='Ipv6CidrBlock'),
        VRouterId: string(name='VRouterId'),
        description: string(name='Description'),
        isDefault: boolean(name='IsDefault'),
        networkAclNum: string(name='NetworkAclNum'),
        resourceGroupId: string(name='ResourceGroupId'),
        cenStatus: string(name='CenStatus'),
        ownerId: long(name='OwnerId'),
        supportAdvancedFeature: boolean(name='SupportAdvancedFeature'),
        advancedResource: boolean(name='AdvancedResource'),
        dhcpOptionsSetId: string(name='DhcpOptionsSetId'),
        dhcpOptionsSetStatus: string(name='DhcpOptionsSetStatus'),
        tags: {
          tag: [
            {
              key: string(name='Key'),
              value: string(name='Value'),
            }
          ](name='Tag'),
        }(name='Tags'),
        vSwitchIds: {
          vSwitchId: [ string ](name='VSwitchId', description='VSwitchId'),
        }(name='VSwitchIds'),
        userCidrs: {
          userCidr: [ string ](name='UserCidr', description='UserCidr'),
        }(name='UserCidrs'),
        natGatewayIds: {
          natGatewayIds: [ string ](name='NatGatewayIds', description='NatGatewayIds'),
        }(name='NatGatewayIds'),
        routerTableIds: {
          routerTableIds: [ string ](name='RouterTableIds', description='RouterTableIds'),
        }(name='RouterTableIds'),
        secondaryCidrBlocks: {
          secondaryCidrBlock: [ string ](name='SecondaryCidrBlock', description='SecondaryCidrBlock'),
        }(name='SecondaryCidrBlocks'),
      }
    ](name='Vpc'),
  }(name='Vpcs'),
}

async function describeVpcsWithOptions(request: DescribeVpcsRequest, runtime: Util.RuntimeOptions): DescribeVpcsResponse {
  Util.validateModel(request);
  return doRequest('DescribeVpcs', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVpcsWithOptions(request, runtime);
}

model DescribeVirtualBorderRoutersForPhysicalConnectionRequest = {
  filter?: [
    {
      key: string(name='Key'),
      value: [ string ](name='Value'),
    }
  ](name='Filter'),
  regionId: string(name='RegionId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  virtualBorderRouterForPhysicalConnectionSet: {
    virtualBorderRouterForPhysicalConnectionType: [
      {
        vbrId: string(name='VbrId'),
        vbrOwnerUid: long(name='VbrOwnerUid'),
        eccId: string(name='EccId'),
        type: string(name='Type'),
        creationTime: string(name='CreationTime'),
        activationTime: string(name='ActivationTime'),
        terminationTime: string(name='TerminationTime'),
        recoveryTime: string(name='RecoveryTime'),
        vlanId: integer(name='VlanId'),
        status: string(name='Status'),
        circuitCode: string(name='CircuitCode'),
        localGatewayIp: string(name='LocalGatewayIp'),
        peerGatewayIp: string(name='PeerGatewayIp'),
        peeringSubnetMask: string(name='PeeringSubnetMask'),
        PConnVbrChargeType: string(name='PConnVbrChargeType'),
        PConnVbrExpireTime: string(name='PConnVbrExpireTime'),
        PConnVbrBussinessStatus: string(name='PConnVbrBussinessStatus'),
        bandwidth: string(name='Bandwidth'),
        localIpv6GatewayIp: string(name='LocalIpv6GatewayIp'),
        peerIpv6GatewayIp: string(name='PeerIpv6GatewayIp'),
        peeringIpv6SubnetMask: string(name='PeeringIpv6SubnetMask'),
        enableIpv6: boolean(name='EnableIpv6'),
      }
    ](name='VirtualBorderRouterForPhysicalConnectionType'),
  }(name='VirtualBorderRouterForPhysicalConnectionSet'),
}

async function describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest, runtime: Util.RuntimeOptions): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  Util.validateModel(request);
  return doRequest('DescribeVirtualBorderRoutersForPhysicalConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVirtualBorderRoutersForPhysicalConnection(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualBorderRoutersForPhysicalConnectionWithOptions(request, runtime);
}

model DescribeVirtualBorderRoutersRequest = {
  regionId: string(name='RegionId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  filter?: [
    {
      key: string(name='Key'),
      value: [ string ](name='Value'),
    }
  ](name='Filter'),
}

model DescribeVirtualBorderRoutersResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  virtualBorderRouterSet: {
    virtualBorderRouterType: [
      {
        vbrId: string(name='VbrId'),
        creationTime: string(name='CreationTime'),
        activationTime: string(name='ActivationTime'),
        terminationTime: string(name='TerminationTime'),
        recoveryTime: string(name='RecoveryTime'),
        status: string(name='Status'),
        vlanId: integer(name='VlanId'),
        circuitCode: string(name='CircuitCode'),
        routeTableId: string(name='RouteTableId'),
        vlanInterfaceId: string(name='VlanInterfaceId'),
        localGatewayIp: string(name='LocalGatewayIp'),
        peerGatewayIp: string(name='PeerGatewayIp'),
        peeringSubnetMask: string(name='PeeringSubnetMask'),
        physicalConnectionId: string(name='PhysicalConnectionId'),
        physicalConnectionStatus: string(name='PhysicalConnectionStatus'),
        physicalConnectionBusinessStatus: string(name='PhysicalConnectionBusinessStatus'),
        physicalConnectionOwnerUid: string(name='PhysicalConnectionOwnerUid'),
        accessPointId: string(name='AccessPointId'),
        name: string(name='Name'),
        description: string(name='Description'),
        PConnVbrExpireTime: string(name='PConnVbrExpireTime'),
        eccId: string(name='EccId'),
        type: string(name='Type'),
        minTxInterval: long(name='MinTxInterval'),
        minRxInterval: long(name='MinRxInterval'),
        detectMultiplier: long(name='DetectMultiplier'),
        localIpv6GatewayIp: string(name='LocalIpv6GatewayIp'),
        peerIpv6GatewayIp: string(name='PeerIpv6GatewayIp'),
        peeringIpv6SubnetMask: string(name='PeeringIpv6SubnetMask'),
        enableIpv6: boolean(name='EnableIpv6'),
        associatedPhysicalConnections: {
          associatedPhysicalConnection: [
            {
              circuitCode: string(name='CircuitCode'),
              vlanInterfaceId: string(name='VlanInterfaceId'),
              localGatewayIp: string(name='LocalGatewayIp'),
              peerGatewayIp: string(name='PeerGatewayIp'),
              peeringSubnetMask: string(name='PeeringSubnetMask'),
              physicalConnectionId: string(name='PhysicalConnectionId'),
              physicalConnectionStatus: string(name='PhysicalConnectionStatus'),
              physicalConnectionBusinessStatus: string(name='PhysicalConnectionBusinessStatus'),
              physicalConnectionOwnerUid: string(name='PhysicalConnectionOwnerUid'),
              vlanId: string(name='VlanId'),
              localIpv6GatewayIp: string(name='LocalIpv6GatewayIp'),
              peerIpv6GatewayIp: string(name='PeerIpv6GatewayIp'),
              peeringIpv6SubnetMask: string(name='PeeringIpv6SubnetMask'),
              status: string(name='Status'),
            }
          ](name='AssociatedPhysicalConnection'),
        }(name='AssociatedPhysicalConnections'),
        associatedCens: {
          associatedCen: [
            {
              cenId: string(name='CenId'),
              cenOwnerId: long(name='CenOwnerId'),
              cenStatus: string(name='CenStatus'),
            }
          ](name='AssociatedCen'),
        }(name='AssociatedCens'),
      }
    ](name='VirtualBorderRouterType'),
  }(name='VirtualBorderRouterSet'),
}

async function describeVirtualBorderRoutersWithOptions(request: DescribeVirtualBorderRoutersRequest, runtime: Util.RuntimeOptions): DescribeVirtualBorderRoutersResponse {
  Util.validateModel(request);
  return doRequest('DescribeVirtualBorderRouters', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeVirtualBorderRouters(request: DescribeVirtualBorderRoutersRequest): DescribeVirtualBorderRoutersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualBorderRoutersWithOptions(request, runtime);
}

model DescribeRouteTablesRequest = {
  regionId?: string(name='RegionId'),
  VRouterId?: string(name='VRouterId'),
  routeTableId?: string(name='RouteTableId'),
  routerType?: string(name='RouterType'),
  routerId?: string(name='RouterId'),
  type?: string(name='Type'),
  routeTableName?: string(name='RouteTableName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeRouteTablesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  routeTables: {
    routeTable: [
      {
        VRouterId: string(name='VRouterId'),
        routeTableId: string(name='RouteTableId'),
        routeTableType: string(name='RouteTableType'),
        creationTime: string(name='CreationTime'),
        resourceGroupId: string(name='ResourceGroupId'),
        status: string(name='Status'),
        routeEntrys: {
          routeEntry: [
            {
              routeTableId: string(name='RouteTableId'),
              destinationCidrBlock: string(name='DestinationCidrBlock'),
              type: string(name='Type'),
              status: string(name='Status'),
              instanceId: string(name='InstanceId'),
              nextHopType: string(name='NextHopType'),
              routeEntryName: string(name='RouteEntryName'),
              description: string(name='Description'),
              routeEntryId: string(name='RouteEntryId'),
              nextHopRegionId: string(name='NextHopRegionId'),
              nextHopOppsiteType: string(name='NextHopOppsiteType'),
              nextHopOppsiteInstanceId: string(name='NextHopOppsiteInstanceId'),
              nextHopOppsiteRegionId: string(name='NextHopOppsiteRegionId'),
              privateIpAddress: string(name='PrivateIpAddress'),
              nextHops: {
                nextHop: [
                  {
                    nextHopType: string(name='NextHopType'),
                    nextHopId: string(name='NextHopId'),
                    enabled: integer(name='Enabled'),
                    weight: integer(name='Weight'),
                    nextHopRegionId: string(name='NextHopRegionId'),
                    nextHopOppsiteType: string(name='NextHopOppsiteType'),
                    nextHopOppsiteInstanceId: string(name='NextHopOppsiteInstanceId'),
                    nextHopOppsiteRegionId: string(name='NextHopOppsiteRegionId'),
                  }
                ](name='NextHop'),
              }(name='NextHops'),
            }
          ](name='RouteEntry'),
        }(name='RouteEntrys'),
        vSwitchIds: {
          vSwitchId: [ string ](name='VSwitchId', description='VSwitchId'),
        }(name='VSwitchIds'),
      }
    ](name='RouteTable'),
  }(name='RouteTables'),
}

async function describeRouteTablesWithOptions(request: DescribeRouteTablesRequest, runtime: Util.RuntimeOptions): DescribeRouteTablesResponse {
  Util.validateModel(request);
  return doRequest('DescribeRouteTables', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeRouteTables(request: DescribeRouteTablesRequest): DescribeRouteTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouteTablesWithOptions(request, runtime);
}

model DescribeRouterInterfacesRequest = {
  regionId: string(name='RegionId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  filter?: [
    {
      key: string(name='Key'),
      value: [ string ](name='Value'),
    }
  ](name='Filter'),
}

model DescribeRouterInterfacesResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  routerInterfaceSet: {
    routerInterfaceType: [
      {
        routerInterfaceId: string(name='RouterInterfaceId'),
        oppositeRegionId: string(name='OppositeRegionId'),
        role: string(name='Role'),
        spec: string(name='Spec'),
        name: string(name='Name'),
        description: string(name='Description'),
        routerId: string(name='RouterId'),
        routerType: string(name='RouterType'),
        creationTime: string(name='CreationTime'),
        endTime: string(name='EndTime'),
        chargeType: string(name='ChargeType'),
        status: string(name='Status'),
        businessStatus: string(name='BusinessStatus'),
        connectedTime: string(name='ConnectedTime'),
        oppositeInterfaceId: string(name='OppositeInterfaceId'),
        oppositeInterfaceSpec: string(name='OppositeInterfaceSpec'),
        oppositeInterfaceStatus: string(name='OppositeInterfaceStatus'),
        oppositeInterfaceBusinessStatus: string(name='OppositeInterfaceBusinessStatus'),
        oppositeRouterId: string(name='OppositeRouterId'),
        oppositeRouterType: string(name='OppositeRouterType'),
        oppositeInterfaceOwnerId: string(name='OppositeInterfaceOwnerId'),
        accessPointId: string(name='AccessPointId'),
        oppositeAccessPointId: string(name='OppositeAccessPointId'),
        healthCheckSourceIp: string(name='HealthCheckSourceIp'),
        healthCheckTargetIp: string(name='HealthCheckTargetIp'),
        oppositeVpcInstanceId: string(name='OppositeVpcInstanceId'),
        bandwidth: integer(name='Bandwidth'),
        vpcInstanceId: string(name='VpcInstanceId'),
        oppositeBandwidth: integer(name='OppositeBandwidth'),
        hasReservationData: string(name='HasReservationData'),
        reservationBandwidth: string(name='ReservationBandwidth'),
        reservationInternetChargeType: string(name='ReservationInternetChargeType'),
        reservationActiveTime: string(name='ReservationActiveTime'),
        reservationOrderType: string(name='ReservationOrderType'),
        crossBorder: boolean(name='CrossBorder'),
        hcThreshold: integer(name='HcThreshold'),
        hcRate: integer(name='HcRate'),
      }
    ](name='RouterInterfaceType'),
  }(name='RouterInterfaceSet'),
}

async function describeRouterInterfacesWithOptions(request: DescribeRouterInterfacesRequest, runtime: Util.RuntimeOptions): DescribeRouterInterfacesResponse {
  Util.validateModel(request);
  return doRequest('DescribeRouterInterfaces', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeRouterInterfaces(request: DescribeRouterInterfacesRequest): DescribeRouterInterfacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRouterInterfacesWithOptions(request, runtime);
}

model DescribeRegionsRequest = {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponse = {
  requestId: string(name='RequestId'),
  regions: {
    region: [
      {
        regionId: string(name='RegionId'),
        localName: string(name='LocalName'),
        regionEndpoint: string(name='RegionEndpoint'),
      }
    ](name='Region'),
  }(name='Regions'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  return doRequest('DescribeRegions', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribePhysicalConnectionsRequest = {
  regionId: string(name='RegionId', description='description: The ID of the region where the leased line is deployed. You can obtain the region ID by calling the [DescribeRegions](~~36063~~); '),
  pageNumber?: integer(name='PageNumber', description='description: Optional. The page number of the physical connection list. Default value: 1.; '),
  pageSize?: integer(name='PageSize', description='description: Optional. The number of rows per page. Maximum value: 50. Default value: 10.; '),
  filter?: [
    {
      key: string(name='Key'),
      value: [ string ](name='Value'),
    }
  ](name='Filter'),
  includeReservationData?: boolean(name='IncludeReservationData', description='description: Optional. Indicates whether to return invalid orders.; '),
  clientToken?: string(name='ClientToken', description='description: Optional. It is used to guarantee the idempotence of requests. This parameter is generated by clients. It must be unique for each request and must not exceed 64 ASCII characters in length.; '),
}

model DescribePhysicalConnectionsResponse = {
  requestId: string(name='RequestId', description='description: The ID of the request ; '),
  pageNumber: integer(name='PageNumber', description='description: The current page number ; '),
  pageSize: integer(name='PageSize', description='description: The number of items per page; '),
  totalCount: integer(name='TotalCount', description='description: The number of items in a list; '),
  physicalConnectionSet: {
    physicalConnectionType: [
      {
        physicalConnectionId: string(name='PhysicalConnectionId', description='description: The ID of the physical connection; '),
        accessPointId: string(name='AccessPointId', description='description: The access point ID of the physical connection; '),
        type: string(name='Type', description='description: The type of the physical connection. Default value: **VPC**.; '),
        status: string(name='Status', description='description: The status of the physical connection. Valid values: * **Initial**: The physical connection has been applied for and is under review by Alibaba Cloud* **Approved**: The application is approved* **Allocating**: Resources* **Allocated**: The leased line is being installed.* **Confirmed**: The completed leased line installation needs to be confirmed by the customer.* **Enabled**: The physical connection interface is enabled.* **Rejected**: The application is rejected.* **Canceled**: The application is canceled.* **Allocation Failed**: Failed to allocate resources* **Terminated**: The physical connection is terminated; '),
        businessStatus: string(name='BusinessStatus', description='description: The payment status of the physical connection. Valid values: * Normal * FinancialLocked: locked due to overdue payment* SecurityLocked: locked due to security reasons; '),
        creationTime: string(name='CreationTime', description='description: The time when the physical connection is established ; '),
        enabledTime: string(name='EnabledTime', description='description: The time when the physical connection is enabled ; '),
        lineOperator: string(name='LineOperator', description='description: The service provider that provides the leased line. Valid values:* CT: China Telecom * CU: China Unicom* CM: China Mobile* CO: Other Chinese service providers* Equinix: Equinix * Other: Other service providers outside Mainland China; '),
        spec: string(name='Spec', description='description: The specification of the physical connection; '),
        peerLocation: string(name='PeerLocation', description='description: The location of the on-premises IDC; '),
        portType: string(name='PortType', description='description: The type of physical connection ports:* 100Base-T: 100M electrical ports * 1000Base-T (default value): Gigabit electrical ports * 1000Base-LX: Gigabit single-mode optical ports (10 km) * 10GBase-T: 10-GE electrical ports  * 10GBase-LR: 10-GE single-mode optical ports (10 km); '),
        redundantPhysicalConnectionId: string(name='RedundantPhysicalConnectionId', description='description: The ID of the redundant physical connection; '),
        name: string(name='Name', description='description: The name of the physical connection; '),
        description: string(name='Description', description='description: A description about the physical connection; '),
        adLocation: string(name='AdLocation', description='description: The location where the leased line is connected; '),
        portNumber: string(name='PortNumber', description='description: The port number of the physical connection device; '),
        circuitCode: string(name='CircuitCode', description='description: The number of the leased line from the service provider; '),
        bandwidth: long(name='Bandwidth', description='description: The bandwidth of the physical connection; '),
        loaStatus: string(name='LoaStatus', description='description: The status of the LOA ; '),
        hasReservationData: string(name='HasReservationData', description='description: Indicates whether subscription messages are received; '),
        reservationInternetChargeType: string(name='ReservationInternetChargeType', description='description: The type of renewal ; '),
        reservationActiveTime: string(name='ReservationActiveTime', description='description: The effective time of a renewal; '),
        reservationOrderType: string(name='ReservationOrderType', description='description: The type of the renewal order ; '),
        endTime: string(name='EndTime', description='description: The time when the physical connection expires ; '),
        chargeType: string(name='ChargeType', description='description: The billing method of the physical connection; '),
      }
    ](name='PhysicalConnectionType'),
  }(name='PhysicalConnectionSet', description='description: Details of physical connections'),
}

/**
 * DescribePhysicalConnections Query physical connections in a region.
  * request demo:   * https://vpc.aliyuncs.com/?Action=DescribePhysicalConnections
  * &RegionId=cn-hangzhou
  * &<CommonParameters>
  * description: 
 */
async function describePhysicalConnectionsWithOptions(request: DescribePhysicalConnectionsRequest, runtime: Util.RuntimeOptions): DescribePhysicalConnectionsResponse {
  Util.validateModel(request);
  return doRequest('DescribePhysicalConnections', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

/**
 * DescribePhysicalConnections Query physical connections in a region.
  * request demo:   * https://vpc.aliyuncs.com/?Action=DescribePhysicalConnections
  * &RegionId=cn-hangzhou
  * &<CommonParameters>
  * description: 
 */
async function describePhysicalConnections(request: DescribePhysicalConnectionsRequest): DescribePhysicalConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePhysicalConnectionsWithOptions(request, runtime);
}

model DescribeNewProjectEipMonitorDataRequest = {
  regionId?: string(name='RegionId'),
  allocationId: string(name='AllocationId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  period?: integer(name='Period'),
}

model DescribeNewProjectEipMonitorDataResponse = {
  requestId: string(name='RequestId'),
  eipMonitorDatas: {
    eipMonitorData: [
      {
        eipRX: integer(name='EipRX'),
        eipTX: integer(name='EipTX'),
        eipFlow: integer(name='EipFlow'),
        eipBandwidth: integer(name='EipBandwidth'),
        eipPackets: integer(name='EipPackets'),
        timeStamp: string(name='TimeStamp'),
      }
    ](name='EipMonitorData'),
  }(name='EipMonitorDatas'),
}

async function describeNewProjectEipMonitorDataWithOptions(request: DescribeNewProjectEipMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeNewProjectEipMonitorDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeNewProjectEipMonitorData', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeNewProjectEipMonitorData(request: DescribeNewProjectEipMonitorDataRequest): DescribeNewProjectEipMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNewProjectEipMonitorDataWithOptions(request, runtime);
}

model DescribeNatGatewaysRequest = {
  regionId: string(name='RegionId'),
  natGatewayId?: string(name='NatGatewayId'),
  vpcId?: string(name='VpcId'),
  name?: string(name='Name'),
  instanceChargeType?: string(name='InstanceChargeType'),
  spec?: string(name='Spec'),
  natType?: string(name='NatType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  dryRun?: boolean(name='DryRun'),
}

model DescribeNatGatewaysResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  natGateways: {
    natGateway: [
      {
        natGatewayId: string(name='NatGatewayId'),
        regionId: string(name='RegionId'),
        name: string(name='Name'),
        description: string(name='Description'),
        vpcId: string(name='VpcId'),
        spec: string(name='Spec'),
        instanceChargeType: string(name='InstanceChargeType'),
        expiredTime: string(name='ExpiredTime'),
        autoPay: boolean(name='AutoPay'),
        businessStatus: string(name='BusinessStatus'),
        creationTime: string(name='CreationTime'),
        status: string(name='Status'),
        natType: string(name='NatType'),
        internetChargeType: string(name='InternetChargeType'),
        resourceGroupId: string(name='ResourceGroupId'),
        deletionProtection: boolean(name='DeletionProtection'),
        ecsMetricEnabled: boolean(name='EcsMetricEnabled'),
        ipLists: {
          ipList: [
            {
              allocationId: string(name='AllocationId'),
              ipAddress: string(name='IpAddress'),
              usingStatus: string(name='UsingStatus'),
              apAccessEnabled: boolean(name='ApAccessEnabled'),
              snatEntryEnabled: boolean(name='SnatEntryEnabled'),
            }
          ](name='IpList'),
        }(name='IpLists'),
        natGatewayPrivateInfo: {
          eniInstanceId: string(name='EniInstanceId'),
          privateIpAddress: string(name='PrivateIpAddress'),
          vswitchId: string(name='VswitchId'),
          izNo: string(name='IzNo'),
          maxBandwidth: integer(name='MaxBandwidth'),
        }(name='NatGatewayPrivateInfo'),
        forwardTableIds: {
          forwardTableId: [ string ](name='ForwardTableId', description='ForwardTableId'),
        }(name='ForwardTableIds'),
        snatTableIds: {
          snatTableId: [ string ](name='SnatTableId', description='SnatTableId'),
        }(name='SnatTableIds'),
        bandwidthPackageIds: {
          bandwidthPackageId: [ string ](name='BandwidthPackageId', description='BandwidthPackageId'),
        }(name='BandwidthPackageIds'),
      }
    ](name='NatGateway'),
  }(name='NatGateways'),
}

async function describeNatGatewaysWithOptions(request: DescribeNatGatewaysRequest, runtime: Util.RuntimeOptions): DescribeNatGatewaysResponse {
  Util.validateModel(request);
  return doRequest('DescribeNatGateways', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeNatGateways(request: DescribeNatGatewaysRequest): DescribeNatGatewaysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNatGatewaysWithOptions(request, runtime);
}

model DescribeHaVipsRequest = {
  regionId: string(name='RegionId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  filter?: [
    {
      key: string(name='Key'),
      value: [ string ](name='Value'),
    }
  ](name='Filter'),
}

model DescribeHaVipsResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  haVips: {
    haVip: [
      {
        haVipId: string(name='HaVipId'),
        regionId: string(name='RegionId'),
        vpcId: string(name='VpcId'),
        vSwitchId: string(name='VSwitchId'),
        ipAddress: string(name='IpAddress'),
        status: string(name='Status'),
        masterInstanceId: string(name='MasterInstanceId'),
        description: string(name='Description'),
        name: string(name='Name'),
        chargeType: string(name='ChargeType'),
        createTime: string(name='CreateTime'),
        associatedInstances: {
          associatedInstance: [ string ](name='associatedInstance', description='associatedInstance'),
        }(name='AssociatedInstances'),
        associatedEipAddresses: {
          associatedEipAddresse: [ string ](name='associatedEipAddresse', description='associatedEipAddresse'),
        }(name='AssociatedEipAddresses'),
      }
    ](name='HaVip'),
  }(name='HaVips'),
}

async function describeHaVipsWithOptions(request: DescribeHaVipsRequest, runtime: Util.RuntimeOptions): DescribeHaVipsResponse {
  Util.validateModel(request);
  return doRequest('DescribeHaVips', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeHaVips(request: DescribeHaVipsRequest): DescribeHaVipsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHaVipsWithOptions(request, runtime);
}

model DescribeForwardTableEntriesRequest = {
  regionId: string(name='RegionId'),
  forwardTableId: string(name='ForwardTableId'),
  forwardEntryId?: string(name='ForwardEntryId'),
  externalIp?: string(name='ExternalIp'),
  externalPort?: string(name='ExternalPort'),
  internalIp?: string(name='InternalIp'),
  internalPort?: string(name='InternalPort'),
  ipProtocol?: string(name='IpProtocol'),
  forwardEntryName?: string(name='ForwardEntryName'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeForwardTableEntriesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  forwardTableEntries: {
    forwardTableEntry: [
      {
        forwardTableId: string(name='ForwardTableId'),
        forwardEntryId: string(name='ForwardEntryId'),
        externalIp: string(name='ExternalIp'),
        externalPort: string(name='ExternalPort'),
        ipProtocol: string(name='IpProtocol'),
        internalIp: string(name='InternalIp'),
        internalPort: string(name='InternalPort'),
        status: string(name='Status'),
        forwardEntryName: string(name='ForwardEntryName'),
      }
    ](name='ForwardTableEntry'),
  }(name='ForwardTableEntries'),
}

async function describeForwardTableEntriesWithOptions(request: DescribeForwardTableEntriesRequest, runtime: Util.RuntimeOptions): DescribeForwardTableEntriesResponse {
  Util.validateModel(request);
  return doRequest('DescribeForwardTableEntries', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): DescribeForwardTableEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeForwardTableEntriesWithOptions(request, runtime);
}

model DescribeEipMonitorDataRequest = {
  regionId?: string(name='RegionId'),
  allocationId: string(name='AllocationId'),
  startTime: string(name='StartTime'),
  endTime: string(name='EndTime'),
  period?: integer(name='Period'),
}

model DescribeEipMonitorDataResponse = {
  requestId: string(name='RequestId'),
  eipMonitorDatas: {
    eipMonitorData: [
      {
        eipRX: long(name='EipRX'),
        eipTX: long(name='EipTX'),
        eipFlow: integer(name='EipFlow'),
        eipBandwidth: integer(name='EipBandwidth'),
        eipPackets: integer(name='EipPackets'),
        timeStamp: string(name='TimeStamp'),
      }
    ](name='EipMonitorData'),
  }(name='EipMonitorDatas'),
}

async function describeEipMonitorDataWithOptions(request: DescribeEipMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeEipMonitorDataResponse {
  Util.validateModel(request);
  return doRequest('DescribeEipMonitorData', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeEipMonitorData(request: DescribeEipMonitorDataRequest): DescribeEipMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipMonitorDataWithOptions(request, runtime);
}

model DescribeEipAddressesRequest = {
  regionId: string(name='RegionId'),
  includeReservationData?: boolean(name='IncludeReservationData'),
  status?: string(name='Status'),
  eipAddress?: string(name='EipAddress'),
  allocationId?: string(name='AllocationId'),
  segmentInstanceId?: string(name='SegmentInstanceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
  ISP?: string(name='ISP'),
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter'),
  lockReason?: string(name='LockReason'),
  associatedInstanceType?: string(name='AssociatedInstanceType'),
  associatedInstanceId?: string(name='AssociatedInstanceId'),
  chargeType?: string(name='ChargeType'),
  dryRun?: boolean(name='DryRun'),
}

model DescribeEipAddressesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  eipAddresses: {
    eipAddress: [
      {
        regionId: string(name='RegionId'),
        ipAddress: string(name='IpAddress'),
        privateIpAddress: string(name='PrivateIpAddress'),
        allocationId: string(name='AllocationId'),
        status: string(name='Status'),
        instanceId: string(name='InstanceId'),
        bandwidth: string(name='Bandwidth'),
        eipBandwidth: string(name='EipBandwidth'),
        internetChargeType: string(name='InternetChargeType'),
        allocationTime: string(name='AllocationTime'),
        instanceType: string(name='InstanceType'),
        instanceRegionId: string(name='InstanceRegionId'),
        chargeType: string(name='ChargeType'),
        expiredTime: string(name='ExpiredTime'),
        HDMonitorStatus: string(name='HDMonitorStatus'),
        name: string(name='Name'),
        ISP: string(name='ISP'),
        descritpion: string(name='Descritpion'),
        bandwidthPackageId: string(name='BandwidthPackageId'),
        bandwidthPackageType: string(name='BandwidthPackageType'),
        bandwidthPackageBandwidth: string(name='BandwidthPackageBandwidth'),
        resourceGroupId: string(name='ResourceGroupId'),
        hasReservationData: string(name='HasReservationData'),
        reservationBandwidth: string(name='ReservationBandwidth'),
        reservationInternetChargeType: string(name='ReservationInternetChargeType'),
        reservationActiveTime: string(name='ReservationActiveTime'),
        reservationOrderType: string(name='ReservationOrderType'),
        mode: string(name='Mode'),
        deletionProtection: boolean(name='DeletionProtection'),
        secondLimited: boolean(name='SecondLimited'),
        segmentInstanceId: string(name='SegmentInstanceId'),
        netmode: string(name='Netmode'),
        operationLocks: {
          lockReason: [
            {
              lockReason: string(name='LockReason'),
            }
          ](name='LockReason'),
        }(name='OperationLocks'),
        availableRegions: {
          availableRegion: [ string ](name='AvailableRegion', description='AvailableRegion'),
        }(name='AvailableRegions'),
      }
    ](name='EipAddress'),
  }(name='EipAddresses'),
}

async function describeEipAddressesWithOptions(request: DescribeEipAddressesRequest, runtime: Util.RuntimeOptions): DescribeEipAddressesResponse {
  Util.validateModel(request);
  return doRequest('DescribeEipAddresses', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeEipAddresses(request: DescribeEipAddressesRequest): DescribeEipAddressesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEipAddressesWithOptions(request, runtime);
}

model DescribeBandwidthPackagesRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  natGatewayId?: string(name='NatGatewayId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeBandwidthPackagesResponse = {
  requestId: string(name='RequestId'),
  totalCount: integer(name='TotalCount'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  bandwidthPackages: {
    bandwidthPackage: [
      {
        bandwidthPackageId: string(name='BandwidthPackageId'),
        regionId: string(name='RegionId'),
        name: string(name='Name'),
        description: string(name='Description'),
        zoneId: string(name='ZoneId'),
        natGatewayId: string(name='NatGatewayId'),
        bandwidth: string(name='Bandwidth'),
        instanceChargeType: string(name='InstanceChargeType'),
        internetChargeType: string(name='InternetChargeType'),
        businessStatus: string(name='BusinessStatus'),
        ipCount: string(name='IpCount'),
        creationTime: string(name='CreationTime'),
        status: string(name='Status'),
        ISP: string(name='ISP'),
        publicIpAddresses: {
          publicIpAddresse: [
            {
              allocationId: string(name='AllocationId'),
              ipAddress: string(name='IpAddress'),
              usingStatus: string(name='UsingStatus'),
              apAccessEnabled: boolean(name='ApAccessEnabled'),
            }
          ](name='PublicIpAddresse'),
        }(name='PublicIpAddresses'),
      }
    ](name='BandwidthPackage'),
  }(name='BandwidthPackages'),
}

async function describeBandwidthPackagesWithOptions(request: DescribeBandwidthPackagesRequest, runtime: Util.RuntimeOptions): DescribeBandwidthPackagesResponse {
  Util.validateModel(request);
  return doRequest('DescribeBandwidthPackages', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeBandwidthPackages(request: DescribeBandwidthPackagesRequest): DescribeBandwidthPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBandwidthPackagesWithOptions(request, runtime);
}

model DescribeAccessPointsRequest = {
  regionId: string(name='RegionId'),
  pageNumber?: integer(name='PageNumber'),
  pageSize?: integer(name='PageSize'),
}

model DescribeAccessPointsResponse = {
  requestId: string(name='RequestId'),
  pageNumber: integer(name='PageNumber'),
  pageSize: integer(name='PageSize'),
  totalCount: integer(name='TotalCount'),
  accessPointSet: {
    accessPointType: [
      {
        accessPointId: string(name='AccessPointId'),
        status: string(name='Status'),
        type: string(name='Type'),
        attachedRegionNo: string(name='AttachedRegionNo'),
        location: string(name='Location'),
        hostOperator: string(name='HostOperator'),
        name: string(name='Name'),
        description: string(name='Description'),
      }
    ](name='AccessPointType'),
  }(name='AccessPointSet'),
}

async function describeAccessPointsWithOptions(request: DescribeAccessPointsRequest, runtime: Util.RuntimeOptions): DescribeAccessPointsResponse {
  Util.validateModel(request);
  return doRequest('DescribeAccessPoints', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function describeAccessPoints(request: DescribeAccessPointsRequest): DescribeAccessPointsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccessPointsWithOptions(request, runtime);
}

model DeleteVSwitchRequest = {
  vSwitchId: string(name='VSwitchId'),
  regionId?: string(name='RegionId'),
}

model DeleteVSwitchResponse = {
  requestId: string(name='RequestId'),
}

async function deleteVSwitchWithOptions(request: DeleteVSwitchRequest, runtime: Util.RuntimeOptions): DeleteVSwitchResponse {
  Util.validateModel(request);
  return doRequest('DeleteVSwitch', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteVSwitch(request: DeleteVSwitchRequest): DeleteVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVSwitchWithOptions(request, runtime);
}

model DeleteVpcRequest = {
  vpcId: string(name='VpcId'),
  regionId?: string(name='RegionId'),
}

model DeleteVpcResponse = {
  requestId: string(name='RequestId'),
}

async function deleteVpcWithOptions(request: DeleteVpcRequest, runtime: Util.RuntimeOptions): DeleteVpcResponse {
  Util.validateModel(request);
  return doRequest('DeleteVpc', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteVpc(request: DeleteVpcRequest): DeleteVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVpcWithOptions(request, runtime);
}

model DeleteVirtualBorderRouterRequest = {
  regionId: string(name='RegionId'),
  vbrId: string(name='VbrId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteVirtualBorderRouterResponse = {
  requestId: string(name='RequestId'),
}

async function deleteVirtualBorderRouterWithOptions(request: DeleteVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): DeleteVirtualBorderRouterResponse {
  Util.validateModel(request);
  return doRequest('DeleteVirtualBorderRouter', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteVirtualBorderRouter(request: DeleteVirtualBorderRouterRequest): DeleteVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualBorderRouterWithOptions(request, runtime);
}

model DeleteRouterInterfaceRequest = {
  regionId: string(name='RegionId'),
  routerInterfaceId: string(name='RouterInterfaceId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteRouterInterfaceResponse = {
  requestId: string(name='RequestId'),
}

async function deleteRouterInterfaceWithOptions(request: DeleteRouterInterfaceRequest, runtime: Util.RuntimeOptions): DeleteRouterInterfaceResponse {
  Util.validateModel(request);
  return doRequest('DeleteRouterInterface', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteRouterInterface(request: DeleteRouterInterfaceRequest): DeleteRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouterInterfaceWithOptions(request, runtime);
}

model DeleteRouteEntryRequest = {
  regionId?: string(name='RegionId'),
  routeTableId?: string(name='RouteTableId'),
  routeEntryId?: string(name='RouteEntryId'),
  destinationCidrBlock?: string(name='DestinationCidrBlock'),
  nextHopId?: string(name='NextHopId'),
  nextHopList?: [
    {
      nextHopType: string(name='NextHopType'),
      nextHopId: string(name='NextHopId'),
    }
  ](name='NextHopList'),
}

model DeleteRouteEntryResponse = {
  requestId: string(name='RequestId'),
}

async function deleteRouteEntryWithOptions(request: DeleteRouteEntryRequest, runtime: Util.RuntimeOptions): DeleteRouteEntryResponse {
  Util.validateModel(request);
  return doRequest('DeleteRouteEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteRouteEntry(request: DeleteRouteEntryRequest): DeleteRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouteEntryWithOptions(request, runtime);
}

model DeletePhysicalConnectionRequest = {
  regionId: string(name='RegionId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
  clientToken?: string(name='ClientToken'),
}

model DeletePhysicalConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function deletePhysicalConnectionWithOptions(request: DeletePhysicalConnectionRequest, runtime: Util.RuntimeOptions): DeletePhysicalConnectionResponse {
  Util.validateModel(request);
  return doRequest('DeletePhysicalConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deletePhysicalConnection(request: DeletePhysicalConnectionRequest): DeletePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePhysicalConnectionWithOptions(request, runtime);
}

model DeleteNatGatewayRequest = {
  regionId: string(name='RegionId'),
  natGatewayId: string(name='NatGatewayId'),
  force?: boolean(name='Force'),
}

model DeleteNatGatewayResponse = {
  requestId: string(name='RequestId'),
}

async function deleteNatGatewayWithOptions(request: DeleteNatGatewayRequest, runtime: Util.RuntimeOptions): DeleteNatGatewayResponse {
  Util.validateModel(request);
  return doRequest('DeleteNatGateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteNatGateway(request: DeleteNatGatewayRequest): DeleteNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNatGatewayWithOptions(request, runtime);
}

model DeleteHaVipRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  haVipId: string(name='HaVipId'),
}

model DeleteHaVipResponse = {
  requestId: string(name='RequestId'),
}

async function deleteHaVipWithOptions(request: DeleteHaVipRequest, runtime: Util.RuntimeOptions): DeleteHaVipResponse {
  Util.validateModel(request);
  return doRequest('DeleteHaVip', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteHaVip(request: DeleteHaVipRequest): DeleteHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHaVipWithOptions(request, runtime);
}

model DeleteForwardEntryRequest = {
  regionId: string(name='RegionId'),
  forwardTableId: string(name='ForwardTableId'),
  forwardEntryId: string(name='ForwardEntryId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteForwardEntryResponse = {
  requestId: string(name='RequestId'),
}

async function deleteForwardEntryWithOptions(request: DeleteForwardEntryRequest, runtime: Util.RuntimeOptions): DeleteForwardEntryResponse {
  Util.validateModel(request);
  return doRequest('DeleteForwardEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteForwardEntry(request: DeleteForwardEntryRequest): DeleteForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteForwardEntryWithOptions(request, runtime);
}

model DeleteBandwidthPackageRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  force?: boolean(name='Force'),
}

model DeleteBandwidthPackageResponse = {
  requestId: string(name='RequestId'),
}

async function deleteBandwidthPackageWithOptions(request: DeleteBandwidthPackageRequest, runtime: Util.RuntimeOptions): DeleteBandwidthPackageResponse {
  Util.validateModel(request);
  return doRequest('DeleteBandwidthPackage', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deleteBandwidthPackage(request: DeleteBandwidthPackageRequest): DeleteBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBandwidthPackageWithOptions(request, runtime);
}

model DeactivateRouterInterfaceRequest = {
  regionId: string(name='RegionId'),
  routerInterfaceId: string(name='RouterInterfaceId'),
}

model DeactivateRouterInterfaceResponse = {
  requestId: string(name='RequestId'),
}

async function deactivateRouterInterfaceWithOptions(request: DeactivateRouterInterfaceRequest, runtime: Util.RuntimeOptions): DeactivateRouterInterfaceResponse {
  Util.validateModel(request);
  return doRequest('DeactivateRouterInterface', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function deactivateRouterInterface(request: DeactivateRouterInterfaceRequest): DeactivateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deactivateRouterInterfaceWithOptions(request, runtime);
}

model CreateVSwitchRequest = {
  zoneId: string(name='ZoneId'),
  regionId?: string(name='RegionId'),
  cidrBlock: string(name='CidrBlock'),
  ipv6CidrBlock?: integer(name='Ipv6CidrBlock'),
  vpcId: string(name='VpcId'),
  vSwitchName?: string(name='VSwitchName'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
}

model CreateVSwitchResponse = {
  requestId: string(name='RequestId'),
  vSwitchId: string(name='VSwitchId'),
}

async function createVSwitchWithOptions(request: CreateVSwitchRequest, runtime: Util.RuntimeOptions): CreateVSwitchResponse {
  Util.validateModel(request);
  return doRequest('CreateVSwitch', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createVSwitch(request: CreateVSwitchRequest): CreateVSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVSwitchWithOptions(request, runtime);
}

model CreateVpcRequest = {
  regionId: string(name='RegionId'),
  cidrBlock?: string(name='CidrBlock'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  enableIpv6?: boolean(name='EnableIpv6'),
  vpcName?: string(name='VpcName'),
  description?: string(name='Description'),
  resourceGroupId?: string(name='ResourceGroupId'),
  dryRun?: boolean(name='DryRun'),
  userCidr?: string(name='UserCidr'),
  clientToken?: string(name='ClientToken'),
}

model CreateVpcResponse = {
  requestId: string(name='RequestId'),
  vpcId: string(name='VpcId'),
  VRouterId: string(name='VRouterId'),
  routeTableId: string(name='RouteTableId'),
  resourceGroupId: string(name='ResourceGroupId'),
}

async function createVpcWithOptions(request: CreateVpcRequest, runtime: Util.RuntimeOptions): CreateVpcResponse {
  Util.validateModel(request);
  return doRequest('CreateVpc', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createVpc(request: CreateVpcRequest): CreateVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVpcWithOptions(request, runtime);
}

model CreateVirtualBorderRouterRequest = {
  regionId: string(name='RegionId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
  vbrOwnerId?: long(name='VbrOwnerId'),
  vlanId: integer(name='VlanId'),
  circuitCode?: string(name='CircuitCode'),
  localGatewayIp?: string(name='LocalGatewayIp'),
  peerGatewayIp?: string(name='PeerGatewayIp'),
  peeringSubnetMask?: string(name='PeeringSubnetMask'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  clientToken?: string(name='ClientToken'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
  enableIpv6?: boolean(name='EnableIpv6'),
}

model CreateVirtualBorderRouterResponse = {
  requestId: string(name='RequestId'),
  vbrId: string(name='VbrId'),
}

async function createVirtualBorderRouterWithOptions(request: CreateVirtualBorderRouterRequest, runtime: Util.RuntimeOptions): CreateVirtualBorderRouterResponse {
  Util.validateModel(request);
  return doRequest('CreateVirtualBorderRouter', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createVirtualBorderRouter(request: CreateVirtualBorderRouterRequest): CreateVirtualBorderRouterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualBorderRouterWithOptions(request, runtime);
}

model CreateRouterInterfaceRequest = {
  regionId: string(name='RegionId'),
  role: string(name='Role'),
  oppositeRegionId: string(name='OppositeRegionId'),
  spec: string(name='Spec'),
  routerType: string(name='RouterType'),
  routerId: string(name='RouterId'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  accessPointId?: string(name='AccessPointId'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  period?: integer(name='Period'),
  instanceChargeType?: string(name='InstanceChargeType'),
  autoPay?: boolean(name='AutoPay'),
  pricingCycle?: string(name='PricingCycle'),
  clientToken?: string(name='ClientToken'),
}

model CreateRouterInterfaceResponse = {
  requestId: string(name='RequestId'),
  routerInterfaceId: string(name='RouterInterfaceId'),
  orderId: long(name='OrderId'),
}

async function createRouterInterfaceWithOptions(request: CreateRouterInterfaceRequest, runtime: Util.RuntimeOptions): CreateRouterInterfaceResponse {
  Util.validateModel(request);
  return doRequest('CreateRouterInterface', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createRouterInterface(request: CreateRouterInterfaceRequest): CreateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouterInterfaceWithOptions(request, runtime);
}

model CreateRouteEntryRequest = {
  regionId?: string(name='RegionId'),
  routeTableId: string(name='RouteTableId'),
  destinationCidrBlock: string(name='DestinationCidrBlock'),
  nextHopId?: string(name='NextHopId'),
  clientToken?: string(name='ClientToken'),
  routeEntryName?: string(name='RouteEntryName'),
  description?: string(name='Description'),
  nextHopType?: string(name='NextHopType'),
  nextHopList?: [
    {
      nextHopType: string(name='NextHopType'),
      nextHopId: string(name='NextHopId'),
      weight: integer(name='Weight'),
    }
  ](name='NextHopList'),
}

model CreateRouteEntryResponse = {
  requestId: string(name='RequestId'),
}

async function createRouteEntryWithOptions(request: CreateRouteEntryRequest, runtime: Util.RuntimeOptions): CreateRouteEntryResponse {
  Util.validateModel(request);
  return doRequest('CreateRouteEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createRouteEntry(request: CreateRouteEntryRequest): CreateRouteEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouteEntryWithOptions(request, runtime);
}

model CreatePhysicalConnectionRequest = {
  regionId: string(name='RegionId'),
  accessPointId: string(name='AccessPointId'),
  type?: string(name='Type'),
  lineOperator: string(name='LineOperator'),
  bandwidth?: integer(name='bandwidth'),
  peerLocation: string(name='PeerLocation'),
  portType?: string(name='PortType'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  circuitCode?: string(name='CircuitCode'),
  clientToken?: string(name='ClientToken'),
}

model CreatePhysicalConnectionResponse = {
  requestId: string(name='RequestId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
}

async function createPhysicalConnectionWithOptions(request: CreatePhysicalConnectionRequest, runtime: Util.RuntimeOptions): CreatePhysicalConnectionResponse {
  Util.validateModel(request);
  return doRequest('CreatePhysicalConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createPhysicalConnection(request: CreatePhysicalConnectionRequest): CreatePhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalConnectionWithOptions(request, runtime);
}

model CreateNatGatewayRequest = {
  regionId: string(name='RegionId'),
  vpcId: string(name='VpcId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientToken?: string(name='ClientToken'),
  spec?: string(name='Spec'),
  bandwidthPackage?: [
    {
      ipCount: integer(name='IpCount'),
      bandwidth: integer(name='Bandwidth'),
      zone: string(name='Zone'),
      ISP: string(name='ISP'),
    }
  ](name='BandwidthPackage'),
  instanceChargeType?: string(name='InstanceChargeType'),
  pricingCycle?: string(name='PricingCycle'),
  duration?: string(name='Duration'),
  autoPay?: boolean(name='AutoPay'),
  vSwitchId?: string(name='VSwitchId'),
  natType?: string(name='NatType'),
  internetChargeType?: string(name='InternetChargeType'),
}

model CreateNatGatewayResponse = {
  requestId: string(name='RequestId'),
  natGatewayId: string(name='NatGatewayId'),
  forwardTableIds: {
    forwardTableId: [ string ](name='ForwardTableId'),
  }(name='ForwardTableIds'),
  snatTableIds: {
    snatTableId: [ string ](name='SnatTableId'),
  }(name='SnatTableIds'),
  bandwidthPackageIds: {
    bandwidthPackageId: [ string ](name='BandwidthPackageId'),
  }(name='BandwidthPackageIds'),
}

async function createNatGatewayWithOptions(request: CreateNatGatewayRequest, runtime: Util.RuntimeOptions): CreateNatGatewayResponse {
  Util.validateModel(request);
  return doRequest('CreateNatGateway', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createNatGateway(request: CreateNatGatewayRequest): CreateNatGatewayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNatGatewayWithOptions(request, runtime);
}

model CreateHaVipRequest = {
  name?: string(name='Name'),
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  vSwitchId: string(name='VSwitchId'),
  ipAddress?: string(name='IpAddress'),
  description?: string(name='Description'),
}

model CreateHaVipResponse = {
  requestId: string(name='RequestId'),
  haVipId: string(name='HaVipId'),
  ipAddress: string(name='IpAddress'),
}

async function createHaVipWithOptions(request: CreateHaVipRequest, runtime: Util.RuntimeOptions): CreateHaVipResponse {
  Util.validateModel(request);
  return doRequest('CreateHaVip', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createHaVip(request: CreateHaVipRequest): CreateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHaVipWithOptions(request, runtime);
}

model CreateForwardEntryRequest = {
  regionId: string(name='RegionId'),
  forwardTableId: string(name='ForwardTableId'),
  externalIp: string(name='ExternalIp'),
  externalPort: string(name='ExternalPort'),
  internalIp: string(name='InternalIp'),
  internalPort: string(name='InternalPort'),
  ipProtocol: string(name='IpProtocol'),
  forwardEntryName?: string(name='ForwardEntryName'),
  clientToken?: string(name='ClientToken'),
  portBreak?: boolean(name='PortBreak'),
}

model CreateForwardEntryResponse = {
  requestId: string(name='RequestId'),
  forwardEntryId: string(name='ForwardEntryId'),
}

async function createForwardEntryWithOptions(request: CreateForwardEntryRequest, runtime: Util.RuntimeOptions): CreateForwardEntryResponse {
  Util.validateModel(request);
  return doRequest('CreateForwardEntry', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function createForwardEntry(request: CreateForwardEntryRequest): CreateForwardEntryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createForwardEntryWithOptions(request, runtime);
}

model ConnectRouterInterfaceRequest = {
  regionId: string(name='RegionId'),
  routerInterfaceId: string(name='RouterInterfaceId'),
}

model ConnectRouterInterfaceResponse = {
  requestId: string(name='RequestId'),
}

async function connectRouterInterfaceWithOptions(request: ConnectRouterInterfaceRequest, runtime: Util.RuntimeOptions): ConnectRouterInterfaceResponse {
  Util.validateModel(request);
  return doRequest('ConnectRouterInterface', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function connectRouterInterface(request: ConnectRouterInterfaceRequest): ConnectRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return connectRouterInterfaceWithOptions(request, runtime);
}

model CancelPhysicalConnectionRequest = {
  regionId: string(name='RegionId'),
  physicalConnectionId: string(name='PhysicalConnectionId'),
  clientToken?: string(name='ClientToken'),
}

model CancelPhysicalConnectionResponse = {
  requestId: string(name='RequestId'),
}

async function cancelPhysicalConnectionWithOptions(request: CancelPhysicalConnectionRequest, runtime: Util.RuntimeOptions): CancelPhysicalConnectionResponse {
  Util.validateModel(request);
  return doRequest('CancelPhysicalConnection', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function cancelPhysicalConnection(request: CancelPhysicalConnectionRequest): CancelPhysicalConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelPhysicalConnectionWithOptions(request, runtime);
}

model AssociateHaVipRequest = {
  clientToken?: string(name='ClientToken'),
  regionId: string(name='RegionId'),
  haVipId: string(name='HaVipId'),
  instanceId: string(name='InstanceId'),
}

model AssociateHaVipResponse = {
  requestId: string(name='RequestId'),
}

async function associateHaVipWithOptions(request: AssociateHaVipRequest, runtime: Util.RuntimeOptions): AssociateHaVipResponse {
  Util.validateModel(request);
  return doRequest('AssociateHaVip', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function associateHaVip(request: AssociateHaVipRequest): AssociateHaVipResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateHaVipWithOptions(request, runtime);
}

model AssociateEipAddressRequest = {
  regionId?: string(name='RegionId'),
  allocationId: string(name='AllocationId'),
  instanceId: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  instanceRegionId?: string(name='InstanceRegionId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  mode?: string(name='Mode'),
  clientToken?: string(name='ClientToken'),
}

model AssociateEipAddressResponse = {
  requestId: string(name='RequestId'),
}

async function associateEipAddressWithOptions(request: AssociateEipAddressRequest, runtime: Util.RuntimeOptions): AssociateEipAddressResponse {
  Util.validateModel(request);
  return doRequest('AssociateEipAddress', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function associateEipAddress(request: AssociateEipAddressRequest): AssociateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateEipAddressWithOptions(request, runtime);
}

model AllocateEipAddressRequest = {
  regionId: string(name='RegionId'),
  bandwidth?: string(name='Bandwidth'),
  period?: integer(name='Period'),
  ISP?: string(name='ISP'),
  activityId?: long(name='ActivityId'),
  netmode?: string(name='Netmode'),
  autoPay?: boolean(name='AutoPay'),
  pricingCycle?: string(name='PricingCycle'),
  instanceChargeType?: string(name='InstanceChargeType'),
  internetChargeType?: string(name='InternetChargeType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
}

model AllocateEipAddressResponse = {
  requestId: string(name='RequestId'),
  allocationId: string(name='AllocationId'),
  eipAddress: string(name='EipAddress'),
  orderId: long(name='OrderId'),
  resourceGroupId: string(name='ResourceGroupId'),
}

async function allocateEipAddressWithOptions(request: AllocateEipAddressRequest, runtime: Util.RuntimeOptions): AllocateEipAddressResponse {
  Util.validateModel(request);
  return doRequest('AllocateEipAddress', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function allocateEipAddress(request: AllocateEipAddressRequest): AllocateEipAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateEipAddressWithOptions(request, runtime);
}

model AddBandwidthPackageIpsRequest = {
  regionId: string(name='RegionId'),
  bandwidthPackageId: string(name='BandwidthPackageId'),
  ipCount: string(name='IpCount'),
  clientToken?: string(name='ClientToken'),
}

model AddBandwidthPackageIpsResponse = {
  requestId: string(name='RequestId'),
}

async function addBandwidthPackageIpsWithOptions(request: AddBandwidthPackageIpsRequest, runtime: Util.RuntimeOptions): AddBandwidthPackageIpsResponse {
  Util.validateModel(request);
  return doRequest('AddBandwidthPackageIps', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function addBandwidthPackageIps(request: AddBandwidthPackageIpsRequest): AddBandwidthPackageIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBandwidthPackageIpsWithOptions(request, runtime);
}

model ActivateRouterInterfaceRequest = {
  regionId: string(name='RegionId'),
  routerInterfaceId: string(name='RouterInterfaceId'),
}

model ActivateRouterInterfaceResponse = {
  requestId: string(name='RequestId'),
}

async function activateRouterInterfaceWithOptions(request: ActivateRouterInterfaceRequest, runtime: Util.RuntimeOptions): ActivateRouterInterfaceResponse {
  Util.validateModel(request);
  return doRequest('ActivateRouterInterface', 'HTTPS', 'POST', '2016-04-28', 'AK', null, request, runtime);
}

async function activateRouterInterface(request: ActivateRouterInterfaceRequest): ActivateRouterInterfaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateRouterInterfaceWithOptions(request, runtime);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
