/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Vpc';
  @version = '2016-04-28';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'vpc.aliyuncs.com',
    cn-beijing = 'vpc.aliyuncs.com',
    cn-hangzhou = 'vpc.aliyuncs.com',
    cn-shanghai = 'vpc.aliyuncs.com',
    cn-shenzhen = 'vpc.aliyuncs.com',
    cn-hongkong = 'vpc.aliyuncs.com',
    ap-southeast-1 = 'vpc.aliyuncs.com',
    us-east-1 = 'vpc.aliyuncs.com',
    us-west-1 = 'vpc.aliyuncs.com',
    cn-shanghai-finance-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-finance-1 = 'vpc.aliyuncs.com',
    cn-north-2-gov-1 = 'vpc.aliyuncs.com',
    ap-northeast-2-pop = 'vpc.aliyuncs.com',
    cn-beijing-finance-pop = 'vpc.aliyuncs.com',
    cn-beijing-gov-1 = 'vpc.aliyuncs.com',
    cn-beijing-nu16-b01 = 'vpc.aliyuncs.com',
    cn-edge-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-fujian = 'vpc.aliyuncs.com',
    cn-haidian-cm12-c01 = 'vpc.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'vpc.aliyuncs.com',
    cn-hangzhou-finance = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'vpc.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'vpc.aliyuncs.com',
    cn-hangzhou-test-306 = 'vpc.aliyuncs.com',
    cn-hongkong-finance-pop = 'vpc.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-qingdao-nebula = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    cn-shanghai-et15-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-et2-b01 = 'vpc.aliyuncs.com',
    cn-shanghai-inner = 'vpc.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'vpc.aliyuncs.com',
    cn-shenzhen-inner = 'vpc.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'vpc.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'vpc.aliyuncs.com',
    cn-wuhan = 'vpc.aliyuncs.com',
    cn-yushanfang = 'vpc.aliyuncs.com',
    cn-zhangbei = 'vpc.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'vpc.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'vpc.cn-zhangjiakou.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'vpc-nebula.cn-qingdao-nebula.aliyuncs.com',
    eu-west-1-oxs = 'vpc-nebula.cn-shenzhen-cloudstone.aliyuncs.com',
    rus-west-1-pop = 'vpc.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model ActivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
}

model ActivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ActivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateRouterInterfaceResponseBody(name='body'),
}

async function activateRouterInterface(request: ActivateRouterInterfaceRequest): ActivateRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ActivateRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model ActiveFlowLogRequest {
  flowLogId: string(name='FlowLogId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ActiveFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ActiveFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: ActiveFlowLogResponseBody(name='body'),
}

async function activeFlowLog(request: ActiveFlowLogRequest): ActiveFlowLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ActiveFlowLog', 'POST', '/', 'json', false, 'json', request);
}

model AddBgpNetworkRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dstCidrBlock: string(name='DstCidrBlock', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerId: string(name='RouterId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model AddBgpNetworkResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddBgpNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: AddBgpNetworkResponseBody(name='body'),
}

async function addBgpNetwork(request: AddBgpNetworkRequest): AddBgpNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddBgpNetwork', 'POST', '/', 'json', false, 'json', request);
}

model AddCommonBandwidthPackageIpRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ipInstanceId: string(name='IpInstanceId', position='Query'),
  ipType?: string(name='IpType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddCommonBandwidthPackageIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCommonBandwidthPackageIpResponse = {
  headers: map[string]string(name='headers'),
  body: AddCommonBandwidthPackageIpResponseBody(name='body'),
}

async function addCommonBandwidthPackageIp(request: AddCommonBandwidthPackageIpRequest): AddCommonBandwidthPackageIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCommonBandwidthPackageIp', 'POST', '/', 'json', false, 'json', request);
}

model AddCommonBandwidthPackageIpsRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ipInstanceIds: [ string ](name='IpInstanceIds', position='Query'),
  ipType?: string(name='IpType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddCommonBandwidthPackageIpsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddCommonBandwidthPackageIpsResponse = {
  headers: map[string]string(name='headers'),
  body: AddCommonBandwidthPackageIpsResponseBody(name='body'),
}

async function addCommonBandwidthPackageIps(request: AddCommonBandwidthPackageIpsRequest): AddCommonBandwidthPackageIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCommonBandwidthPackageIps', 'POST', '/', 'json', false, 'json', request);
}

model AddGlobalAccelerationInstanceIpRequest {
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId', position='Query'),
  ipInstanceId: string(name='IpInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddGlobalAccelerationInstanceIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddGlobalAccelerationInstanceIpResponse = {
  headers: map[string]string(name='headers'),
  body: AddGlobalAccelerationInstanceIpResponseBody(name='body'),
}

async function addGlobalAccelerationInstanceIp(request: AddGlobalAccelerationInstanceIpRequest): AddGlobalAccelerationInstanceIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddGlobalAccelerationInstanceIp', 'POST', '/', 'json', false, 'json', request);
}

model AddIPv6TranslatorAclListEntryRequest {
  aclEntryComment?: string(name='AclEntryComment', position='Query'),
  aclEntryIp: string(name='AclEntryIp', position='Query'),
  aclId: string(name='AclId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddIPv6TranslatorAclListEntryResponseBody = {
  aclEntryId?: string(name='AclEntryId'),
  requestId?: string(name='RequestId'),
}

model AddIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: AddIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function addIPv6TranslatorAclListEntry(request: AddIPv6TranslatorAclListEntryRequest): AddIPv6TranslatorAclListEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddIPv6TranslatorAclListEntry', 'POST', '/', 'json', false, 'json', request);
}

model AddPublicIpAddressPoolCidrBlockRequest {
  cidrBlock: string(name='CidrBlock', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publicIpAddressPoolId: string(name='PublicIpAddressPoolId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AddPublicIpAddressPoolCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddPublicIpAddressPoolCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  body: AddPublicIpAddressPoolCidrBlockResponseBody(name='body'),
}

async function addPublicIpAddressPoolCidrBlock(request: AddPublicIpAddressPoolCidrBlockRequest): AddPublicIpAddressPoolCidrBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddPublicIpAddressPoolCidrBlock', 'POST', '/', 'json', false, 'json', request);
}

model AddSourcesToTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorSessionId: string(name='TrafficMirrorSessionId', position='Query'),
  trafficMirrorSourceIds: [ string ](name='TrafficMirrorSourceIds', maxLength=128, position='Query'),
}

model AddSourcesToTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddSourcesToTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  body: AddSourcesToTrafficMirrorSessionResponseBody(name='body'),
}

async function addSourcesToTrafficMirrorSession(request: AddSourcesToTrafficMirrorSessionRequest): AddSourcesToTrafficMirrorSessionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddSourcesToTrafficMirrorSession', 'POST', '/', 'json', false, 'json', request);
}

model AllocateEipAddressRequest {
  activityId?: long(name='ActivityId', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth?: string(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  name?: string(name='Name', position='Query'),
  netmode?: string(name='Netmode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityProtectionTypes?: [ string ](name='SecurityProtectionTypes', position='Query'),
}

model AllocateEipAddressResponseBody = {
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model AllocateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipAddressResponseBody(name='body'),
}

async function allocateEipAddress(request: AllocateEipAddressRequest): AllocateEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model AllocateEipAddressProRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth?: string(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  ipAddress?: string(name='IpAddress', position='Query'),
  netmode?: string(name='Netmode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityProtectionTypes?: [ string ](name='SecurityProtectionTypes', position='Query'),
}

model AllocateEipAddressProResponseBody = {
  allocationId?: string(name='AllocationId'),
  eipAddress?: string(name='EipAddress'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model AllocateEipAddressProResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipAddressProResponseBody(name='body'),
}

async function allocateEipAddressPro(request: AllocateEipAddressProRequest): AllocateEipAddressProResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateEipAddressPro', 'POST', '/', 'json', false, 'json', request);
}

model AllocateEipSegmentAddressRequest {
  bandwidth?: string(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  eipMask: string(name='EipMask', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  isp?: string(name='Isp', position='Query'),
  netmode?: string(name='Netmode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AllocateEipSegmentAddressResponseBody = {
  eipSegmentInstanceId?: string(name='EipSegmentInstanceId'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model AllocateEipSegmentAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateEipSegmentAddressResponseBody(name='body'),
}

async function allocateEipSegmentAddress(request: AllocateEipSegmentAddressRequest): AllocateEipSegmentAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateEipSegmentAddress', 'POST', '/', 'json', false, 'json', request);
}

model AllocateIpv6InternetBandwidthRequest {
  bandwidth: int32(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  ipv6AddressId: string(name='Ipv6AddressId', position='Query'),
  ipv6GatewayId: string(name='Ipv6GatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AllocateIpv6InternetBandwidthResponseBody = {
  internetBandwidthId?: string(name='InternetBandwidthId'),
  ipv6AddressId?: string(name='Ipv6AddressId'),
  requestId?: string(name='RequestId'),
}

model AllocateIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateIpv6InternetBandwidthResponseBody(name='body'),
}

async function allocateIpv6InternetBandwidth(request: AllocateIpv6InternetBandwidthRequest): AllocateIpv6InternetBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateIpv6InternetBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model AllocateVpcIpv6CidrRequest {
  addressPoolType?: string(name='AddressPoolType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock', position='Query'),
  ipv6Isp?: string(name='Ipv6Isp', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AllocateVpcIpv6CidrResponseBody = {
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  requestId?: string(name='RequestId'),
}

model AllocateVpcIpv6CidrResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateVpcIpv6CidrResponseBody(name='body'),
}

async function allocateVpcIpv6Cidr(request: AllocateVpcIpv6CidrRequest): AllocateVpcIpv6CidrResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateVpcIpv6Cidr', 'POST', '/', 'json', false, 'json', request);
}

model ApplyPhysicalConnectionLOARequest {
  bandwidth?: int32(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  companyName: string(name='CompanyName', position='Query'),
  constructionTime: string(name='ConstructionTime', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lineType: string(name='LineType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  PMInfo?: [ 
    {
      PMCertificateNo?: string(name='PMCertificateNo'),
      PMCertificateType?: string(name='PMCertificateType'),
      PMContactInfo?: string(name='PMContactInfo'),
      PMGender?: string(name='PMGender'),
      PMName?: string(name='PMName'),
    }
  ](name='PMInfo', position='Query'),
  peerLocation?: string(name='PeerLocation', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  si: string(name='Si', position='Query'),
}

model ApplyPhysicalConnectionLOAResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApplyPhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyPhysicalConnectionLOAResponseBody(name='body'),
}

async function applyPhysicalConnectionLOA(request: ApplyPhysicalConnectionLOARequest): ApplyPhysicalConnectionLOAResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyPhysicalConnectionLOA', 'POST', '/', 'json', false, 'json', request);
}

model AssociateEipAddressRequest {
  allocationId: string(name='AllocationId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceRegionId?: string(name='InstanceRegionId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  mode?: string(name='Mode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AssociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateEipAddressResponseBody(name='body'),
}

async function associateEipAddress(request: AssociateEipAddressRequest): AssociateEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model AssociateGlobalAccelerationInstanceRequest {
  backendServerId: string(name='BackendServerId', position='Query'),
  backendServerRegionId: string(name='BackendServerRegionId', position='Query'),
  backendServerType?: string(name='BackendServerType', position='Query'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AssociateGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function associateGlobalAccelerationInstance(request: AssociateGlobalAccelerationInstanceRequest): AssociateGlobalAccelerationInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateGlobalAccelerationInstance', 'POST', '/', 'json', false, 'json', request);
}

model AssociateHaVipRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  haVipId: string(name='HaVipId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AssociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateHaVipResponseBody(name='body'),
}

async function associateHaVip(request: AssociateHaVipRequest): AssociateHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateHaVip', 'POST', '/', 'json', false, 'json', request);
}

model AssociateNetworkAclRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  networkAclId: string(name='NetworkAclId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resource', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AssociateNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateNetworkAclResponseBody(name='body'),
}

async function associateNetworkAcl(request: AssociateNetworkAclRequest): AssociateNetworkAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateNetworkAcl', 'POST', '/', 'json', false, 'json', request);
}

model AssociatePhysicalConnectionToVirtualBorderRouterRequest {
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  enableIpv6?: string(name='EnableIpv6', position='Query'),
  localGatewayIp?: string(name='LocalGatewayIp', position='Query'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerGatewayIp?: string(name='PeerGatewayIp', position='Query'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp', position='Query'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask', position='Query'),
  peeringSubnetMask?: string(name='PeeringSubnetMask', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
  vlanId: string(name='VlanId', position='Query'),
}

model AssociatePhysicalConnectionToVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociatePhysicalConnectionToVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: AssociatePhysicalConnectionToVirtualBorderRouterResponseBody(name='body'),
}

async function associatePhysicalConnectionToVirtualBorderRouter(request: AssociatePhysicalConnectionToVirtualBorderRouterRequest): AssociatePhysicalConnectionToVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociatePhysicalConnectionToVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model AssociateRouteTableRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model AssociateRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateRouteTableResponseBody(name='body'),
}

async function associateRouteTable(request: AssociateRouteTableRequest): AssociateRouteTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateRouteTable', 'POST', '/', 'json', false, 'json', request);
}

model AssociateRouteTableWithGatewayRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  gatewayId: string(name='GatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
}

model AssociateRouteTableWithGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateRouteTableWithGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateRouteTableWithGatewayResponseBody(name='body'),
}

async function associateRouteTableWithGateway(request: AssociateRouteTableWithGatewayRequest): AssociateRouteTableWithGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateRouteTableWithGateway', 'POST', '/', 'json', false, 'json', request);
}

model AssociateRouteTablesWithVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken', description='幂等参数', position='Query'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求', position='Query'),
  endpointId: string(name='EndpointId', description='VPC网关实例ID', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableIds: [ string ](name='RouteTableIds', description='路由表列表', position='Query'),
}

model AssociateRouteTablesWithVpcGatewayEndpointResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AssociateRouteTablesWithVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateRouteTablesWithVpcGatewayEndpointResponseBody(name='body'),
}

async function associateRouteTablesWithVpcGatewayEndpoint(request: AssociateRouteTablesWithVpcGatewayEndpointRequest): AssociateRouteTablesWithVpcGatewayEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateRouteTablesWithVpcGatewayEndpoint', 'POST', '/', 'json', false, 'json', request);
}

model AssociateVpcCidrBlockRequest {
  iPv6CidrBlock?: string(name='IPv6CidrBlock', position='Query'),
  ipVersion?: string(name='IpVersion', position='Query'),
  ipv6Isp?: string(name='Ipv6Isp', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model AssociateVpcCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateVpcCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateVpcCidrBlockResponseBody(name='body'),
}

async function associateVpcCidrBlock(request: AssociateVpcCidrBlockRequest): AssociateVpcCidrBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateVpcCidrBlock', 'POST', '/', 'json', false, 'json', request);
}

model AssociateVpnGatewayWithCertificateRequest {
  certificateId: string(name='CertificateId', position='Query'),
  certificateType: string(name='CertificateType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model AssociateVpnGatewayWithCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateVpnGatewayWithCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateVpnGatewayWithCertificateResponseBody(name='body'),
}

async function associateVpnGatewayWithCertificate(request: AssociateVpnGatewayWithCertificateRequest): AssociateVpnGatewayWithCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateVpnGatewayWithCertificate', 'POST', '/', 'json', false, 'json', request);
}

model AttachDhcpOptionsSetToVpcRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model AttachDhcpOptionsSetToVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachDhcpOptionsSetToVpcResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDhcpOptionsSetToVpcResponseBody(name='body'),
}

async function attachDhcpOptionsSetToVpc(request: AttachDhcpOptionsSetToVpcRequest): AttachDhcpOptionsSetToVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachDhcpOptionsSetToVpc', 'POST', '/', 'json', false, 'json', request);
}

model AttachVbrToVpconnRequest {
  dryRun?: boolean(name='DryRun', description='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  token?: string(name='Token', description='幂等Token', position='Query'),
  vbrId: string(name='VbrId', description='待迁移的vbr', position='Query'),
  vpconnId: string(name='VpconnId', description='迁移到目标vpconn', position='Query'),
}

model AttachVbrToVpconnResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  virtualPhysicalConnection?: string(name='VirtualPhysicalConnection', description='Vpconn的实例ID'),
}

model AttachVbrToVpconnResponse = {
  headers: map[string]string(name='headers'),
  body: AttachVbrToVpconnResponseBody(name='body'),
}

async function attachVbrToVpconn(request: AttachVbrToVpconnRequest): AttachVbrToVpconnResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachVbrToVpconn', 'POST', '/', 'json', false, 'json', request);
}

model CancelCommonBandwidthPackageIpBandwidthRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  eipId: string(name='EipId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CancelCommonBandwidthPackageIpBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCommonBandwidthPackageIpBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: CancelCommonBandwidthPackageIpBandwidthResponseBody(name='body'),
}

async function cancelCommonBandwidthPackageIpBandwidth(request: CancelCommonBandwidthPackageIpBandwidthRequest): CancelCommonBandwidthPackageIpBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelCommonBandwidthPackageIpBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model CancelPhysicalConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CancelPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelPhysicalConnectionResponseBody(name='body'),
}

async function cancelPhysicalConnection(request: CancelPhysicalConnectionRequest): CancelPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelPhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model CheckCanAllocateVpcPrivateIpAddressRequest {
  ipVersion?: string(name='IpVersion', description='IpVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privateIpAddress: string(name='PrivateIpAddress', description='PrivateIpAddress', position='Query'),
  regionId: string(name='RegionId', description='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId: string(name='VSwitchId', description='VSwitchId', position='Query'),
}

model CheckCanAllocateVpcPrivateIpAddressResponseBody = {
  canAllocate?: boolean(name='CanAllocate'),
  requestId?: string(name='RequestId'),
}

model CheckCanAllocateVpcPrivateIpAddressResponse = {
  headers: map[string]string(name='headers'),
  body: CheckCanAllocateVpcPrivateIpAddressResponseBody(name='body'),
}

async function checkCanAllocateVpcPrivateIpAddress(request: CheckCanAllocateVpcPrivateIpAddressRequest): CheckCanAllocateVpcPrivateIpAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckCanAllocateVpcPrivateIpAddress', 'POST', '/', 'json', false, 'json', request);
}

model CheckVpnBgpEnabledRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckVpnBgpEnabledResponseBody = {
  bgpEnabled?: boolean(name='BgpEnabled'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CheckVpnBgpEnabledResponse = {
  headers: map[string]string(name='headers'),
  body: CheckVpnBgpEnabledResponseBody(name='body'),
}

async function checkVpnBgpEnabled(request: CheckVpnBgpEnabledRequest): CheckVpnBgpEnabledResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckVpnBgpEnabled', 'POST', '/', 'json', false, 'json', request);
}

model CompletePhysicalConnectionLOARequest {
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lineCode?: string(name='LineCode', position='Query'),
  lineLabel?: string(name='LineLabel', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CompletePhysicalConnectionLOAResponseBody = {
  requestId?: string(name='RequestId'),
}

model CompletePhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  body: CompletePhysicalConnectionLOAResponseBody(name='body'),
}

async function completePhysicalConnectionLOA(request: CompletePhysicalConnectionLOARequest): CompletePhysicalConnectionLOAResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CompletePhysicalConnectionLOA', 'POST', '/', 'json', false, 'json', request);
}

model ConfirmPhysicalConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ConfirmPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfirmPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmPhysicalConnectionResponseBody(name='body'),
}

async function confirmPhysicalConnection(request: ConfirmPhysicalConnectionRequest): ConfirmPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfirmPhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model ConnectRouterInterfaceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
}

model ConnectRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConnectRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: ConnectRouterInterfaceResponseBody(name='body'),
}

async function connectRouterInterface(request: ConnectRouterInterfaceRequest): ConnectRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConnectRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model ConvertBandwidthPackageRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ConvertBandwidthPackageResponseBody = {
  convertInstanceId?: string(name='ConvertInstanceId'),
  requestId?: string(name='RequestId'),
}

model ConvertBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertBandwidthPackageResponseBody(name='body'),
}

async function convertBandwidthPackage(request: ConvertBandwidthPackageRequest): ConvertBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConvertBandwidthPackage', 'POST', '/', 'json', false, 'json', request);
}

model CopyNetworkAclEntriesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  networkAclId: string(name='NetworkAclId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceNetworkAclId: string(name='SourceNetworkAclId', position='Query'),
}

model CopyNetworkAclEntriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model CopyNetworkAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: CopyNetworkAclEntriesResponseBody(name='body'),
}

async function copyNetworkAclEntries(request: CopyNetworkAclEntriesRequest): CopyNetworkAclEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyNetworkAclEntries', 'POST', '/', 'json', false, 'json', request);
}

model CreateBgpGroupRequest {
  authKey?: string(name='AuthKey', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ipVersion?: string(name='IpVersion', position='Query'),
  isFakeAsn?: boolean(name='IsFakeAsn', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerAsn: long(name='PeerAsn', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerId: string(name='RouterId', position='Query'),
}

model CreateBgpGroupResponseBody = {
  bgpGroupId?: string(name='BgpGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateBgpGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBgpGroupResponseBody(name='body'),
}

async function createBgpGroup(request: CreateBgpGroupRequest): CreateBgpGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBgpGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateBgpPeerRequest {
  bfdMultiHop?: int32(name='BfdMultiHop', position='Query'),
  bgpGroupId: string(name='BgpGroupId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  enableBfd?: boolean(name='EnableBfd', position='Query'),
  ipVersion?: string(name='IpVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerIpAddress?: string(name='PeerIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateBgpPeerResponseBody = {
  bgpPeerId?: string(name='BgpPeerId'),
  requestId?: string(name='RequestId'),
}

model CreateBgpPeerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBgpPeerResponseBody(name='body'),
}

async function createBgpPeer(request: CreateBgpPeerRequest): CreateBgpPeerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBgpPeer', 'POST', '/', 'json', false, 'json', request);
}

model CreateCommonBandwidthPackageRequest {
  bandwidth: int32(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  ratio?: int32(name='Ratio', minimum=0, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityProtectionTypes?: [ string ](name='SecurityProtectionTypes', position='Query'),
  zone?: string(name='Zone', position='Query'),
}

model CreateCommonBandwidthPackageResponseBody = {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateCommonBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCommonBandwidthPackageResponseBody(name='body'),
}

async function createCommonBandwidthPackage(request: CreateCommonBandwidthPackageRequest): CreateCommonBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCommonBandwidthPackage', 'POST', '/', 'json', false, 'json', request);
}

model CreateCustomerGatewayRequest {
  asn?: string(name='Asn', position='Query'),
  authKey?: string(name='AuthKey', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ipAddress: string(name='IpAddress', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateCustomerGatewayResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model CreateCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCustomerGatewayResponseBody(name='body'),
}

async function createCustomerGateway(request: CreateCustomerGatewayRequest): CreateCustomerGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCustomerGateway', 'POST', '/', 'json', false, 'json', request);
}

model CreateDhcpOptionsSetRequest {
  bootFileName?: string(name='BootFileName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription', position='Query'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  domainNameServers?: string(name='DomainNameServers', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ipv6LeaseTime?: string(name='Ipv6LeaseTime', position='Query'),
  leaseTime?: string(name='LeaseTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  TFTPServerName?: string(name='TFTPServerName', position='Query'),
}

model CreateDhcpOptionsSetResponseBody = {
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  requestId?: string(name='RequestId'),
}

model CreateDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDhcpOptionsSetResponseBody(name='body'),
}

async function createDhcpOptionsSet(request: CreateDhcpOptionsSetRequest): CreateDhcpOptionsSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDhcpOptionsSet', 'POST', '/', 'json', false, 'json', request);
}

model CreateExpressCloudConnectionRequest {
  bandwidth: int32(name='Bandwidth', position='Query'),
  contactMail?: string(name='ContactMail', position='Query'),
  contactTel?: string(name='ContactTel', position='Query'),
  description?: string(name='Description', position='Query'),
  IDCardNo?: string(name='IDCardNo', position='Query'),
  idcSP: string(name='IdcSP', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerCity?: string(name='PeerCity', position='Query'),
  peerLocation: string(name='PeerLocation', position='Query'),
  portType?: string(name='PortType', position='Query'),
  redundantEccId?: string(name='RedundantEccId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateExpressCloudConnectionResponseBody = {
  eccId?: string(name='EccId'),
  requestId?: string(name='RequestId'),
}

model CreateExpressCloudConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExpressCloudConnectionResponseBody(name='body'),
}

async function createExpressCloudConnection(request: CreateExpressCloudConnectionRequest): CreateExpressCloudConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateExpressCloudConnection', 'POST', '/', 'json', false, 'json', request);
}

model CreateFlowLogRequest {
  aggregationInterval?: int32(name='AggregationInterval', position='Query'),
  description?: string(name='Description', position='Query'),
  flowLogName?: string(name='FlowLogName', position='Query'),
  logStoreName: string(name='LogStoreName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  projectName: string(name='ProjectName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  trafficType: string(name='TrafficType', position='Query'),
}

model CreateFlowLogResponseBody = {
  flowLogId?: string(name='FlowLogId'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowLogResponseBody(name='body'),
}

async function createFlowLog(request: CreateFlowLogRequest): CreateFlowLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFlowLog', 'POST', '/', 'json', false, 'json', request);
}

model CreateForwardEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  externalIp: string(name='ExternalIp', position='Query'),
  externalPort: string(name='ExternalPort', position='Query'),
  forwardEntryName?: string(name='ForwardEntryName', position='Query'),
  forwardTableId: string(name='ForwardTableId', position='Query'),
  internalIp: string(name='InternalIp', position='Query'),
  internalPort: string(name='InternalPort', position='Query'),
  ipProtocol: string(name='IpProtocol', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  portBreak?: boolean(name='PortBreak', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateForwardEntryResponseBody = {
  forwardEntryId?: string(name='ForwardEntryId'),
  requestId?: string(name='RequestId'),
}

model CreateForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardEntryResponseBody(name='body'),
}

async function createForwardEntry(request: CreateForwardEntryRequest): CreateForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateForwardEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateFullNatEntryRequest {
  accessIp: string(name='AccessIp', description='需要进行转发的后端IP', position='Query'),
  accessPort: string(name='AccessPort', description='需要进行端口转发的内部端口，取值范围：1~65535。', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fullNatEntryDescription?: string(name='FullNatEntryDescription', position='Query'),
  fullNatEntryName?: string(name='FullNatEntryName', description='FULLNAT规则的名称。 长度为2~128个字符，必须以大小写字母或中文开头，但不能以http://或https://开头。', position='Query'),
  fullNatTableId: string(name='FullNatTableId', description='FullNAT条目所属的FullNAT列表的ID。', position='Query'),
  ipProtocol: string(name='IpProtocol', description='协议类型，取值： • TCP：转发TCP协议的报文。 • UDP：转发UDP协议的报文。', position='Query'),
  natIp: string(name='NatIp', description='提供入方向访问的IP地址，该公网IP需要是当前VpcNat下的NatIP', position='Query'),
  natIpPort: string(name='NatIpPort', description='需要进行端口转发的外部端口，取值范围：1~65535。', position='Query'),
  networkInterfaceId: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateFullNatEntryResponseBody = {
  fullNatEntryId?: string(name='FullNatEntryId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateFullNatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFullNatEntryResponseBody(name='body'),
}

async function createFullNatEntry(request: CreateFullNatEntryRequest): CreateFullNatEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFullNatEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateGlobalAccelerationInstanceRequest {
  bandwidth: string(name='Bandwidth', position='Query'),
  bandwidthType?: string(name='BandwidthType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceLocation: string(name='ServiceLocation', position='Query'),
}

model CreateGlobalAccelerationInstanceResponseBody = {
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
  ipAddress?: string(name='IpAddress'),
  requestId?: string(name='RequestId'),
}

model CreateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function createGlobalAccelerationInstance(request: CreateGlobalAccelerationInstanceRequest): CreateGlobalAccelerationInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGlobalAccelerationInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateHaVipRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ipAddress?: string(name='IpAddress', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model CreateHaVipResponseBody = {
  haVipId?: string(name='HaVipId'),
  ipAddress?: string(name='IpAddress'),
  requestId?: string(name='RequestId'),
}

model CreateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHaVipResponseBody(name='body'),
}

async function createHaVip(request: CreateHaVipRequest): CreateHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateHaVip', 'POST', '/', 'json', false, 'json', request);
}

model CreateIPv6TranslatorRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth?: int32(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  duration?: int32(name='Duration', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType?: string(name='PayType', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spec?: string(name='Spec', position='Query'),
}

model CreateIPv6TranslatorResponseBody = {
  ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
  name?: string(name='Name'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
}

model CreateIPv6TranslatorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIPv6TranslatorResponseBody(name='body'),
}

async function createIPv6Translator(request: CreateIPv6TranslatorRequest): CreateIPv6TranslatorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIPv6Translator', 'POST', '/', 'json', false, 'json', request);
}

model CreateIPv6TranslatorAclListRequest {
  aclName: string(name='AclName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateIPv6TranslatorAclListResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId'),
}

model CreateIPv6TranslatorAclListResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIPv6TranslatorAclListResponseBody(name='body'),
}

async function createIPv6TranslatorAclList(request: CreateIPv6TranslatorAclListRequest): CreateIPv6TranslatorAclListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIPv6TranslatorAclList', 'POST', '/', 'json', false, 'json', request);
}

model CreateIPv6TranslatorEntryRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  allocateIpv6Port: int32(name='AllocateIpv6Port', position='Query'),
  backendIpv4Addr: string(name='BackendIpv4Addr', position='Query'),
  backendIpv4Port: int32(name='BackendIpv4Port', position='Query'),
  entryBandwidth?: int32(name='EntryBandwidth', position='Query'),
  entryDescription?: string(name='EntryDescription', position='Query'),
  entryName?: string(name='EntryName', position='Query'),
  ipv6TranslatorId: string(name='Ipv6TranslatorId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  transProtocol: string(name='TransProtocol', position='Query'),
}

model CreateIPv6TranslatorEntryResponseBody = {
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
  requestId?: string(name='RequestId'),
}

model CreateIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIPv6TranslatorEntryResponseBody(name='body'),
}

async function createIPv6TranslatorEntry(request: CreateIPv6TranslatorEntryRequest): CreateIPv6TranslatorEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIPv6TranslatorEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateIpsecServerRequest {
  clientIpPool: string(name='ClientIpPool', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: string(name='DryRun', position='Query'),
  effectImmediately?: boolean(name='EffectImmediately', position='Query'),
  ikeConfig?: string(name='IkeConfig', position='Query'),
  ipSecServerName?: string(name='IpSecServerName', maxLength=100, position='Query'),
  ipsecConfig?: string(name='IpsecConfig', position='Query'),
  localSubnet: string(name='LocalSubnet', position='Query'),
  psk?: string(name='Psk', position='Query'),
  pskEnabled?: boolean(name='PskEnabled', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model CreateIpsecServerResponseBody = {
  creationTime?: string(name='CreationTime'),
  ipsecServerId?: string(name='IpsecServerId'),
  ipsecServerName?: string(name='IpsecServerName'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpsecServerResponseBody(name='body'),
}

async function createIpsecServer(request: CreateIpsecServerRequest): CreateIpsecServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIpsecServer', 'POST', '/', 'json', false, 'json', request);
}

model CreateIpv4GatewayRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ipv4GatewayDescription?: string(name='Ipv4GatewayDescription', position='Query'),
  ipv4GatewayName?: string(name='Ipv4GatewayName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model CreateIpv4GatewayResponseBody = {
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv4GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpv4GatewayResponseBody(name='body'),
}

async function createIpv4Gateway(request: CreateIpv4GatewayRequest): CreateIpv4GatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIpv4Gateway', 'POST', '/', 'json', false, 'json', request);
}

model CreateIpv6EgressOnlyRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ipv6GatewayId: string(name='Ipv6GatewayId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateIpv6EgressOnlyRuleResponseBody = {
  ipv6EgressRuleId?: string(name='Ipv6EgressRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv6EgressOnlyRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpv6EgressOnlyRuleResponseBody(name='body'),
}

async function createIpv6EgressOnlyRule(request: CreateIpv6EgressOnlyRuleRequest): CreateIpv6EgressOnlyRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIpv6EgressOnlyRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateIpv6GatewayRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spec?: string(name='Spec', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model CreateIpv6GatewayResponseBody = {
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  requestId?: string(name='RequestId'),
}

model CreateIpv6GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpv6GatewayResponseBody(name='body'),
}

async function createIpv6Gateway(request: CreateIpv6GatewayRequest): CreateIpv6GatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIpv6Gateway', 'POST', '/', 'json', false, 'json', request);
}

model CreateNatGatewayRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  duration?: string(name='Duration', position='Query'),
  eipBindMode?: string(name='EipBindMode', description='NAT：NAT模式，支持SNAT/访问DANT，最多支持绑定50个EIP，支持ingress routing;
MULTI_BINDED：多EIP网卡可见模式。', position='Query'),
  icmpReplyEnabled?: boolean(name='IcmpReplyEnabled', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  name?: string(name='Name', position='Query'),
  natType?: string(name='NatType', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled', position='Query'),
  spec?: string(name='Spec', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model CreateNatGatewayResponseBody = {
  forwardTableIds?: {
    forwardTableId?: [ string ](name='ForwardTableId')
  }(name='ForwardTableIds'),
  fullNatTableIds?: {
    fullNatTableId?: [ string ](name='FullNatTableId')
  }(name='FullNatTableIds'),
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId'),
  snatTableIds?: {
    snatTableId?: [ string ](name='SnatTableId')
  }(name='SnatTableIds'),
}

model CreateNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatGatewayResponseBody(name='body'),
}

async function createNatGateway(request: CreateNatGatewayRequest): CreateNatGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNatGateway', 'POST', '/', 'json', false, 'json', request);
}

model CreateNatIpRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  natIp?: string(name='NatIp', position='Query'),
  natIpCidr?: string(name='NatIpCidr', position='Query'),
  natIpCidrId?: string(name='NatIpCidrId', position='Query'),
  natIpDescription?: string(name='NatIpDescription', position='Query'),
  natIpName?: string(name='NatIpName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateNatIpResponseBody = {
  natIp?: string(name='NatIp'),
  natIpId?: string(name='NatIpId'),
  requestId?: string(name='RequestId'),
}

model CreateNatIpResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatIpResponseBody(name='body'),
}

async function createNatIp(request: CreateNatIpRequest): CreateNatIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNatIp', 'POST', '/', 'json', false, 'json', request);
}

model CreateNatIpCidrRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  natIpCidr?: string(name='NatIpCidr', position='Query'),
  natIpCidrDescription?: string(name='NatIpCidrDescription', position='Query'),
  natIpCidrName?: string(name='NatIpCidrName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateNatIpCidrResponseBody = {
  natIpCidrId?: string(name='NatIpCidrId'),
  requestId?: string(name='RequestId'),
}

model CreateNatIpCidrResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNatIpCidrResponseBody(name='body'),
}

async function createNatIpCidr(request: CreateNatIpCidrRequest): CreateNatIpCidrResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNatIpCidr', 'POST', '/', 'json', false, 'json', request);
}

model CreateNetworkAclRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  networkAclName?: string(name='NetworkAclName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model CreateNetworkAclResponseBody = {
  networkAclAttribute?: {
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    egressAclEntries?: {
      egressAclEntry?: [ 
      {
        description?: string(name='Description'),
        destinationCidrIp?: string(name='DestinationCidrIp'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
      }
    ](name='EgressAclEntry')
    }(name='EgressAclEntries'),
    ingressAclEntries?: {
      ingressAclEntry?: [ 
      {
        description?: string(name='Description'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
        sourceCidrIp?: string(name='SourceCidrIp'),
      }
    ](name='IngressAclEntry')
    }(name='IngressAclEntries'),
    networkAclId?: string(name='NetworkAclId'),
    networkAclName?: string(name='NetworkAclName'),
    regionId?: string(name='RegionId'),
    resources?: {
      resource?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        status?: string(name='Status'),
      }
    ](name='Resource')
    }(name='Resources'),
    status?: string(name='Status'),
    vpcId?: string(name='VpcId'),
  }(name='NetworkAclAttribute'),
  networkAclId?: string(name='NetworkAclId'),
  requestId?: string(name='RequestId'),
}

model CreateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkAclResponseBody(name='body'),
}

async function createNetworkAcl(request: CreateNetworkAclRequest): CreateNetworkAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNetworkAcl', 'POST', '/', 'json', false, 'json', request);
}

model CreatePhysicalConnectionRequest {
  accessPointId: string(name='AccessPointId', position='Query'),
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  lineOperator: string(name='LineOperator', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerLocation?: string(name='PeerLocation', position='Query'),
  portType?: string(name='PortType', position='Query'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  type?: string(name='Type', position='Query'),
  bandwidth?: int32(name='bandwidth', position='Query'),
}

model CreatePhysicalConnectionResponseBody = {
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePhysicalConnectionResponseBody(name='body'),
}

async function createPhysicalConnection(request: CreatePhysicalConnectionRequest): CreatePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model CreatePhysicalConnectionOccupancyOrderRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreatePhysicalConnectionOccupancyOrderResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionOccupancyOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePhysicalConnectionOccupancyOrderResponseBody(name='body'),
}

async function createPhysicalConnectionOccupancyOrder(request: CreatePhysicalConnectionOccupancyOrderRequest): CreatePhysicalConnectionOccupancyOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePhysicalConnectionOccupancyOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreatePhysicalConnectionSetupOrderRequest {
  accessPointId: string(name='AccessPointId', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  lineOperator: string(name='LineOperator', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  portType?: string(name='PortType', position='Query'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreatePhysicalConnectionSetupOrderResponseBody = {
  orderId?: string(name='OrderId'),
  physicalConnectionId?: string(name='PhysicalConnectionId'),
  requestId?: string(name='RequestId'),
}

model CreatePhysicalConnectionSetupOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePhysicalConnectionSetupOrderResponseBody(name='body'),
}

async function createPhysicalConnectionSetupOrder(request: CreatePhysicalConnectionSetupOrderRequest): CreatePhysicalConnectionSetupOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePhysicalConnectionSetupOrder', 'POST', '/', 'json', false, 'json', request);
}

model CreatePublicIpAddressPoolRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  isp?: string(name='Isp', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreatePublicIpAddressPoolResponseBody = {
  pulbicIpAddressPoolId?: string(name='PulbicIpAddressPoolId'),
  requestId?: string(name='RequestId'),
}

model CreatePublicIpAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePublicIpAddressPoolResponseBody(name='body'),
}

async function createPublicIpAddressPool(request: CreatePublicIpAddressPoolRequest): CreatePublicIpAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePublicIpAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model CreateRouteEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  destinationCidrBlock: string(name='DestinationCidrBlock', position='Query'),
  nextHopId?: string(name='NextHopId', position='Query'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
      weight?: int32(name='Weight'),
    }
  ](name='NextHopList', position='Query'),
  nextHopType?: string(name='NextHopType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeEntryName?: string(name='RouteEntryName', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
}

model CreateRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
  routeEntryId?: string(name='RouteEntryId'),
}

model CreateRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouteEntryResponseBody(name='body'),
}

async function createRouteEntry(request: CreateRouteEntryRequest): CreateRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateRouteTableRequest {
  associateType?: string(name='AssociateType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableName?: string(name='RouteTableName', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model CreateRouteTableResponseBody = {
  associateType?: string(name='AssociateType'),
  requestId?: string(name='RequestId'),
  routeTableId?: string(name='RouteTableId'),
}

model CreateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouteTableResponseBody(name='body'),
}

async function createRouteTable(request: CreateRouteTableRequest): CreateRouteTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRouteTable', 'POST', '/', 'json', false, 'json', request);
}

model CreateRouterInterfaceRequest {
  accessPointId?: string(name='AccessPointId', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp', position='Query'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  name?: string(name='Name', position='Query'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId', position='Query'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId', position='Query'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId', position='Query'),
  oppositeRegionId: string(name='OppositeRegionId', position='Query'),
  oppositeRouterId?: string(name='OppositeRouterId', position='Query'),
  oppositeRouterType?: string(name='OppositeRouterType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  role: string(name='Role', position='Query'),
  routerId: string(name='RouterId', position='Query'),
  routerType: string(name='RouterType', position='Query'),
  spec: string(name='Spec', position='Query'),
}

model CreateRouterInterfaceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
}

model CreateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouterInterfaceResponseBody(name='body'),
}

async function createRouterInterface(request: CreateRouterInterfaceRequest): CreateRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model CreateSnatEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  eipAffinity?: int32(name='EipAffinity', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snatEntryName?: string(name='SnatEntryName', position='Query'),
  snatIp: string(name='SnatIp', position='Query'),
  snatTableId: string(name='SnatTableId', position='Query'),
  sourceCIDR?: string(name='SourceCIDR', position='Query'),
  sourceVSwitchId?: string(name='SourceVSwitchId', position='Query'),
}

model CreateSnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
  snatEntryId?: string(name='SnatEntryId'),
}

model CreateSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnatEntryResponseBody(name='body'),
}

async function createSnatEntry(request: CreateSnatEntryRequest): CreateSnatEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSnatEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateSslVpnClientCertRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslVpnServerId: string(name='SslVpnServerId', position='Query'),
}

model CreateSslVpnClientCertResponseBody = {
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model CreateSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSslVpnClientCertResponseBody(name='body'),
}

async function createSslVpnClientCert(request: CreateSslVpnClientCertRequest): CreateSslVpnClientCertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSslVpnClientCert', 'POST', '/', 'json', false, 'json', request);
}

model CreateSslVpnServerRequest {
  cipher?: string(name='Cipher', position='Query'),
  clientIpPool: string(name='ClientIpPool', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  compress?: boolean(name='Compress', position='Query'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth', position='Query'),
  iDaaSInstanceId?: string(name='IDaaSInstanceId', position='Query'),
  iDaaSRegionId?: string(name='IDaaSRegionId', position='Query'),
  localSubnet: string(name='LocalSubnet', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  port?: int32(name='Port', position='Query'),
  proto?: string(name='Proto', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model CreateSslVpnServerResponseBody = {
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
}

model CreateSslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSslVpnServerResponseBody(name='body'),
}

async function createSslVpnServer(request: CreateSslVpnServerRequest): CreateSslVpnServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSslVpnServer', 'POST', '/', 'json', false, 'json', request);
}

model CreateTrafficMirrorFilterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  egressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='EgressRules', position='Query'),
  ingressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='IngressRules', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorFilterDescription?: string(name='TrafficMirrorFilterDescription', position='Query'),
  trafficMirrorFilterName?: string(name='TrafficMirrorFilterName', position='Query'),
}

model CreateTrafficMirrorFilterResponseBody = {
  requestId?: string(name='RequestId'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
}

model CreateTrafficMirrorFilterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTrafficMirrorFilterResponseBody(name='body'),
}

async function createTrafficMirrorFilter(request: CreateTrafficMirrorFilterRequest): CreateTrafficMirrorFilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTrafficMirrorFilter', 'POST', '/', 'json', false, 'json', request);
}

model CreateTrafficMirrorFilterRulesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  egressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='EgressRules', position='Query'),
  ingressRules?: [ 
    {
      action?: string(name='Action'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      destinationPortRange?: string(name='DestinationPortRange'),
      priority?: int32(name='Priority'),
      protocol?: string(name='Protocol'),
      sourceCidrBlock?: string(name='SourceCidrBlock'),
      sourcePortRange?: string(name='SourcePortRange'),
    }
  ](name='IngressRules', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorFilterId: string(name='TrafficMirrorFilterId', position='Query'),
}

model CreateTrafficMirrorFilterRulesResponseBody = {
  egressRules?: [ 
    {
      instanceId?: string(name='InstanceId'),
    }
  ](name='EgressRules'),
  ingressRules?: [ 
    {
      instanceId?: string(name='InstanceId'),
    }
  ](name='IngressRules'),
  requestId?: string(name='RequestId'),
}

model CreateTrafficMirrorFilterRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTrafficMirrorFilterRulesResponseBody(name='body'),
}

async function createTrafficMirrorFilterRules(request: CreateTrafficMirrorFilterRulesRequest): CreateTrafficMirrorFilterRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTrafficMirrorFilterRules', 'POST', '/', 'json', false, 'json', request);
}

model CreateTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  enabled?: boolean(name='Enabled', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  packetLength?: int32(name='PacketLength', position='Query'),
  priority: int32(name='Priority', minimum=1, maximum=32766, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorFilterId: string(name='TrafficMirrorFilterId', position='Query'),
  trafficMirrorSessionDescription?: string(name='TrafficMirrorSessionDescription', position='Query'),
  trafficMirrorSessionName?: string(name='TrafficMirrorSessionName', position='Query'),
  trafficMirrorSourceIds: [ string ](name='TrafficMirrorSourceIds', maxLength=128, position='Query'),
  trafficMirrorTargetId: string(name='TrafficMirrorTargetId', position='Query'),
  trafficMirrorTargetType: string(name='TrafficMirrorTargetType', position='Query'),
  virtualNetworkId?: int32(name='VirtualNetworkId', position='Query'),
}

model CreateTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
  trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
}

model CreateTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTrafficMirrorSessionResponseBody(name='body'),
}

async function createTrafficMirrorSession(request: CreateTrafficMirrorSessionRequest): CreateTrafficMirrorSessionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTrafficMirrorSession', 'POST', '/', 'json', false, 'json', request);
}

model CreateVSwitchRequest {
  cidrBlock: string(name='CidrBlock', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ipv6CidrBlock?: int32(name='Ipv6CidrBlock', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchName?: string(name='VSwitchName', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
  vpcIpv6CidrBlock?: string(name='VpcIpv6CidrBlock', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVSwitchResponseBody(name='body'),
}

async function createVSwitch(request: CreateVSwitchRequest): CreateVSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVSwitch', 'POST', '/', 'json', false, 'json', request);
}

model CreateVbrHaRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerVbrId: string(name='PeerVbrId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
}

model CreateVbrHaResponseBody = {
  requestId?: string(name='RequestId'),
  vbrHaId?: string(name='VbrHaId'),
}

model CreateVbrHaResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVbrHaResponseBody(name='body'),
}

async function createVbrHa(request: CreateVbrHaRequest): CreateVbrHaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVbrHa', 'POST', '/', 'json', false, 'json', request);
}

model CreateVcoRouteEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  overlayMode?: string(name='OverlayMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model CreateVcoRouteEntryResponseBody = {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  requestId?: string(name='RequestId'),
  routeDest?: string(name='RouteDest'),
  state?: string(name='State'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  weight?: int32(name='Weight'),
}

model CreateVcoRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVcoRouteEntryResponseBody(name='body'),
}

async function createVcoRouteEntry(request: CreateVcoRouteEntryRequest): CreateVcoRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVcoRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateVirtualBorderRouterRequest {
  bandwidth?: long(name='Bandwidth', position='Query'),
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  enableIpv6?: boolean(name='EnableIpv6', position='Query'),
  localGatewayIp?: string(name='LocalGatewayIp', position='Query'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerGatewayIp?: string(name='PeerGatewayIp', position='Query'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp', position='Query'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask', position='Query'),
  peeringSubnetMask?: string(name='PeeringSubnetMask', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vbrOwnerId?: long(name='VbrOwnerId', position='Query'),
  vlanId: int32(name='VlanId', position='Query'),
}

model CreateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
  vbrId?: string(name='VbrId'),
}

model CreateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualBorderRouterResponseBody(name='body'),
}

async function createVirtualBorderRouter(request: CreateVirtualBorderRouterRequest): CreateVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model CreateVirtualPhysicalConnectionRequest {
  description?: string(name='Description', description='Vpconn的description', position='Query'),
  dryRun?: boolean(name='DryRun', description='DryRun', position='Query'),
  name?: string(name='Name', description='Vpconn的name', position='Query'),
  orderMode: string(name='OrderMode', description='vpconn的支付方', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', description='Vpconn的主Pconn', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  spec: string(name='Spec', description='vpconn规格', position='Query'),
  token?: string(name='Token', description='幂等Token', position='Query'),
  vlanId: long(name='VlanId', description='vpconn的VlanID', position='Query'),
  vpconnAliUid: long(name='VpconnAliUid', description='Vpconn拥有者', position='Query'),
}

model CreateVirtualPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  virtualPhysicalConnection?: string(name='VirtualPhysicalConnection', description='Vpconn的实例ID'),
}

model CreateVirtualPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualPhysicalConnectionResponseBody(name='body'),
}

async function createVirtualPhysicalConnection(request: CreateVirtualPhysicalConnectionRequest): CreateVirtualPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVirtualPhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpcRequest {
  cidrBlock?: string(name='CidrBlock', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  enableIpv6?: boolean(name='EnableIpv6', position='Query'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock', position='Query'),
  ipv6Isp?: string(name='Ipv6Isp', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userCidr?: string(name='UserCidr', position='Query'),
  vpcName?: string(name='VpcName', position='Query'),
}

model CreateVpcResponseBody = {
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  routeTableId?: string(name='RouteTableId'),
  vRouterId?: string(name='VRouterId'),
  vpcId?: string(name='VpcId'),
}

model CreateVpcResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcResponseBody(name='body'),
}

async function createVpc(request: CreateVpcRequest): CreateVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpc', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken', description='幂等参数', position='Query'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求', position='Query'),
  endpointDescription?: string(name='EndpointDescription', description='网关节点描述', position='Query'),
  endpointName?: string(name='EndpointName', description='网关节点名称', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  policyDocument?: string(name='PolicyDocument', description='访问云服务的权限控制策略', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName: string(name='ServiceName', description='网关节点服务的名称', position='Query'),
  vpcId: string(name='VpcId', description='专有网络实例ID', position='Query'),
}

model CreateVpcGatewayEndpointResponseBody = {
  creationTime?: string(name='CreationTime'),
  endpointId?: string(name='EndpointId'),
  endpointName?: string(name='EndpointName'),
  requestId?: string(name='RequestId', description='Id of the request'),
  serviceName?: string(name='ServiceName'),
}

model CreateVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcGatewayEndpointResponseBody(name='body'),
}

async function createVpcGatewayEndpoint(request: CreateVpcGatewayEndpointRequest): CreateVpcGatewayEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpcGatewayEndpoint', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpcPrefixListRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ipVersion?: string(name='IpVersion', position='Query'),
  maxEntries?: int32(name='MaxEntries', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListDescription?: string(name='PrefixListDescription', position='Query'),
  prefixListEntrys?: [ 
    {
      cidr?: string(name='Cidr'),
      description?: string(name='Description'),
    }
  ](name='PrefixListEntrys', position='Query'),
  prefixListName?: string(name='PrefixListName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateVpcPrefixListResponseBody = {
  prefixListId?: string(name='PrefixListId'),
  requestId?: string(name='RequestId'),
}

model CreateVpcPrefixListResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcPrefixListResponseBody(name='body'),
}

async function createVpcPrefixList(request: CreateVpcPrefixListRequest): CreateVpcPrefixListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpcPrefixList', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpconnFromVbrRequest {
  dryRun?: boolean(name='DryRun', description='DryRun', position='Query'),
  orderMode?: string(name='OrderMode', description='vpconn的支付方', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  token?: string(name='Token', description='幂等Token', position='Query'),
  vbrId: string(name='VbrId', description='跨帐号的VBR', position='Query'),
}

model CreateVpconnFromVbrResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  virtualPhysicalConnection?: string(name='VirtualPhysicalConnection', description='Vpconn的实例ID'),
}

model CreateVpconnFromVbrResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpconnFromVbrResponseBody(name='body'),
}

async function createVpconnFromVbr(request: CreateVpconnFromVbrRequest): CreateVpconnFromVbrResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpconnFromVbr', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpnAttachmentRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute', position='Query'),
  bgpConfig?: string(name='BgpConfig', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  customerGatewayId: string(name='CustomerGatewayId', position='Query'),
  effectImmediately?: boolean(name='EffectImmediately', description='立即生效', position='Query'),
  enableDpd?: boolean(name='EnableDpd', position='Query'),
  enableNatTraversal?: boolean(name='EnableNatTraversal', position='Query'),
  healthCheckConfig?: string(name='HealthCheckConfig', position='Query'),
  ikeConfig?: string(name='IkeConfig', position='Query'),
  ipsecConfig?: string(name='IpsecConfig', position='Query'),
  localSubnet: string(name='LocalSubnet', description='路由模式为感兴趣流模式时，设置本端ip和对端ip', position='Query'),
  name?: string(name='Name', position='Query'),
  networkType?: string(name='NetworkType', description='public/private', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  remoteCaCert?: string(name='RemoteCaCert', position='Query'),
  remoteSubnet: string(name='RemoteSubnet', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateVpnAttachmentResponseBody = {
  code?: string(name='Code'),
  createTime?: long(name='CreateTime'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model CreateVpnAttachmentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnAttachmentResponseBody(name='body'),
}

async function createVpnAttachment(request: CreateVpnAttachmentRequest): CreateVpnAttachmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpnAttachment', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpnConnectionRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute', position='Query'),
  bgpConfig?: string(name='BgpConfig', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  customerGatewayId: string(name='CustomerGatewayId', position='Query'),
  effectImmediately?: boolean(name='EffectImmediately', position='Query'),
  enableDpd?: boolean(name='EnableDpd', position='Query'),
  enableNatTraversal?: boolean(name='EnableNatTraversal', position='Query'),
  healthCheckConfig?: string(name='HealthCheckConfig', position='Query'),
  ikeConfig?: string(name='IkeConfig', position='Query'),
  ipsecConfig?: string(name='IpsecConfig', position='Query'),
  localSubnet: string(name='LocalSubnet', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  remoteCaCertificate?: string(name='RemoteCaCertificate', position='Query'),
  remoteSubnet: string(name='RemoteSubnet', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model CreateVpnConnectionResponseBody = {
  createTime?: long(name='CreateTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  vpnConnectionId?: string(name='VpnConnectionId'),
}

model CreateVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnConnectionResponseBody(name='body'),
}

async function createVpnConnection(request: CreateVpnConnectionRequest): CreateVpnConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpnConnection', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpnGatewayRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth: int32(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  enableIpsec?: boolean(name='EnableIpsec', position='Query'),
  enableSsl?: boolean(name='EnableSsl', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  name?: string(name='Name', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslConnections?: int32(name='SslConnections', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
  vpnType?: string(name='VpnType', position='Query'),
}

model CreateVpnGatewayResponseBody = {
  name?: string(name='Name'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model CreateVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnGatewayResponseBody(name='body'),
}

async function createVpnGateway(request: CreateVpnGatewayRequest): CreateVpnGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpnGateway', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpnPbrRouteEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  overlayMode?: string(name='OverlayMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publishVpc: boolean(name='PublishVpc', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  routeSource: string(name='RouteSource', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model CreateVpnPbrRouteEntryResponseBody = {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  requestId?: string(name='RequestId'),
  routeDest?: string(name='RouteDest'),
  routeSource?: string(name='RouteSource'),
  state?: string(name='State'),
  vpnInstanceId?: string(name='VpnInstanceId'),
  weight?: int32(name='Weight'),
}

model CreateVpnPbrRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnPbrRouteEntryResponseBody(name='body'),
}

async function createVpnPbrRouteEntry(request: CreateVpnPbrRouteEntryRequest): CreateVpnPbrRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpnPbrRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model CreateVpnRouteEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  overlayMode?: string(name='OverlayMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publishVpc: boolean(name='PublishVpc', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model CreateVpnRouteEntryResponseBody = {
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  nextHop?: string(name='NextHop'),
  overlayMode?: string(name='OverlayMode'),
  requestId?: string(name='RequestId'),
  routeDest?: string(name='RouteDest'),
  state?: string(name='State'),
  vpnInstanceId?: string(name='VpnInstanceId'),
  weight?: int32(name='Weight'),
}

model CreateVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpnRouteEntryResponseBody(name='body'),
}

async function createVpnRouteEntry(request: CreateVpnRouteEntryRequest): CreateVpnRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVpnRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeactivateRouterInterfaceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
}

model DeactivateRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeactivateRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateRouterInterfaceResponseBody(name='body'),
}

async function deactivateRouterInterface(request: DeactivateRouterInterfaceRequest): DeactivateRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeactivateRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model DeactiveFlowLogRequest {
  flowLogId: string(name='FlowLogId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeactiveFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeactiveFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: DeactiveFlowLogResponseBody(name='body'),
}

async function deactiveFlowLog(request: DeactiveFlowLogRequest): DeactiveFlowLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeactiveFlowLog', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBgpGroupRequest {
  bgpGroupId: string(name='BgpGroupId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteBgpGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBgpGroupResponseBody(name='body'),
}

async function deleteBgpGroup(request: DeleteBgpGroupRequest): DeleteBgpGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBgpGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBgpNetworkRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dstCidrBlock: string(name='DstCidrBlock', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerId: string(name='RouterId', position='Query'),
}

model DeleteBgpNetworkResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBgpNetworkResponseBody(name='body'),
}

async function deleteBgpNetwork(request: DeleteBgpNetworkRequest): DeleteBgpNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBgpNetwork', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBgpPeerRequest {
  bgpPeerId: string(name='BgpPeerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteBgpPeerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBgpPeerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBgpPeerResponseBody(name='body'),
}

async function deleteBgpPeer(request: DeleteBgpPeerRequest): DeleteBgpPeerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBgpPeer', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCommonBandwidthPackageRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  force?: string(name='Force', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteCommonBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCommonBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCommonBandwidthPackageResponseBody(name='body'),
}

async function deleteCommonBandwidthPackage(request: DeleteCommonBandwidthPackageRequest): DeleteCommonBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCommonBandwidthPackage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCustomerGatewayRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  customerGatewayId: string(name='CustomerGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteCustomerGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCustomerGatewayResponseBody(name='body'),
}

async function deleteCustomerGateway(request: DeleteCustomerGatewayRequest): DeleteCustomerGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCustomerGateway', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDhcpOptionsSetRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDhcpOptionsSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDhcpOptionsSetResponseBody(name='body'),
}

async function deleteDhcpOptionsSet(request: DeleteDhcpOptionsSetRequest): DeleteDhcpOptionsSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDhcpOptionsSet', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFlowLogRequest {
  flowLogId: string(name='FlowLogId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteFlowLogResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteFlowLogResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowLogResponseBody(name='body'),
}

async function deleteFlowLog(request: DeleteFlowLogRequest): DeleteFlowLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFlowLog', 'POST', '/', 'json', false, 'json', request);
}

model DeleteForwardEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  forwardEntryId: string(name='ForwardEntryId', position='Query'),
  forwardTableId: string(name='ForwardTableId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardEntryResponseBody(name='body'),
}

async function deleteForwardEntry(request: DeleteForwardEntryRequest): DeleteForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteForwardEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFullNatEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fullNatEntryId: string(name='FullNatEntryId', description='要修改的DNAT条目的ID。', position='Query'),
  fullNatTableId: string(name='FullNatTableId', description='FullNAT条目所属的FullNAT列表的ID。', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteFullNatEntryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteFullNatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFullNatEntryResponseBody(name='body'),
}

async function deleteFullNatEntry(request: DeleteFullNatEntryRequest): DeleteFullNatEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFullNatEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGlobalAccelerationInstanceRequest {
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGlobalAccelerationInstanceResponseBody(name='body'),
}

async function deleteGlobalAccelerationInstance(request: DeleteGlobalAccelerationInstanceRequest): DeleteGlobalAccelerationInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGlobalAccelerationInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteHaVipRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  haVipId: string(name='HaVipId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHaVipResponseBody(name='body'),
}

async function deleteHaVip(request: DeleteHaVipRequest): DeleteHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteHaVip', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIPv6TranslatorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ipv6TranslatorId: string(name='Ipv6TranslatorId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteIPv6TranslatorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIPv6TranslatorResponseBody(name='body'),
}

async function deleteIPv6Translator(request: DeleteIPv6TranslatorRequest): DeleteIPv6TranslatorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIPv6Translator', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIPv6TranslatorAclListRequest {
  aclId: string(name='AclId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteIPv6TranslatorAclListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorAclListResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIPv6TranslatorAclListResponseBody(name='body'),
}

async function deleteIPv6TranslatorAclList(request: DeleteIPv6TranslatorAclListRequest): DeleteIPv6TranslatorAclListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIPv6TranslatorAclList', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIPv6TranslatorEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId', position='Query'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteIPv6TranslatorEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIPv6TranslatorEntryResponseBody(name='body'),
}

async function deleteIPv6TranslatorEntry(request: DeleteIPv6TranslatorEntryRequest): DeleteIPv6TranslatorEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIPv6TranslatorEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIpsecServerRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: string(name='DryRun', position='Query'),
  ipsecServerId: string(name='IpsecServerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteIpsecServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpsecServerResponseBody(name='body'),
}

async function deleteIpsecServer(request: DeleteIpsecServerRequest): DeleteIpsecServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIpsecServer', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIpv4GatewayRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ipv4GatewayId: string(name='Ipv4GatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteIpv4GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv4GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv4GatewayResponseBody(name='body'),
}

async function deleteIpv4Gateway(request: DeleteIpv4GatewayRequest): DeleteIpv4GatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIpv4Gateway', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIpv6EgressOnlyRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ipv6EgressOnlyRuleId: string(name='Ipv6EgressOnlyRuleId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteIpv6EgressOnlyRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6EgressOnlyRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv6EgressOnlyRuleResponseBody(name='body'),
}

async function deleteIpv6EgressOnlyRule(request: DeleteIpv6EgressOnlyRuleRequest): DeleteIpv6EgressOnlyRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIpv6EgressOnlyRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIpv6GatewayRequest {
  ipv6GatewayId: string(name='Ipv6GatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteIpv6GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv6GatewayResponseBody(name='body'),
}

async function deleteIpv6Gateway(request: DeleteIpv6GatewayRequest): DeleteIpv6GatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIpv6Gateway', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIpv6InternetBandwidthRequest {
  ipv6AddressId?: string(name='Ipv6AddressId', position='Query'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteIpv6InternetBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpv6InternetBandwidthResponseBody(name='body'),
}

async function deleteIpv6InternetBandwidth(request: DeleteIpv6InternetBandwidthRequest): DeleteIpv6InternetBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIpv6InternetBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNatGatewayRequest {
  force?: boolean(name='Force', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteNatGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatGatewayResponseBody(name='body'),
}

async function deleteNatGateway(request: DeleteNatGatewayRequest): DeleteNatGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNatGateway', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNatIpRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  natIpId: string(name='NatIpId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteNatIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatIpResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatIpResponseBody(name='body'),
}

async function deleteNatIp(request: DeleteNatIpRequest): DeleteNatIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNatIp', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNatIpCidrRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  natIpCidr: string(name='NatIpCidr', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteNatIpCidrResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNatIpCidrResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNatIpCidrResponseBody(name='body'),
}

async function deleteNatIpCidr(request: DeleteNatIpCidrRequest): DeleteNatIpCidrResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNatIpCidr', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNetworkAclRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  networkAclId: string(name='NetworkAclId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkAclResponseBody(name='body'),
}

async function deleteNetworkAcl(request: DeleteNetworkAclRequest): DeleteNetworkAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNetworkAcl', 'POST', '/', 'json', false, 'json', request);
}

model DeletePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeletePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePhysicalConnectionResponseBody(name='body'),
}

async function deletePhysicalConnection(request: DeletePhysicalConnectionRequest): DeletePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model DeletePublicIpAddressPoolRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publicIpAddressPoolId: string(name='PublicIpAddressPoolId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeletePublicIpAddressPoolResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicIpAddressPoolResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePublicIpAddressPoolResponseBody(name='body'),
}

async function deletePublicIpAddressPool(request: DeletePublicIpAddressPoolRequest): DeletePublicIpAddressPoolResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePublicIpAddressPool', 'POST', '/', 'json', false, 'json', request);
}

model DeletePublicIpAddressPoolCidrBlockRequest {
  cidrBlock: string(name='CidrBlock', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publicIpAddressPoolId: string(name='PublicIpAddressPoolId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeletePublicIpAddressPoolCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePublicIpAddressPoolCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePublicIpAddressPoolCidrBlockResponseBody(name='body'),
}

async function deletePublicIpAddressPoolCidrBlock(request: DeletePublicIpAddressPoolCidrBlockRequest): DeletePublicIpAddressPoolCidrBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePublicIpAddressPoolCidrBlock', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRouteEntryRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock', position='Query'),
  nextHopId?: string(name='NextHopId', position='Query'),
  nextHopList?: [ 
    {
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
    }
  ](name='NextHopList', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeEntryId?: string(name='RouteEntryId', position='Query'),
  routeTableId?: string(name='RouteTableId', position='Query'),
}

model DeleteRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouteEntryResponseBody(name='body'),
}

async function deleteRouteEntry(request: DeleteRouteEntryRequest): DeleteRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRouteTableRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
}

model DeleteRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouteTableResponseBody(name='body'),
}

async function deleteRouteTable(request: DeleteRouteTableRequest): DeleteRouteTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRouteTable', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRouterInterfaceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
}

model DeleteRouterInterfaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRouterInterfaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouterInterfaceResponseBody(name='body'),
}

async function deleteRouterInterface(request: DeleteRouterInterfaceRequest): DeleteRouterInterfaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRouterInterface', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnatEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snatEntryId: string(name='SnatEntryId', position='Query'),
  snatTableId: string(name='SnatTableId', position='Query'),
}

model DeleteSnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnatEntryResponseBody(name='body'),
}

async function deleteSnatEntry(request: DeleteSnatEntryRequest): DeleteSnatEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnatEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSslVpnClientCertRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslVpnClientCertId: string(name='SslVpnClientCertId', position='Query'),
}

model DeleteSslVpnClientCertResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSslVpnClientCertResponseBody(name='body'),
}

async function deleteSslVpnClientCert(request: DeleteSslVpnClientCertRequest): DeleteSslVpnClientCertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSslVpnClientCert', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSslVpnServerRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslVpnServerId: string(name='SslVpnServerId', position='Query'),
}

model DeleteSslVpnServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSslVpnServerResponseBody(name='body'),
}

async function deleteSslVpnServer(request: DeleteSslVpnServerRequest): DeleteSslVpnServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSslVpnServer', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTrafficMirrorFilterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorFilterId: string(name='TrafficMirrorFilterId', position='Query'),
}

model DeleteTrafficMirrorFilterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTrafficMirrorFilterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTrafficMirrorFilterResponseBody(name='body'),
}

async function deleteTrafficMirrorFilter(request: DeleteTrafficMirrorFilterRequest): DeleteTrafficMirrorFilterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTrafficMirrorFilter', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTrafficMirrorFilterRulesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorFilterId: string(name='TrafficMirrorFilterId', position='Query'),
  trafficMirrorFilterRuleIds: [ string ](name='TrafficMirrorFilterRuleIds', maxLength=128, position='Query'),
}

model DeleteTrafficMirrorFilterRulesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTrafficMirrorFilterRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTrafficMirrorFilterRulesResponseBody(name='body'),
}

async function deleteTrafficMirrorFilterRules(request: DeleteTrafficMirrorFilterRulesRequest): DeleteTrafficMirrorFilterRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTrafficMirrorFilterRules', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorSessionId: string(name='TrafficMirrorSessionId', position='Query'),
}

model DeleteTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTrafficMirrorSessionResponseBody(name='body'),
}

async function deleteTrafficMirrorSession(request: DeleteTrafficMirrorSessionRequest): DeleteTrafficMirrorSessionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTrafficMirrorSession', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVSwitchRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model DeleteVSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVSwitchResponseBody(name='body'),
}

async function deleteVSwitch(request: DeleteVSwitchRequest): DeleteVSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVSwitch', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVbrHaRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteVbrHaResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVbrHaResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVbrHaResponseBody(name='body'),
}

async function deleteVbrHa(request: DeleteVbrHaRequest): DeleteVbrHaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVbrHa', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVcoRouteEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  overlayMode?: string(name='OverlayMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model DeleteVcoRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVcoRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVcoRouteEntryResponseBody(name='body'),
}

async function deleteVcoRouteEntry(request: DeleteVcoRouteEntryRequest): DeleteVcoRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVcoRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
}

model DeleteVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualBorderRouterResponseBody(name='body'),
}

async function deleteVirtualBorderRouter(request: DeleteVirtualBorderRouterRequest): DeleteVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVpcRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model DeleteVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcResponseBody(name='body'),
}

async function deleteVpc(request: DeleteVpcRequest): DeleteVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpc', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken', description='幂等参数', position='Query'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求', position='Query'),
  endpointId: string(name='EndpointId', description='VPC网关实例ID', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteVpcGatewayEndpointResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcGatewayEndpointResponseBody(name='body'),
}

async function deleteVpcGatewayEndpoint(request: DeleteVpcGatewayEndpointRequest): DeleteVpcGatewayEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpcGatewayEndpoint', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVpcPrefixListRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListId: string(name='PrefixListId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteVpcPrefixListResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpcPrefixListResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcPrefixListResponseBody(name='body'),
}

async function deleteVpcPrefixList(request: DeleteVpcPrefixListRequest): DeleteVpcPrefixListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpcPrefixList', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVpnAttachmentRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
}

model DeleteVpnAttachmentResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteVpnAttachmentResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnAttachmentResponseBody(name='body'),
}

async function deleteVpnAttachment(request: DeleteVpnAttachmentRequest): DeleteVpnAttachmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpnAttachment', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVpnConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
}

model DeleteVpnConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnConnectionResponseBody(name='body'),
}

async function deleteVpnConnection(request: DeleteVpnConnectionRequest): DeleteVpnConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpnConnection', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVpnGatewayRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model DeleteVpnGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnGatewayResponseBody(name='body'),
}

async function deleteVpnGateway(request: DeleteVpnGatewayRequest): DeleteVpnGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpnGateway', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVpnPbrRouteEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  overlayMode?: string(name='OverlayMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  routeSource: string(name='RouteSource', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model DeleteVpnPbrRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnPbrRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnPbrRouteEntryResponseBody(name='body'),
}

async function deleteVpnPbrRouteEntry(request: DeleteVpnPbrRouteEntryRequest): DeleteVpnPbrRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpnPbrRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVpnRouteEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  overlayMode?: string(name='OverlayMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model DeleteVpnRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpnRouteEntryResponseBody(name='body'),
}

async function deleteVpnRouteEntry(request: DeleteVpnRouteEntryRequest): DeleteVpnRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVpnRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model DeletionProtectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  protectionEnable: boolean(name='ProtectionEnable', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeletionProtectionResponseBody(name='body'),
}

async function deletionProtection(request: DeletionProtectionRequest): DeletionProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletionProtection', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccessPointsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAccessPointsResponseBody = {
  accessPointSet?: {
    accessPointType?: [ 
    {
      accessPointFeatureModels?: {
        accessPointFeatureModel?: [ 
        {
          featureKey?: string(name='FeatureKey'),
          featureValue?: string(name='FeatureValue'),
        }
      ](name='AccessPointFeatureModel')
      }(name='AccessPointFeatureModels'),
      accessPointId?: string(name='AccessPointId'),
      attachedRegionNo?: string(name='AttachedRegionNo'),
      description?: string(name='Description'),
      hostOperator?: string(name='HostOperator'),
      location?: string(name='Location'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='AccessPointType')
  }(name='AccessPointSet'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAccessPointsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessPointsResponseBody(name='body'),
}

async function describeAccessPoints(request: DescribeAccessPointsRequest): DescribeAccessPointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccessPoints', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBgpGroupsRequest {
  bgpGroupId?: string(name='BgpGroupId', position='Query'),
  isDefault?: boolean(name='IsDefault', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerId?: string(name='RouterId', position='Query'),
}

model DescribeBgpGroupsResponseBody = {
  bgpGroups?: {
    bgpGroup?: [ 
    {
      authKey?: string(name='AuthKey'),
      bgpGroupId?: string(name='BgpGroupId'),
      description?: string(name='Description'),
      hold?: string(name='Hold'),
      ipVersion?: string(name='IpVersion'),
      isFake?: string(name='IsFake'),
      keepalive?: string(name='Keepalive'),
      localAsn?: string(name='LocalAsn'),
      name?: string(name='Name'),
      peerAsn?: string(name='PeerAsn'),
      regionId?: string(name='RegionId'),
      routeLimit?: string(name='RouteLimit'),
      routerId?: string(name='RouterId'),
      status?: string(name='Status'),
    }
  ](name='BgpGroup')
  }(name='BgpGroups'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBgpGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBgpGroupsResponseBody(name='body'),
}

async function describeBgpGroups(request: DescribeBgpGroupsRequest): DescribeBgpGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBgpGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBgpNetworksRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerId?: string(name='RouterId', position='Query'),
}

model DescribeBgpNetworksResponseBody = {
  bgpNetworks?: {
    bgpNetwork?: [ 
    {
      dstCidrBlock?: string(name='DstCidrBlock'),
      routerId?: string(name='RouterId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='BgpNetwork')
  }(name='BgpNetworks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBgpNetworksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBgpNetworksResponseBody(name='body'),
}

async function describeBgpNetworks(request: DescribeBgpNetworksRequest): DescribeBgpNetworksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBgpNetworks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBgpPeersRequest {
  bgpGroupId?: string(name='BgpGroupId', position='Query'),
  bgpPeerId?: string(name='BgpPeerId', position='Query'),
  isDefault?: boolean(name='IsDefault', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerId?: string(name='RouterId', position='Query'),
}

model DescribeBgpPeersResponseBody = {
  bgpPeers?: {
    bgpPeer?: [ 
    {
      advertisedRouteCount?: int32(name='AdvertisedRouteCount'),
      authKey?: string(name='AuthKey'),
      bfdMultiHop?: int32(name='BfdMultiHop'),
      bgpGroupId?: string(name='BgpGroupId'),
      bgpPeerId?: string(name='BgpPeerId'),
      bgpStatus?: string(name='BgpStatus'),
      description?: string(name='Description'),
      enableBfd?: boolean(name='EnableBfd'),
      gmtModified?: string(name='GmtModified'),
      hold?: string(name='Hold'),
      ipVersion?: string(name='IpVersion'),
      isFake?: boolean(name='IsFake'),
      keepalive?: string(name='Keepalive'),
      localAsn?: string(name='LocalAsn'),
      name?: string(name='Name'),
      peerAsn?: string(name='PeerAsn'),
      peerIpAddress?: string(name='PeerIpAddress'),
      receivedRouteCount?: int32(name='ReceivedRouteCount'),
      regionId?: string(name='RegionId'),
      routeLimit?: string(name='RouteLimit'),
      routerId?: string(name='RouterId'),
      status?: string(name='Status'),
    }
  ](name='BgpPeer')
  }(name='BgpPeers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBgpPeersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBgpPeersResponseBody(name='body'),
}

async function describeBgpPeers(request: DescribeBgpPeersRequest): DescribeBgpPeersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBgpPeers', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCommonBandwidthPackagesRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  includeReservationData?: boolean(name='IncludeReservationData', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled', description='是否开启安全防护', position='Query'),
}

model DescribeCommonBandwidthPackagesResponseBody = {
  commonBandwidthPackages?: {
    commonBandwidthPackage?: [ 
    {
      bandwidth?: string(name='Bandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      deletionProtection?: boolean(name='DeletionProtection'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      hasReservationData?: string(name='HasReservationData'),
      ISP?: string(name='ISP'),
      instanceChargeType?: string(name='InstanceChargeType'),
      internetChargeType?: string(name='InternetChargeType'),
      name?: string(name='Name'),
      publicIpAddresses?: {
        publicIpAddresse?: [ 
        {
          allocationId?: string(name='AllocationId'),
          bandwidthPackageIpRelationStatus?: string(name='BandwidthPackageIpRelationStatus'),
          ipAddress?: string(name='IpAddress'),
        }
      ](name='PublicIpAddresse')
      }(name='PublicIpAddresses'),
      ratio?: int32(name='Ratio'),
      regionId?: string(name='RegionId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityProtectionTypes?: {
        securityProtectionType?: [ string ](name='SecurityProtectionType')
      }(name='SecurityProtectionTypes'),
      serviceManaged?: int32(name='ServiceManaged'),
      status?: string(name='Status'),
    }
  ](name='CommonBandwidthPackage')
  }(name='CommonBandwidthPackages'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCommonBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCommonBandwidthPackagesResponseBody(name='body'),
}

async function describeCommonBandwidthPackages(request: DescribeCommonBandwidthPackagesRequest): DescribeCommonBandwidthPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCommonBandwidthPackages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCustomerGatewayRequest {
  customerGatewayId: string(name='CustomerGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCustomerGatewayResponseBody = {
  asn?: long(name='Asn'),
  authKey?: string(name='AuthKey'),
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model DescribeCustomerGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomerGatewayResponseBody(name='body'),
}

async function describeCustomerGateway(request: DescribeCustomerGatewayRequest): DescribeCustomerGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCustomerGateway', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCustomerGatewaysRequest {
  customerGatewayId?: string(name='CustomerGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCustomerGatewaysResponseBody = {
  customerGateways?: {
    customerGateway?: [ 
    {
      asn?: long(name='Asn'),
      authKey?: string(name='AuthKey'),
      createTime?: long(name='CreateTime'),
      customerGatewayId?: string(name='CustomerGatewayId'),
      description?: string(name='Description'),
      ipAddress?: string(name='IpAddress'),
      name?: string(name='Name'),
    }
  ](name='CustomerGateway')
  }(name='CustomerGateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeCustomerGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomerGatewaysResponseBody(name='body'),
}

async function describeCustomerGateways(request: DescribeCustomerGatewaysRequest): DescribeCustomerGatewaysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCustomerGateways', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEipAddressesRequest {
  filter?: [
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filter', position='Query'),
  allocationId?: string(name='AllocationId', position='Query'),
  associatedInstanceId?: string(name='AssociatedInstanceId', position='Query'),
  associatedInstanceType?: string(name='AssociatedInstanceType', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  eipAddress?: string(name='EipAddress', position='Query'),
  eipName?: string(name='EipName', position='Query'),
  ISP?: string(name='ISP', position='Query'),
  includeReservationData?: boolean(name='IncludeReservationData', position='Query'),
  lockReason?: string(name='LockReason', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  publicIpAddressPoolId?: string(name='PublicIpAddressPoolId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled', description='是否开启安全防护', position='Query'),
  segmentInstanceId?: string(name='SegmentInstanceId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeEipAddressesResponseBody = {
  eipAddresses?: {
    eipAddress?: [ 
    {
      allocationId?: string(name='AllocationId'),
      allocationTime?: string(name='AllocationTime'),
      availableRegions?: {
        availableRegion?: [ string ](name='AvailableRegion')
      }(name='AvailableRegions'),
      bandwidth?: string(name='Bandwidth'),
      bandwidthPackageBandwidth?: string(name='BandwidthPackageBandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidthPackageType?: string(name='BandwidthPackageType'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      deletionProtection?: boolean(name='DeletionProtection'),
      description?: string(name='Description'),
      eipBandwidth?: string(name='EipBandwidth'),
      expiredTime?: string(name='ExpiredTime'),
      HDMonitorStatus?: string(name='HDMonitorStatus'),
      hasReservationData?: string(name='HasReservationData'),
      ISP?: string(name='ISP'),
      instanceId?: string(name='InstanceId'),
      instanceRegionId?: string(name='InstanceRegionId'),
      instanceType?: string(name='InstanceType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipAddress?: string(name='IpAddress'),
      name?: string(name='Name'),
      netmode?: string(name='Netmode'),
      operationLocks?: {
        lockReason?: [ 
        {
          lockReason?: string(name='LockReason'),
        }
      ](name='LockReason')
      }(name='OperationLocks'),
      publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
      regionId?: string(name='RegionId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      secondLimited?: boolean(name='SecondLimited'),
      securityProtectionTypes?: {
        securityProtectionType?: [ string ](name='SecurityProtectionType')
      }(name='SecurityProtectionTypes'),
      segmentInstanceId?: string(name='SegmentInstanceId'),
      serviceManaged?: int32(name='ServiceManaged'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='EipAddress')
  }(name='EipAddresses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEipAddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipAddressesResponseBody(name='body'),
}

async function describeEipAddresses(request: DescribeEipAddressesRequest): DescribeEipAddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipAddresses', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEipGatewayInfoRequest {
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeEipGatewayInfoResponseBody = {
  code?: string(name='Code'),
  eipInfos?: {
    eipInfo?: [ 
    {
      ip?: string(name='Ip'),
      ipGw?: string(name='IpGw'),
      ipMask?: string(name='IpMask'),
    }
  ](name='EipInfo')
  }(name='EipInfos'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeEipGatewayInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipGatewayInfoResponseBody(name='body'),
}

async function describeEipGatewayInfo(request: DescribeEipGatewayInfoRequest): DescribeEipGatewayInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipGatewayInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEipMonitorDataRequest {
  allocationId: string(name='AllocationId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: int32(name='Period', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeEipMonitorDataResponseBody = {
  eipMonitorDatas?: {
    eipMonitorData?: [ 
    {
      eipBandwidth?: int32(name='EipBandwidth'),
      eipFlow?: int32(name='EipFlow'),
      eipPackets?: int32(name='EipPackets'),
      eipRX?: long(name='EipRX'),
      eipTX?: long(name='EipTX'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='EipMonitorData')
  }(name='EipMonitorDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeEipMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipMonitorDataResponseBody(name='body'),
}

async function describeEipMonitorData(request: DescribeEipMonitorDataRequest): DescribeEipMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipMonitorData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEipSegmentRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  segmentInstanceId?: string(name='SegmentInstanceId', position='Query'),
}

model DescribeEipSegmentResponseBody = {
  eipSegments?: {
    eipSegment?: [ 
    {
      creationTime?: string(name='CreationTime'),
      descritpion?: string(name='Descritpion'),
      instanceId?: string(name='InstanceId'),
      ipCount?: string(name='IpCount'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      segment?: string(name='Segment'),
      status?: string(name='Status'),
    }
  ](name='EipSegment')
  }(name='EipSegments'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeEipSegmentResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEipSegmentResponseBody(name='body'),
}

async function describeEipSegment(request: DescribeEipSegmentRequest): DescribeEipSegmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEipSegment', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFlowLogsRequest {
  description?: string(name='Description', position='Query'),
  flowLogId?: string(name='FlowLogId', position='Query'),
  flowLogName?: string(name='FlowLogName', position='Query'),
  logStoreName?: string(name='LogStoreName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  projectName?: string(name='ProjectName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  status?: string(name='Status', position='Query'),
  trafficType?: string(name='TrafficType', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeFlowLogsResponseBody = {
  flowLogs?: {
    flowLog?: [ 
    {
      aggregationInterval?: int32(name='AggregationInterval'),
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      flowLogId?: string(name='FlowLogId'),
      flowLogName?: string(name='FlowLogName'),
      logStoreName?: string(name='LogStoreName'),
      projectName?: string(name='ProjectName'),
      regionId?: string(name='RegionId'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      status?: string(name='Status'),
      trafficType?: string(name='TrafficType'),
    }
  ](name='FlowLog')
  }(name='FlowLogs'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  totalCount?: string(name='TotalCount'),
}

model DescribeFlowLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowLogsResponseBody(name='body'),
}

async function describeFlowLogs(request: DescribeFlowLogsRequest): DescribeFlowLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFlowLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeForwardTableEntriesRequest {
  externalIp?: string(name='ExternalIp', position='Query'),
  externalPort?: string(name='ExternalPort', position='Query'),
  forwardEntryId?: string(name='ForwardEntryId', position='Query'),
  forwardEntryName?: string(name='ForwardEntryName', position='Query'),
  forwardTableId: string(name='ForwardTableId', position='Query'),
  internalIp?: string(name='InternalIp', position='Query'),
  internalPort?: string(name='InternalPort', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeForwardTableEntriesResponseBody = {
  forwardTableEntries?: {
    forwardTableEntry?: [ 
    {
      externalIp?: string(name='ExternalIp'),
      externalPort?: string(name='ExternalPort'),
      forwardEntryId?: string(name='ForwardEntryId'),
      forwardEntryName?: string(name='ForwardEntryName'),
      forwardTableId?: string(name='ForwardTableId'),
      internalIp?: string(name='InternalIp'),
      internalPort?: string(name='InternalPort'),
      ipProtocol?: string(name='IpProtocol'),
      status?: string(name='Status'),
    }
  ](name='ForwardTableEntry')
  }(name='ForwardTableEntries'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeForwardTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeForwardTableEntriesResponseBody(name='body'),
}

async function describeForwardTableEntries(request: DescribeForwardTableEntriesRequest): DescribeForwardTableEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeForwardTableEntries', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGlobalAccelerationInstancesRequest {
  bandwidthType?: string(name='BandwidthType', position='Query'),
  globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId', position='Query'),
  includeReservationData?: boolean(name='IncludeReservationData', position='Query'),
  ipAddress?: string(name='IpAddress', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serverId?: string(name='ServerId', position='Query'),
  serviceLocation?: string(name='ServiceLocation', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeGlobalAccelerationInstancesResponseBody = {
  globalAccelerationInstances?: {
    globalAccelerationInstance?: [ 
    {
      accelerationLocation?: string(name='AccelerationLocation'),
      backendServers?: {
        backendServer?: [ 
        {
          regionId?: string(name='RegionId'),
          serverId?: string(name='ServerId'),
          serverIpAddress?: string(name='ServerIpAddress'),
          serverType?: string(name='ServerType'),
        }
      ](name='BackendServer')
      }(name='BackendServers'),
      bandwidth?: string(name='Bandwidth'),
      bandwidthType?: string(name='BandwidthType'),
      chargeType?: string(name='ChargeType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
      internetChargeType?: string(name='InternetChargeType'),
      ipAddress?: string(name='IpAddress'),
      name?: string(name='Name'),
      publicIpAddresses?: {
        publicIpAddress?: [ 
        {
          allocationId?: string(name='AllocationId'),
          ipAddress?: string(name='IpAddress'),
        }
      ](name='PublicIpAddress')
      }(name='PublicIpAddresses'),
      regionId?: string(name='RegionId'),
      serviceLocation?: string(name='ServiceLocation'),
      status?: string(name='Status'),
    }
  ](name='GlobalAccelerationInstance')
  }(name='GlobalAccelerationInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGlobalAccelerationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGlobalAccelerationInstancesResponseBody(name='body'),
}

async function describeGlobalAccelerationInstances(request: DescribeGlobalAccelerationInstancesRequest): DescribeGlobalAccelerationInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGlobalAccelerationInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGrantRulesToCenRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeGrantRulesToCenResponseBody = {
  cenGrantRules?: {
    cbnGrantRule?: [ 
    {
      cenInstanceId?: string(name='CenInstanceId'),
      cenOwnerId?: long(name='CenOwnerId'),
      creationTime?: string(name='CreationTime'),
    }
  ](name='CbnGrantRule')
  }(name='CenGrantRules'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeGrantRulesToCenResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGrantRulesToCenResponseBody(name='body'),
}

async function describeGrantRulesToCen(request: DescribeGrantRulesToCenRequest): DescribeGrantRulesToCenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGrantRulesToCen', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHaVipsRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeHaVipsResponseBody = {
  haVips?: {
    haVip?: [ 
    {
      associatedEipAddresses?: {
        associatedEipAddresse?: [ string ](name='associatedEipAddresse')
      }(name='AssociatedEipAddresses'),
      associatedInstanceType?: string(name='AssociatedInstanceType'),
      associatedInstances?: {
        associatedInstance?: [ string ](name='associatedInstance')
      }(name='AssociatedInstances'),
      chargeType?: string(name='ChargeType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      haVipId?: string(name='HaVipId'),
      ipAddress?: string(name='IpAddress'),
      masterInstanceId?: string(name='MasterInstanceId'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='HaVip')
  }(name='HaVips'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeHaVipsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHaVipsResponseBody(name='body'),
}

async function describeHaVips(request: DescribeHaVipsRequest): DescribeHaVipsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHaVips', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHighDefinitionMonitorLogAttributeRequest {
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeHighDefinitionMonitorLogAttributeResponseBody = {
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  logProject?: string(name='LogProject'),
  logStore?: string(name='LogStore'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeHighDefinitionMonitorLogAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHighDefinitionMonitorLogAttributeResponseBody(name='body'),
}

async function describeHighDefinitionMonitorLogAttribute(request: DescribeHighDefinitionMonitorLogAttributeRequest): DescribeHighDefinitionMonitorLogAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHighDefinitionMonitorLogAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIPv6TranslatorAclListAttributesRequest {
  aclId: string(name='AclId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeIPv6TranslatorAclListAttributesResponseBody = {
  aclEntries?: {
    aclEntry?: [ 
    {
      aclEntryComment?: string(name='AclEntryComment'),
      aclEntryId?: string(name='AclEntryId'),
      aclEntryIp?: string(name='AclEntryIp'),
    }
  ](name='AclEntry')
  }(name='AclEntries'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorAclListAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorAclListAttributesResponseBody(name='body'),
}

async function describeIPv6TranslatorAclListAttributes(request: DescribeIPv6TranslatorAclListAttributesRequest): DescribeIPv6TranslatorAclListAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIPv6TranslatorAclListAttributes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIPv6TranslatorAclListsRequest {
  aclId?: string(name='AclId', position='Query'),
  aclName?: string(name='AclName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeIPv6TranslatorAclListsResponseBody = {
  ipv6TranslatorAcls?: {
    iPv6TranslatorAcl?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
    }
  ](name='IPv6TranslatorAcl')
  }(name='Ipv6TranslatorAcls'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorAclListsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorAclListsResponseBody(name='body'),
}

async function describeIPv6TranslatorAclLists(request: DescribeIPv6TranslatorAclListsRequest): DescribeIPv6TranslatorAclListsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIPv6TranslatorAclLists', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIPv6TranslatorEntriesRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr', position='Query'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port', position='Query'),
  backendIpv4Addr?: string(name='BackendIpv4Addr', position='Query'),
  backendIpv4Port?: int32(name='BackendIpv4Port', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  entryName?: string(name='EntryName', position='Query'),
  ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId', position='Query'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  transProtocol?: string(name='TransProtocol', position='Query'),
}

model DescribeIPv6TranslatorEntriesResponseBody = {
  ipv6TranslatorEntries?: {
    ipv6TranslatorEntry?: [ 
    {
      aclId?: string(name='AclId'),
      aclStatus?: string(name='AclStatus'),
      aclType?: string(name='AclType'),
      allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
      allocateIpv6Port?: int32(name='AllocateIpv6Port'),
      backendIpv4Addr?: string(name='BackendIpv4Addr'),
      backendIpv4Port?: string(name='BackendIpv4Port'),
      entryBandwidth?: string(name='EntryBandwidth'),
      entryDescription?: string(name='EntryDescription'),
      entryName?: string(name='EntryName'),
      entryStatus?: string(name='EntryStatus'),
      ipv6TranslatorEntryId?: string(name='Ipv6TranslatorEntryId'),
      ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
      regionId?: string(name='RegionId'),
      transProtocol?: string(name='TransProtocol'),
    }
  ](name='Ipv6TranslatorEntry')
  }(name='Ipv6TranslatorEntries'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorEntriesResponseBody(name='body'),
}

async function describeIPv6TranslatorEntries(request: DescribeIPv6TranslatorEntriesRequest): DescribeIPv6TranslatorEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIPv6TranslatorEntries', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIPv6TranslatorsRequest {
  allocateIpv4Addr?: string(name='AllocateIpv4Addr', position='Query'),
  allocateIpv6Addr?: string(name='AllocateIpv6Addr', position='Query'),
  businessStatus?: string(name='BusinessStatus', position='Query'),
  ipv6TranslatorId?: string(name='Ipv6TranslatorId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  payType?: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spec?: string(name='Spec', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeIPv6TranslatorsResponseBody = {
  ipv6Translators?: {
    ipv6Translator?: [ 
    {
      allocateIpv4Addr?: string(name='AllocateIpv4Addr'),
      allocateIpv6Addr?: string(name='AllocateIpv6Addr'),
      availableBandwidth?: string(name='AvailableBandwidth'),
      bandwidth?: int32(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      endTime?: long(name='EndTime'),
      ipv6TranslatorEntryIds?: {
        ipv6TranslatorEntryId?: [ string ](name='Ipv6TranslatorEntryId')
      }(name='Ipv6TranslatorEntryIds'),
      ipv6TranslatorId?: string(name='Ipv6TranslatorId'),
      name?: string(name='Name'),
      payType?: string(name='PayType'),
      regionId?: string(name='RegionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
    }
  ](name='Ipv6Translator')
  }(name='Ipv6Translators'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIPv6TranslatorsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIPv6TranslatorsResponseBody(name='body'),
}

async function describeIPv6Translators(request: DescribeIPv6TranslatorsRequest): DescribeIPv6TranslatorsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIPv6Translators', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIpv6AddressesRequest {
  associatedInstanceId?: string(name='AssociatedInstanceId', position='Query'),
  associatedInstanceType?: string(name='AssociatedInstanceType', position='Query'),
  ipv6Address?: string(name='Ipv6Address', position='Query'),
  ipv6AddressId?: string(name='Ipv6AddressId', position='Query'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId', position='Query'),
  name?: string(name='Name', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeIpv6AddressesResponseBody = {
  ipv6Addresses?: {
    ipv6Address?: [ 
    {
      allocationTime?: string(name='AllocationTime'),
      associatedInstanceId?: string(name='AssociatedInstanceId'),
      associatedInstanceType?: string(name='AssociatedInstanceType'),
      ipv6Address?: string(name='Ipv6Address'),
      ipv6AddressId?: string(name='Ipv6AddressId'),
      ipv6AddressName?: string(name='Ipv6AddressName'),
      ipv6GatewayId?: string(name='Ipv6GatewayId'),
      ipv6InternetBandwidth?: {
        bandwidth?: int32(name='Bandwidth'),
        businessStatus?: string(name='BusinessStatus'),
        instanceChargeType?: string(name='InstanceChargeType'),
        internetChargeType?: string(name='InternetChargeType'),
        ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId'),
      }(name='Ipv6InternetBandwidth'),
      ipv6Isp?: string(name='Ipv6Isp'),
      networkType?: string(name='NetworkType'),
      realBandwidth?: int32(name='RealBandwidth'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Ipv6Address')
  }(name='Ipv6Addresses'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIpv6AddressesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6AddressesResponseBody(name='body'),
}

async function describeIpv6Addresses(request: DescribeIpv6AddressesRequest): DescribeIpv6AddressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIpv6Addresses', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIpv6EgressOnlyRulesRequest {
  instanceId?: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId', position='Query'),
  ipv6GatewayId: string(name='Ipv6GatewayId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeIpv6EgressOnlyRulesResponseBody = {
  ipv6EgressOnlyRules?: {
    ipv6EgressOnlyRule?: [ 
    {
      description?: string(name='Description'),
      instanceId?: string(name='InstanceId'),
      instanceType?: string(name='InstanceType'),
      ipv6EgressOnlyRuleId?: string(name='Ipv6EgressOnlyRuleId'),
      name?: string(name='Name'),
      status?: string(name='Status'),
    }
  ](name='Ipv6EgressOnlyRule')
  }(name='Ipv6EgressOnlyRules'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIpv6EgressOnlyRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6EgressOnlyRulesResponseBody(name='body'),
}

async function describeIpv6EgressOnlyRules(request: DescribeIpv6EgressOnlyRulesRequest): DescribeIpv6EgressOnlyRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIpv6EgressOnlyRules', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIpv6GatewayAttributeRequest {
  ipv6GatewayId: string(name='Ipv6GatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeIpv6GatewayAttributeResponseBody = {
  businessStatus?: string(name='BusinessStatus'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  expiredTime?: string(name='ExpiredTime'),
  instanceChargeType?: string(name='InstanceChargeType'),
  ipv6GatewayId?: string(name='Ipv6GatewayId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
}

model DescribeIpv6GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6GatewayAttributeResponseBody(name='body'),
}

async function describeIpv6GatewayAttribute(request: DescribeIpv6GatewayAttributeRequest): DescribeIpv6GatewayAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIpv6GatewayAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIpv6GatewaysRequest {
  ipv6GatewayId?: string(name='Ipv6GatewayId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeIpv6GatewaysResponseBody = {
  ipv6Gateways?: {
    ipv6Gateway?: [ 
    {
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      instanceChargeType?: string(name='InstanceChargeType'),
      ipv6GatewayId?: string(name='Ipv6GatewayId'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Ipv6Gateway')
  }(name='Ipv6Gateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeIpv6GatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpv6GatewaysResponseBody(name='body'),
}

async function describeIpv6Gateways(request: DescribeIpv6GatewaysRequest): DescribeIpv6GatewaysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIpv6Gateways', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNatGatewaysRequest {
  dryRun?: boolean(name='DryRun', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  name?: string(name='Name', position='Query'),
  natGatewayId?: string(name='NatGatewayId', position='Query'),
  natType?: string(name='NatType', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spec?: string(name='Spec', position='Query'),
  status?: string(name='Status', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', description='可用区', position='Query'),
}

model DescribeNatGatewaysResponseBody = {
  natGateways?: {
    natGateway?: [ 
    {
      autoPay?: boolean(name='AutoPay'),
      businessStatus?: string(name='BusinessStatus'),
      creationTime?: string(name='CreationTime'),
      deletionProtection?: boolean(name='DeletionProtection'),
      description?: string(name='Description'),
      ecsMetricEnabled?: boolean(name='EcsMetricEnabled'),
      expiredTime?: string(name='ExpiredTime'),
      forwardTableIds?: {
        forwardTableId?: [ string ](name='ForwardTableId')
      }(name='ForwardTableIds'),
      fullNatTableIds?: {
        fullNatTableId?: [ string ](name='FullNatTableId')
      }(name='FullNatTableIds'),
      icmpReplyEnabled?: boolean(name='IcmpReplyEnabled'),
      instanceChargeType?: string(name='InstanceChargeType'),
      internetChargeType?: string(name='InternetChargeType'),
      ipLists?: {
        ipList?: [ 
        {
          allocationId?: string(name='AllocationId'),
          ipAddress?: string(name='IpAddress'),
          privateIpAddress?: string(name='PrivateIpAddress'),
          snatEntryEnabled?: boolean(name='SnatEntryEnabled'),
          usingStatus?: string(name='UsingStatus'),
        }
      ](name='IpList')
      }(name='IpLists'),
      name?: string(name='Name'),
      natGatewayId?: string(name='NatGatewayId'),
      natGatewayPrivateInfo?: {
        eniInstanceId?: string(name='EniInstanceId'),
        eniType?: string(name='EniType'),
        izNo?: string(name='IzNo'),
        maxBandwidth?: int32(name='MaxBandwidth'),
        maxSessionEstablishRate?: int32(name='MaxSessionEstablishRate'),
        maxSessionQuota?: int32(name='MaxSessionQuota'),
        privateIpAddress?: string(name='PrivateIpAddress'),
        vswitchId?: string(name='VswitchId'),
      }(name='NatGatewayPrivateInfo'),
      natType?: string(name='NatType'),
      networkType?: string(name='NetworkType'),
      privateLinkEnabled?: boolean(name='PrivateLinkEnabled', description='默认不支持私网链接。设置为1则意味着支持私网链接'),
      privateLinkMode?: string(name='PrivateLinkMode', description='Fullnat：使用FullNat模式 Geneve：使用Geneve模式。 预估大部分场景都是非Geneve模式的。'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityProtectionEnabled?: boolean(name='SecurityProtectionEnabled'),
      snatTableIds?: {
        snatTableId?: [ string ](name='SnatTableId')
      }(name='SnatTableIds'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='NatGateway')
  }(name='NatGateways'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeNatGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNatGatewaysResponseBody(name='body'),
}

async function describeNatGateways(request: DescribeNatGatewaysRequest): DescribeNatGatewaysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNatGateways', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkAclAttributesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  networkAclId: string(name='NetworkAclId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeNetworkAclAttributesResponseBody = {
  networkAclAttribute?: {
    creationTime?: string(name='CreationTime'),
    description?: string(name='Description'),
    egressAclEntries?: {
      egressAclEntry?: [ 
      {
        description?: string(name='Description'),
        destinationCidrIp?: string(name='DestinationCidrIp'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
      }
    ](name='EgressAclEntry')
    }(name='EgressAclEntries'),
    ingressAclEntries?: {
      ingressAclEntry?: [ 
      {
        description?: string(name='Description'),
        networkAclEntryId?: string(name='NetworkAclEntryId'),
        networkAclEntryName?: string(name='NetworkAclEntryName'),
        policy?: string(name='Policy'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
        sourceCidrIp?: string(name='SourceCidrIp'),
      }
    ](name='IngressAclEntry')
    }(name='IngressAclEntries'),
    networkAclId?: string(name='NetworkAclId'),
    networkAclName?: string(name='NetworkAclName'),
    ownerId?: long(name='OwnerId'),
    regionId?: string(name='RegionId'),
    resources?: {
      resource?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        status?: string(name='Status'),
      }
    ](name='Resource')
    }(name='Resources'),
    status?: string(name='Status'),
    vpcId?: string(name='VpcId'),
  }(name='NetworkAclAttribute'),
  requestId?: string(name='RequestId'),
}

model DescribeNetworkAclAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkAclAttributesResponseBody(name='body'),
}

async function describeNetworkAclAttributes(request: DescribeNetworkAclAttributesRequest): DescribeNetworkAclAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkAclAttributes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkAclsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  networkAclId?: string(name='NetworkAclId', position='Query'),
  networkAclName?: string(name='NetworkAclName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeNetworkAclsResponseBody = {
  networkAcls?: {
    networkAcl?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      egressAclEntries?: {
        egressAclEntry?: [ 
        {
          description?: string(name='Description'),
          destinationCidrIp?: string(name='DestinationCidrIp'),
          networkAclEntryId?: string(name='NetworkAclEntryId'),
          networkAclEntryName?: string(name='NetworkAclEntryName'),
          policy?: string(name='Policy'),
          port?: string(name='Port'),
          protocol?: string(name='Protocol'),
        }
      ](name='EgressAclEntry')
      }(name='EgressAclEntries'),
      ingressAclEntries?: {
        ingressAclEntry?: [ 
        {
          description?: string(name='Description'),
          networkAclEntryId?: string(name='NetworkAclEntryId'),
          networkAclEntryName?: string(name='NetworkAclEntryName'),
          policy?: string(name='Policy'),
          port?: string(name='Port'),
          protocol?: string(name='Protocol'),
          sourceCidrIp?: string(name='SourceCidrIp'),
        }
      ](name='IngressAclEntry')
      }(name='IngressAclEntries'),
      networkAclId?: string(name='NetworkAclId'),
      networkAclName?: string(name='NetworkAclName'),
      ownerId?: long(name='OwnerId'),
      regionId?: string(name='RegionId'),
      resources?: {
        resource?: [ 
        {
          resourceId?: string(name='ResourceId'),
          resourceType?: string(name='ResourceType'),
          status?: string(name='Status'),
        }
      ](name='Resource')
      }(name='Resources'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='NetworkAcl')
  }(name='NetworkAcls'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model DescribeNetworkAclsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkAclsResponseBody(name='body'),
}

async function describeNetworkAcls(request: DescribeNetworkAclsRequest): DescribeNetworkAclsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkAcls', 'POST', '/', 'json', false, 'json', request);
}

model DescribePhysicalConnectionLOARequest {
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribePhysicalConnectionLOAResponseBody = {
  physicalConnectionLOAType?: {
    companyLocalizedName?: string(name='CompanyLocalizedName'),
    companyName?: string(name='CompanyName'),
    constructionTime?: string(name='ConstructionTime'),
    instanceId?: string(name='InstanceId'),
    lineCode?: string(name='LineCode'),
    lineLabel?: string(name='LineLabel'),
    lineType?: string(name='LineType'),
    loaUrl?: string(name='LoaUrl'),
    PMInfo?: {
      PMInfo?: [ 
      {
        PMCertificateNo?: string(name='PMCertificateNo'),
        PMCertificateType?: string(name='PMCertificateType'),
        PMContactInfo?: string(name='PMContactInfo'),
        PMGender?: string(name='PMGender'),
        PMName?: string(name='PMName'),
      }
    ](name='PMInfo')
    }(name='PMInfo'),
    si?: string(name='SI'),
    status?: string(name='Status'),
  }(name='PhysicalConnectionLOAType'),
  requestId?: string(name='RequestId'),
}

model DescribePhysicalConnectionLOAResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePhysicalConnectionLOAResponseBody(name='body'),
}

async function describePhysicalConnectionLOA(request: DescribePhysicalConnectionLOARequest): DescribePhysicalConnectionLOAResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePhysicalConnectionLOA', 'POST', '/', 'json', false, 'json', request);
}

model DescribePhysicalConnectionsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  includeReservationData?: boolean(name='IncludeReservationData', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribePhysicalConnectionsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  physicalConnectionSet?: {
    physicalConnectionType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      accessPointType?: string(name='AccessPointType'),
      adLocation?: string(name='AdLocation'),
      bandwidth?: long(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      enabledTime?: string(name='EnabledTime'),
      endTime?: string(name='EndTime'),
      expectSpec?: string(name='ExpectSpec'),
      hasReservationData?: string(name='HasReservationData'),
      lineOperator?: string(name='LineOperator'),
      loaStatus?: string(name='LoaStatus'),
      name?: string(name='Name'),
      orderMode?: string(name='OrderMode'),
      parentPhysicalConnectionAliUid?: long(name='ParentPhysicalConnectionAliUid'),
      parentPhysicalConnectionId?: string(name='ParentPhysicalConnectionId'),
      peerLocation?: string(name='PeerLocation'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      portNumber?: string(name='PortNumber'),
      portType?: string(name='PortType'),
      productType?: string(name='ProductType'),
      redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      virtualPhysicalConnectionCount?: int32(name='VirtualPhysicalConnectionCount'),
      vlanId?: string(name='VlanId'),
      vpconnStatus?: string(name='VpconnStatus'),
    }
  ](name='PhysicalConnectionType')
  }(name='PhysicalConnectionSet'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribePhysicalConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePhysicalConnectionsResponseBody(name='body'),
}

async function describePhysicalConnections(request: DescribePhysicalConnectionsRequest): DescribePhysicalConnectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePhysicalConnections', 'POST', '/', 'json', false, 'json', request);
}

model DescribePublicIpAddressRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribePublicIpAddressResponseBody = {
  code?: string(name='Code'),
  ipRange?: {
    ipRange?: [ string ](name='IpRange')
  }(name='IpRange'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  publicIpAddress?: string(name='PublicIpAddress'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribePublicIpAddressResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePublicIpAddressResponseBody(name='body'),
}

async function describePublicIpAddress(request: DescribePublicIpAddressRequest): DescribePublicIpAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePublicIpAddress', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRouteEntryListRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock', position='Query'),
  ipVersion?: string(name='IpVersion', position='Query'),
  maxResult?: int32(name='MaxResult', maximum=500, position='Query'),
  nextHopId?: string(name='NextHopId', position='Query'),
  nextHopType?: string(name='NextHopType', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeEntryId?: string(name='RouteEntryId', position='Query'),
  routeEntryName?: string(name='RouteEntryName', position='Query'),
  routeEntryType?: string(name='RouteEntryType', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
}

model DescribeRouteEntryListResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  routeEntrys?: {
    routeEntry?: [ 
    {
      description?: string(name='Description'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      gmtModified?: string(name='GmtModified'),
      ipVersion?: string(name='IpVersion'),
      nextHops?: {
        nextHop?: [ 
        {
          enabled?: int32(name='Enabled'),
          nextHopId?: string(name='NextHopId'),
          nextHopRegionId?: string(name='NextHopRegionId'),
          nextHopRelatedInfo?: {
            instanceId?: string(name='InstanceId'),
            instanceType?: string(name='InstanceType'),
            regionId?: string(name='RegionId'),
          }(name='NextHopRelatedInfo'),
          nextHopType?: string(name='NextHopType'),
          weight?: int32(name='Weight'),
        }
      ](name='NextHop')
      }(name='NextHops'),
      routeEntryId?: string(name='RouteEntryId'),
      routeEntryName?: string(name='RouteEntryName'),
      routeTableId?: string(name='RouteTableId'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='RouteEntry')
  }(name='RouteEntrys'),
}

model DescribeRouteEntryListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteEntryListResponseBody(name='body'),
}

async function describeRouteEntryList(request: DescribeRouteEntryListRequest): DescribeRouteEntryListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRouteEntryList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRouteTableListRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId?: string(name='RouteTableId', position='Query'),
  routeTableName?: string(name='RouteTableName', position='Query'),
  routerId?: string(name='RouterId', position='Query'),
  routerType?: string(name='RouterType', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeRouteTableListResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routerTableList?: {
    routerTableListType?: [ 
    {
      associateType?: string(name='AssociateType'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      gatewayIds?: {
        gatewayIds?: [ string ](name='GatewayIds')
      }(name='GatewayIds'),
      ownerId?: long(name='OwnerId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeTableId?: string(name='RouteTableId'),
      routeTableName?: string(name='RouteTableName'),
      routeTableType?: string(name='RouteTableType'),
      routerId?: string(name='RouterId'),
      routerType?: string(name='RouterType'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
    }
  ](name='RouterTableListType')
  }(name='RouterTableList'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouteTableListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteTableListResponseBody(name='body'),
}

async function describeRouteTableList(request: DescribeRouteTableListRequest): DescribeRouteTableListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRouteTableList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRouteTablesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId?: string(name='RouteTableId', position='Query'),
  routeTableName?: string(name='RouteTableName', position='Query'),
  routerId?: string(name='RouterId', position='Query'),
  routerType?: string(name='RouterType', position='Query'),
  type?: string(name='Type', position='Query'),
  vRouterId?: string(name='VRouterId', position='Query'),
}

model DescribeRouteTablesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routeTables?: {
    routeTable?: [ 
    {
      creationTime?: string(name='CreationTime'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeEntrys?: {
        routeEntry?: [ 
        {
          description?: string(name='Description'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          instanceId?: string(name='InstanceId'),
          nextHopType?: string(name='NextHopType'),
          nextHops?: {
            nextHop?: [ 
            {
              enabled?: int32(name='Enabled'),
              nextHopId?: string(name='NextHopId'),
              nextHopType?: string(name='NextHopType'),
              weight?: int32(name='Weight'),
            }
          ](name='NextHop')
          }(name='NextHops'),
          routeEntryId?: string(name='RouteEntryId'),
          routeEntryName?: string(name='RouteEntryName'),
          routeTableId?: string(name='RouteTableId'),
          status?: string(name='Status'),
          type?: string(name='Type'),
        }
      ](name='RouteEntry')
      }(name='RouteEntrys'),
      routeTableId?: string(name='RouteTableId'),
      routeTableType?: string(name='RouteTableType'),
      status?: string(name='Status'),
      vRouterId?: string(name='VRouterId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
    }
  ](name='RouteTable')
  }(name='RouteTables'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouteTablesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouteTablesResponseBody(name='body'),
}

async function describeRouteTables(request: DescribeRouteTablesRequest): DescribeRouteTablesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRouteTables', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRouterInterfaceAttributeRequest {
  instanceId: string(name='InstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRouterInterfaceAttributeResponseBody = {
  accessPointId?: string(name='AccessPointId'),
  bandwidth?: int32(name='Bandwidth'),
  businessStatus?: string(name='BusinessStatus'),
  chargeType?: string(name='ChargeType'),
  code?: string(name='Code'),
  connectedTime?: string(name='ConnectedTime'),
  creationTime?: string(name='CreationTime'),
  crossBorder?: boolean(name='CrossBorder'),
  description?: string(name='Description'),
  endTime?: string(name='EndTime'),
  gmtModified?: string(name='GmtModified'),
  hasReservationData?: string(name='HasReservationData'),
  hcRate?: int32(name='HcRate'),
  hcThreshold?: int32(name='HcThreshold'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
  healthCheckStatus?: string(name='HealthCheckStatus'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  oppositeAccessPointId?: string(name='OppositeAccessPointId'),
  oppositeBandwidth?: int32(name='OppositeBandwidth'),
  oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId'),
  oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
  oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
  oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
  oppositeRegionId?: string(name='OppositeRegionId'),
  oppositeRouterId?: string(name='OppositeRouterId'),
  oppositeRouterType?: string(name='OppositeRouterType'),
  oppositeVpcInstanceId?: string(name='OppositeVpcInstanceId'),
  requestId?: string(name='RequestId'),
  reservationActiveTime?: string(name='ReservationActiveTime'),
  reservationBandwidth?: string(name='ReservationBandwidth'),
  reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
  reservationOrderType?: string(name='ReservationOrderType'),
  role?: string(name='Role'),
  routerId?: string(name='RouterId'),
  routerInterfaceId?: string(name='RouterInterfaceId'),
  routerType?: string(name='RouterType'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
  vpcInstanceId?: string(name='VpcInstanceId'),
}

model DescribeRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouterInterfaceAttributeResponseBody(name='body'),
}

async function describeRouterInterfaceAttribute(request: DescribeRouterInterfaceAttributeRequest): DescribeRouterInterfaceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRouterInterfaceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRouterInterfacesRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  includeReservationData?: boolean(name='IncludeReservationData', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRouterInterfacesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  routerInterfaceSet?: {
    routerInterfaceType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      bandwidth?: int32(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      connectedTime?: string(name='ConnectedTime'),
      creationTime?: string(name='CreationTime'),
      crossBorder?: boolean(name='CrossBorder'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      hasReservationData?: string(name='HasReservationData'),
      hcRate?: int32(name='HcRate'),
      hcThreshold?: int32(name='HcThreshold'),
      healthCheckSourceIp?: string(name='HealthCheckSourceIp'),
      healthCheckTargetIp?: string(name='HealthCheckTargetIp'),
      ipv6Status?: string(name='Ipv6Status'),
      name?: string(name='Name'),
      oppositeAccessPointId?: string(name='OppositeAccessPointId'),
      oppositeBandwidth?: int32(name='OppositeBandwidth'),
      oppositeInterfaceBusinessStatus?: string(name='OppositeInterfaceBusinessStatus'),
      oppositeInterfaceId?: string(name='OppositeInterfaceId'),
      oppositeInterfaceOwnerId?: string(name='OppositeInterfaceOwnerId'),
      oppositeInterfaceSpec?: string(name='OppositeInterfaceSpec'),
      oppositeInterfaceStatus?: string(name='OppositeInterfaceStatus'),
      oppositeRegionId?: string(name='OppositeRegionId'),
      oppositeRouterId?: string(name='OppositeRouterId'),
      oppositeRouterType?: string(name='OppositeRouterType'),
      oppositeVpcInstanceId?: string(name='OppositeVpcInstanceId'),
      reservationActiveTime?: string(name='ReservationActiveTime'),
      reservationBandwidth?: string(name='ReservationBandwidth'),
      reservationInternetChargeType?: string(name='ReservationInternetChargeType'),
      reservationOrderType?: string(name='ReservationOrderType'),
      role?: string(name='Role'),
      routerId?: string(name='RouterId'),
      routerInterfaceId?: string(name='RouterInterfaceId'),
      routerType?: string(name='RouterType'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      vpcInstanceId?: string(name='VpcInstanceId'),
    }
  ](name='RouterInterfaceType')
  }(name='RouterInterfaceSet'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRouterInterfacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRouterInterfacesResponseBody(name='body'),
}

async function describeRouterInterfaces(request: DescribeRouterInterfacesRequest): DescribeRouterInterfacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRouterInterfaces', 'POST', '/', 'json', false, 'json', request);
}

model DescribeServerRelatedGlobalAccelerationInstancesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serverId: string(name='ServerId', position='Query'),
  serverType?: string(name='ServerType', position='Query'),
}

model DescribeServerRelatedGlobalAccelerationInstancesResponseBody = {
  globalAccelerationInstances?: {
    globalAccelerationInstance?: [ 
    {
      globalAccelerationInstanceId?: string(name='GlobalAccelerationInstanceId'),
      ipAddress?: string(name='IpAddress'),
      regionId?: string(name='RegionId'),
      serverIpAddress?: string(name='ServerIpAddress'),
    }
  ](name='GlobalAccelerationInstance')
  }(name='GlobalAccelerationInstances'),
  requestId?: string(name='RequestId'),
}

model DescribeServerRelatedGlobalAccelerationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServerRelatedGlobalAccelerationInstancesResponseBody(name='body'),
}

async function describeServerRelatedGlobalAccelerationInstances(request: DescribeServerRelatedGlobalAccelerationInstancesRequest): DescribeServerRelatedGlobalAccelerationInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServerRelatedGlobalAccelerationInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnatTableEntriesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snatEntryId?: string(name='SnatEntryId', position='Query'),
  snatEntryName?: string(name='SnatEntryName', position='Query'),
  snatIp?: string(name='SnatIp', position='Query'),
  snatTableId: string(name='SnatTableId', position='Query'),
  sourceCIDR?: string(name='SourceCIDR', position='Query'),
  sourceVSwitchId?: string(name='SourceVSwitchId', position='Query'),
}

model DescribeSnatTableEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  snatTableEntries?: {
    snatTableEntry?: [ 
    {
      snatEntryId?: string(name='SnatEntryId'),
      snatEntryName?: string(name='SnatEntryName'),
      snatIp?: string(name='SnatIp'),
      snatTableId?: string(name='SnatTableId'),
      sourceCIDR?: string(name='SourceCIDR'),
      sourceVSwitchId?: string(name='SourceVSwitchId'),
      status?: string(name='Status'),
    }
  ](name='SnatTableEntry')
  }(name='SnatTableEntries'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSnatTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnatTableEntriesResponseBody(name='body'),
}

async function describeSnatTableEntries(request: DescribeSnatTableEntriesRequest): DescribeSnatTableEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnatTableEntries', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSslVpnClientCertRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslVpnClientCertId: string(name='SslVpnClientCertId', position='Query'),
}

model DescribeSslVpnClientCertResponseBody = {
  caCert?: string(name='CaCert'),
  clientCert?: string(name='ClientCert'),
  clientConfig?: string(name='ClientConfig'),
  clientKey?: string(name='ClientKey'),
  createTime?: long(name='CreateTime'),
  endTime?: long(name='EndTime'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  status?: string(name='Status'),
}

model DescribeSslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSslVpnClientCertResponseBody(name='body'),
}

async function describeSslVpnClientCert(request: DescribeSslVpnClientCertRequest): DescribeSslVpnClientCertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSslVpnClientCert', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSslVpnClientCertsRequest {
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId', position='Query'),
  sslVpnServerId?: string(name='SslVpnServerId', position='Query'),
}

model DescribeSslVpnClientCertsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertKeys?: {
    sslVpnClientCertKey?: [ 
    {
      createTime?: long(name='CreateTime'),
      endTime?: long(name='EndTime'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      sslVpnClientCertId?: string(name='SslVpnClientCertId'),
      sslVpnServerId?: string(name='SslVpnServerId'),
      status?: string(name='Status'),
    }
  ](name='SslVpnClientCertKey')
  }(name='SslVpnClientCertKeys'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSslVpnClientCertsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSslVpnClientCertsResponseBody(name='body'),
}

async function describeSslVpnClientCerts(request: DescribeSslVpnClientCertsRequest): DescribeSslVpnClientCertsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSslVpnClientCerts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSslVpnServersRequest {
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslVpnServerId?: string(name='SslVpnServerId', position='Query'),
  vpnGatewayId?: string(name='VpnGatewayId', position='Query'),
}

model DescribeSslVpnServersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  sslVpnServers?: {
    sslVpnServer?: [ 
    {
      cipher?: string(name='Cipher'),
      clientIpPool?: string(name='ClientIpPool'),
      compress?: boolean(name='Compress'),
      connections?: int32(name='Connections'),
      createTime?: long(name='CreateTime'),
      enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
      iDaaSInstanceId?: string(name='IDaaSInstanceId'),
      iDaaSRegionId?: string(name='IDaaSRegionId'),
      internetIp?: string(name='InternetIp'),
      localSubnet?: string(name='LocalSubnet'),
      maxConnections?: int32(name='MaxConnections'),
      name?: string(name='Name'),
      port?: int32(name='Port'),
      proto?: string(name='Proto'),
      regionId?: string(name='RegionId'),
      sslVpnServerId?: string(name='SslVpnServerId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='SslVpnServer')
  }(name='SslVpnServers'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSslVpnServersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSslVpnServersResponseBody(name='body'),
}

async function describeSslVpnServers(request: DescribeSslVpnServersRequest): DescribeSslVpnServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSslVpnServers', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVRoutersRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vRouterId?: string(name='VRouterId', position='Query'),
}

model DescribeVRoutersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vRouters?: {
    vRouter?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      routeTableIds?: {
        routeTableId?: [ string ](name='RouteTableId')
      }(name='RouteTableIds'),
      vRouterId?: string(name='VRouterId'),
      vRouterName?: string(name='VRouterName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='VRouter')
  }(name='VRouters'),
}

model DescribeVRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVRoutersResponseBody(name='body'),
}

async function describeVRouters(request: DescribeVRoutersRequest): DescribeVRoutersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVRouters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVSwitchAttributesRequest {
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model DescribeVSwitchAttributesResponseBody = {
  availableIpAddressCount?: long(name='AvailableIpAddressCount'),
  cidrBlock?: string(name='CidrBlock'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  isDefault?: boolean(name='IsDefault'),
  networkAclId?: string(name='NetworkAclId'),
  ownerId?: long(name='OwnerId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  routeTable?: {
    routeTableId?: string(name='RouteTableId'),
    routeTableType?: string(name='RouteTableType'),
  }(name='RouteTable'),
  status?: string(name='Status'),
  vSwitchId?: string(name='VSwitchId'),
  vSwitchName?: string(name='VSwitchName'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeVSwitchAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchAttributesResponseBody(name='body'),
}

async function describeVSwitchAttributes(request: DescribeVSwitchAttributesRequest): DescribeVSwitchAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVSwitchAttributes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVSwitchesRequest {
  dryRun?: boolean(name='DryRun', position='Query'),
  isDefault?: boolean(name='IsDefault', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId?: string(name='RouteTableId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vSwitchName?: string(name='VSwitchName', position='Query'),
  vSwitchOwnerId?: long(name='VSwitchOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vSwitches?: {
    vSwitch?: [ 
    {
      availableIpAddressCount?: long(name='AvailableIpAddressCount'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      isDefault?: boolean(name='IsDefault'),
      networkAclId?: string(name='NetworkAclId'),
      ownerId?: long(name='OwnerId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routeTable?: {
        routeTableId?: string(name='RouteTableId'),
        routeTableType?: string(name='RouteTableType'),
      }(name='RouteTable'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='VSwitch')
  }(name='VSwitches'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVSwitches', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVbrHaRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vbrHaId?: string(name='VbrHaId', position='Query'),
  vbrId?: string(name='VbrId', position='Query'),
}

model DescribeVbrHaResponseBody = {
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  peerVbrId?: string(name='PeerVbrId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  vbrHaId?: string(name='VbrHaId'),
  vbrId?: string(name='VbrId'),
}

model DescribeVbrHaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVbrHaResponseBody(name='body'),
}

async function describeVbrHa(request: DescribeVbrHaRequest): DescribeVbrHaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVbrHa', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVcoRouteEntriesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeEntryType?: string(name='RouteEntryType', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
}

model DescribeVcoRouteEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vcoRouteEntries?: [ 
    {
      asPath?: string(name='AsPath'),
      community?: string(name='Community'),
      createTime?: long(name='CreateTime'),
      nextHop?: string(name='NextHop'),
      routeDest?: string(name='RouteDest'),
      routeEntryType?: string(name='RouteEntryType'),
      source?: string(name='Source'),
      state?: string(name='State'),
      vpnConnectionId?: string(name='VpnConnectionId'),
      weight?: int32(name='Weight'),
    }
  ](name='VcoRouteEntries'),
}

model DescribeVcoRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVcoRouteEntriesResponseBody(name='body'),
}

async function describeVcoRouteEntries(request: DescribeVcoRouteEntriesRequest): DescribeVcoRouteEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVcoRouteEntries', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVirtualBorderRoutersRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeVirtualBorderRoutersResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterSet?: {
    virtualBorderRouterType?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      activationTime?: string(name='ActivationTime'),
      associatedCens?: {
        associatedCen?: [ 
        {
          cenId?: string(name='CenId'),
          cenOwnerId?: long(name='CenOwnerId'),
          cenStatus?: string(name='CenStatus'),
        }
      ](name='AssociatedCen')
      }(name='AssociatedCens'),
      associatedPhysicalConnections?: {
        associatedPhysicalConnection?: [ 
        {
          circuitCode?: string(name='CircuitCode'),
          enableIpv6?: boolean(name='EnableIpv6'),
          localGatewayIp?: string(name='LocalGatewayIp'),
          localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
          peerGatewayIp?: string(name='PeerGatewayIp'),
          peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
          peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
          peeringSubnetMask?: string(name='PeeringSubnetMask'),
          physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
          physicalConnectionId?: string(name='PhysicalConnectionId'),
          physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
          physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
          status?: string(name='Status'),
          vlanId?: string(name='VlanId'),
          vlanInterfaceId?: string(name='VlanInterfaceId'),
        }
      ](name='AssociatedPhysicalConnection')
      }(name='AssociatedPhysicalConnections'),
      circuitCode?: string(name='CircuitCode'),
      cloudBoxInstanceId?: string(name='CloudBoxInstanceId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      detectMultiplier?: long(name='DetectMultiplier'),
      eccId?: string(name='EccId'),
      enableIpv6?: boolean(name='EnableIpv6'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
      minRxInterval?: long(name='MinRxInterval'),
      minTxInterval?: long(name='MinTxInterval'),
      name?: string(name='Name'),
      pConnVbrChargeType?: string(name='PConnVbrChargeType'),
      pConnVbrExpireTime?: string(name='PConnVbrExpireTime'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
      peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      physicalConnectionBusinessStatus?: string(name='PhysicalConnectionBusinessStatus'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      physicalConnectionOwnerUid?: string(name='PhysicalConnectionOwnerUid'),
      physicalConnectionStatus?: string(name='PhysicalConnectionStatus'),
      recoveryTime?: string(name='RecoveryTime'),
      routeTableId?: string(name='RouteTableId'),
      status?: string(name='Status'),
      terminationTime?: string(name='TerminationTime'),
      type?: string(name='Type'),
      vbrId?: string(name='VbrId'),
      vlanId?: int32(name='VlanId'),
      vlanInterfaceId?: string(name='VlanInterfaceId'),
    }
  ](name='VirtualBorderRouterType')
  }(name='VirtualBorderRouterSet'),
}

model DescribeVirtualBorderRoutersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersResponseBody(name='body'),
}

async function describeVirtualBorderRouters(request: DescribeVirtualBorderRoutersRequest): DescribeVirtualBorderRoutersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVirtualBorderRouters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVirtualBorderRoutersForPhysicalConnectionRequest {
  filter?: [ 
    {
      key?: string(name='Key'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualBorderRouterForPhysicalConnectionSet?: {
    virtualBorderRouterForPhysicalConnectionType?: [ 
    {
      activationTime?: string(name='ActivationTime'),
      bandwidth?: string(name='Bandwidth'),
      bandwidthStatus?: string(name='BandwidthStatus'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      eccId?: string(name='EccId'),
      enableIpv6?: boolean(name='EnableIpv6'),
      localGatewayIp?: string(name='LocalGatewayIp'),
      localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp'),
      pConnVbrBussinessStatus?: string(name='PConnVbrBussinessStatus'),
      pConnVbrChargeType?: string(name='PConnVbrChargeType'),
      pConnVbrExpireTime?: string(name='PConnVbrExpireTime'),
      peerGatewayIp?: string(name='PeerGatewayIp'),
      peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp'),
      peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask'),
      peeringSubnetMask?: string(name='PeeringSubnetMask'),
      recoveryTime?: string(name='RecoveryTime'),
      status?: string(name='Status'),
      terminationTime?: string(name='TerminationTime'),
      type?: string(name='Type'),
      vbrId?: string(name='VbrId'),
      vbrOwnerUid?: long(name='VbrOwnerUid'),
      vlanId?: int32(name='VlanId'),
    }
  ](name='VirtualBorderRouterForPhysicalConnectionType')
  }(name='VirtualBorderRouterForPhysicalConnectionSet'),
}

model DescribeVirtualBorderRoutersForPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody(name='body'),
}

async function describeVirtualBorderRoutersForPhysicalConnection(request: DescribeVirtualBorderRoutersForPhysicalConnectionRequest): DescribeVirtualBorderRoutersForPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVirtualBorderRoutersForPhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpcAttributeRequest {
  dryRun?: boolean(name='DryRun', position='Query'),
  isDefault?: boolean(name='IsDefault', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model DescribeVpcAttributeResponseBody = {
  associatedCens?: {
    associatedCen?: [ 
    {
      cenId?: string(name='CenId'),
      cenOwnerId?: long(name='CenOwnerId'),
      cenStatus?: string(name='CenStatus'),
    }
  ](name='AssociatedCen')
  }(name='AssociatedCens'),
  cidrBlock?: string(name='CidrBlock'),
  classicLinkEnabled?: boolean(name='ClassicLinkEnabled'),
  cloudResources?: {
    cloudResourceSetType?: [ 
    {
      resourceCount?: int32(name='ResourceCount'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='CloudResourceSetType')
  }(name='CloudResources'),
  creationTime?: string(name='CreationTime'),
  description?: string(name='Description'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dhcpOptionsSetStatus?: string(name='DhcpOptionsSetStatus'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
  ipv6CidrBlocks?: {
    ipv6CidrBlock?: [ 
    {
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      ipv6Isp?: string(name='Ipv6Isp'),
    }
  ](name='Ipv6CidrBlock')
  }(name='Ipv6CidrBlocks'),
  isDefault?: boolean(name='IsDefault'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  secondaryCidrBlocks?: {
    secondaryCidrBlock?: [ string ](name='SecondaryCidrBlock')
  }(name='SecondaryCidrBlocks'),
  status?: string(name='Status'),
  supportIpv4Gateway?: boolean(name='SupportIpv4Gateway'),
  userCidrs?: {
    userCidr?: [ string ](name='UserCidr')
  }(name='UserCidrs'),
  vRouterId?: string(name='VRouterId'),
  vSwitchIds?: {
    vSwitchId?: [ string ](name='VSwitchId')
  }(name='VSwitchIds'),
  vpcId?: string(name='VpcId'),
  vpcName?: string(name='VpcName'),
}

model DescribeVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcAttributeResponseBody(name='body'),
}

async function describeVpcAttribute(request: DescribeVpcAttributeRequest): DescribeVpcAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpcAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpcsRequest {
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  isDefault?: boolean(name='IsDefault', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  vpcName?: string(name='VpcName', position='Query'),
  vpcOwnerId?: long(name='VpcOwnerId', position='Query'),
}

model DescribeVpcsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpcs?: {
    vpc?: [ 
    {
      cenStatus?: string(name='CenStatus'),
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
      dhcpOptionsSetStatus?: string(name='DhcpOptionsSetStatus'),
      ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
      ipv6CidrBlocks?: {
        ipv6CidrBlock?: [ 
        {
          ipv6CidrBlock?: string(name='Ipv6CidrBlock'),
          ipv6Isp?: string(name='Ipv6Isp'),
        }
      ](name='Ipv6CidrBlock')
      }(name='Ipv6CidrBlocks'),
      isDefault?: boolean(name='IsDefault'),
      natGatewayIds?: {
        natGatewayIds?: [ string ](name='NatGatewayIds')
      }(name='NatGatewayIds'),
      ownerId?: long(name='OwnerId'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      routerTableIds?: {
        routerTableIds?: [ string ](name='RouterTableIds')
      }(name='RouterTableIds'),
      secondaryCidrBlocks?: {
        secondaryCidrBlock?: [ string ](name='SecondaryCidrBlock')
      }(name='SecondaryCidrBlocks'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      userCidrs?: {
        userCidr?: [ string ](name='UserCidr')
      }(name='UserCidrs'),
      vRouterId?: string(name='VRouterId'),
      vSwitchIds?: {
        vSwitchId?: [ string ](name='VSwitchId')
      }(name='VSwitchIds'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
    }
  ](name='Vpc')
  }(name='Vpcs'),
}

model DescribeVpcsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpcsResponseBody(name='body'),
}

async function describeVpcs(request: DescribeVpcsRequest): DescribeVpcsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpcs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpnAttachmentsRequest {
  attachType?: string(name='AttachType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnConnectionId?: string(name='VpnConnectionId', position='Query'),
}

model DescribeVpnAttachmentsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
  vpnAttachments?: [ 
    {
      attachType?: string(name='AttachType'),
      crossAccountAuthorized?: boolean(name='CrossAccountAuthorized'),
      description?: string(name='Description'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      transitRouterId?: string(name='TransitRouterId'),
      transitRouterName?: string(name='TransitRouterName'),
    }
  ](name='VpnAttachments'),
}

model DescribeVpnAttachmentsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnAttachmentsResponseBody(name='body'),
}

async function describeVpnAttachments(request: DescribeVpnAttachmentsRequest): DescribeVpnAttachmentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpnAttachments', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpnConnectionRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
}

model DescribeVpnConnectionResponseBody = {
  attachInstanceId?: string(name='AttachInstanceId'),
  attachType?: string(name='AttachType'),
  createTime?: long(name='CreateTime'),
  crossAccountAuthorized?: boolean(name='CrossAccountAuthorized'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  ikeConfig?: {
    ikeAuthAlg?: string(name='IkeAuthAlg'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeMode?: string(name='IkeMode'),
    ikePfs?: string(name='IkePfs'),
    ikeVersion?: string(name='IkeVersion'),
    localId?: string(name='LocalId'),
    psk?: string(name='Psk'),
    remoteId?: string(name='RemoteId'),
  }(name='IkeConfig'),
  internetIp?: string(name='InternetIp'),
  ipsecConfig?: {
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecPfs?: string(name='IpsecPfs'),
  }(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
  remoteCaCertificate?: string(name='RemoteCaCertificate'),
  remoteSubnet?: string(name='RemoteSubnet'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  state?: string(name='State'),
  status?: string(name='Status'),
  transitRouterId?: string(name='TransitRouterId'),
  transitRouterName?: string(name='TransitRouterName'),
  vcoHealthCheck?: {
    dip?: string(name='Dip'),
    enable?: string(name='Enable'),
    interval?: int32(name='Interval'),
    policy?: string(name='Policy'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
    status?: string(name='Status'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig?: {
    authKey?: string(name='AuthKey'),
    enableBgp?: string(name='EnableBgp'),
    localAsn?: long(name='LocalAsn'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: long(name='PeerAsn'),
    peerBgpIp?: string(name='PeerBgpIp'),
    status?: string(name='Status'),
    tunnelCidr?: string(name='TunnelCidr'),
  }(name='VpnBgpConfig'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  zoneNo?: string(name='ZoneNo'),
}

model DescribeVpnConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnConnectionResponseBody(name='body'),
}

async function describeVpnConnection(request: DescribeVpnConnectionRequest): DescribeVpnConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpnConnection', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpnConnectionsRequest {
  customerGatewayId?: string(name='CustomerGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnConnectionId?: string(name='VpnConnectionId', position='Query'),
  vpnGatewayId?: string(name='VpnGatewayId', position='Query'),
}

model DescribeVpnConnectionsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnConnections?: {
    vpnConnection?: [ 
    {
      attachInstanceId?: string(name='AttachInstanceId'),
      attachType?: string(name='AttachType'),
      createTime?: long(name='CreateTime'),
      crossAccountAuthorized?: boolean(name='CrossAccountAuthorized'),
      customerGatewayId?: string(name='CustomerGatewayId'),
      effectImmediately?: boolean(name='EffectImmediately'),
      enableDpd?: boolean(name='EnableDpd'),
      enableNatTraversal?: boolean(name='EnableNatTraversal'),
      ikeConfig?: {
        ikeAuthAlg?: string(name='IkeAuthAlg'),
        ikeEncAlg?: string(name='IkeEncAlg'),
        ikeLifetime?: long(name='IkeLifetime'),
        ikeMode?: string(name='IkeMode'),
        ikePfs?: string(name='IkePfs'),
        ikeVersion?: string(name='IkeVersion'),
        localId?: string(name='LocalId'),
        psk?: string(name='Psk'),
        remoteId?: string(name='RemoteId'),
      }(name='IkeConfig'),
      ipsecConfig?: {
        ipsecAuthAlg?: string(name='IpsecAuthAlg'),
        ipsecEncAlg?: string(name='IpsecEncAlg'),
        ipsecLifetime?: long(name='IpsecLifetime'),
        ipsecPfs?: string(name='IpsecPfs'),
      }(name='IpsecConfig'),
      localSubnet?: string(name='LocalSubnet'),
      name?: string(name='Name'),
      networkType?: string(name='NetworkType'),
      remoteCaCertificate?: string(name='RemoteCaCertificate'),
      remoteSubnet?: string(name='RemoteSubnet'),
      spec?: string(name='Spec'),
      state?: string(name='State'),
      status?: string(name='Status'),
      transitRouterId?: string(name='TransitRouterId'),
      transitRouterName?: string(name='TransitRouterName'),
      vcoHealthCheck?: {
        dip?: string(name='Dip'),
        enable?: string(name='Enable'),
        interval?: int32(name='Interval'),
        policy?: string(name='Policy'),
        retry?: int32(name='Retry'),
        sip?: string(name='Sip'),
        status?: string(name='Status'),
      }(name='VcoHealthCheck'),
      vpnBgpConfig?: {
        authKey?: string(name='AuthKey'),
        localAsn?: long(name='LocalAsn'),
        localBgpIp?: string(name='LocalBgpIp'),
        peerAsn?: long(name='PeerAsn'),
        peerBgpIp?: string(name='PeerBgpIp'),
        status?: string(name='Status'),
        tunnelCidr?: string(name='TunnelCidr'),
      }(name='VpnBgpConfig'),
      vpnConnectionId?: string(name='VpnConnectionId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='VpnConnection')
  }(name='VpnConnections'),
}

model DescribeVpnConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnConnectionsResponseBody(name='body'),
}

async function describeVpnConnections(request: DescribeVpnConnectionsRequest): DescribeVpnConnectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpnConnections', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpnCrossAccountAuthorizationsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
}

model DescribeVpnCrossAccountAuthorizationsResponseBody = {
  crossAccountAuthorizations?: [ 
    {
      aliUid?: long(name='AliUid'),
      bindInstance?: string(name='BindInstance'),
      bindProduct?: string(name='BindProduct'),
      bindUid?: long(name='BindUid'),
      creationTime?: long(name='CreationTime'),
      vpnConnectionId?: string(name='VpnConnectionId'),
    }
  ](name='CrossAccountAuthorizations'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeVpnCrossAccountAuthorizationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnCrossAccountAuthorizationsResponseBody(name='body'),
}

async function describeVpnCrossAccountAuthorizations(request: DescribeVpnCrossAccountAuthorizationsRequest): DescribeVpnCrossAccountAuthorizationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpnCrossAccountAuthorizations', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpnGatewayRequest {
  includeReservationData?: boolean(name='IncludeReservationData', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model DescribeVpnGatewayResponseBody = {
  autoPropagate?: boolean(name='AutoPropagate'),
  businessStatus?: string(name='BusinessStatus'),
  chargeType?: string(name='ChargeType'),
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  enableBgp?: boolean(name='EnableBgp'),
  endTime?: long(name='EndTime'),
  internetIp?: string(name='InternetIp'),
  ipsecVpn?: string(name='IpsecVpn'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  reservationData?: {
    reservationEndTime?: string(name='ReservationEndTime'),
    reservationIpsec?: string(name='ReservationIpsec'),
    reservationMaxConnections?: int32(name='ReservationMaxConnections'),
    reservationOrderType?: string(name='ReservationOrderType'),
    reservationSpec?: string(name='ReservationSpec'),
    reservationSsl?: string(name='ReservationSsl'),
    status?: string(name='Status'),
  }(name='ReservationData'),
  spec?: string(name='Spec'),
  sslMaxConnections?: long(name='SslMaxConnections'),
  sslVpn?: string(name='SslVpn'),
  status?: string(name='Status'),
  tag?: string(name='Tag'),
  tags?: {
    tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
  vpnType?: string(name='VpnType'),
}

model DescribeVpnGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnGatewayResponseBody(name='body'),
}

async function describeVpnGateway(request: DescribeVpnGatewayRequest): DescribeVpnGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpnGateway', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpnGatewaysRequest {
  businessStatus?: string(name='BusinessStatus', position='Query'),
  includeReservationData?: boolean(name='IncludeReservationData', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  vpnGatewayId?: string(name='VpnGatewayId', position='Query'),
}

model DescribeVpnGatewaysResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnGateways?: {
    vpnGateway?: [ 
    {
      autoPropagate?: boolean(name='AutoPropagate'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      enableBgp?: boolean(name='EnableBgp'),
      endTime?: long(name='EndTime'),
      internetIp?: string(name='InternetIp'),
      ipsecVpn?: string(name='IpsecVpn'),
      name?: string(name='Name'),
      networkType?: string(name='NetworkType'),
      reservationData?: {
        reservationEndTime?: string(name='ReservationEndTime'),
        reservationIpsec?: string(name='ReservationIpsec'),
        reservationMaxConnections?: int32(name='ReservationMaxConnections'),
        reservationOrderType?: string(name='ReservationOrderType'),
        reservationSpec?: string(name='ReservationSpec'),
        reservationSsl?: string(name='ReservationSsl'),
        status?: string(name='Status'),
      }(name='ReservationData'),
      spec?: string(name='Spec'),
      sslMaxConnections?: long(name='SslMaxConnections'),
      sslVpn?: string(name='SslVpn'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
      vpnType?: string(name='VpnType'),
    }
  ](name='VpnGateway')
  }(name='VpnGateways'),
}

model DescribeVpnGatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnGatewaysResponseBody(name='body'),
}

async function describeVpnGateways(request: DescribeVpnGatewaysRequest): DescribeVpnGatewaysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpnGateways', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpnPbrRouteEntriesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model DescribeVpnPbrRouteEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnPbrRouteEntries?: {
    vpnPbrRouteEntry?: [ 
    {
      createTime?: long(name='CreateTime'),
      nextHop?: string(name='NextHop'),
      routeDest?: string(name='RouteDest'),
      routeSource?: string(name='RouteSource'),
      state?: string(name='State'),
      vpnInstanceId?: string(name='VpnInstanceId'),
      weight?: int32(name='Weight'),
    }
  ](name='VpnPbrRouteEntry')
  }(name='VpnPbrRouteEntries'),
}

model DescribeVpnPbrRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnPbrRouteEntriesResponseBody(name='body'),
}

async function describeVpnPbrRouteEntries(request: DescribeVpnPbrRouteEntriesRequest): DescribeVpnPbrRouteEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpnPbrRouteEntries', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpnRouteEntriesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeEntryType?: string(name='RouteEntryType', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model DescribeVpnRouteEntriesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnRouteEntries?: {
    vpnRouteEntry?: [ 
    {
      asPath?: string(name='AsPath'),
      community?: string(name='Community'),
      createTime?: long(name='CreateTime'),
      nextHop?: string(name='NextHop'),
      routeDest?: string(name='RouteDest'),
      routeEntryType?: string(name='RouteEntryType'),
      source?: string(name='Source'),
      state?: string(name='State'),
      vpnInstanceId?: string(name='VpnInstanceId'),
      weight?: int32(name='Weight'),
    }
  ](name='VpnRouteEntry')
  }(name='VpnRouteEntries'),
}

model DescribeVpnRouteEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnRouteEntriesResponseBody(name='body'),
}

async function describeVpnRouteEntries(request: DescribeVpnRouteEntriesRequest): DescribeVpnRouteEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpnRouteEntries', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVpnSslServerLogsRequest {
  from?: int32(name='From', position='Query'),
  minutePeriod?: int32(name='MinutePeriod', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId', position='Query'),
  to?: int32(name='To', position='Query'),
  vpnSslServerId: string(name='VpnSslServerId', position='Query'),
}

model DescribeVpnSslServerLogsResponseBody = {
  count?: int32(name='Count'),
  data?: {
    logs?: [ string ](name='Logs')
  }(name='Data'),
  isCompleted?: boolean(name='IsCompleted'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
}

model DescribeVpnSslServerLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVpnSslServerLogsResponseBody(name='body'),
}

async function describeVpnSslServerLogs(request: DescribeVpnSslServerLogsRequest): DescribeVpnSslServerLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVpnSslServerLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneType?: string(name='ZoneType', position='Query'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
      zoneType?: string(name='ZoneType'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeZones', 'POST', '/', 'json', false, 'json', request);
}

model DetachDhcpOptionsSetFromVpcRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model DetachDhcpOptionsSetFromVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachDhcpOptionsSetFromVpcResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDhcpOptionsSetFromVpcResponseBody(name='body'),
}

async function detachDhcpOptionsSetFromVpc(request: DetachDhcpOptionsSetFromVpcRequest): DetachDhcpOptionsSetFromVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachDhcpOptionsSetFromVpc', 'POST', '/', 'json', false, 'json', request);
}

model DisableNatGatewayEcsMetricRequest {
  dryRun?: boolean(name='DryRun', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DisableNatGatewayEcsMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  body: DisableNatGatewayEcsMetricResponseBody(name='body'),
}

async function disableNatGatewayEcsMetric(request: DisableNatGatewayEcsMetricRequest): DisableNatGatewayEcsMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableNatGatewayEcsMetric', 'POST', '/', 'json', false, 'json', request);
}

model DisableVpcClassicLinkRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model DisableVpcClassicLinkResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableVpcClassicLinkResponse = {
  headers: map[string]string(name='headers'),
  body: DisableVpcClassicLinkResponseBody(name='body'),
}

async function disableVpcClassicLink(request: DisableVpcClassicLinkRequest): DisableVpcClassicLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableVpcClassicLink', 'POST', '/', 'json', false, 'json', request);
}

model DissociateRouteTableFromGatewayRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  gatewayId: string(name='GatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
}

model DissociateRouteTableFromGatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateRouteTableFromGatewayResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateRouteTableFromGatewayResponseBody(name='body'),
}

async function dissociateRouteTableFromGateway(request: DissociateRouteTableFromGatewayRequest): DissociateRouteTableFromGatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DissociateRouteTableFromGateway', 'POST', '/', 'json', false, 'json', request);
}

model DissociateRouteTablesFromVpcGatewayEndpointRequest {
  clientToken?: string(name='ClientToken', description='幂等参数', position='Query'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求', position='Query'),
  endpointId: string(name='EndpointId', description='VPC网关实例ID', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableIds: [ string ](name='RouteTableIds', description='路由表列表', position='Query'),
}

model DissociateRouteTablesFromVpcGatewayEndpointResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DissociateRouteTablesFromVpcGatewayEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateRouteTablesFromVpcGatewayEndpointResponseBody(name='body'),
}

async function dissociateRouteTablesFromVpcGatewayEndpoint(request: DissociateRouteTablesFromVpcGatewayEndpointRequest): DissociateRouteTablesFromVpcGatewayEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DissociateRouteTablesFromVpcGatewayEndpoint', 'POST', '/', 'json', false, 'json', request);
}

model DissociateVpnGatewayWithCertificateRequest {
  certificateId: string(name='CertificateId', position='Query'),
  certificateType: string(name='CertificateType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model DissociateVpnGatewayWithCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateVpnGatewayWithCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateVpnGatewayWithCertificateResponseBody(name='body'),
}

async function dissociateVpnGatewayWithCertificate(request: DissociateVpnGatewayWithCertificateRequest): DissociateVpnGatewayWithCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DissociateVpnGatewayWithCertificate', 'POST', '/', 'json', false, 'json', request);
}

model DownloadVpnConnectionConfigRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
}

model DownloadVpnConnectionConfigResponseBody = {
  requestId?: string(name='RequestId'),
  vpnConnectionConfig?: {
    ikeConfig?: {
      ikeAuthAlg?: string(name='IkeAuthAlg'),
      ikeEncAlg?: string(name='IkeEncAlg'),
      ikeLifetime?: long(name='IkeLifetime'),
      ikeMode?: string(name='IkeMode'),
      ikePfs?: string(name='IkePfs'),
      ikeVersion?: string(name='IkeVersion'),
      localId?: string(name='LocalId'),
      psk?: string(name='Psk'),
      remoteId?: string(name='RemoteId'),
    }(name='IkeConfig'),
    ipsecConfig?: {
      ipsecAuthAlg?: string(name='IpsecAuthAlg'),
      ipsecEncAlg?: string(name='IpsecEncAlg'),
      ipsecLifetime?: long(name='IpsecLifetime'),
      ipsecPfs?: string(name='IpsecPfs'),
    }(name='IpsecConfig'),
    local?: string(name='Local'),
    localSubnet?: string(name='LocalSubnet'),
    remote?: string(name='Remote'),
    remoteSubnet?: string(name='RemoteSubnet'),
  }(name='VpnConnectionConfig'),
}

model DownloadVpnConnectionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DownloadVpnConnectionConfigResponseBody(name='body'),
}

async function downloadVpnConnectionConfig(request: DownloadVpnConnectionConfigRequest): DownloadVpnConnectionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DownloadVpnConnectionConfig', 'POST', '/', 'json', false, 'json', request);
}

model EnableNatGatewayEcsMetricRequest {
  dryRun?: boolean(name='DryRun', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model EnableNatGatewayEcsMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableNatGatewayEcsMetricResponse = {
  headers: map[string]string(name='headers'),
  body: EnableNatGatewayEcsMetricResponseBody(name='body'),
}

async function enableNatGatewayEcsMetric(request: EnableNatGatewayEcsMetricRequest): EnableNatGatewayEcsMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableNatGatewayEcsMetric', 'POST', '/', 'json', false, 'json', request);
}

model EnablePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model EnablePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnablePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: EnablePhysicalConnectionResponseBody(name='body'),
}

async function enablePhysicalConnection(request: EnablePhysicalConnectionRequest): EnablePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnablePhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model EnableVpcClassicLinkRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model EnableVpcClassicLinkResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableVpcClassicLinkResponse = {
  headers: map[string]string(name='headers'),
  body: EnableVpcClassicLinkResponseBody(name='body'),
}

async function enableVpcClassicLink(request: EnableVpcClassicLinkRequest): EnableVpcClassicLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableVpcClassicLink', 'POST', '/', 'json', false, 'json', request);
}

model EnableVpcIpv4GatewayRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ipv4GatewayId: string(name='Ipv4GatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableList?: [ string ](name='RouteTableList', position='Query'),
}

model EnableVpcIpv4GatewayResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableVpcIpv4GatewayResponse = {
  headers: map[string]string(name='headers'),
  body: EnableVpcIpv4GatewayResponseBody(name='body'),
}

async function enableVpcIpv4Gateway(request: EnableVpcIpv4GatewayRequest): EnableVpcIpv4GatewayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableVpcIpv4Gateway', 'POST', '/', 'json', false, 'json', request);
}

model GetDhcpOptionsSetRequest {
  dhcpOptionsSetId: string(name='DhcpOptionsSetId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetDhcpOptionsSetResponseBody = {
  associateVpcs?: [ 
    {
      associateStatus?: string(name='AssociateStatus'),
      vpcId?: string(name='VpcId'),
    }
  ](name='AssociateVpcs'),
  dhcpOptions?: {
    bootFileName?: string(name='BootFileName'),
    domainName?: string(name='DomainName'),
    domainNameServers?: string(name='DomainNameServers'),
    ipv6LeaseTime?: string(name='Ipv6LeaseTime'),
    leaseTime?: string(name='LeaseTime'),
    TFTPServerName?: string(name='TFTPServerName'),
  }(name='DhcpOptions'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
  dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
  ownerId?: long(name='OwnerId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: GetDhcpOptionsSetResponseBody(name='body'),
}

async function getDhcpOptionsSet(request: GetDhcpOptionsSetRequest): GetDhcpOptionsSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDhcpOptionsSet', 'POST', '/', 'json', false, 'json', request);
}

model GetIpv4GatewayAttributeRequest {
  ipv4GatewayId: string(name='Ipv4GatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetIpv4GatewayAttributeResponseBody = {
  createTime?: string(name='CreateTime'),
  enabled?: boolean(name='Enabled'),
  ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
  ipv4GatewayId?: string(name='Ipv4GatewayId'),
  ipv4GatewayName?: string(name='Ipv4GatewayName'),
  ipv4GatewayRouteTableId?: string(name='Ipv4GatewayRouteTableId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
}

model GetIpv4GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetIpv4GatewayAttributeResponseBody(name='body'),
}

async function getIpv4GatewayAttribute(request: GetIpv4GatewayAttributeRequest): GetIpv4GatewayAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetIpv4GatewayAttribute', 'POST', '/', 'json', false, 'json', request);
}

model GetNatGatewayAttributeRequest {
  natGatewayId: string(name='NatGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetNatGatewayAttributeResponseBody = {
  billingConfig?: {
    autoPay?: string(name='AutoPay'),
    instanceChargeType?: string(name='InstanceChargeType'),
    internetChargeType?: string(name='InternetChargeType'),
    spec?: string(name='Spec'),
  }(name='BillingConfig'),
  businessStatus?: string(name='BusinessStatus'),
  creationTime?: string(name='CreationTime'),
  deletionProtectionInfo?: {
    enabled?: boolean(name='Enabled'),
  }(name='DeletionProtectionInfo'),
  description?: string(name='Description'),
  ecsMetricEnabled?: boolean(name='EcsMetricEnabled'),
  expiredTime?: string(name='ExpiredTime'),
  forwardTable?: {
    forwardEntryCount?: int32(name='ForwardEntryCount'),
    forwardTableId?: string(name='ForwardTableId'),
  }(name='ForwardTable'),
  fullNatTable?: {
    fullNatEntryCount?: long(name='FullNatEntryCount'),
    fullNatTableId?: string(name='FullNatTableId'),
  }(name='FullNatTable'),
  ipList?: [ 
    {
      allocationId?: string(name='AllocationId'),
      ipAddress?: string(name='IpAddress'),
      usingStatus?: string(name='UsingStatus'),
    }
  ](name='IpList'),
  name?: string(name='Name'),
  natGatewayId?: string(name='NatGatewayId'),
  natType?: string(name='NatType'),
  networkType?: string(name='NetworkType'),
  privateInfo?: {
    eniInstanceId?: string(name='EniInstanceId'),
    izNo?: string(name='IzNo'),
    maxBandwidth?: int32(name='MaxBandwidth'),
    privateIpAddress?: string(name='PrivateIpAddress'),
    vswitchId?: string(name='VswitchId'),
  }(name='PrivateInfo'),
  privateLinkEnabled?: boolean(name='PrivateLinkEnabled', description='默认不支持私网链接。设置为1则意味着支持私网链接'),
  privateLinkMode?: string(name='PrivateLinkMode', description='Fullnat：使用FullNat模式 Geneve：使用Geneve模式。 预估大部分场景都是非Geneve模式的。'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  snatTable?: {
    snatEntryCount?: int32(name='SnatEntryCount'),
    snatTableId?: string(name='SnatTableId'),
  }(name='SnatTable'),
  status?: string(name='Status'),
  vpcId?: string(name='VpcId'),
}

model GetNatGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetNatGatewayAttributeResponseBody(name='body'),
}

async function getNatGatewayAttribute(request: GetNatGatewayAttributeRequest): GetNatGatewayAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNatGatewayAttribute', 'POST', '/', 'json', false, 'json', request);
}

model GetNatGatewayConvertStatusRequest {
  natGatewayId: string(name='NatGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetNatGatewayConvertStatusResponseBody = {
  convertSteps?: [ 
    {
      stepName?: string(name='StepName'),
      stepStartTime?: string(name='StepStartTime'),
      stepStatus?: string(name='StepStatus'),
    }
  ](name='ConvertSteps'),
  dstNatType?: string(name='DstNatType'),
  natGatewayId?: string(name='NatGatewayId'),
  requestId?: string(name='RequestId'),
}

model GetNatGatewayConvertStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetNatGatewayConvertStatusResponseBody(name='body'),
}

async function getNatGatewayConvertStatus(request: GetNatGatewayConvertStatusRequest): GetNatGatewayConvertStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetNatGatewayConvertStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetPhysicalConnectionServiceStatusRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetPhysicalConnectionServiceStatusResponseBody = {
  enabled?: boolean(name='Enabled', description='是否开通出云流量服务'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetPhysicalConnectionServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetPhysicalConnectionServiceStatusResponseBody(name='body'),
}

async function getPhysicalConnectionServiceStatus(request: GetPhysicalConnectionServiceStatusRequest): GetPhysicalConnectionServiceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPhysicalConnectionServiceStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetTrafficMirrorServiceStatusRequest {
  ownerId?: long(name='OwnerId', position='Query'),
}

model GetTrafficMirrorServiceStatusResponseBody = {
  enabled?: boolean(name='Enabled'),
  requestId?: string(name='RequestId'),
}

model GetTrafficMirrorServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetTrafficMirrorServiceStatusResponseBody(name='body'),
}

async function getTrafficMirrorServiceStatus(request: GetTrafficMirrorServiceStatusRequest): GetTrafficMirrorServiceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTrafficMirrorServiceStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetVpcGatewayEndpointAttributeRequest {
  endpointId: string(name='EndpointId', description='VPC网关实例ID', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetVpcGatewayEndpointAttributeResponseBody = {
  creationTime?: string(name='CreationTime'),
  endpointDescription?: string(name='EndpointDescription'),
  endpointId?: string(name='EndpointId'),
  endpointName?: string(name='EndpointName'),
  endpointStatus?: string(name='EndpointStatus'),
  policyDocument?: string(name='PolicyDocument'),
  requestId?: string(name='RequestId', description='Id of the request'),
  routeTables?: [ string ](name='RouteTables'),
  serviceName?: string(name='ServiceName'),
  vpcId?: string(name='VpcId'),
}

model GetVpcGatewayEndpointAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetVpcGatewayEndpointAttributeResponseBody(name='body'),
}

async function getVpcGatewayEndpointAttribute(request: GetVpcGatewayEndpointAttributeRequest): GetVpcGatewayEndpointAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVpcGatewayEndpointAttribute', 'POST', '/', 'json', false, 'json', request);
}

model GetVpcPrefixListAssociationsRequest {
  maxResults?: long(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListId: string(name='PrefixListId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetVpcPrefixListAssociationsResponseBody = {
  count?: long(name='Count'),
  nextToken?: string(name='NextToken'),
  prefixListAssociation?: [ 
    {
      ownerId?: string(name='OwnerId'),
      prefixListId?: string(name='PrefixListId', description='前缀列表的实例ID'),
      reason?: string(name='Reason'),
      resourceId?: string(name='ResourceId', description='状态'),
      resourceType?: string(name='ResourceType', description='名称'),
      status?: string(name='Status', description='IpVersion'),
    }
  ](name='PrefixListAssociation'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model GetVpcPrefixListAssociationsResponse = {
  headers: map[string]string(name='headers'),
  body: GetVpcPrefixListAssociationsResponseBody(name='body'),
}

async function getVpcPrefixListAssociations(request: GetVpcPrefixListAssociationsRequest): GetVpcPrefixListAssociationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVpcPrefixListAssociations', 'POST', '/', 'json', false, 'json', request);
}

model GetVpcPrefixListEntriesRequest {
  maxResults?: long(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListId: string(name='PrefixListId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GetVpcPrefixListEntriesResponseBody = {
  count?: long(name='Count'),
  nextToken?: string(name='NextToken'),
  prefixListEntry?: [ 
    {
      cidr?: string(name='Cidr', description='状态'),
      description?: string(name='Description', description='名称'),
      prefixListId?: string(name='PrefixListId', description='前缀列表的实例ID'),
    }
  ](name='PrefixListEntry'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model GetVpcPrefixListEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: GetVpcPrefixListEntriesResponseBody(name='body'),
}

async function getVpcPrefixListEntries(request: GetVpcPrefixListEntriesRequest): GetVpcPrefixListEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVpcPrefixListEntries', 'POST', '/', 'json', false, 'json', request);
}

model GrantInstanceToCenRequest {
  cenId: string(name='CenId', position='Query'),
  cenOwnerId: long(name='CenOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GrantInstanceToCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model GrantInstanceToCenResponse = {
  headers: map[string]string(name='headers'),
  body: GrantInstanceToCenResponseBody(name='body'),
}

async function grantInstanceToCen(request: GrantInstanceToCenRequest): GrantInstanceToCenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GrantInstanceToCen', 'POST', '/', 'json', false, 'json', request);
}

model ListDhcpOptionsSetsRequest {
  dhcpOptionsSetId?: [ string ](name='DhcpOptionsSetId', position='Query'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListDhcpOptionsSetsResponseBody = {
  dhcpOptionsSets?: [ 
    {
      associateVpcCount?: int32(name='AssociateVpcCount'),
      dhcpOptions?: {
        domainName?: string(name='DomainName'),
        domainNameServers?: string(name='DomainNameServers'),
        ipv6LeaseTime?: string(name='Ipv6LeaseTime'),
        leaseTime?: string(name='LeaseTime'),
      }(name='DhcpOptions'),
      dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription'),
      dhcpOptionsSetId?: string(name='DhcpOptionsSetId'),
      dhcpOptionsSetName?: string(name='DhcpOptionsSetName'),
      ownerId?: long(name='OwnerId'),
      status?: string(name='Status'),
    }
  ](name='DhcpOptionsSets'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListDhcpOptionsSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDhcpOptionsSetsResponseBody(name='body'),
}

async function listDhcpOptionsSets(request: ListDhcpOptionsSetsRequest): ListDhcpOptionsSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDhcpOptionsSets', 'POST', '/', 'json', false, 'json', request);
}

model ListEnhanhcedNatGatewayAvailableZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListEnhanhcedNatGatewayAvailableZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zones'),
}

model ListEnhanhcedNatGatewayAvailableZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEnhanhcedNatGatewayAvailableZonesResponseBody(name='body'),
}

async function listEnhanhcedNatGatewayAvailableZones(request: ListEnhanhcedNatGatewayAvailableZonesRequest): ListEnhanhcedNatGatewayAvailableZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEnhanhcedNatGatewayAvailableZones', 'POST', '/', 'json', false, 'json', request);
}

model ListFullNatEntriesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  fullNatEntryId?: string(name='FullNatEntryId', position='Query'),
  fullNatEntryNames?: [ string ](name='FullNatEntryNames', position='Query'),
  fullNatTableId: string(name='FullNatTableId', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  maxResults?: long(name='MaxResults', position='Query'),
  networkInterfaceIds?: [ string ](name='NetworkInterfaceIds', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListFullNatEntriesResponseBody = {
  fullNatEntries?: [ 
    {
      accessIp?: string(name='AccessIp', description='通过DNAT条目进行公网通信的ECS实例的私网IP地址。'),
      accessPort?: string(name='AccessPort', description='DNAT条目中进行端口转发的内部端口，取值范围：1-65535。'),
      creationTime?: string(name='CreationTime'),
      fullNatEntryDescription?: string(name='FullNatEntryDescription'),
      fullNatEntryId?: string(name='FullNatEntryId'),
      fullNatEntryName?: string(name='FullNatEntryName', description='FULLNAT规则的名称。 长度为2~128个字符，必须以大小写字母或中文开头，但不能以http://或https://开头。'),
      fullNatEntryStatus?: string(name='FullNatEntryStatus'),
      ipProtocol?: string(name='IpProtocol', description='协议类型，取值： • TCP：转发TCP协议的报文。 • UDP：转发UDP协议的报文。'),
      natIp?: string(name='NatIp', description='DNAT条目中提供公网访问的公网IP地址。'),
      natIpPort?: string(name='NatIpPort', description='DNAT条目中进行端口转发的外部端口，取值范围：1~65535。'),
      networkInterfaceId?: string(name='NetworkInterfaceId', description='当前VpcNat作为服务资源所加入的eni'),
      networkInterfaceType?: string(name='NetworkInterfaceType', description='ENI类型，目前仅支持Endpoint'),
    }
  ](name='FullNatEntries'),
  fullNatTableId?: string(name='FullNatTableId'),
  maxResults?: long(name='MaxResults'),
  natGatewayId?: string(name='NatGatewayId'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListFullNatEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListFullNatEntriesResponseBody(name='body'),
}

async function listFullNatEntries(request: ListFullNatEntriesRequest): ListFullNatEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFullNatEntries', 'POST', '/', 'json', false, 'json', request);
}

model ListGatewayRouteTableEntriesRequest {
  destinationCidrBlock?: string(name='DestinationCidrBlock', position='Query'),
  gatewayRouteTableId: string(name='GatewayRouteTableId', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListGatewayRouteTableEntriesResponseBody = {
  gatewayRouteEntryModels?: [ 
    {
      description?: string(name='Description'),
      destinationCidrBlock?: string(name='DestinationCidrBlock'),
      name?: string(name='Name'),
      nextHopId?: string(name='NextHopId'),
      nextHopType?: string(name='NextHopType'),
      status?: string(name='Status'),
    }
  ](name='GatewayRouteEntryModels'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListGatewayRouteTableEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListGatewayRouteTableEntriesResponseBody(name='body'),
}

async function listGatewayRouteTableEntries(request: ListGatewayRouteTableEntriesRequest): ListGatewayRouteTableEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGatewayRouteTableEntries', 'POST', '/', 'json', false, 'json', request);
}

model ListIpsecServersRequest {
  ipsecServerId?: [ string ](name='IpsecServerId', maxLength=128, position='Query'),
  ipsecServerName?: string(name='IpsecServerName', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vpnGatewayId?: string(name='VpnGatewayId', position='Query'),
}

model ListIpsecServersResponseBody = {
  ipsecServers?: [ 
    {
      clientIpPool?: string(name='ClientIpPool'),
      creationTime?: string(name='CreationTime'),
      effectImmediately?: boolean(name='EffectImmediately'),
      iDaaSInstanceId?: string(name='IDaaSInstanceId'),
      ikeConfig?: {
        ikeAuthAlg?: string(name='IkeAuthAlg'),
        ikeEncAlg?: string(name='IkeEncAlg'),
        ikeLifetime?: long(name='IkeLifetime'),
        ikeMode?: string(name='IkeMode'),
        ikePfs?: string(name='IkePfs'),
        ikeVersion?: string(name='IkeVersion'),
        localId?: string(name='LocalId'),
        remoteId?: string(name='RemoteId'),
      }(name='IkeConfig'),
      internetIp?: string(name='InternetIp'),
      ipsecConfig?: {
        ipsecAuthAlg?: string(name='IpsecAuthAlg'),
        ipsecEncAlg?: string(name='IpsecEncAlg'),
        ipsecLifetime?: long(name='IpsecLifetime'),
        ipsecPfs?: string(name='IpsecPfs'),
      }(name='IpsecConfig'),
      ipsecServerId?: string(name='IpsecServerId'),
      ipsecServerName?: string(name='IpsecServerName'),
      localSubnet?: string(name='LocalSubnet'),
      maxConnections?: int32(name='MaxConnections'),
      multiFactorAuthEnabled?: boolean(name='MultiFactorAuthEnabled'),
      onlineClientCount?: int32(name='OnlineClientCount'),
      psk?: string(name='Psk'),
      pskEnabled?: boolean(name='PskEnabled'),
      regionId?: string(name='RegionId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='IpsecServers'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIpsecServersResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpsecServersResponseBody(name='body'),
}

async function listIpsecServers(request: ListIpsecServersRequest): ListIpsecServersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIpsecServers', 'POST', '/', 'json', false, 'json', request);
}

model ListIpv4GatewaysRequest {
  ipv4GatewayId?: string(name='Ipv4GatewayId', position='Query'),
  ipv4GatewayName?: string(name='Ipv4GatewayName', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model ListIpv4GatewaysResponseBody = {
  ipv4GatewayModels?: [ 
    {
      enabled?: boolean(name='Enabled'),
      gmtCreate?: string(name='GmtCreate'),
      ipv4GatewayDescription?: string(name='Ipv4GatewayDescription'),
      ipv4GatewayId?: string(name='Ipv4GatewayId'),
      ipv4GatewayName?: string(name='Ipv4GatewayName'),
      ipv4GatewayRouteTableId?: string(name='Ipv4GatewayRouteTableId'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Ipv4GatewayModels'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListIpv4GatewaysResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpv4GatewaysResponseBody(name='body'),
}

async function listIpv4Gateways(request: ListIpv4GatewaysRequest): ListIpv4GatewaysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIpv4Gateways', 'POST', '/', 'json', false, 'json', request);
}

model ListNatIpCidrsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  maxResults?: string(name='MaxResults', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  natIpCidr?: string(name='NatIpCidr', position='Query'),
  natIpCidrName?: [ string ](name='NatIpCidrName', position='Query'),
  natIpCidrStatus?: string(name='NatIpCidrStatus', position='Query'),
  natIpCidrs?: [ string ](name='NatIpCidrs', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListNatIpCidrsResponseBody = {
  natIpCidrs?: [ 
    {
      creationTime?: string(name='CreationTime'),
      isDefault?: boolean(name='IsDefault'),
      natGatewayId?: string(name='NatGatewayId'),
      natIpCidr?: string(name='NatIpCidr'),
      natIpCidrDescription?: string(name='NatIpCidrDescription'),
      natIpCidrId?: string(name='NatIpCidrId'),
      natIpCidrName?: string(name='NatIpCidrName'),
      natIpCidrStatus?: string(name='NatIpCidrStatus'),
    }
  ](name='NatIpCidrs'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListNatIpCidrsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNatIpCidrsResponseBody(name='body'),
}

async function listNatIpCidrs(request: ListNatIpCidrsRequest): ListNatIpCidrsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNatIpCidrs', 'POST', '/', 'json', false, 'json', request);
}

model ListNatIpsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  maxResults?: string(name='MaxResults', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  natIpCidr?: string(name='NatIpCidr', position='Query'),
  natIpIds?: [ string ](name='NatIpIds', position='Query'),
  natIpName?: [ string ](name='NatIpName', position='Query'),
  natIpStatus?: string(name='NatIpStatus', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListNatIpsResponseBody = {
  natIps?: [ 
    {
      isDefault?: boolean(name='IsDefault'),
      natGatewayId?: string(name='NatGatewayId'),
      natIp?: string(name='NatIp'),
      natIpCidr?: string(name='NatIpCidr'),
      natIpDescription?: string(name='NatIpDescription'),
      natIpId?: string(name='NatIpId'),
      natIpName?: string(name='NatIpName'),
      natIpStatus?: string(name='NatIpStatus'),
    }
  ](name='NatIps'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListNatIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNatIpsResponseBody(name='body'),
}

async function listNatIps(request: ListNatIpsRequest): ListNatIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNatIps', 'POST', '/', 'json', false, 'json', request);
}

model ListPrefixListsRequest {
  maxResults?: long(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListIds?: [ string ](name='PrefixListIds', description='前缀列表的实例ID', position='Query'),
  prefixListName?: string(name='PrefixListName', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListPrefixListsResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  prefixLists?: [ 
    {
      cidrBlocks?: [ string ](name='CidrBlocks', description='前缀列表包含的网段'),
      creationTime?: string(name='CreationTime', description='创建时间'),
      ipVersion?: string(name='IpVersion', description='IpVersion'),
      maxEntries?: int32(name='MaxEntries'),
      ownerId?: string(name='OwnerId'),
      prefixListDescription?: string(name='PrefixListDescription', description='描述'),
      prefixListId?: string(name='PrefixListId', description='前缀列表的实例ID'),
      prefixListName?: string(name='PrefixListName', description='名称'),
      prefixListStatus?: string(name='PrefixListStatus'),
      shareType?: string(name='ShareType'),
      status?: string(name='Status'),
    }
  ](name='PrefixLists'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListPrefixListsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPrefixListsResponseBody(name='body'),
}

async function listPrefixLists(request: ListPrefixListsRequest): ListPrefixListsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPrefixLists', 'POST', '/', 'json', false, 'json', request);
}

model ListPublicIpAddressPoolCidrBlocksRequest {
  cidrBlock?: string(name='CidrBlock', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publicIpAddressPoolId: string(name='PublicIpAddressPoolId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListPublicIpAddressPoolCidrBlocksResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  publicIpPoolCidrBlockList?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      creationTime?: string(name='CreationTime'),
      publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
      status?: string(name='Status'),
      totalIpNum?: int32(name='TotalIpNum'),
      usedIpNum?: int32(name='UsedIpNum'),
    }
  ](name='PublicIpPoolCidrBlockList'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListPublicIpAddressPoolCidrBlocksResponse = {
  headers: map[string]string(name='headers'),
  body: ListPublicIpAddressPoolCidrBlocksResponseBody(name='body'),
}

async function listPublicIpAddressPoolCidrBlocks(request: ListPublicIpAddressPoolCidrBlocksRequest): ListPublicIpAddressPoolCidrBlocksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPublicIpAddressPoolCidrBlocks', 'POST', '/', 'json', false, 'json', request);
}

model ListPublicIpAddressPoolsRequest {
  dryRun?: boolean(name='DryRun', position='Query'),
  isp?: string(name='Isp', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  name?: string(name='Name', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publicIpAddressPoolIds?: [ string ](name='PublicIpAddressPoolIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListPublicIpAddressPoolsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  publicIpAddressPoolList?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      ipAddressRemaining?: boolean(name='IpAddressRemaining'),
      isp?: string(name='Isp'),
      name?: string(name='Name'),
      publicIpAddressPoolId?: string(name='PublicIpAddressPoolId'),
      publicIpCidrBlockList?: [ 
        {
          cidrBlock?: string(name='CidrBlock'),
          creationTime?: string(name='CreationTime'),
          status?: string(name='Status'),
          totalIpNum?: int32(name='TotalIpNum'),
          usedIpNum?: int32(name='UsedIpNum'),
        }
      ](name='PublicIpCidrBlockList'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      totalIpNum?: int32(name='TotalIpNum'),
      usedIpNum?: int32(name='UsedIpNum'),
      userType?: boolean(name='UserType'),
    }
  ](name='PublicIpAddressPoolList'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListPublicIpAddressPoolsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPublicIpAddressPoolsResponseBody(name='body'),
}

async function listPublicIpAddressPools(request: ListPublicIpAddressPoolsRequest): ListPublicIpAddressPoolsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPublicIpAddressPools', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults', maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListTrafficMirrorFiltersRequest {
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorFilterIds?: [ string ](name='TrafficMirrorFilterIds', maxLength=128, position='Query'),
  trafficMirrorFilterName?: string(name='TrafficMirrorFilterName', position='Query'),
}

model ListTrafficMirrorFiltersResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
  trafficMirrorFilters?: [ 
    {
      egressRules?: [ 
        {
          action?: string(name='Action'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          destinationPortRange?: string(name='DestinationPortRange'),
          priority?: int32(name='Priority'),
          protocol?: string(name='Protocol'),
          sourceCidrBlock?: string(name='SourceCidrBlock'),
          sourcePortRange?: string(name='SourcePortRange'),
          trafficDirection?: string(name='TrafficDirection'),
          trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
          trafficMirrorFilterRuleId?: string(name='TrafficMirrorFilterRuleId'),
          trafficMirrorFilterRuleStatus?: string(name='TrafficMirrorFilterRuleStatus'),
        }
      ](name='EgressRules'),
      ingressRules?: [ 
        {
          action?: string(name='Action'),
          destinationCidrBlock?: string(name='DestinationCidrBlock'),
          destinationPortRange?: string(name='DestinationPortRange'),
          priority?: int32(name='Priority'),
          protocol?: string(name='Protocol'),
          sourceCidrBlock?: string(name='SourceCidrBlock'),
          sourcePortRange?: string(name='SourcePortRange'),
          trafficDirection?: string(name='TrafficDirection'),
          trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
          trafficMirrorFilterRuleId?: string(name='TrafficMirrorFilterRuleId'),
          trafficMirrorFilterRuleStatus?: string(name='TrafficMirrorFilterRuleStatus'),
        }
      ](name='IngressRules'),
      trafficMirrorFilterDescription?: string(name='TrafficMirrorFilterDescription'),
      trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
      trafficMirrorFilterName?: string(name='TrafficMirrorFilterName'),
      trafficMirrorFilterStatus?: string(name='TrafficMirrorFilterStatus'),
    }
  ](name='TrafficMirrorFilters'),
}

model ListTrafficMirrorFiltersResponse = {
  headers: map[string]string(name='headers'),
  body: ListTrafficMirrorFiltersResponseBody(name='body'),
}

async function listTrafficMirrorFilters(request: ListTrafficMirrorFiltersRequest): ListTrafficMirrorFiltersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTrafficMirrorFilters', 'POST', '/', 'json', false, 'json', request);
}

model ListTrafficMirrorSessionsRequest {
  enabled?: boolean(name='Enabled', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  priority?: int32(name='Priority', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId', position='Query'),
  trafficMirrorSessionIds?: [ string ](name='TrafficMirrorSessionIds', maxLength=128, position='Query'),
  trafficMirrorSessionName?: string(name='TrafficMirrorSessionName', position='Query'),
  trafficMirrorSourceId?: string(name='TrafficMirrorSourceId', position='Query'),
  trafficMirrorTargetId?: string(name='TrafficMirrorTargetId', position='Query'),
  virtualNetworkId?: int32(name='VirtualNetworkId', position='Query'),
}

model ListTrafficMirrorSessionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
  trafficMirrorSessions?: [ 
    {
      enabled?: boolean(name='Enabled'),
      packetLength?: int32(name='PacketLength'),
      priority?: int32(name='Priority'),
      trafficMirrorFilterId?: string(name='TrafficMirrorFilterId'),
      trafficMirrorSessionBusinessStatus?: string(name='TrafficMirrorSessionBusinessStatus'),
      trafficMirrorSessionDescription?: string(name='TrafficMirrorSessionDescription'),
      trafficMirrorSessionId?: string(name='TrafficMirrorSessionId'),
      trafficMirrorSessionName?: string(name='TrafficMirrorSessionName'),
      trafficMirrorSessionStatus?: string(name='TrafficMirrorSessionStatus'),
      trafficMirrorSourceIds?: [ string ](name='TrafficMirrorSourceIds'),
      trafficMirrorTargetId?: string(name='TrafficMirrorTargetId'),
      trafficMirrorTargetType?: string(name='TrafficMirrorTargetType'),
      virtualNetworkId?: int32(name='VirtualNetworkId'),
    }
  ](name='TrafficMirrorSessions'),
}

model ListTrafficMirrorSessionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTrafficMirrorSessionsResponseBody(name='body'),
}

async function listTrafficMirrorSessions(request: ListTrafficMirrorSessionsRequest): ListTrafficMirrorSessionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTrafficMirrorSessions', 'POST', '/', 'json', false, 'json', request);
}

model ListVirtualPhysicalConnectionsRequest {
  isConfirmed?: boolean(name='IsConfirmed', description='Vpconn是否被确认', position='Query'),
  maxResults?: int32(name='MaxResults', description='单次查询最大量', position='Query'),
  nextToken?: string(name='NextToken', description='单次查询最大量', position='Query'),
  physicalConnectionId?: string(name='PhysicalConnectionId', description='Vpconn的主Pconn', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  virtualPhysicalConnectionAliUids?: [ string ](name='VirtualPhysicalConnectionAliUids', description='Vpconn的OwnerUid', position='Query'),
  virtualPhysicalConnectionBusinessStatus?: string(name='VirtualPhysicalConnectionBusinessStatus', description='Vpconn的商业状态', position='Query'),
  virtualPhysicalConnectionIds?: [ string ](name='VirtualPhysicalConnectionIds', description='根据Vpconn的ID列表过滤', position='Query'),
  virtualPhysicalConnectionStatuses?: [ string ](name='VirtualPhysicalConnectionStatuses', description='Vpconn的状态', position='Query'),
  vlanIds?: [ string ](name='VlanIds', description='Vpconn的vlanId', position='Query'),
}

model ListVirtualPhysicalConnectionsResponseBody = {
  count?: int32(name='Count', description='本次查询数量'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount', description='总数'),
  virtualPhysicalConnections?: [ 
    {
      accessPointId?: string(name='AccessPointId'),
      adLocation?: string(name='AdLocation'),
      aliUid?: string(name='AliUid'),
      bandwidth?: long(name='Bandwidth'),
      businessStatus?: string(name='BusinessStatus'),
      chargeType?: string(name='ChargeType'),
      circuitCode?: string(name='CircuitCode'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      enabledTime?: string(name='EnabledTime'),
      endTime?: string(name='EndTime'),
      expectSpec?: string(name='ExpectSpec'),
      lineOperator?: string(name='LineOperator'),
      loaStatus?: string(name='LoaStatus'),
      name?: string(name='Name'),
      orderMode?: string(name='OrderMode'),
      parentPhysicalConnectionAliUid?: string(name='ParentPhysicalConnectionAliUid'),
      parentPhysicalConnectionId?: string(name='ParentPhysicalConnectionId'),
      peerLocation?: string(name='PeerLocation'),
      physicalConnectionId?: string(name='PhysicalConnectionId'),
      portNumber?: string(name='PortNumber'),
      portType?: string(name='PortType'),
      productType?: string(name='ProductType'),
      redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId'),
      spec?: string(name='Spec'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      virtualPhysicalConnectionStatus?: string(name='VirtualPhysicalConnectionStatus'),
      vlanId?: string(name='VlanId'),
    }
  ](name='VirtualPhysicalConnections', description='Vpconn'),
}

model ListVirtualPhysicalConnectionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVirtualPhysicalConnectionsResponseBody(name='body'),
}

async function listVirtualPhysicalConnections(request: ListVirtualPhysicalConnectionsRequest): ListVirtualPhysicalConnectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVirtualPhysicalConnections', 'POST', '/', 'json', false, 'json', request);
}

model ListVpcEndpointServicesByEndUserRequest {
  maxResults?: long(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
}

model ListVpcEndpointServicesByEndUserResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  services?: [ 
    {
      defaultPolicyDocument?: string(name='DefaultPolicyDocument'),
      serviceDomain?: string(name='ServiceDomain'),
      serviceId?: string(name='ServiceId'),
      serviceName?: string(name='ServiceName'),
      supportPolicy?: boolean(name='SupportPolicy'),
    }
  ](name='Services'),
}

model ListVpcEndpointServicesByEndUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointServicesByEndUserResponseBody(name='body'),
}

async function listVpcEndpointServicesByEndUser(request: ListVpcEndpointServicesByEndUserRequest): ListVpcEndpointServicesByEndUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVpcEndpointServicesByEndUser', 'POST', '/', 'json', false, 'json', request);
}

model ListVpcGatewayEndpointsRequest {
  endpointId?: string(name='EndpointId', description='VPC网关实例ID', position='Query'),
  endpointName?: string(name='EndpointName', description='VPC网关实例名称', position='Query'),
  maxResults?: long(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceName?: string(name='ServiceName', description='后端的服务名称', position='Query'),
}

model ListVpcGatewayEndpointsResponseBody = {
  endpoints?: [ 
    {
      associatedRouteTables?: [ string ](name='AssociatedRouteTables'),
      creationTime?: string(name='CreationTime'),
      endpointDescription?: string(name='EndpointDescription'),
      endpointId?: string(name='EndpointId'),
      endpointName?: string(name='EndpointName'),
      endpointStatus?: string(name='EndpointStatus'),
      policyDocument?: string(name='PolicyDocument'),
      serviceName?: string(name='ServiceName'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Endpoints'),
  maxResults?: long(name='MaxResults', description='本次请求最大数量'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListVpcGatewayEndpointsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcGatewayEndpointsResponseBody(name='body'),
}

async function listVpcGatewayEndpoints(request: ListVpcGatewayEndpointsRequest): ListVpcGatewayEndpointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVpcGatewayEndpoints', 'POST', '/', 'json', false, 'json', request);
}

model ListVpnCertificateAssociationsRequest {
  certificateId?: [ string ](name='CertificateId', maxLength=128, position='Query'),
  certificateType?: string(name='CertificateType', position='Query'),
  maxResults?: int32(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  vpnGatewayId?: [ string ](name='VpnGatewayId', maxLength=128, position='Query'),
}

model ListVpnCertificateAssociationsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vpnCertificateRelations?: [ 
    {
      associationTime?: string(name='AssociationTime'),
      certificateId?: string(name='CertificateId'),
      certificateType?: string(name='CertificateType'),
      regionId?: string(name='RegionId'),
      vpnGatewayId?: string(name='VpnGatewayId'),
    }
  ](name='VpnCertificateRelations'),
}

model ListVpnCertificateAssociationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpnCertificateAssociationsResponseBody(name='body'),
}

async function listVpnCertificateAssociations(request: ListVpnCertificateAssociationsRequest): ListVpnCertificateAssociationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVpnCertificateAssociations', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBgpGroupAttributeRequest {
  authKey?: string(name='AuthKey', position='Query'),
  bgpGroupId: string(name='BgpGroupId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  isFakeAsn?: boolean(name='IsFakeAsn', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerAsn?: long(name='PeerAsn', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyBgpGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBgpGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBgpGroupAttributeResponseBody(name='body'),
}

async function modifyBgpGroupAttribute(request: ModifyBgpGroupAttributeRequest): ModifyBgpGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBgpGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBgpPeerAttributeRequest {
  bfdMultiHop?: int32(name='BfdMultiHop', position='Query'),
  bgpGroupId?: string(name='BgpGroupId', position='Query'),
  bgpPeerId: string(name='BgpPeerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  enableBfd?: boolean(name='EnableBfd', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerIpAddress?: string(name='PeerIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyBgpPeerAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBgpPeerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBgpPeerAttributeResponseBody(name='body'),
}

async function modifyBgpPeerAttribute(request: ModifyBgpPeerAttributeRequest): ModifyBgpPeerAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBgpPeerAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCommonBandwidthPackageAttributeRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyCommonBandwidthPackageAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageAttributeResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageAttribute(request: ModifyCommonBandwidthPackageAttributeRequest): ModifyCommonBandwidthPackageAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCommonBandwidthPackageAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCommonBandwidthPackageInternetChargeTypeRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth?: int32(name='Bandwidth', minimum=0, maximum=10000, position='Query'),
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  internetChargeType?: string(name='InternetChargeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  ratio?: int32(name='Ratio', minimum=0, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyCommonBandwidthPackageInternetChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageInternetChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageInternetChargeTypeResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageInternetChargeType(request: ModifyCommonBandwidthPackageInternetChargeTypeRequest): ModifyCommonBandwidthPackageInternetChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCommonBandwidthPackageInternetChargeType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCommonBandwidthPackageIpBandwidthRequest {
  bandwidth: string(name='Bandwidth', position='Query'),
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  eipId: string(name='EipId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyCommonBandwidthPackageIpBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageIpBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageIpBandwidthResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageIpBandwidth(request: ModifyCommonBandwidthPackageIpBandwidthRequest): ModifyCommonBandwidthPackageIpBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCommonBandwidthPackageIpBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCommonBandwidthPackageSpecRequest {
  bandwidth: string(name='Bandwidth', position='Query'),
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyCommonBandwidthPackageSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCommonBandwidthPackageSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCommonBandwidthPackageSpecResponseBody(name='body'),
}

async function modifyCommonBandwidthPackageSpec(request: ModifyCommonBandwidthPackageSpecRequest): ModifyCommonBandwidthPackageSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCommonBandwidthPackageSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCustomerGatewayAttributeRequest {
  authKey?: string(name='AuthKey', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  customerGatewayId: string(name='CustomerGatewayId', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyCustomerGatewayAttributeResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  ipAddress?: string(name='IpAddress'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model ModifyCustomerGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCustomerGatewayAttributeResponseBody(name='body'),
}

async function modifyCustomerGatewayAttribute(request: ModifyCustomerGatewayAttributeRequest): ModifyCustomerGatewayAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCustomerGatewayAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyEipAddressAttributeRequest {
  allocationId: string(name='AllocationId', position='Query'),
  bandwidth?: string(name='Bandwidth', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyEipAddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyEipAddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyEipAddressAttributeResponseBody(name='body'),
}

async function modifyEipAddressAttribute(request: ModifyEipAddressAttributeRequest): ModifyEipAddressAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyEipAddressAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyExpressCloudConnectionAttributeRequest {
  bgpAs?: string(name='BgpAs', position='Query'),
  ceIp?: string(name='CeIp', position='Query'),
  description?: string(name='Description', position='Query'),
  eccId: string(name='EccId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peIp?: string(name='PeIp', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyExpressCloudConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExpressCloudConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyExpressCloudConnectionAttributeResponseBody(name='body'),
}

async function modifyExpressCloudConnectionAttribute(request: ModifyExpressCloudConnectionAttributeRequest): ModifyExpressCloudConnectionAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyExpressCloudConnectionAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyExpressCloudConnectionBandwidthRequest {
  bandwidth?: string(name='Bandwidth', position='Query'),
  eccId: string(name='EccId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyExpressCloudConnectionBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyExpressCloudConnectionBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyExpressCloudConnectionBandwidthResponseBody(name='body'),
}

async function modifyExpressCloudConnectionBandwidth(request: ModifyExpressCloudConnectionBandwidthRequest): ModifyExpressCloudConnectionBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyExpressCloudConnectionBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFlowLogAttributeRequest {
  aggregationInterval?: int32(name='AggregationInterval', position='Query'),
  description?: string(name='Description', position='Query'),
  flowLogId: string(name='FlowLogId', position='Query'),
  flowLogName?: string(name='FlowLogName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyFlowLogAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ModifyFlowLogAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowLogAttributeResponseBody(name='body'),
}

async function modifyFlowLogAttribute(request: ModifyFlowLogAttributeRequest): ModifyFlowLogAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFlowLogAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyForwardEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  externalIp?: string(name='ExternalIp', position='Query'),
  externalPort?: string(name='ExternalPort', position='Query'),
  forwardEntryId: string(name='ForwardEntryId', position='Query'),
  forwardEntryName?: string(name='ForwardEntryName', position='Query'),
  forwardTableId: string(name='ForwardTableId', position='Query'),
  internalIp?: string(name='InternalIp', position='Query'),
  internalPort?: string(name='InternalPort', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  portBreak?: boolean(name='PortBreak', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyForwardEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyForwardEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyForwardEntryResponseBody(name='body'),
}

async function modifyForwardEntry(request: ModifyForwardEntryRequest): ModifyForwardEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyForwardEntry', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFullNatEntryAttributeRequest {
  accessIp?: string(name='AccessIp', position='Query'),
  accessPort?: string(name='AccessPort', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fullNatEntryDescription?: string(name='FullNatEntryDescription', position='Query'),
  fullNatEntryId: string(name='FullNatEntryId', position='Query'),
  fullNatEntryName?: string(name='FullNatEntryName', position='Query'),
  fullNatTableId: string(name='FullNatTableId', position='Query'),
  ipProtocol?: string(name='IpProtocol', position='Query'),
  natIp?: string(name='NatIp', position='Query'),
  natIpPort?: string(name='NatIpPort', position='Query'),
  networkInterfaceId?: string(name='NetworkInterfaceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyFullNatEntryAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyFullNatEntryAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFullNatEntryAttributeResponseBody(name='body'),
}

async function modifyFullNatEntryAttribute(request: ModifyFullNatEntryAttributeRequest): ModifyFullNatEntryAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFullNatEntryAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyGlobalAccelerationInstanceAttributesRequest {
  description?: string(name='Description', position='Query'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyGlobalAccelerationInstanceAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyGlobalAccelerationInstanceAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGlobalAccelerationInstanceAttributesResponseBody(name='body'),
}

async function modifyGlobalAccelerationInstanceAttributes(request: ModifyGlobalAccelerationInstanceAttributesRequest): ModifyGlobalAccelerationInstanceAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyGlobalAccelerationInstanceAttributes', 'POST', '/', 'json', false, 'json', request);
}

model ModifyGlobalAccelerationInstanceSpecRequest {
  bandwidth: string(name='Bandwidth', position='Query'),
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyGlobalAccelerationInstanceSpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyGlobalAccelerationInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGlobalAccelerationInstanceSpecResponseBody(name='body'),
}

async function modifyGlobalAccelerationInstanceSpec(request: ModifyGlobalAccelerationInstanceSpecRequest): ModifyGlobalAccelerationInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyGlobalAccelerationInstanceSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHaVipAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  haVipId: string(name='HaVipId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyHaVipAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHaVipAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHaVipAttributeResponseBody(name='body'),
}

async function modifyHaVipAttribute(request: ModifyHaVipAttributeRequest): ModifyHaVipAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHaVipAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIPv6TranslatorAclAttributeRequest {
  aclId: string(name='AclId', position='Query'),
  aclName: string(name='AclName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyIPv6TranslatorAclAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAclAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorAclAttributeResponseBody(name='body'),
}

async function modifyIPv6TranslatorAclAttribute(request: ModifyIPv6TranslatorAclAttributeRequest): ModifyIPv6TranslatorAclAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIPv6TranslatorAclAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIPv6TranslatorAclListEntryRequest {
  aclEntryComment: string(name='AclEntryComment', position='Query'),
  aclEntryId: string(name='AclEntryId', position='Query'),
  aclId: string(name='AclId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyIPv6TranslatorAclListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function modifyIPv6TranslatorAclListEntry(request: ModifyIPv6TranslatorAclListEntryRequest): ModifyIPv6TranslatorAclListEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIPv6TranslatorAclListEntry', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIPv6TranslatorAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  ipv6TranslatorId: string(name='Ipv6TranslatorId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyIPv6TranslatorAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorAttributeResponseBody(name='body'),
}

async function modifyIPv6TranslatorAttribute(request: ModifyIPv6TranslatorAttributeRequest): ModifyIPv6TranslatorAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIPv6TranslatorAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIPv6TranslatorBandwidthRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  bandwidth: int32(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ipv6TranslatorId: string(name='Ipv6TranslatorId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyIPv6TranslatorBandwidthResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorBandwidthResponseBody(name='body'),
}

async function modifyIPv6TranslatorBandwidth(request: ModifyIPv6TranslatorBandwidthRequest): ModifyIPv6TranslatorBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIPv6TranslatorBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIPv6TranslatorEntryRequest {
  aclId?: string(name='AclId', position='Query'),
  aclStatus?: string(name='AclStatus', position='Query'),
  aclType?: string(name='AclType', position='Query'),
  allocateIpv6Port?: int32(name='AllocateIpv6Port', position='Query'),
  backendIpv4Addr?: string(name='BackendIpv4Addr', position='Query'),
  backendIpv4Port?: int32(name='BackendIpv4Port', position='Query'),
  entryBandwidth?: int32(name='EntryBandwidth', position='Query'),
  entryDescription?: string(name='EntryDescription', position='Query'),
  entryName?: string(name='EntryName', position='Query'),
  ipv6TranslatorEntryId: string(name='Ipv6TranslatorEntryId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  transProtocol?: string(name='TransProtocol', position='Query'),
}

model ModifyIPv6TranslatorEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIPv6TranslatorEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIPv6TranslatorEntryResponseBody(name='body'),
}

async function modifyIPv6TranslatorEntry(request: ModifyIPv6TranslatorEntryRequest): ModifyIPv6TranslatorEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIPv6TranslatorEntry', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIpv6AddressAttributeRequest {
  description?: string(name='Description', position='Query'),
  ipv6AddressId: string(name='Ipv6AddressId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyIpv6AddressAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6AddressAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6AddressAttributeResponseBody(name='body'),
}

async function modifyIpv6AddressAttribute(request: ModifyIpv6AddressAttributeRequest): ModifyIpv6AddressAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIpv6AddressAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIpv6GatewayAttributeRequest {
  description?: string(name='Description', position='Query'),
  ipv6GatewayId: string(name='Ipv6GatewayId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyIpv6GatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6GatewayAttributeResponseBody(name='body'),
}

async function modifyIpv6GatewayAttribute(request: ModifyIpv6GatewayAttributeRequest): ModifyIpv6GatewayAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIpv6GatewayAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIpv6GatewaySpecRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ipv6GatewayId: string(name='Ipv6GatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spec: string(name='Spec', position='Query'),
}

model ModifyIpv6GatewaySpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6GatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6GatewaySpecResponseBody(name='body'),
}

async function modifyIpv6GatewaySpec(request: ModifyIpv6GatewaySpecRequest): ModifyIpv6GatewaySpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIpv6GatewaySpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyIpv6InternetBandwidthRequest {
  bandwidth: long(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ipv6AddressId?: string(name='Ipv6AddressId', position='Query'),
  ipv6InternetBandwidthId?: string(name='Ipv6InternetBandwidthId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyIpv6InternetBandwidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyIpv6InternetBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyIpv6InternetBandwidthResponseBody(name='body'),
}

async function modifyIpv6InternetBandwidth(request: ModifyIpv6InternetBandwidthRequest): ModifyIpv6InternetBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyIpv6InternetBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNatGatewayAttributeRequest {
  description?: string(name='Description', position='Query'),
  icmpReplyEnabled?: boolean(name='IcmpReplyEnabled', position='Query'),
  name?: string(name='Name', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyNatGatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatGatewayAttributeResponseBody(name='body'),
}

async function modifyNatGatewayAttribute(request: ModifyNatGatewayAttributeRequest): ModifyNatGatewayAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNatGatewayAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNatGatewaySpecRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spec: string(name='Spec', position='Query'),
}

model ModifyNatGatewaySpecResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatGatewaySpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatGatewaySpecResponseBody(name='body'),
}

async function modifyNatGatewaySpec(request: ModifyNatGatewaySpecRequest): ModifyNatGatewaySpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNatGatewaySpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNatIpAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  natIpDescription?: string(name='NatIpDescription', position='Query'),
  natIpId: string(name='NatIpId', position='Query'),
  natIpName?: string(name='NatIpName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyNatIpAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatIpAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatIpAttributeResponseBody(name='body'),
}

async function modifyNatIpAttribute(request: ModifyNatIpAttributeRequest): ModifyNatIpAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNatIpAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNatIpCidrAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  natIpCidr: string(name='NatIpCidr', position='Query'),
  natIpCidrDescription?: string(name='NatIpCidrDescription', position='Query'),
  natIpCidrName?: string(name='NatIpCidrName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyNatIpCidrAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNatIpCidrAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNatIpCidrAttributeResponseBody(name='body'),
}

async function modifyNatIpCidrAttribute(request: ModifyNatIpCidrAttributeRequest): ModifyNatIpCidrAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNatIpCidrAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNetworkAclAttributesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  networkAclId: string(name='NetworkAclId', position='Query'),
  networkAclName?: string(name='NetworkAclName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyNetworkAclAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkAclAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkAclAttributesResponseBody(name='body'),
}

async function modifyNetworkAclAttributes(request: ModifyNetworkAclAttributesRequest): ModifyNetworkAclAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkAclAttributes', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPhysicalConnectionAttributeRequest {
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  lineOperator?: string(name='LineOperator', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerLocation?: string(name='PeerLocation', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  portType?: string(name='PortType', position='Query'),
  redundantPhysicalConnectionId?: string(name='RedundantPhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  bandwidth?: int32(name='bandwidth', position='Query'),
}

model ModifyPhysicalConnectionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPhysicalConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPhysicalConnectionAttributeResponseBody(name='body'),
}

async function modifyPhysicalConnectionAttribute(request: ModifyPhysicalConnectionAttributeRequest): ModifyPhysicalConnectionAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPhysicalConnectionAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyRouteEntryRequest {
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeEntryId: string(name='RouteEntryId', position='Query'),
  routeEntryName?: string(name='RouteEntryName', position='Query'),
}

model ModifyRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouteEntryResponseBody(name='body'),
}

async function modifyRouteEntry(request: ModifyRouteEntryRequest): ModifyRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model ModifyRouteTableAttributesRequest {
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
  routeTableName?: string(name='RouteTableName', position='Query'),
}

model ModifyRouteTableAttributesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouteTableAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouteTableAttributesResponseBody(name='body'),
}

async function modifyRouteTableAttributes(request: ModifyRouteTableAttributesRequest): ModifyRouteTableAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRouteTableAttributes', 'POST', '/', 'json', false, 'json', request);
}

model ModifyRouterInterfaceAttributeRequest {
  deleteHealthCheckIp?: boolean(name='DeleteHealthCheckIp', position='Query'),
  description?: string(name='Description', position='Query'),
  hcRate?: int32(name='HcRate', position='Query'),
  hcThreshold?: int32(name='HcThreshold', position='Query'),
  healthCheckSourceIp?: string(name='HealthCheckSourceIp', position='Query'),
  healthCheckTargetIp?: string(name='HealthCheckTargetIp', position='Query'),
  name?: string(name='Name', position='Query'),
  oppositeInterfaceId?: string(name='OppositeInterfaceId', position='Query'),
  oppositeInterfaceOwnerId?: long(name='OppositeInterfaceOwnerId', position='Query'),
  oppositeRouterId?: string(name='OppositeRouterId', position='Query'),
  oppositeRouterType?: string(name='OppositeRouterType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
}

model ModifyRouterInterfaceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyRouterInterfaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceAttributeResponseBody(name='body'),
}

async function modifyRouterInterfaceAttribute(request: ModifyRouterInterfaceAttributeRequest): ModifyRouterInterfaceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRouterInterfaceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyRouterInterfaceSpecRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routerInterfaceId: string(name='RouterInterfaceId', position='Query'),
  spec: string(name='Spec', position='Query'),
}

model ModifyRouterInterfaceSpecResponseBody = {
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
}

model ModifyRouterInterfaceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRouterInterfaceSpecResponseBody(name='body'),
}

async function modifyRouterInterfaceSpec(request: ModifyRouterInterfaceSpecRequest): ModifyRouterInterfaceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyRouterInterfaceSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifySnatEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snatEntryId: string(name='SnatEntryId', position='Query'),
  snatEntryName?: string(name='SnatEntryName', position='Query'),
  snatIp?: string(name='SnatIp', position='Query'),
  snatTableId: string(name='SnatTableId', position='Query'),
}

model ModifySnatEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySnatEntryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySnatEntryResponseBody(name='body'),
}

async function modifySnatEntry(request: ModifySnatEntryRequest): ModifySnatEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySnatEntry', 'POST', '/', 'json', false, 'json', request);
}

model ModifySslVpnClientCertRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslVpnClientCertId: string(name='SslVpnClientCertId', position='Query'),
}

model ModifySslVpnClientCertResponseBody = {
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sslVpnClientCertId?: string(name='SslVpnClientCertId'),
}

model ModifySslVpnClientCertResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySslVpnClientCertResponseBody(name='body'),
}

async function modifySslVpnClientCert(request: ModifySslVpnClientCertRequest): ModifySslVpnClientCertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySslVpnClientCert', 'POST', '/', 'json', false, 'json', request);
}

model ModifySslVpnServerRequest {
  cipher?: string(name='Cipher', position='Query'),
  clientIpPool?: string(name='ClientIpPool', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  compress?: boolean(name='Compress', position='Query'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth', position='Query'),
  iDaaSInstanceId?: string(name='IDaaSInstanceId', position='Query'),
  iDaaSRegionId?: string(name='IDaaSRegionId', position='Query'),
  localSubnet?: string(name='LocalSubnet', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  port?: int32(name='Port', position='Query'),
  proto?: string(name='Proto', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sslVpnServerId: string(name='SslVpnServerId', position='Query'),
}

model ModifySslVpnServerResponseBody = {
  cipher?: string(name='Cipher'),
  clientIpPool?: string(name='ClientIpPool'),
  compress?: boolean(name='Compress'),
  connections?: int32(name='Connections'),
  createTime?: long(name='CreateTime'),
  enableMultiFactorAuth?: boolean(name='EnableMultiFactorAuth'),
  iDaaSInstanceId?: string(name='IDaaSInstanceId'),
  internetIp?: string(name='InternetIp'),
  localSubnet?: string(name='LocalSubnet'),
  maxConnections?: int32(name='MaxConnections'),
  name?: string(name='Name'),
  port?: int32(name='Port'),
  proto?: string(name='Proto'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  sslVpnServerId?: string(name='SslVpnServerId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifySslVpnServerResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySslVpnServerResponseBody(name='body'),
}

async function modifySslVpnServer(request: ModifySslVpnServerRequest): ModifySslVpnServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySslVpnServer', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVRouterAttributeRequest {
  description?: string(name='Description', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vRouterId: string(name='VRouterId', position='Query'),
  vRouterName?: string(name='VRouterName', position='Query'),
}

model ModifyVRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVRouterAttributeResponseBody(name='body'),
}

async function modifyVRouterAttribute(request: ModifyVRouterAttributeRequest): ModifyVRouterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVRouterAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVSwitchAttributeRequest {
  description?: string(name='Description', position='Query'),
  enableIPv6?: boolean(name='EnableIPv6', position='Query'),
  ipv6CidrBlock?: int32(name='Ipv6CidrBlock', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
  vSwitchName?: string(name='VSwitchName', position='Query'),
  vpcIpv6CidrBlock?: string(name='VpcIpv6CidrBlock', position='Query'),
}

model ModifyVSwitchAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVSwitchAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVSwitchAttributeResponseBody(name='body'),
}

async function modifyVSwitchAttribute(request: ModifyVSwitchAttributeRequest): ModifyVSwitchAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVSwitchAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVcoRouteEntryWeightRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  newWeight: int32(name='NewWeight', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  overlayMode?: string(name='OverlayMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model ModifyVcoRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVcoRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVcoRouteEntryWeightResponseBody(name='body'),
}

async function modifyVcoRouteEntryWeight(request: ModifyVcoRouteEntryWeightRequest): ModifyVcoRouteEntryWeightResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVcoRouteEntryWeight', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVirtualBorderRouterAttributeRequest {
  associatedPhysicalConnections?: string(name='AssociatedPhysicalConnections', position='Query'),
  bandwidth?: int32(name='Bandwidth', position='Query'),
  circuitCode?: string(name='CircuitCode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  detectMultiplier?: long(name='DetectMultiplier', position='Query'),
  enableIpv6?: boolean(name='EnableIpv6', position='Query'),
  localGatewayIp?: string(name='LocalGatewayIp', position='Query'),
  localIpv6GatewayIp?: string(name='LocalIpv6GatewayIp', position='Query'),
  minRxInterval?: long(name='MinRxInterval', position='Query'),
  minTxInterval?: long(name='MinTxInterval', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  peerGatewayIp?: string(name='PeerGatewayIp', position='Query'),
  peerIpv6GatewayIp?: string(name='PeerIpv6GatewayIp', position='Query'),
  peeringIpv6SubnetMask?: string(name='PeeringIpv6SubnetMask', position='Query'),
  peeringSubnetMask?: string(name='PeeringSubnetMask', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
  vlanId?: int32(name='VlanId', position='Query'),
}

model ModifyVirtualBorderRouterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVirtualBorderRouterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVirtualBorderRouterAttributeResponseBody(name='body'),
}

async function modifyVirtualBorderRouterAttribute(request: ModifyVirtualBorderRouterAttributeRequest): ModifyVirtualBorderRouterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVirtualBorderRouterAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVpcAttributeRequest {
  cidrBlock?: string(name='CidrBlock', position='Query'),
  description?: string(name='Description', position='Query'),
  enableIPv6?: boolean(name='EnableIPv6', position='Query'),
  ipv6CidrBlock?: string(name='Ipv6CidrBlock', position='Query'),
  ipv6Isp?: string(name='Ipv6Isp', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
  vpcName?: string(name='VpcName', position='Query'),
}

model ModifyVpcAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpcAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpcAttributeResponseBody(name='body'),
}

async function modifyVpcAttribute(request: ModifyVpcAttributeRequest): ModifyVpcAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVpcAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVpcPrefixListRequest {
  addPrefixListEntry?: [ 
    {
      cidr?: string(name='Cidr'),
      description?: string(name='Description'),
    }
  ](name='AddPrefixListEntry', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  maxEntries?: int32(name='MaxEntries', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListDescription?: string(name='PrefixListDescription', position='Query'),
  prefixListId: string(name='PrefixListId', position='Query'),
  prefixListName?: string(name='PrefixListName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  removePrefixListEntry?: [ 
    {
      cidr?: string(name='Cidr'),
      description?: string(name='Description'),
    }
  ](name='RemovePrefixListEntry', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyVpcPrefixListResponseBody = {
  prefixListId?: string(name='PrefixListId'),
  requestId?: string(name='RequestId'),
}

model ModifyVpcPrefixListResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpcPrefixListResponseBody(name='body'),
}

async function modifyVpcPrefixList(request: ModifyVpcPrefixListRequest): ModifyVpcPrefixListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVpcPrefixList', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVpnAttachmentAttributeRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute', position='Query'),
  bgpConfig?: string(name='BgpConfig', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  effectImmediately?: boolean(name='EffectImmediately', position='Query'),
  enableDpd?: boolean(name='EnableDpd', position='Query'),
  enableNatTraversal?: boolean(name='EnableNatTraversal', position='Query'),
  healthCheckConfig?: string(name='HealthCheckConfig', position='Query'),
  ikeConfig?: string(name='IkeConfig', position='Query'),
  ipsecConfig?: string(name='IpsecConfig', position='Query'),
  localSubnet?: string(name='LocalSubnet', position='Query'),
  name?: string(name='Name', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  remoteCaCert?: string(name='RemoteCaCert', position='Query'),
  remoteSubnet?: string(name='RemoteSubnet', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
}

model ModifyVpnAttachmentAttributeResponseBody = {
  attachInstanceId?: string(name='AttachInstanceId'),
  attachType?: string(name='AttachType'),
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  ikeConfig?: {
    ikeAuthAlg?: string(name='IkeAuthAlg'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeMode?: string(name='IkeMode'),
    ikePfs?: string(name='IkePfs'),
    ikeVersion?: string(name='IkeVersion'),
    localId?: string(name='LocalId'),
    psk?: string(name='Psk'),
    remoteId?: string(name='RemoteId'),
  }(name='IkeConfig'),
  ipsecConfig?: {
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecPfs?: string(name='IpsecPfs'),
  }(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
  remoteSubnet?: string(name='RemoteSubnet'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  vcoHealthCheck?: {
    dip?: string(name='Dip'),
    enable?: string(name='Enable'),
    interval?: int32(name='Interval'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig?: {
    enableBgp?: string(name='EnableBgp'),
    localAsn?: long(name='LocalAsn'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: long(name='PeerAsn'),
    peerBgpIp?: string(name='PeerBgpIp'),
    status?: string(name='Status'),
    tunnelCidr?: string(name='TunnelCidr'),
  }(name='VpnBgpConfig'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnAttachmentAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnAttachmentAttributeResponseBody(name='body'),
}

async function modifyVpnAttachmentAttribute(request: ModifyVpnAttachmentAttributeRequest): ModifyVpnAttachmentAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVpnAttachmentAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVpnConnectionAttributeRequest {
  autoConfigRoute?: boolean(name='AutoConfigRoute', position='Query'),
  bgpConfig?: string(name='BgpConfig', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  effectImmediately?: boolean(name='EffectImmediately', position='Query'),
  enableDpd?: boolean(name='EnableDpd', position='Query'),
  enableNatTraversal?: boolean(name='EnableNatTraversal', position='Query'),
  healthCheckConfig?: string(name='HealthCheckConfig', position='Query'),
  ikeConfig?: string(name='IkeConfig', position='Query'),
  ipsecConfig?: string(name='IpsecConfig', position='Query'),
  localSubnet?: string(name='LocalSubnet', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  remoteCaCertificate?: string(name='RemoteCaCertificate', position='Query'),
  remoteSubnet?: string(name='RemoteSubnet', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnConnectionId: string(name='VpnConnectionId', position='Query'),
}

model ModifyVpnConnectionAttributeResponseBody = {
  createTime?: long(name='CreateTime'),
  customerGatewayId?: string(name='CustomerGatewayId'),
  description?: string(name='Description'),
  effectImmediately?: boolean(name='EffectImmediately'),
  enableDpd?: boolean(name='EnableDpd'),
  enableNatTraversal?: boolean(name='EnableNatTraversal'),
  ikeConfig?: {
    ikeAuthAlg?: string(name='IkeAuthAlg'),
    ikeEncAlg?: string(name='IkeEncAlg'),
    ikeLifetime?: long(name='IkeLifetime'),
    ikeMode?: string(name='IkeMode'),
    ikePfs?: string(name='IkePfs'),
    ikeVersion?: string(name='IkeVersion'),
    localId?: string(name='LocalId'),
    psk?: string(name='Psk'),
    remoteId?: string(name='RemoteId'),
  }(name='IkeConfig'),
  ipsecConfig?: {
    ipsecAuthAlg?: string(name='IpsecAuthAlg'),
    ipsecEncAlg?: string(name='IpsecEncAlg'),
    ipsecLifetime?: long(name='IpsecLifetime'),
    ipsecPfs?: string(name='IpsecPfs'),
  }(name='IpsecConfig'),
  localSubnet?: string(name='LocalSubnet'),
  name?: string(name='Name'),
  remoteSubnet?: string(name='RemoteSubnet'),
  requestId?: string(name='RequestId'),
  vcoHealthCheck?: {
    dip?: string(name='Dip'),
    enable?: string(name='Enable'),
    interval?: int32(name='Interval'),
    retry?: int32(name='Retry'),
    sip?: string(name='Sip'),
  }(name='VcoHealthCheck'),
  vpnBgpConfig?: {
    enableBgp?: string(name='EnableBgp'),
    localAsn?: int32(name='LocalAsn'),
    localBgpIp?: string(name='LocalBgpIp'),
    peerAsn?: int32(name='PeerAsn'),
    peerBgpIp?: string(name='PeerBgpIp'),
    status?: string(name='Status'),
    tunnelCidr?: string(name='TunnelCidr'),
  }(name='VpnBgpConfig'),
  vpnConnectionId?: string(name='VpnConnectionId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnConnectionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnConnectionAttributeResponseBody(name='body'),
}

async function modifyVpnConnectionAttribute(request: ModifyVpnConnectionAttributeRequest): ModifyVpnConnectionAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVpnConnectionAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVpnGatewayAttributeRequest {
  autoPropagate?: boolean(name='AutoPropagate', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model ModifyVpnGatewayAttributeResponseBody = {
  autoPropagate?: boolean(name='AutoPropagate'),
  businessStatus?: string(name='BusinessStatus'),
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  enableBgp?: boolean(name='EnableBgp'),
  endTime?: long(name='EndTime'),
  internetIp?: string(name='InternetIp'),
  intranetIp?: string(name='IntranetIp'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  spec?: string(name='Spec'),
  status?: string(name='Status'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  vpnGatewayId?: string(name='VpnGatewayId'),
}

model ModifyVpnGatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnGatewayAttributeResponseBody(name='body'),
}

async function modifyVpnGatewayAttribute(request: ModifyVpnGatewayAttributeRequest): ModifyVpnGatewayAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVpnGatewayAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVpnPbrRouteEntryWeightRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  newWeight: int32(name='NewWeight', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  overlayMode?: string(name='OverlayMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  routeSource: string(name='RouteSource', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model ModifyVpnPbrRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpnPbrRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnPbrRouteEntryWeightResponseBody(name='body'),
}

async function modifyVpnPbrRouteEntryWeight(request: ModifyVpnPbrRouteEntryWeightRequest): ModifyVpnPbrRouteEntryWeightResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVpnPbrRouteEntryWeight', 'POST', '/', 'json', false, 'json', request);
}

model ModifyVpnRouteEntryWeightRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  newWeight: int32(name='NewWeight', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  overlayMode?: string(name='OverlayMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
  weight: int32(name='Weight', position='Query'),
}

model ModifyVpnRouteEntryWeightResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyVpnRouteEntryWeightResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyVpnRouteEntryWeightResponseBody(name='body'),
}

async function modifyVpnRouteEntryWeight(request: ModifyVpnRouteEntryWeightRequest): ModifyVpnRouteEntryWeightResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyVpnRouteEntryWeight', 'POST', '/', 'json', false, 'json', request);
}

model MoveResourceGroupRequest {
  newResourceGroupId: string(name='NewResourceGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model OpenPhysicalConnectionServiceRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model OpenPhysicalConnectionServiceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model OpenPhysicalConnectionServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenPhysicalConnectionServiceResponseBody(name='body'),
}

async function openPhysicalConnectionService(request: OpenPhysicalConnectionServiceRequest): OpenPhysicalConnectionServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenPhysicalConnectionService', 'POST', '/', 'json', false, 'json', request);
}

model OpenTrafficMirrorServiceRequest {
  ownerId?: long(name='OwnerId', position='Query'),
}

model OpenTrafficMirrorServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenTrafficMirrorServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenTrafficMirrorServiceResponseBody(name='body'),
}

async function openTrafficMirrorService(request: OpenTrafficMirrorServiceRequest): OpenTrafficMirrorServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenTrafficMirrorService', 'POST', '/', 'json', false, 'json', request);
}

model PublishVpnRouteEntryRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  nextHop: string(name='NextHop', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publishVpc: boolean(name='PublishVpc', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeDest: string(name='RouteDest', position='Query'),
  routeType: string(name='RouteType', position='Query'),
  vpnGatewayId: string(name='VpnGatewayId', position='Query'),
}

model PublishVpnRouteEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model PublishVpnRouteEntryResponse = {
  headers: map[string]string(name='headers'),
  body: PublishVpnRouteEntryResponseBody(name='body'),
}

async function publishVpnRouteEntry(request: PublishVpnRouteEntryRequest): PublishVpnRouteEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PublishVpnRouteEntry', 'POST', '/', 'json', false, 'json', request);
}

model RecoverPhysicalConnectionRequest {
  dryRun?: boolean(name='DryRun', description='DryRun', position='Query'),
  instanceId: string(name='InstanceId', description='恢复的Pconn', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  token?: string(name='Token', description='幂等Token', position='Query'),
}

model RecoverPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RecoverPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverPhysicalConnectionResponseBody(name='body'),
}

async function recoverPhysicalConnection(request: RecoverPhysicalConnectionRequest): RecoverPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RecoverPhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model RecoverVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
}

model RecoverVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model RecoverVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: RecoverVirtualBorderRouterResponseBody(name='body'),
}

async function recoverVirtualBorderRouter(request: RecoverVirtualBorderRouterRequest): RecoverVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RecoverVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseEipAddressRequest {
  allocationId: string(name='AllocationId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleaseEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseEipAddressResponseBody(name='body'),
}

async function releaseEipAddress(request: ReleaseEipAddressRequest): ReleaseEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseEipSegmentAddressRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  segmentInstanceId: string(name='SegmentInstanceId', position='Query'),
}

model ReleaseEipSegmentAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseEipSegmentAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseEipSegmentAddressResponseBody(name='body'),
}

async function releaseEipSegmentAddress(request: ReleaseEipSegmentAddressRequest): ReleaseEipSegmentAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseEipSegmentAddress', 'POST', '/', 'json', false, 'json', request);
}

model RemoveCommonBandwidthPackageIpRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ipInstanceId: string(name='IpInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RemoveCommonBandwidthPackageIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveCommonBandwidthPackageIpResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveCommonBandwidthPackageIpResponseBody(name='body'),
}

async function removeCommonBandwidthPackageIp(request: RemoveCommonBandwidthPackageIpRequest): RemoveCommonBandwidthPackageIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveCommonBandwidthPackageIp', 'POST', '/', 'json', false, 'json', request);
}

model RemoveGlobalAccelerationInstanceIpRequest {
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId', position='Query'),
  ipInstanceId: string(name='IpInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RemoveGlobalAccelerationInstanceIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveGlobalAccelerationInstanceIpResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveGlobalAccelerationInstanceIpResponseBody(name='body'),
}

async function removeGlobalAccelerationInstanceIp(request: RemoveGlobalAccelerationInstanceIpRequest): RemoveGlobalAccelerationInstanceIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveGlobalAccelerationInstanceIp', 'POST', '/', 'json', false, 'json', request);
}

model RemoveIPv6TranslatorAclListEntryRequest {
  aclEntryId: string(name='AclEntryId', position='Query'),
  aclId: string(name='AclId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RemoveIPv6TranslatorAclListEntryResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveIPv6TranslatorAclListEntryResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveIPv6TranslatorAclListEntryResponseBody(name='body'),
}

async function removeIPv6TranslatorAclListEntry(request: RemoveIPv6TranslatorAclListEntryRequest): RemoveIPv6TranslatorAclListEntryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveIPv6TranslatorAclListEntry', 'POST', '/', 'json', false, 'json', request);
}

model RemoveSourcesFromTrafficMirrorSessionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorSessionId: string(name='TrafficMirrorSessionId', position='Query'),
  trafficMirrorSourceIds: [ string ](name='TrafficMirrorSourceIds', maxLength=128, position='Query'),
}

model RemoveSourcesFromTrafficMirrorSessionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveSourcesFromTrafficMirrorSessionResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveSourcesFromTrafficMirrorSessionResponseBody(name='body'),
}

async function removeSourcesFromTrafficMirrorSession(request: RemoveSourcesFromTrafficMirrorSessionRequest): RemoveSourcesFromTrafficMirrorSessionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveSourcesFromTrafficMirrorSession', 'POST', '/', 'json', false, 'json', request);
}

model ReplaceVpcDhcpOptionsSetRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model ReplaceVpcDhcpOptionsSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReplaceVpcDhcpOptionsSetResponse = {
  headers: map[string]string(name='headers'),
  body: ReplaceVpcDhcpOptionsSetResponseBody(name='body'),
}

async function replaceVpcDhcpOptionsSet(request: ReplaceVpcDhcpOptionsSetRequest): ReplaceVpcDhcpOptionsSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReplaceVpcDhcpOptionsSet', 'POST', '/', 'json', false, 'json', request);
}

model RetryVpcPrefixListAssociationRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  prefixListId: string(name='PrefixListId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model RetryVpcPrefixListAssociationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RetryVpcPrefixListAssociationResponse = {
  headers: map[string]string(name='headers'),
  body: RetryVpcPrefixListAssociationResponseBody(name='body'),
}

async function retryVpcPrefixListAssociation(request: RetryVpcPrefixListAssociationRequest): RetryVpcPrefixListAssociationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RetryVpcPrefixListAssociation', 'POST', '/', 'json', false, 'json', request);
}

model RevokeInstanceFromCenRequest {
  cenId: string(name='CenId', position='Query'),
  cenOwnerId: long(name='CenOwnerId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RevokeInstanceFromCenResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeInstanceFromCenResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeInstanceFromCenResponseBody(name='body'),
}

async function revokeInstanceFromCen(request: RevokeInstanceFromCenRequest): RevokeInstanceFromCenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeInstanceFromCen', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model TerminatePhysicalConnectionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model TerminatePhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminatePhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: TerminatePhysicalConnectionResponseBody(name='body'),
}

async function terminatePhysicalConnection(request: TerminatePhysicalConnectionRequest): TerminatePhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TerminatePhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model TerminateVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
}

model TerminateVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: TerminateVirtualBorderRouterResponseBody(name='body'),
}

async function terminateVirtualBorderRouter(request: TerminateVirtualBorderRouterRequest): TerminateVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TerminateVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model UnTagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnTagResources', 'POST', '/', 'json', false, 'json', request);
}

model UnassociateEipAddressRequest {
  allocationId: string(name='AllocationId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  force?: boolean(name='Force', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnassociateEipAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateEipAddressResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateEipAddressResponseBody(name='body'),
}

async function unassociateEipAddress(request: UnassociateEipAddressRequest): UnassociateEipAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateEipAddress', 'POST', '/', 'json', false, 'json', request);
}

model UnassociateGlobalAccelerationInstanceRequest {
  globalAccelerationInstanceId: string(name='GlobalAccelerationInstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnassociateGlobalAccelerationInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateGlobalAccelerationInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateGlobalAccelerationInstanceResponseBody(name='body'),
}

async function unassociateGlobalAccelerationInstance(request: UnassociateGlobalAccelerationInstanceRequest): UnassociateGlobalAccelerationInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateGlobalAccelerationInstance', 'POST', '/', 'json', false, 'json', request);
}

model UnassociateHaVipRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  force?: string(name='Force', position='Query'),
  haVipId: string(name='HaVipId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  instanceType?: string(name='InstanceType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnassociateHaVipResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateHaVipResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateHaVipResponseBody(name='body'),
}

async function unassociateHaVip(request: UnassociateHaVipRequest): UnassociateHaVipResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateHaVip', 'POST', '/', 'json', false, 'json', request);
}

model UnassociateNetworkAclRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  networkAclId: string(name='NetworkAclId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resource', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnassociateNetworkAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateNetworkAclResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateNetworkAclResponseBody(name='body'),
}

async function unassociateNetworkAcl(request: UnassociateNetworkAclRequest): UnassociateNetworkAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateNetworkAcl', 'POST', '/', 'json', false, 'json', request);
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  physicalConnectionId: string(name='PhysicalConnectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vbrId: string(name='VbrId', position='Query'),
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociatePhysicalConnectionFromVirtualBorderRouterResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociatePhysicalConnectionFromVirtualBorderRouterResponseBody(name='body'),
}

async function unassociatePhysicalConnectionFromVirtualBorderRouter(request: UnassociatePhysicalConnectionFromVirtualBorderRouterRequest): UnassociatePhysicalConnectionFromVirtualBorderRouterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociatePhysicalConnectionFromVirtualBorderRouter', 'POST', '/', 'json', false, 'json', request);
}

model UnassociateRouteTableRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  routeTableId: string(name='RouteTableId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model UnassociateRouteTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateRouteTableResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateRouteTableResponseBody(name='body'),
}

async function unassociateRouteTable(request: UnassociateRouteTableRequest): UnassociateRouteTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateRouteTable', 'POST', '/', 'json', false, 'json', request);
}

model UnassociateVpcCidrBlockRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  secondaryCidrBlock?: string(name='SecondaryCidrBlock', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model UnassociateVpcCidrBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnassociateVpcCidrBlockResponse = {
  headers: map[string]string(name='headers'),
  body: UnassociateVpcCidrBlockResponseBody(name='body'),
}

async function unassociateVpcCidrBlock(request: UnassociateVpcCidrBlockRequest): UnassociateVpcCidrBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnassociateVpcCidrBlock', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDhcpOptionsSetAttributeRequest {
  bootFileName?: string(name='BootFileName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dhcpOptionsSetDescription?: string(name='DhcpOptionsSetDescription', position='Query'),
  dhcpOptionsSetId: string(name='DhcpOptionsSetId', position='Query'),
  dhcpOptionsSetName?: string(name='DhcpOptionsSetName', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  domainNameServers?: string(name='DomainNameServers', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ipv6LeaseTime?: string(name='Ipv6LeaseTime', position='Query'),
  leaseTime?: string(name='LeaseTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  TFTPServerName?: string(name='TFTPServerName', position='Query'),
}

model UpdateDhcpOptionsSetAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDhcpOptionsSetAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDhcpOptionsSetAttributeResponseBody(name='body'),
}

async function updateDhcpOptionsSetAttribute(request: UpdateDhcpOptionsSetAttributeRequest): UpdateDhcpOptionsSetAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDhcpOptionsSetAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGatewayRouteTableEntryAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  destinationCidrBlock: string(name='DestinationCidrBlock', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  iPv4GatewayRouteTableId: string(name='IPv4GatewayRouteTableId', position='Query'),
  name?: string(name='Name', position='Query'),
  nextHopId?: string(name='NextHopId', position='Query'),
  nextHopType: string(name='NextHopType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateGatewayRouteTableEntryAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateGatewayRouteTableEntryAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGatewayRouteTableEntryAttributeResponseBody(name='body'),
}

async function updateGatewayRouteTableEntryAttribute(request: UpdateGatewayRouteTableEntryAttributeRequest): UpdateGatewayRouteTableEntryAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGatewayRouteTableEntryAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIpsecServerRequest {
  clientIpPool?: string(name='ClientIpPool', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: string(name='DryRun', position='Query'),
  effectImmediately?: boolean(name='EffectImmediately', position='Query'),
  ikeConfig?: string(name='IkeConfig', position='Query'),
  ipsecConfig?: string(name='IpsecConfig', position='Query'),
  ipsecServerId: string(name='IpsecServerId', position='Query'),
  ipsecServerName?: string(name='IpsecServerName', maxLength=100, position='Query'),
  localSubnet?: string(name='LocalSubnet', position='Query'),
  psk?: string(name='Psk', position='Query'),
  pskEnabled?: boolean(name='PskEnabled', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateIpsecServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpsecServerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpsecServerResponseBody(name='body'),
}

async function updateIpsecServer(request: UpdateIpsecServerRequest): UpdateIpsecServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIpsecServer', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIpv4GatewayAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ipv4GatewayDescription?: string(name='Ipv4GatewayDescription', position='Query'),
  ipv4GatewayId: string(name='Ipv4GatewayId', position='Query'),
  ipv4GatewayName?: string(name='Ipv4GatewayName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateIpv4GatewayAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpv4GatewayAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpv4GatewayAttributeResponseBody(name='body'),
}

async function updateIpv4GatewayAttribute(request: UpdateIpv4GatewayAttributeRequest): UpdateIpv4GatewayAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIpv4GatewayAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateNatGatewayNatTypeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  natGatewayId: string(name='NatGatewayId', position='Query'),
  natType: string(name='NatType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model UpdateNatGatewayNatTypeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNatGatewayNatTypeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNatGatewayNatTypeResponseBody(name='body'),
}

async function updateNatGatewayNatType(request: UpdateNatGatewayNatTypeRequest): UpdateNatGatewayNatTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNatGatewayNatType', 'POST', '/', 'json', false, 'json', request);
}

model UpdateNetworkAclEntriesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  egressAclEntries?: [ 
    {
      description?: string(name='Description'),
      destinationCidrIp?: string(name='DestinationCidrIp'),
      entryType?: string(name='EntryType'),
      networkAclEntryId?: string(name='NetworkAclEntryId'),
      networkAclEntryName?: string(name='NetworkAclEntryName'),
      policy?: string(name='Policy'),
      port?: string(name='Port'),
      protocol?: string(name='Protocol'),
    }
  ](name='EgressAclEntries', position='Query'),
  ingressAclEntries?: [ 
    {
      description?: string(name='Description'),
      entryType?: string(name='EntryType'),
      networkAclEntryId?: string(name='NetworkAclEntryId'),
      networkAclEntryName?: string(name='NetworkAclEntryName'),
      policy?: string(name='Policy'),
      port?: string(name='Port'),
      protocol?: string(name='Protocol'),
      sourceCidrIp?: string(name='SourceCidrIp'),
    }
  ](name='IngressAclEntries', position='Query'),
  networkAclId: string(name='NetworkAclId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  updateEgressAclEntries?: boolean(name='UpdateEgressAclEntries', position='Query'),
  updateIngressAclEntries?: boolean(name='UpdateIngressAclEntries', position='Query'),
}

model UpdateNetworkAclEntriesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateNetworkAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNetworkAclEntriesResponseBody(name='body'),
}

async function updateNetworkAclEntries(request: UpdateNetworkAclEntriesRequest): UpdateNetworkAclEntriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNetworkAclEntries', 'POST', '/', 'json', false, 'json', request);
}

model UpdatePublicIpAddressPoolAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  publicIpAddressPoolId: string(name='PublicIpAddressPoolId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdatePublicIpAddressPoolAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdatePublicIpAddressPoolAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePublicIpAddressPoolAttributeResponseBody(name='body'),
}

async function updatePublicIpAddressPoolAttribute(request: UpdatePublicIpAddressPoolAttributeRequest): UpdatePublicIpAddressPoolAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdatePublicIpAddressPoolAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTrafficMirrorFilterAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorFilterDescription?: string(name='TrafficMirrorFilterDescription', position='Query'),
  trafficMirrorFilterId: string(name='TrafficMirrorFilterId', position='Query'),
  trafficMirrorFilterName?: string(name='TrafficMirrorFilterName', position='Query'),
}

model UpdateTrafficMirrorFilterAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrafficMirrorFilterAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTrafficMirrorFilterAttributeResponseBody(name='body'),
}

async function updateTrafficMirrorFilterAttribute(request: UpdateTrafficMirrorFilterAttributeRequest): UpdateTrafficMirrorFilterAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTrafficMirrorFilterAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTrafficMirrorFilterRuleAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  destinationCidrBlock?: string(name='DestinationCidrBlock', position='Query'),
  destinationPortRange?: string(name='DestinationPortRange', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  priority?: int32(name='Priority', position='Query'),
  protocol?: string(name='Protocol', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  ruleAction?: string(name='RuleAction', position='Query'),
  sourceCidrBlock?: string(name='SourceCidrBlock', position='Query'),
  sourcePortRange?: string(name='SourcePortRange', position='Query'),
  trafficMirrorFilterRuleId: string(name='TrafficMirrorFilterRuleId', position='Query'),
}

model UpdateTrafficMirrorFilterRuleAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrafficMirrorFilterRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTrafficMirrorFilterRuleAttributeResponseBody(name='body'),
}

async function updateTrafficMirrorFilterRuleAttribute(request: UpdateTrafficMirrorFilterRuleAttributeRequest): UpdateTrafficMirrorFilterRuleAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTrafficMirrorFilterRuleAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateTrafficMirrorSessionAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  enabled?: boolean(name='Enabled', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  priority?: int32(name='Priority', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  trafficMirrorFilterId?: string(name='TrafficMirrorFilterId', position='Query'),
  trafficMirrorSessionDescription?: string(name='TrafficMirrorSessionDescription', position='Query'),
  trafficMirrorSessionId: string(name='TrafficMirrorSessionId', position='Query'),
  trafficMirrorSessionName?: string(name='TrafficMirrorSessionName', position='Query'),
  trafficMirrorTargetId?: string(name='TrafficMirrorTargetId', position='Query'),
  trafficMirrorTargetType?: string(name='TrafficMirrorTargetType', position='Query'),
  virtualNetworkId?: int32(name='VirtualNetworkId', position='Query'),
}

model UpdateTrafficMirrorSessionAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrafficMirrorSessionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTrafficMirrorSessionAttributeResponseBody(name='body'),
}

async function updateTrafficMirrorSessionAttribute(request: UpdateTrafficMirrorSessionAttributeRequest): UpdateTrafficMirrorSessionAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTrafficMirrorSessionAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVirtualBorderBandwidthRequest {
  bandwidth: int32(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  virtualBorderRouterId: string(name='VirtualBorderRouterId', position='Query'),
}

model UpdateVirtualBorderBandwidthResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateVirtualBorderBandwidthResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVirtualBorderBandwidthResponseBody(name='body'),
}

async function updateVirtualBorderBandwidth(request: UpdateVirtualBorderBandwidthRequest): UpdateVirtualBorderBandwidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVirtualBorderBandwidth', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVirtualPhysicalConnectionRequest {
  dryRun?: boolean(name='DryRun', description='DryRun', position='Query'),
  expectSpec?: string(name='ExpectSpec', description='ExpectSpec', position='Query'),
  instanceId: string(name='InstanceId', description='Vpconn的实例ID', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  token?: string(name='Token', description='幂等Token', position='Query'),
  vlanId: long(name='VlanId', description='vpconn的VlanID', position='Query'),
}

model UpdateVirtualPhysicalConnectionResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: string(name='Success', description='是否修改成功'),
}

model UpdateVirtualPhysicalConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVirtualPhysicalConnectionResponseBody(name='body'),
}

async function updateVirtualPhysicalConnection(request: UpdateVirtualPhysicalConnectionRequest): UpdateVirtualPhysicalConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVirtualPhysicalConnection', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVpcGatewayEndpointAttributeRequest {
  clientToken?: string(name='ClientToken', description='幂等参数', position='Query'),
  dryRun?: boolean(name='DryRun', description='是否只预检此次请求', position='Query'),
  endpointDescription?: string(name='EndpointDescription', description='网关节点描述', position='Query'),
  endpointId: string(name='EndpointId', description='VPC网关实例ID', position='Query'),
  endpointName?: string(name='EndpointName', description='网关节点名称', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  policyDocument?: string(name='PolicyDocument', description='访问云服务的权限控制策略', position='Query'),
  regionId: string(name='RegionId', description='地域', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpdateVpcGatewayEndpointAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateVpcGatewayEndpointAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVpcGatewayEndpointAttributeResponseBody(name='body'),
}

async function updateVpcGatewayEndpointAttribute(request: UpdateVpcGatewayEndpointAttributeRequest): UpdateVpcGatewayEndpointAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVpcGatewayEndpointAttribute', 'POST', '/', 'json', false, 'json', request);
}

