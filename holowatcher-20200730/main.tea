/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('holowatcher', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CheckImageRequest {
  imagePath?: string(name='ImagePath'),
}

model CheckImageResponseBody = {
  requestId?: string(name='RequestId'),
  msgInfo?: string(name='MsgInfo'),
  msgCode?: string(name='MsgCode'),
  error?: string(name='Error'),
  data?: map[string]any(name='Data'),
  success?: boolean(name='Success'),
}

model CheckImageResponse = {
  headers: map[string]string(name='headers'),
  body: CheckImageResponseBody(name='body'),
}

async function checkImageWithOptions(request: CheckImageRequest, runtime: Util.RuntimeOptions): CheckImageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckImage', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkImage(request: CheckImageRequest): CheckImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkImageWithOptions(request, runtime);
}

model DeleteQRCodeRequest {
  SId?: string(name='SId', description='sId'),
}

model DeleteQRCodeResponseBody = {
  msgInfo?: string(name='MsgInfo', description='msgInfo'),
  msgCode?: string(name='MsgCode', description='msgCode'),
  error?: string(name='Error', description='error'),
  requestId?: string(name='RequestId', description='traceId'),
  data?: string(name='Data', description='data'),
  success?: boolean(name='Success', description='success'),
}

model DeleteQRCodeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQRCodeResponseBody(name='body'),
}

async function deleteQRCodeWithOptions(request: DeleteQRCodeRequest, runtime: Util.RuntimeOptions): DeleteQRCodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteQRCode', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteQRCode(request: DeleteQRCodeRequest): DeleteQRCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQRCodeWithOptions(request, runtime);
}

model PublishRealRequest {
  datasetId?: long(name='DatasetId', description='datasetId'),
  tag?: string(name='Tag', description='tag'),
  projectId?: long(name='ProjectId', description='projectId'),
}

model PublishRealResponseBody = {
  msgInfo?: string(name='MsgInfo', description='msgInfo'),
  msgCode?: string(name='MsgCode', description='msgCode'),
  error?: string(name='Error', description='error'),
  requestId?: string(name='RequestId', description='traceId'),
  data?: string(name='Data', description='data'),
  success?: boolean(name='Success', description='success'),
}

model PublishRealResponse = {
  headers: map[string]string(name='headers'),
  body: PublishRealResponseBody(name='body'),
}

async function publishRealWithOptions(request: PublishRealRequest, runtime: Util.RuntimeOptions): PublishRealResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PublishReal', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function publishReal(request: PublishRealRequest): PublishRealResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishRealWithOptions(request, runtime);
}

model ProduceExpoNoticeRequest {
  bizType?: string(name='BizType', description='A short description of struct'),
  operationType?: string(name='OperationType'),
  extInfo?: string(name='ExtInfo'),
  userId?: long(name='UserId'),
}

model ProduceExpoNoticeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  msgInfo?: string(name='MsgInfo'),
  msgCode?: string(name='MsgCode'),
  error?: string(name='Error'),
  data?: map[string]any(name='Data'),
  success?: boolean(name='Success'),
}

model ProduceExpoNoticeResponse = {
  headers: map[string]string(name='headers'),
  body: ProduceExpoNoticeResponseBody(name='body'),
}

async function produceExpoNoticeWithOptions(request: ProduceExpoNoticeRequest, runtime: Util.RuntimeOptions): ProduceExpoNoticeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ProduceExpoNotice', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function produceExpoNotice(request: ProduceExpoNoticeRequest): ProduceExpoNoticeResponse {
  var runtime = new Util.RuntimeOptions{};
  return produceExpoNoticeWithOptions(request, runtime);
}

model PublishGalleryRequest {
  template?: string(name='Template'),
  datasetId?: long(name='DatasetId'),
  tag?: string(name='Tag'),
}

model PublishGalleryResponseBody = {
  requestId?: string(name='RequestId'),
  msgInfo?: string(name='MsgInfo'),
  msgCode?: string(name='MsgCode'),
  error?: string(name='Error'),
  data?: map[string]any(name='Data'),
  success?: boolean(name='Success'),
}

model PublishGalleryResponse = {
  headers: map[string]string(name='headers'),
  body: PublishGalleryResponseBody(name='body'),
}

async function publishGalleryWithOptions(request: PublishGalleryRequest, runtime: Util.RuntimeOptions): PublishGalleryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PublishGallery', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function publishGallery(request: PublishGalleryRequest): PublishGalleryResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishGalleryWithOptions(request, runtime);
}

model GetTokenRequest {
  pathType?: string(name='PathType'),
}

model GetTokenResponseBody = {
  requestId?: string(name='RequestId'),
  msgInfo?: string(name='MsgInfo'),
  msgCode?: string(name='MsgCode'),
  error?: string(name='Error'),
  data?: map[string]any(name='Data'),
  success?: boolean(name='Success'),
}

model GetTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetTokenResponseBody(name='body'),
}

async function getTokenWithOptions(request: GetTokenRequest, runtime: Util.RuntimeOptions): GetTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetToken', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getToken(request: GetTokenRequest): GetTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTokenWithOptions(request, runtime);
}

model DeleteMaterialRequest {
  id?: long(name='Id'),
}

model DeleteMaterialResponseBody = {
  requestId?: string(name='RequestId'),
  msgInfo?: string(name='MsgInfo'),
  msgCode?: string(name='MsgCode'),
  error?: string(name='Error'),
  data?: map[string]any(name='Data'),
  success?: boolean(name='Success'),
}

model DeleteMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMaterialResponseBody(name='body'),
}

async function deleteMaterialWithOptions(request: DeleteMaterialRequest, runtime: Util.RuntimeOptions): DeleteMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMaterial', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMaterial(request: DeleteMaterialRequest): DeleteMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMaterialWithOptions(request, runtime);
}

model AddQRCodeRequest {
  datasetId?: long(name='DatasetId', description='datasetId'),
  tag?: string(name='Tag', description='tag'),
}

model AddQRCodeResponseBody = {
  msgInfo?: string(name='MsgInfo', description='msgInfo'),
  msgCode?: string(name='MsgCode', description='msgCode'),
  error?: string(name='Error', description='error'),
  requestId?: string(name='RequestId', description='traceId'),
  data?: string(name='Data', description='data'),
  success?: boolean(name='Success', description='success'),
}

model AddQRCodeResponse = {
  headers: map[string]string(name='headers'),
  body: AddQRCodeResponseBody(name='body'),
}

async function addQRCodeWithOptions(request: AddQRCodeRequest, runtime: Util.RuntimeOptions): AddQRCodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddQRCode', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addQRCode(request: AddQRCodeRequest): AddQRCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return addQRCodeWithOptions(request, runtime);
}

model CommonRequestRequest {
  api?: string(name='Api', description='A short description of struct'),
  userType?: string(name='UserType'),
  params?: string(name='Params'),
  userId?: string(name='UserId'),
  bizOrderNo?: string(name='BizOrderNo'),
}

model CommonRequestResponseBody = {
  traceId?: string(name='TraceId', description='Id of the request'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  retry?: boolean(name='Retry'),
  errorMsg?: string(name='ErrorMsg'),
  resultObj?: string(name='ResultObj'),
  requestId?: string(name='RequestId'),
}

model CommonRequestResponse = {
  headers: map[string]string(name='headers'),
  body: CommonRequestResponseBody(name='body'),
}

async function commonRequestWithOptions(request: CommonRequestRequest, runtime: Util.RuntimeOptions): CommonRequestResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CommonRequest', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function commonRequest(request: CommonRequestRequest): CommonRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  return commonRequestWithOptions(request, runtime);
}

model TransTextToAudioRequest {
  text?: string(name='Text', description='text'),
}

model TransTextToAudioResponseBody = {
  msgInfo?: string(name='MsgInfo', description='msgInfo'),
  msgCode?: string(name='MsgCode', description='msgCode'),
  error?: string(name='Error', description='error'),
  traceId?: string(name='TraceId', description='traceId'),
  data?: string(name='Data', description='data'),
  success?: boolean(name='Success', description='success'),
}

model TransTextToAudioResponse = {
  headers: map[string]string(name='headers'),
  body: TransTextToAudioResponseBody(name='body'),
}

async function transTextToAudioWithOptions(request: TransTextToAudioRequest, runtime: Util.RuntimeOptions): TransTextToAudioResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TransTextToAudio', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function transTextToAudio(request: TransTextToAudioRequest): TransTextToAudioResponse {
  var runtime = new Util.RuntimeOptions{};
  return transTextToAudioWithOptions(request, runtime);
}

model CreateMaterialRequest {
  path?: string(name='Path'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  uuid?: string(name='Uuid'),
  clientToken?: string(name='ClientToken'),
}

model CreateMaterialResponseBody = {
  requestId?: string(name='RequestId'),
  msgInfo?: string(name='MsgInfo'),
  msgCode?: string(name='MsgCode'),
  error?: string(name='Error'),
  data?: map[string]any(name='Data'),
  success?: boolean(name='Success'),
}

model CreateMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMaterialResponseBody(name='body'),
}

async function createMaterialWithOptions(request: CreateMaterialRequest, runtime: Util.RuntimeOptions): CreateMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMaterial', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMaterial(request: CreateMaterialRequest): CreateMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMaterialWithOptions(request, runtime);
}

model QueryQRCodeInfoRequest {
  SId?: string(name='SId', description='sId'),
}

model QueryQRCodeInfoResponseBody = {
  msgInfo?: string(name='MsgInfo', description='msgInfo'),
  msgCode?: string(name='MsgCode', description='msgCode'),
  error?: string(name='Error', description='error'),
  requestId?: string(name='RequestId', description='traceId'),
  data?: string(name='Data', description='data'),
  success?: boolean(name='Success', description='success'),
}

model QueryQRCodeInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryQRCodeInfoResponseBody(name='body'),
}

async function queryQRCodeInfoWithOptions(request: QueryQRCodeInfoRequest, runtime: Util.RuntimeOptions): QueryQRCodeInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryQRCodeInfo', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryQRCodeInfo(request: QueryQRCodeInfoRequest): QueryQRCodeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryQRCodeInfoWithOptions(request, runtime);
}

model GetTemplateListRequest {
  current?: int32(name='Current'),
  size?: int32(name='Size'),
  style?: string(name='Style'),
  id?: long(name='Id'),
  type?: string(name='Type'),
  spec?: string(name='Spec'),
  name?: string(name='Name'),
}

model GetTemplateListResponseBody = {
  requestId?: string(name='RequestId'),
  msgInfo?: string(name='MsgInfo'),
  msgCode?: string(name='MsgCode'),
  error?: string(name='Error'),
  data?: map[string]any(name='Data'),
  success?: boolean(name='Success'),
}

model GetTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateListResponseBody(name='body'),
}

async function getTemplateListWithOptions(request: GetTemplateListRequest, runtime: Util.RuntimeOptions): GetTemplateListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetTemplateList', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getTemplateList(request: GetTemplateListRequest): GetTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTemplateListWithOptions(request, runtime);
}

model GetMaterialListRequest {
  current?: int32(name='Current'),
  size?: int32(name='Size'),
  name?: string(name='Name'),
  type?: string(name='Type'),
}

model GetMaterialListResponseBody = {
  requestId?: string(name='RequestId'),
  msgInfo?: string(name='MsgInfo'),
  msgCode?: string(name='MsgCode'),
  error?: string(name='Error'),
  data?: map[string]any(name='Data'),
  success?: boolean(name='Success'),
}

model GetMaterialListResponse = {
  headers: map[string]string(name='headers'),
  body: GetMaterialListResponseBody(name='body'),
}

async function getMaterialListWithOptions(request: GetMaterialListRequest, runtime: Util.RuntimeOptions): GetMaterialListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetMaterialList', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getMaterialList(request: GetMaterialListRequest): GetMaterialListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMaterialListWithOptions(request, runtime);
}

model ProduceNoticeRequest {
  bizType?: string(name='BizType'),
  bizId?: string(name='BizId'),
  operationType?: string(name='OperationType'),
  extInfo?: string(name='ExtInfo'),
  userId?: long(name='UserId'),
}

model ProduceNoticeResponseBody = {
  requestId?: string(name='RequestId'),
  msgInfo?: string(name='MsgInfo'),
  msgCode?: string(name='MsgCode'),
  error?: string(name='Error'),
  data?: map[string]any(name='Data'),
  success?: boolean(name='Success'),
}

model ProduceNoticeResponse = {
  headers: map[string]string(name='headers'),
  body: ProduceNoticeResponseBody(name='body'),
}

async function produceNoticeWithOptions(request: ProduceNoticeRequest, runtime: Util.RuntimeOptions): ProduceNoticeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ProduceNotice', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function produceNotice(request: ProduceNoticeRequest): ProduceNoticeResponse {
  var runtime = new Util.RuntimeOptions{};
  return produceNoticeWithOptions(request, runtime);
}

model QueryAccountLabelRequest {
  PK?: long(name='PK'),
  labelSeries?: string(name='LabelSeries'),
  token?: string(name='Token'),
}

model QueryAccountLabelResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  count?: int32(name='Count'),
  message?: string(name='Message'),
  data?: [ 
    {
      label?: string(name='Label'),
      labelSeries?: string(name='LabelSeries'),
    }
  ](name='Data'),
}

model QueryAccountLabelResponse = {
  headers: map[string]string(name='headers'),
  body: QueryAccountLabelResponseBody(name='body'),
}

async function queryAccountLabelWithOptions(request: QueryAccountLabelRequest, runtime: Util.RuntimeOptions): QueryAccountLabelResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryAccountLabel', '2020-07-30', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryAccountLabel(request: QueryAccountLabelRequest): QueryAccountLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccountLabelWithOptions(request, runtime);
}

