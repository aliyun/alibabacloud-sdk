/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'elasticsearch';
  @version = '2017-06-13';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model ClientNodeConfiguration {
  amount: long(name='amount', description='协调节点数量', minimum=2, maximum=25),
  disk: long(name='disk', description='协调节点磁盘大小', minimum=20, maximum=20),
  diskType: string(name='diskType', description='协调节点磁盘类型'),
  spec: string(name='spec', description='协调节点规格'),
}

model DictInfo {
  fileSize?: long(name='fileSize', description='词典文件大小'),
  name?: string(name='name', description='词典文件名称'),
  sourceType?: string(name='sourceType', description='词典来源'),
  type?: string(name='type', description='词典类型'),
}

model ElasticDataNodeConfiguration {
  amount?: long(name='amount', description='弹性节点数量', minimum=2, maximum=50),
  disk?: long(name='disk', description='弹性节点磁盘大小', minimum=20, maximum=20480),
  diskEncryption?: boolean(name='diskEncryption', description='弹性节点磁盘加密'),
  diskType?: string(name='diskType', description='弹性节点磁盘类型'),
  performanceLevel?: string(name='performanceLevel', description='弹性节点essd磁盘等级'),
  spec: string(name='spec', description='弹性节点规格'),
}

model Elasticsearch {
  advancedDedicateMaster?: boolean(name='advancedDedicateMaster', description='开启新版专有主节点'),
  advancedSetting?: {
    gcName?: string(name='gcName', description='GC垃圾回收器名称'),
  }(name='advancedSetting', description='高级配置'),
  aliwsDicts?: [
    DictInfo
  ](name='aliwsDicts', description='Aliws词典配置'),
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration', description='协调节点配置'),
  createdAt?: string(name='createdAt', description='创建时间'),
  dataNode?: boolean(name='dataNode', description='是否包含数据节点'),
  dedicateMaster?: boolean(name='dedicateMaster', description='是否包含旧专有主节点'),
  description?: string(name='description', description='集群自定义名称'),
  dictList?: [
    DictInfo
  ](name='dictList', description='IK词典配置'),
  domain?: string(name='domain', description='Elasticsearch集群私网访问链接'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork', description='是否开启Kibana私网访问'),
  enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork', description='是否开启kibana公网访问'),
  enablePublic?: boolean(name='enablePublic', description='Elasticsearch是否开启公网访问'),
  endTime?: long(name='endTime', description='集群到期时间，后付费实例默认100年'),
  esConfig?: map[string]string(name='esConfig', description='Elasticsearch集群settings配置'),
  esIPWhitelist?: [ string ](name='esIPWhitelist', description='Elasticsearch集群私网访问白名单。已废弃'),
  esVersion?: string(name='esVersion', description='实例版本'),
  extendConfigs?: [  map[string]any ](name='extendConfigs', description='集群扩展参数配置'),
  haveClientNode?: boolean(name='haveClientNode', description='是否开启协调节点'),
  haveElasticDataNode?: boolean(name='haveElasticDataNode', description='是否开启弹性节点'),
  haveKibana?: boolean(name='haveKibana', description='存在kibana节点'),
  ikHotDicts?: [
    DictInfo
  ](name='ikHotDicts', description='IK热词词典配置'),
  instanceId?: string(name='instanceId', description='实例ID'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  kibanaDomain?: string(name='kibanaDomain', description='Kibana公网访问链接'),
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist', description='Kibana公网访问白名单'),
  kibanaPort?: long(name='kibanaPort', description='Kibana公网访问端口号'),
  kibanaPrivateDomain?: string(name='kibanaPrivateDomain', description='Kibana私网访问链接'),
  kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist', description='Kibana节点私网访问IP'),
  kibanaPrivatePort?: long(name='kibanaPrivatePort', description='Kibana私网访问端口号'),
  kibanaProtocol?: string(name='kibanaProtocol', description='Kibana访问协议'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  networkConfig?: NetworkConfig(name='networkConfig', description='实例网络设置'),
  nodeAmount?: long(name='nodeAmount', description='Elasticseach集群热数据节点数量'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  paymentType?: string(name='paymentType', description='实例付费类型'),
  port?: long(name='port', description='集群私网访问端口'),
  privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList', description='Elasticsearch集群私网访问白名单'),
  productType?: string(name='productType', description='实例类型'),
  protocol?: string(name='protocol', description='Elasticsearch集群访问协议'),
  publicDomain?: string(name='publicDomain', description='Elasticsearch公网访问'),
  publicIpWhitelist?: [ string ](name='publicIpWhitelist', description='Elasticsearch集群公网访问IP'),
  publicPort?: long(name='publicPort', description='Elasticsearch集群公网访问端口号'),
  readWritePolicy?: ReadWritePolicy(name='readWritePolicy'),
  resourceGroupId?: string(name='resourceGroupId', description='资源组标识'),
  serviceVpc?: boolean(name='serviceVpc', description='云服务VPC'),
  status?: string(name='status', description='集群变更状态'),
  synonymsDicts?: [
    DictInfo
  ](name='synonymsDicts', description='实例同义词配置'),
  tags?: [
    Tag
  ](name='tags', description='标签'),
  updatedAt?: string(name='updatedAt', description='实例修改时间'),
  warmNode?: boolean(name='warmNode', description='是否开启冷节点'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  zoneCount?: long(name='zoneCount', description='实例所在可用区数量'),
  zoneInfos?: [
    ZoneInfo
  ](name='zoneInfos', description='集群可用区分布状态'),
}

model KibanaNodeConfiguration {
  amount?: long(name='amount', description='Kibana节点数量', minimum=1, maximum=1),
  disk?: long(name='disk', description='Kibana节点磁盘大小'),
  spec: string(name='spec', description='Kibana节点规格'),
}

model Logstash {
  config?: map[string]string(name='config', description='Config'),
  createdAt?: string(name='createdAt', description='CreatedAt'),
  dataNode?: boolean(name='dataNode', description='DataNode'),
  description?: string(name='description', description='Description'),
  endTime?: long(name='endTime', description='EndTime'),
  endpointList?: [ 
    {
      host?: string(name='host', description='Host'),
      port?: long(name='port', description='Port'),
      zoneId?: string(name='zoneId', description='ZoneId'),
    }
  ](name='endpointList', description='EndpointList'),
  instanceId?: string(name='instanceId', description='InstanceId'),
  networkConfig?: {
    type?: string(name='type', description='Type'),
    vpcId?: string(name='vpcId', description='VpcId'),
    vsArea?: string(name='vsArea', description='VsArea'),
    vswitchId?: string(name='vswitchId', description='VswitchId'),
  }(name='networkConfig', description='NetworkConfig'),
  nodeAmount?: long(name='nodeAmount', description='NodeAmount'),
  nodeSpec?: {
    disk?: long(name='disk', description='Disk'),
    diskType?: string(name='diskType', description='DiskType'),
    spec?: string(name='spec', description='Spec'),
  }(name='nodeSpec', description='NodeSpec'),
  paymentType?: string(name='paymentType', description='PaymentType'),
  protocol?: string(name='protocol', description='Protocol'),
  resourceGroupId?: string(name='resourceGroupId', description='ResourceGroupId'),
  status?: string(name='status', description='Status'),
  tags?: [ 
    {
      tagKey?: string(name='tagKey', description='TagKey'),
      tagValue?: string(name='tagValue', description='TagValue'),
    }
  ](name='tags', description='Tags'),
  updatedAt?: string(name='updatedAt', description='UpdatedAt'),
  version?: string(name='version', description='Version'),
  zoneCount?: long(name='zoneCount', description='ZoneCount'),
  zoneInfos?: [ 
    {
      status?: string(name='status', description='Status'),
      zoneId?: string(name='zoneId', description='ZoneId'),
    }
  ](name='zoneInfos', description='ZoneInfos'),
}

model MasterNodeConfiguration {
  amount: long(name='amount', description='专有主节点数量', minimum=3, maximum=3),
  disk: long(name='disk', description='专有主节点磁盘大小', minimum=20, maximum=20),
  diskType: string(name='diskType', description='专有主节点磁盘类型'),
  spec: string(name='spec', description='专有主节点规格'),
}

model NetworkConfig {
  type?: string(name='type', description='网络类型'),
  vpcId?: string(name='vpcId', description='专有网络VPC标识'),
  vsArea?: string(name='vsArea', description='网络所属可用区'),
  vswitchId?: string(name='vswitchId', description='专有网络交换机标识'),
  whiteIpGroupList?: [
    WhiteIpGroup
  ](name='whiteIpGroupList', description='IP白名单分组列表'),
}

model NodeInfo {
  host?: string(name='host', description='节点IP'),
  hostName?: string(name='hostName', description='节点名称'),
  port?: long(name='port', description='节点端口号'),
  zoneId?: string(name='zoneId', description='节点所在可用区标识'),
}

model NodeSpec {
  disk?: int32(name='disk', description='数据节点磁盘大小', minimum=20, maximum=20480),
  diskEncryption?: boolean(name='diskEncryption', description='数据节点磁盘加密'),
  diskType?: string(name='diskType', description='数据节点磁盘类型'),
  performanceLevel?: string(name='performanceLevel', description='数据节点essd磁盘等级'),
  spec: string(name='spec', description='数据节点规格'),
}

model PaymentInfo {
  autoRenewDuration?: long(name='autoRenewDuration', description='自动续费时间周期'),
  duration?: long(name='duration', description='预付费时间数'),
  isAutoRenew?: boolean(name='isAutoRenew', description='到期是否自动续费'),
  pricingCycle?: string(name='pricingCycle', description='预付费时间单位'),
}

model ReadWritePolicy {
  autoGeneratePk?: boolean(name='autoGeneratePk', description='是否开启自动主键'),
  writeHa?: boolean(name='writeHa', description='是否开启读写分离'),
  writePolicy?: string(name='writePolicy', description='读写分离方式'),
}

model Tag {
  tagKey?: string(name='tagKey', description='标签Key'),
  tagValue?: string(name='tagValue', description='标签Value'),
}

model WarmNodeConfiguration {
  amount?: long(name='amount', description='节点数量', minimum=1, maximum=50),
  disk?: long(name='disk', description='节点磁盘', minimum=500, maximum=20480),
  diskEncryption?: boolean(name='diskEncryption', description='节点磁盘加密'),
  diskType?: string(name='diskType', description='节点磁盘类型'),
  performanceLevel?: string(name='performanceLevel', description='节点essd磁盘等级'),
  spec: string(name='spec', description='节点规格'),
}

model WhiteIpGroup {
  whiteIpType?: string(name='WhiteIpType', description='IP白名单分组类型'),
  groupName?: string(name='groupName', description='IP白名单分组名称'),
  ips?: [ string ](name='ips', description='IP白名单列表'),
}

model ZoneInfo {
  status?: string(name='status', description='可用区状态'),
  zoneId?: string(name='zoneId', description='可用区唯一标识'),
}

model ActivateZonesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model ActivateZonesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ActivateZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateZonesResponseBody(name='body'),
}

async function activateZones(request: ActivateZonesRequest): ActivateZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ActivateZones', 'POST', '/openapi/instances/{InstanceId}/actions/recover-zones', 'json', false, 'json', request);
}

model AddConnectableClusterRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model AddConnectableClusterResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model AddConnectableClusterResponse = {
  headers: map[string]string(name='headers'),
  body: AddConnectableClusterResponseBody(name='body'),
}

async function addConnectableCluster(request: AddConnectableClusterRequest): AddConnectableClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AddConnectableCluster', 'POST', '/openapi/instances/{InstanceId}/connected-clusters', 'json', false, 'json', request);
}

model AddSnapshotRepoRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
}

model AddSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model AddSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  body: AddSnapshotRepoResponseBody(name='body'),
}

async function addSnapshotRepo(request: AddSnapshotRepoRequest): AddSnapshotRepoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AddSnapshotRepo', 'POST', '/openapi/instances/{InstanceId}/snapshot-repos', 'json', false, 'json', request);
}

model CancelDeletionRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model CancelDeletionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelDeletionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelDeletionResponseBody(name='body'),
}

async function cancelDeletion(request: CancelDeletionRequest): CancelDeletionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelDeletion', 'POST', '/openapi/instances/{InstanceId}/actions/cancel-deletion', 'json', false, 'json', request);
}

model CancelLogstashDeletionRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model CancelLogstashDeletionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelLogstashDeletionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelLogstashDeletionResponseBody(name='body'),
}

async function cancelLogstashDeletion(request: CancelLogstashDeletionRequest): CancelLogstashDeletionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelLogstashDeletion', 'POST', '/openapi/logstashes/{InstanceId}/actions/cancel-deletion', 'json', false, 'json', request);
}

model CancelTaskRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
  taskType: string(name='taskType', position='Query'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelTask', 'POST', '/openapi/instances/{InstanceId}/actions/cancel-task', 'json', false, 'json', request);
}

model CapacityPlanRequest {
  complexQueryAvailable?: boolean(name='complexQueryAvailable', position='Body'),
  dataInfo?: [ 
    {
      code?: string(name='code'),
      size?: long(name='size'),
      totalCount?: int32(name='totalCount'),
      type?: string(name='type'),
      unit?: string(name='unit'),
    }
  ](name='dataInfo', position='Body'),
  metric?: [ 
    {
      averageQps?: int32(name='averageQps'),
      code?: string(name='code'),
      concurrent?: long(name='concurrent'),
      peakQps?: int32(name='peakQps'),
      responseTime?: int32(name='responseTime'),
      throughput?: long(name='throughput'),
      type?: string(name='type'),
    }
  ](name='metric', position='Body'),
  usageScenario?: string(name='usageScenario', position='Body'),
}

model CapacityPlanResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    extendConfigs?: [ 
      {
        configType?: string(name='ConfigType'),
        disk?: long(name='Disk'),
        diskType?: string(name='DiskType'),
      }
    ](name='ExtendConfigs'),
    instanceCategory?: string(name='InstanceCategory'),
    nodeConfigurations?: [ 
      {
        amount?: long(name='Amount'),
        cpu?: long(name='Cpu'),
        disk?: long(name='Disk'),
        diskType?: string(name='DiskType'),
        memory?: long(name='Memory'),
        nodeType?: string(name='NodeType'),
      }
    ](name='NodeConfigurations'),
    oversizedCluster?: boolean(name='OversizedCluster'),
  }(name='Result'),
}

model CapacityPlanResponse = {
  headers: map[string]string(name='headers'),
  body: CapacityPlanResponseBody(name='body'),
}

async function capacityPlan(request: CapacityPlanRequest): CapacityPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CapacityPlan', 'POST', '/openapi/assist/actions/capacity-plan', 'json', false, 'json', request);
}

model CloseDiagnosisRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  lang?: string(name='lang', position='Query'),
}

model CloseDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CloseDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: CloseDiagnosisResponseBody(name='body'),
}

async function closeDiagnosis(request: CloseDiagnosisRequest): CloseDiagnosisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CloseDiagnosis', 'POST', '/openapi/diagnosis/instances/{InstanceId}/actions/close-diagnosis', 'json', false, 'json', request);
}

model CloseHttpsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model CloseHttpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CloseHttpsResponse = {
  headers: map[string]string(name='headers'),
  body: CloseHttpsResponseBody(name='body'),
}

async function closeHttps(request: CloseHttpsRequest): CloseHttpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CloseHttps', 'POST', '/openapi/instances/{InstanceId}/actions/close-https', 'json', false, 'json', request);
}

model CloseManagedIndexRequest {
  instanceId: string(name='InstanceId', position='Path'),
  index: string(name='Index', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model CloseManagedIndexResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CloseManagedIndexResponse = {
  headers: map[string]string(name='headers'),
  body: CloseManagedIndexResponseBody(name='body'),
}

async function closeManagedIndex(request: CloseManagedIndexRequest): CloseManagedIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CloseManagedIndex', 'POST', '/openapi/instances/{InstanceId}/indices/{Index}/close-managed', 'json', false, 'json', request);
}

model CreateCollectorRequest {
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model CreateCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    resId?: string(name='resId'),
  }(name='Result'),
}

model CreateCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCollectorResponseBody(name='body'),
}

async function createCollector(request: CreateCollectorRequest): CreateCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCollector', 'POST', '/openapi/collectors', 'json', false, 'json', request);
}

model CreateComponentIndexRequest {
  instanceId: string(name='InstanceId', description='A short description of struct', position='Path'),
  name: string(name='name', position='Path'),
  meta?: map[string]any(name='_meta', position='Body'),
  template?: {
    aliases?: map[string]any(name='aliases'),
    mappings?: map[string]any(name='mappings'),
    settings?: map[string]any(name='settings'),
  }(name='template', position='Body'),
}

model CreateComponentIndexResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  result?: boolean(name='Result'),
}

model CreateComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  body: CreateComponentIndexResponseBody(name='body'),
}

async function createComponentIndex(request: CreateComponentIndexRequest): CreateComponentIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateComponentIndex', 'POST', '/openapi/instances/{InstanceId}/component-index/{name}', 'json', false, 'json', request);
}

model CreateDataStreamRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model CreateDataStreamResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    name?: string(name='name'),
  }(name='Result'),
}

model CreateDataStreamResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataStreamResponseBody(name='body'),
}

async function createDataStream(request: CreateDataStreamRequest): CreateDataStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateDataStream', 'POST', '/openapi/instances/{InstanceId}/data-streams', 'json', false, 'json', request);
}

model CreateDataTasksRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model CreateDataTasksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        index?: string(name='index'),
        mapping?: string(name='mapping'),
        password?: string(name='password'),
        routing?: string(name='routing'),
        settings?: string(name='settings'),
        type?: string(name='type'),
        username?: string(name='username'),
        vpcId?: string(name='vpcId'),
        vpcInstanceId?: string(name='vpcInstanceId'),
        vpcInstancePort?: string(name='vpcInstancePort'),
      }(name='sinkCluster'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        endpoint?: string(name='endpoint'),
        index?: string(name='index'),
        password?: string(name='password'),
        type?: string(name='type'),
        username?: string(name='username'),
        vpcId?: string(name='vpcId'),
        vpcInstanceId?: string(name='vpcInstanceId'),
        vpcInstancePort?: int32(name='vpcInstancePort'),
      }(name='sourceCluster'),
    }
  ](name='Result'),
}

model CreateDataTasksResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataTasksResponseBody(name='body'),
}

async function createDataTasks(request: CreateDataTasksRequest): CreateDataTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateDataTasks', 'POST', '/openapi/instances/{InstanceId}/data-task', 'json', false, 'json', request);
}

model CreateILMPolicyRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model CreateILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateILMPolicyResponseBody(name='body'),
}

async function createILMPolicy(request: CreateILMPolicyRequest): CreateILMPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateILMPolicy', 'POST', '/openapi/instances/{InstanceId}/ilm-policies', 'json', false, 'json', request);
}

model CreateIndexTemplateRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model CreateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIndexTemplateResponseBody(name='body'),
}

async function createIndexTemplate(request: CreateIndexTemplateRequest): CreateIndexTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateIndexTemplate', 'POST', '/openapi/instances/{InstanceId}/index-templates', 'json', false, 'json', request);
}

model CreateLogstashRequest {
  description?: string(name='description', position='Body'),
  networkConfig?: {
    type?: string(name='type'),
    vpcId?: string(name='vpcId'),
    vsArea?: string(name='vsArea'),
    vswitchId?: string(name='vswitchId'),
  }(name='networkConfig', position='Body'),
  nodeAmount?: int32(name='nodeAmount', position='Body'),
  nodeSpec?: {
    disk?: long(name='disk'),
    diskType?: string(name='diskType'),
    spec?: string(name='spec'),
  }(name='nodeSpec', position='Body'),
  paymentInfo?: {
    autoRenewDuration?: long(name='autoRenewDuration', description='自动续费包月周期'),
    duration?: long(name='duration', description='包月周期'),
    isAutoRenew?: boolean(name='isAutoRenew', description='是否自动续费'),
    pricingCycle?: string(name='pricingCycle', description='日期单位'),
  }(name='paymentInfo', position='Body'),
  paymentType?: string(name='paymentType', position='Body'),
  version?: string(name='version', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model CreateLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: Logstash(name='Result'),
}

model CreateLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLogstashResponseBody(name='body'),
}

async function createLogstash(request: CreateLogstashRequest): CreateLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLogstash', 'POST', '/openapi/logstashes', 'json', false, 'json', request);
}

model CreatePipelinesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
  trigger?: boolean(name='trigger', position='Query'),
}

model CreatePipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CreatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePipelinesResponseBody(name='body'),
}

async function createPipelines(request: CreatePipelinesRequest): CreatePipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreatePipelines', 'POST', '/openapi/logstashes/{InstanceId}/pipelines', 'json', false, 'json', request);
}

model CreateSnapshotRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSnapshot', 'POST', '/openapi/instances/{InstanceId}/snapshots', 'json', false, 'json', request);
}

model CreateVpcEndpointRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  serviceId?: string(name='serviceId', description='终端节点服务ID', position='Body'),
  zoneId?: string(name='zoneId', description='可用区ID', position='Body'),
  dryRun?: boolean(name='dryRun', position='Query'),
}

model CreateVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    endpointDomain?: string(name='endpointDomain'),
    endpointId?: string(name='endpointId'),
    endpointName?: string(name='endpointName'),
    serviceId?: string(name='serviceId'),
  }(name='Result'),
}

model CreateVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcEndpointResponseBody(name='body'),
}

async function createVpcEndpoint(request: CreateVpcEndpointRequest): CreateVpcEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateVpcEndpoint', 'POST', '/openapi/instances/{InstanceId}/vpc-endpoints', 'json', false, 'json', request);
}

model DeactivateZonesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model DeactivateZonesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeactivateZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateZonesResponseBody(name='body'),
}

async function deactivateZones(request: DeactivateZonesRequest): DeactivateZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeactivateZones', 'POST', '/openapi/instances/{InstanceId}/actions/down-zones', 'json', false, 'json', request);
}

model DeleteCollectorRequest {
  resId: string(name='ResId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model DeleteCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCollectorResponseBody(name='body'),
}

async function deleteCollector(request: DeleteCollectorRequest): DeleteCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCollector', 'DELETE', '/openapi/collectors/{ResId}', 'json', false, 'json', request);
}

model DeleteComponentIndexRequest {
  instanceId: string(name='InstanceId', position='Path'),
  name: string(name='name', position='Path'),
}

model DeleteComponentIndexResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  result?: boolean(name='Result'),
}

model DeleteComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteComponentIndexResponseBody(name='body'),
}

async function deleteComponentIndex(request: DeleteComponentIndexRequest): DeleteComponentIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteComponentIndex', 'DELETE', '/openapi/instances/{InstanceId}/component-index/{name}', 'json', false, 'json', request);
}

model DeleteConnectedClusterRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
  connectedInstanceId: string(name='connectedInstanceId', position='Query'),
}

model DeleteConnectedClusterResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteConnectedClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConnectedClusterResponseBody(name='body'),
}

async function deleteConnectedCluster(request: DeleteConnectedClusterRequest): DeleteConnectedClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteConnectedCluster', 'DELETE', '/openapi/instances/{InstanceId}/connected-clusters', 'json', false, 'json', request);
}

model DeleteDataStreamRequest {
  instanceId: string(name='InstanceId', position='Path'),
  dataStream: string(name='DataStream', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model DeleteDataStreamResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteDataStreamResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataStreamResponseBody(name='body'),
}

async function deleteDataStream(request: DeleteDataStreamRequest): DeleteDataStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDataStream', 'DELETE', '/openapi/instances/{InstanceId}/data-streams/{DataStream}', 'json', false, 'json', request);
}

model DeleteDataTaskRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken: string(name='ClientToken', position='Query'),
  taskId: string(name='taskId', position='Query'),
}

model DeleteDataTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteDataTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataTaskResponseBody(name='body'),
}

async function deleteDataTask(request: DeleteDataTaskRequest): DeleteDataTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDataTask', 'DELETE', '/openapi/instances/{InstanceId}/data-task', 'json', false, 'json', request);
}

model DeleteDeprecatedTemplateRequest {
  instanceId?: string(name='InstanceId', description='A short description of struct', position='Path'),
  name?: string(name='name', position='Path'),
}

model DeleteDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteDeprecatedTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDeprecatedTemplateResponseBody(name='body'),
}

async function deleteDeprecatedTemplate(request: DeleteDeprecatedTemplateRequest): DeleteDeprecatedTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDeprecatedTemplate', 'DELETE', '/openapi/instances/{InstanceId}/deprecated-templates/{name}', 'json', false, 'json', request);
}

model DeleteILMPolicyRequest {
  instanceId: string(name='InstanceId', position='Path'),
  policyName: string(name='PolicyName', position='Path'),
}

model DeleteILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteILMPolicyResponseBody(name='body'),
}

async function deleteILMPolicy(request: DeleteILMPolicyRequest): DeleteILMPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteILMPolicy', 'DELETE', '/openapi/instances/{InstanceId}/ilm-policies/{PolicyName}', 'json', false, 'json', request);
}

model DeleteIndexTemplateRequest {
  instanceId: string(name='InstanceId', position='Path'),
  indexTemplate: string(name='IndexTemplate', position='Path'),
}

model DeleteIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIndexTemplateResponseBody(name='body'),
}

async function deleteIndexTemplate(request: DeleteIndexTemplateRequest): DeleteIndexTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteIndexTemplate', 'DELETE', '/openapi/instances/{InstanceId}/index-templates/{IndexTemplate}', 'json', false, 'json', request);
}

model DeleteInstanceRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
  deleteType?: string(name='deleteType', position='Query'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteInstance', 'DELETE', '/openapi/instances/{InstanceId}', 'json', false, 'json', request);
}

model DeleteLogstashRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
  deleteType?: string(name='deleteType', position='Query'),
}

model DeleteLogstashResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLogstashResponseBody(name='body'),
}

async function deleteLogstash(request: DeleteLogstashRequest): DeleteLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLogstash', 'DELETE', '/openapi/logstashes/{InstanceId}', 'json', false, 'json', request);
}

model DeletePipelinesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  pipelineIds?: string(name='pipelineIds', position='Query'),
}

model DeletePipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeletePipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePipelinesResponseBody(name='body'),
}

async function deletePipelines(request: DeletePipelinesRequest): DeletePipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeletePipelines', 'DELETE', '/openapi/logstashes/{InstanceId}/pipelines', 'json', false, 'json', request);
}

model DeleteSnapshotRepoRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
  repoPath: string(name='repoPath', position='Query'),
}

model DeleteSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotRepoResponseBody(name='body'),
}

async function deleteSnapshotRepo(request: DeleteSnapshotRepoRequest): DeleteSnapshotRepoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteSnapshotRepo', 'DELETE', '/openapi/instances/{InstanceId}/snapshot-repos', 'json', false, 'json', request);
}

model DeleteVpcEndpointRequest {
  instanceId: string(name='InstanceId', position='Path'),
  endpointId: string(name='EndpointId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model DeleteVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcEndpointResponseBody(name='body'),
}

async function deleteVpcEndpoint(request: DeleteVpcEndpointRequest): DeleteVpcEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteVpcEndpoint', 'DELETE', '/openapi/instances/{InstanceId}/vpc-endpoints/{EndpointId}', 'json', false, 'json', request);
}

model DescribeAckOperatorRequest {
  clusterId: string(name='ClusterId', position='Path'),
}

model DescribeAckOperatorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    status?: string(name='status'),
    version?: string(name='version'),
  }(name='Result'),
}

model DescribeAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAckOperatorResponseBody(name='body'),
}

async function describeAckOperator(request: DescribeAckOperatorRequest): DescribeAckOperatorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeAckOperator', 'GET', '/openapi/ack-clusters/{ClusterId}/operator', 'json', false, 'json', request);
}

model DescribeApmRequest {
  instanceId: string(name='instanceId', position='Path'),
}

model DescribeApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    apmServerDomain?: string(name='apmServerDomain'),
    createdAt?: string(name='createdAt'),
    deployedReplica?: long(name='deployedReplica'),
    description?: string(name='description'),
    endTime?: long(name='endTime'),
    instanceId?: string(name='instanceId'),
    nodeAmount?: long(name='nodeAmount'),
    outputES?: string(name='outputES'),
    outputESUserName?: string(name='outputESUserName'),
    ownerId?: string(name='ownerId'),
    paymentType?: string(name='paymentType'),
    region?: string(name='region'),
    replica?: int32(name='replica'),
    resourceSpec?: string(name='resourceSpec'),
    status?: string(name='status'),
    version?: string(name='version'),
    vpcId?: string(name='vpcId'),
    vsArea?: string(name='vsArea'),
    vswitchId?: string(name='vswitchId'),
  }(name='Result'),
}

model DescribeApmResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApmResponseBody(name='body'),
}

async function describeApm(request: DescribeApmRequest): DescribeApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApm', 'GET', '/openapi/apm/{instanceId}', 'json', false, 'json', request);
}

model DescribeCollectorRequest {
  resId: string(name='ResId', position='Path'),
}

model DescribeCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content'),
        fileName?: string(name='fileName'),
      }
    ](name='configs'),
    dryRun?: boolean(name='dryRun'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType'),
        enableMonitoring?: boolean(name='enableMonitoring'),
        groupId?: string(name='groupId'),
        host?: string(name='host'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId'),
        instanceType?: string(name='instanceType'),
        kibanaHost?: string(name='kibanaHost'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus'),
            instanceId?: string(name='instanceId'),
          }
        ](name='machines'),
        protocol?: string(name='protocol'),
        successPodsCount?: string(name='successPodsCount'),
        totalPodsCount?: string(name='totalPodsCount'),
        type?: string(name='type'),
        userName?: string(name='userName'),
      }
    ](name='extendConfigs'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    name?: string(name='name'),
    ownerId?: string(name='ownerId'),
    resId?: string(name='resId'),
    resType?: string(name='resType'),
    resVersion?: string(name='resVersion'),
    status?: string(name='status'),
    vpcId?: string(name='vpcId'),
  }(name='Result'),
}

model DescribeCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCollectorResponseBody(name='body'),
}

async function describeCollector(request: DescribeCollectorRequest): DescribeCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeCollector', 'GET', '/openapi/collectors/{ResId}', 'json', false, 'json', request);
}

model DescribeComponentIndexRequest {
  instanceId: string(name='InstanceId', position='Path'),
  name?: string(name='name', position='Path'),
}

model DescribeComponentIndexResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    meta?: map[string]any(name='_meta'),
    template?: {
      aliases?: map[string]any(name='aliases'),
      mappings?: map[string]any(name='mappings'),
      settings?: map[string]any(name='settings'),
    }(name='template'),
  }(name='Result'),
}

model DescribeComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeComponentIndexResponseBody(name='body'),
}

async function describeComponentIndex(request: DescribeComponentIndexRequest): DescribeComponentIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeComponentIndex', 'GET', '/openapi/instances/{InstanceId}/component-index/{name}', 'json', false, 'json', request);
}

model DescribeConnectableClustersRequest {
  instanceId: string(name='InstanceId', position='Path'),
  alreadySetItems?: boolean(name='alreadySetItems', position='Query'),
}

model DescribeConnectableClustersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      instances?: string(name='instances'),
      networkType?: string(name='networkType'),
    }
  ](name='Result'),
}

model DescribeConnectableClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeConnectableClustersResponseBody(name='body'),
}

async function describeConnectableClusters(request: DescribeConnectableClustersRequest): DescribeConnectableClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeConnectableClusters', 'GET', '/openapi/instances/{InstanceId}/connectable-clusters', 'json', false, 'json', request);
}

model DescribeDeprecatedTemplateRequest {
  instanceId?: string(name='InstanceId', position='Path'),
  name?: string(name='name', position='Path'),
}

model DescribeDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    dataStream?: boolean(name='dataStream'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate'),
    order?: long(name='order'),
    template?: {
      aliases?: string(name='aliases'),
      mappings?: string(name='mappings'),
      settings?: string(name='settings'),
    }(name='template'),
    version?: string(name='version'),
  }(name='Result'),
}

model DescribeDeprecatedTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeprecatedTemplateResponseBody(name='body'),
}

async function describeDeprecatedTemplate(request: DescribeDeprecatedTemplateRequest): DescribeDeprecatedTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeDeprecatedTemplate', 'GET', '/openapi/instances/{InstanceId}/deprecated-templates/{name}', 'json', false, 'json', request);
}

model DescribeDiagnoseReportRequest {
  instanceId: string(name='InstanceId', position='Path'),
  reportId: string(name='ReportId', position='Path'),
  lang?: string(name='lang', position='Query'),
}

model DescribeDiagnoseReportResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createTime?: long(name='createTime'),
    diagnoseItems?: [ 
      {
        detail?: {
          desc?: string(name='desc'),
          name?: string(name='name'),
          result?: string(name='result'),
          suggest?: string(name='suggest'),
          type?: string(name='type'),
        }(name='detail'),
        health?: string(name='health'),
        item?: string(name='item'),
      }
    ](name='diagnoseItems'),
    health?: string(name='health'),
    instanceId?: string(name='instanceId'),
    reportId?: string(name='reportId'),
    state?: string(name='state'),
    trigger?: string(name='trigger'),
  }(name='Result'),
}

model DescribeDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnoseReportResponseBody(name='body'),
}

async function describeDiagnoseReport(request: DescribeDiagnoseReportRequest): DescribeDiagnoseReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeDiagnoseReport', 'GET', '/openapi/diagnosis/instances/{InstanceId}/reports/{ReportId}', 'json', false, 'json', request);
}

model DescribeDiagnosisSettingsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  lang?: string(name='lang', position='Query'),
}

model DescribeDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    scene?: string(name='scene'),
    updateTime?: long(name='updateTime'),
  }(name='Result'),
}

model DescribeDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnosisSettingsResponseBody(name='body'),
}

async function describeDiagnosisSettings(request: DescribeDiagnosisSettingsRequest): DescribeDiagnosisSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeDiagnosisSettings', 'GET', '/openapi/diagnosis/instances/{InstanceId}/settings', 'json', false, 'json', request);
}

model DescribeDynamicSettingsRequest {
  instanceId?: string(name='InstanceId', position='Path'),
}

model DescribeDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result', description='Id of the request'),
}

model DescribeDynamicSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDynamicSettingsResponseBody(name='body'),
}

async function describeDynamicSettings(request: DescribeDynamicSettingsRequest): DescribeDynamicSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeDynamicSettings', 'GET', '/openapi/instances/{InstanceId}/dynamic-settings', 'json', false, 'json', request);
}

model DescribeElasticsearchHealthRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model DescribeElasticsearchHealthResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeElasticsearchHealthResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeElasticsearchHealthResponseBody(name='body'),
}

async function describeElasticsearchHealth(request: DescribeElasticsearchHealthRequest): DescribeElasticsearchHealthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeElasticsearchHealth', 'GET', '/openapi/instances/{InstanceId}/elasticsearch-health', 'json', false, 'json', request);
}

model DescribeILMPolicyRequest {
  instanceId: string(name='InstanceId', position='Path'),
  policyName: string(name='PolicyName', position='Path'),
}

model DescribeILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    name?: string(name='name'),
    phases?: map[string]any(name='phases'),
  }(name='Result'),
}

model DescribeILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeILMPolicyResponseBody(name='body'),
}

async function describeILMPolicy(request: DescribeILMPolicyRequest): DescribeILMPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeILMPolicy', 'GET', '/openapi/instances/{InstanceId}/ilm-policies/{PolicyName}', 'json', false, 'json', request);
}

model DescribeIndexTemplateRequest {
  instanceId: string(name='InstanceId', position='Path'),
  indexTemplate: string(name='IndexTemplate', position='Path'),
}

model DescribeIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    dataStream?: boolean(name='dataStream'),
    ilmPolicy?: string(name='ilmPolicy'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate'),
    priority?: int32(name='priority'),
    template?: {
      aliases?: string(name='aliases'),
      mappings?: string(name='mappings'),
      settings?: string(name='settings'),
    }(name='template'),
  }(name='Result'),
}

model DescribeIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIndexTemplateResponseBody(name='body'),
}

async function describeIndexTemplate(request: DescribeIndexTemplateRequest): DescribeIndexTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeIndexTemplate', 'GET', '/openapi/instances/{InstanceId}/index-templates/{IndexTemplate}', 'json', false, 'json', request);
}

model DescribeInstanceRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model DescribeInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
    advancedSetting?: {
      gcName?: string(name='gcName'),
    }(name='advancedSetting'),
    aliwsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='aliwsDicts'),
    clientNodeConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='clientNodeConfiguration'),
    createdAt?: string(name='createdAt'),
    dedicateMaster?: boolean(name='dedicateMaster'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    elasticDataNodeConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='elasticDataNodeConfiguration'),
    enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork'),
    enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork'),
    enablePublic?: boolean(name='enablePublic'),
    esConfig?: map[string]any(name='esConfig'),
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
    esIPWhitelist?: [ string ](name='esIPWhitelist'),
    esVersion?: string(name='esVersion'),
    extendConfigs?: [  map[string]any ](name='extendConfigs'),
    haveClientNode?: boolean(name='haveClientNode'),
    haveKibana?: boolean(name='haveKibana'),
    ikHotDicts?: [ 
      {
        fileSize?: int32(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='ikHotDicts'),
    instanceId?: string(name='instanceId'),
    isNewDeployment?: boolean(name='isNewDeployment'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
    kibanaPort?: int32(name='kibanaPort'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      performanceLevel?: string(name='performanceLevel'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    port?: int32(name='port'),
    postpaidServiceStatus?: string(name='postpaidServiceStatus'),
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
    protocol?: string(name='protocol'),
    publicDomain?: string(name='publicDomain'),
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
    publicPort?: int32(name='publicPort'),
    resourceGroupId?: string(name='resourceGroupId'),
    serviceVpc?: boolean(name='serviceVpc'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey'),
        tagValue?: string(name='tagValue'),
      }
    ](name='tags'),
    updatedAt?: string(name='updatedAt'),
    vpcInstanceId?: string(name='vpcInstanceId'),
    warmNode?: boolean(name='warmNode'),
    warmNodeConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='warmNodeConfiguration'),
    zoneCount?: int32(name='zoneCount'),
    zoneInfos?: [ 
      {
        status?: string(name='status'),
        zoneId?: string(name='zoneId'),
      }
    ](name='zoneInfos'),
  }(name='Result'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstance(request: DescribeInstanceRequest): DescribeInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeInstance', 'GET', '/openapi/instances/{InstanceId}', 'json', false, 'json', request);
}

model DescribeKibanaSettingsRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model DescribeKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
}

model DescribeKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKibanaSettingsResponseBody(name='body'),
}

async function describeKibanaSettings(request: DescribeKibanaSettingsRequest): DescribeKibanaSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeKibanaSettings', 'GET', '/openapi/instances/{InstanceId}/kibana-settings', 'json', false, 'json', request);
}

model DescribeLogstashRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model DescribeLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    extendConfigs?: [  map[string]any ](name='ExtendConfigs'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey'),
        tagValue?: string(name='tagValue'),
      }
    ](name='Tags'),
    zoneInfos?: [ 
      {
        status?: string(name='status'),
        zoneId?: string(name='zoneId'),
      }
    ](name='ZoneInfos'),
    config?: map[string]any(name='config'),
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    endpointList?: [ 
      {
        host?: string(name='host'),
        port?: string(name='port'),
        zoneId?: string(name='zoneId'),
      }
    ](name='endpointList'),
    instanceId?: string(name='instanceId'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    status?: string(name='status'),
    updatedAt?: string(name='updatedAt'),
    version?: string(name='version'),
    vpcInstanceId?: string(name='vpcInstanceId'),
  }(name='Result'),
}

model DescribeLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLogstashResponseBody(name='body'),
}

async function describeLogstash(request: DescribeLogstashRequest): DescribeLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeLogstash', 'GET', '/openapi/logstashes/{InstanceId}', 'json', false, 'json', request);
}

model DescribePipelineRequest {
  instanceId: string(name='InstanceId', position='Path'),
  pipelineId: string(name='PipelineId', position='Path'),
}

model DescribePipelineResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    batchDelay?: int32(name='batchDelay'),
    batchSize?: int32(name='batchSize'),
    config?: string(name='config'),
    description?: string(name='description'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    pipelineId?: string(name='pipelineId'),
    pipelineStatus?: string(name='pipelineStatus'),
    queueCheckPointWrites?: int32(name='queueCheckPointWrites'),
    queueMaxBytes?: int32(name='queueMaxBytes'),
    queueType?: string(name='queueType'),
    workers?: int32(name='workers'),
  }(name='Result'),
}

model DescribePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePipelineResponseBody(name='body'),
}

async function describePipeline(request: DescribePipelineRequest): DescribePipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePipeline', 'GET', '/openapi/logstashes/{InstanceId}/pipelines/{PipelineId}', 'json', false, 'json', request);
}

model DescribePipelineManagementConfigRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model DescribePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    endpoints?: string(name='endpoints'),
    esInstanceId?: string(name='esInstanceId'),
    pipelineIds?: [ string ](name='pipelineIds'),
    pipelineManagementType?: string(name='pipelineManagementType'),
    userName?: string(name='userName'),
  }(name='Result'),
}

model DescribePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePipelineManagementConfigResponseBody(name='body'),
}

async function describePipelineManagementConfig(request: DescribePipelineManagementConfigRequest): DescribePipelineManagementConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePipelineManagementConfig', 'GET', '/openapi/logstashes/{InstanceId}/pipeline-management-config', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      consoleEndpoint?: string(name='consoleEndpoint'),
      localName?: string(name='localName'),
      regionEndpoint?: string(name='regionEndpoint'),
      regionId?: string(name='regionId'),
      status?: string(name='status'),
    }
  ](name='Result'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeRegions', 'GET', '/openapi/regions', 'json', false, 'json', request);
}

model DescribeSnapshotSettingRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model DescribeSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='Enable'),
    quartzRegex?: string(name='QuartzRegex'),
  }(name='Result'),
}

model DescribeSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotSettingResponseBody(name='body'),
}

async function describeSnapshotSetting(request: DescribeSnapshotSettingRequest): DescribeSnapshotSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeSnapshotSetting', 'GET', '/openapi/instances/{InstanceId}/snapshot-setting', 'json', false, 'json', request);
}

model DescribeTemplatesRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model DescribeTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      templateName?: string(name='templateName'),
    }
  ](name='Result'),
}

model DescribeTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTemplatesResponseBody(name='body'),
}

async function describeTemplates(request: DescribeTemplatesRequest): DescribeTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeTemplates', 'GET', '/openapi/instances/{InstanceId}/templates', 'json', false, 'json', request);
}

model DescribeXpackMonitorConfigRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model DescribeXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='enable'),
    endpoints?: [ string ](name='endpoints'),
    esInstanceId?: string(name='esInstanceId'),
    pipelineIds?: [ string ](name='pipelineIds'),
    userName?: string(name='userName'),
  }(name='Result'),
}

model DescribeXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeXpackMonitorConfigResponseBody(name='body'),
}

async function describeXpackMonitorConfig(request: DescribeXpackMonitorConfigRequest): DescribeXpackMonitorConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeXpackMonitorConfig', 'GET', '/openapi/logstashes/{InstanceId}/xpack-monitor-config', 'json', false, 'json', request);
}

model DiagnoseInstanceRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  diagnoseItems?: [ string ](name='diagnoseItems', position='Body'),
  indices?: [ string ](name='indices', position='Body'),
  type?: string(name='type', position='Body'),
  lang?: string(name='lang', position='Query'),
}

model DiagnoseInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createTime?: long(name='createTime'),
    instanceId?: string(name='instanceId'),
    reportId?: string(name='reportId'),
    state?: string(name='state'),
  }(name='Result'),
}

model DiagnoseInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DiagnoseInstanceResponseBody(name='body'),
}

async function diagnoseInstance(request: DiagnoseInstanceRequest): DiagnoseInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DiagnoseInstance', 'POST', '/openapi/diagnosis/instances/{InstanceId}/actions/diagnose', 'json', false, 'json', request);
}

model EstimatedLogstashRestartTimeRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  force?: boolean(name='force', position='Query'),
}

model EstimatedLogstashRestartTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    unit?: string(name='unit'),
    value?: long(name='value'),
  }(name='Result'),
}

model EstimatedLogstashRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  body: EstimatedLogstashRestartTimeResponseBody(name='body'),
}

async function estimatedLogstashRestartTime(request: EstimatedLogstashRestartTimeRequest): EstimatedLogstashRestartTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'EstimatedLogstashRestartTime', 'POST', '/openapi/logstashes/{InstanceId}/estimated-time/restart-time', 'json', false, 'json', request);
}

model EstimatedRestartTimeRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  force?: boolean(name='force', position='Query'),
}

model EstimatedRestartTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    unit?: string(name='unit'),
    value?: long(name='value'),
  }(name='Result'),
}

model EstimatedRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  body: EstimatedRestartTimeResponseBody(name='body'),
}

async function estimatedRestartTime(request: EstimatedRestartTimeRequest): EstimatedRestartTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'EstimatedRestartTime', 'POST', '/openapi/instances/{InstanceId}/estimated-time/restart-time', 'json', false, 'json', request);
}

model GetClusterDataInformationRequest {
  body?: string(name='body', position='Body'),
}

model GetClusterDataInformationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    connectable?: boolean(name='connectable'),
    metaInfo?: {
      fields?: [ string ](name='fields'),
      indices?: [ string ](name='indices'),
      mapping?: string(name='mapping'),
      settings?: string(name='settings'),
      typeName?: [ string ](name='typeName'),
    }(name='metaInfo'),
  }(name='Result'),
}

model GetClusterDataInformationResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterDataInformationResponseBody(name='body'),
}

async function getClusterDataInformation(request: GetClusterDataInformationRequest): GetClusterDataInformationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetClusterDataInformation', 'POST', '/openapi/cluster/data-information', 'json', false, 'json', request);
}

model GetElastictaskRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model GetElastictaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model GetElastictaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetElastictaskResponseBody(name='body'),
}

async function getElastictask(request: GetElastictaskRequest): GetElastictaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetElastictask', 'GET', '/openapi/instances/{InstanceId}/elastic-task', 'json', false, 'json', request);
}

model GetEmonGrafanaAlertsRequest {
  projectId: string(name='ProjectId', position='Path'),
  body?: string(name='body', position='Body'),
}

model GetEmonGrafanaAlertsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEmonGrafanaAlertsResponse = {
  headers: map[string]string(name='headers'),
  body: GetEmonGrafanaAlertsResponseBody(name='body'),
}

async function getEmonGrafanaAlerts(request: GetEmonGrafanaAlertsRequest): GetEmonGrafanaAlertsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetEmonGrafanaAlerts', 'GET', '/openapi/emon/projects/{ProjectId}/grafana/proxy/api/alerts', 'json', false, 'json', request);
}

model GetEmonGrafanaDashboardsRequest {
  projectId: string(name='ProjectId', position='Path'),
  body?: string(name='body', position='Body'),
}

model GetEmonGrafanaDashboardsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEmonGrafanaDashboardsResponse = {
  headers: map[string]string(name='headers'),
  body: GetEmonGrafanaDashboardsResponseBody(name='body'),
}

async function getEmonGrafanaDashboards(request: GetEmonGrafanaDashboardsRequest): GetEmonGrafanaDashboardsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetEmonGrafanaDashboards', 'GET', '/openapi/emon/projects/{ProjectId}/grafana/proxy/api/search', 'json', false, 'json', request);
}

model GetEmonMonitorDataRequest {
  projectId: string(name='ProjectId', position='Path'),
  body?: string(name='body', position='Body'),
}

model GetEmonMonitorDataResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      dps?: map[string]any(name='dps'),
      integrity?: float(name='integrity'),
      messageWatermark?: long(name='messageWatermark'),
      metric?: string(name='metric'),
      summary?: float(name='summary'),
      tags?: map[string]any(name='tags'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model GetEmonMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: GetEmonMonitorDataResponseBody(name='body'),
}

async function getEmonMonitorData(request: GetEmonMonitorDataRequest): GetEmonMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetEmonMonitorData', 'POST', '/openapi/emon/projects/{ProjectId}/metrics/query', 'json', false, 'json', request);
}

model GetOpenStoreUsageRequest {
  instanceId: string(name='InstanceId', description='实例id', position='Path'),
}

model GetOpenStoreUsageResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  result?: {
    currentUsage?: long(name='currentUsage', description='当前使用量'),
    lastDayUsage?: long(name='lastDayUsage', description='昨日使用容量'),
  }(name='Result'),
}

model GetOpenStoreUsageResponse = {
  headers: map[string]string(name='headers'),
  body: GetOpenStoreUsageResponseBody(name='body'),
}

async function getOpenStoreUsage(request: GetOpenStoreUsageRequest): GetOpenStoreUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetOpenStoreUsage', 'GET', '/openapi/instances/{InstanceId}/openstore/usage', 'json', false, 'json', request);
}

model GetRegionConfigurationRequest {
  zoneId?: string(name='zoneId', position='Query'),
}

model GetRegionConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    clientNodeAmountRange?: {
      maxAmount?: int32(name='maxAmount'),
      minAmount?: int32(name='minAmount'),
    }(name='clientNodeAmountRange'),
    clientNodeDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
      }
    ](name='clientNodeDiskList'),
    clientNodeSpec?: [ string ](name='clientNodeSpec'),
    createUrl?: string(name='createUrl'),
    dataDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
        valueLimitSet?: [ string ](name='valueLimitSet'),
      }
    ](name='dataDiskList'),
    elasticNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount'),
        minAmount?: int32(name='minAmount'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption'),
          diskType?: string(name='diskType'),
          maxSize?: int32(name='maxSize'),
          minSize?: int32(name='minSize'),
          scaleLimit?: int32(name='scaleLimit'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='elasticNodeProperties'),
    env?: string(name='env'),
    esVersions?: [ string ](name='esVersions'),
    esVersionsLatestList?: [ 
      {
        key?: string(name='key'),
        value?: string(name='value'),
      }
    ](name='esVersionsLatestList'),
    instanceSupportNodes?: [ string ](name='instanceSupportNodes'),
    jvmConfine?: {
      memory?: int32(name='memory'),
      supportEsVersions?: [ string ](name='supportEsVersions'),
      supportGcs?: [ string ](name='supportGcs'),
    }(name='jvmConfine'),
    kibanaNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount'),
        minAmount?: int32(name='minAmount'),
      }(name='amountRange'),
      spec?: [ string ](name='spec'),
    }(name='kibanaNodeProperties'),
    masterDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
      }
    ](name='masterDiskList'),
    masterSpec?: [ string ](name='masterSpec'),
    node?: {
      maxAmount?: int32(name='maxAmount'),
      minAmount?: int32(name='minAmount'),
    }(name='node'),
    nodeSpecList?: [ 
      {
        cpuCount?: int32(name='cpuCount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        enable?: boolean(name='enable'),
        memorySize?: int32(name='memorySize'),
        spec?: string(name='spec'),
        specGroupType?: string(name='specGroupType'),
      }
    ](name='nodeSpecList'),
    regionId?: string(name='regionId'),
    supportVersions?: [ 
      {
        instanceCategory?: string(name='instanceCategory'),
        supportVersionList?: [ 
          {
            key?: string(name='key'),
            value?: string(name='value'),
          }
        ](name='supportVersionList'),
      }
    ](name='supportVersions'),
    warmNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount'),
        minAmount?: int32(name='minAmount'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption'),
          diskType?: string(name='diskType'),
          maxSize?: int32(name='maxSize'),
          minSize?: int32(name='minSize'),
          scaleLimit?: int32(name='scaleLimit'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='warmNodeProperties'),
    zones?: [ string ](name='zones'),
  }(name='Result'),
}

model GetRegionConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegionConfigurationResponseBody(name='body'),
}

async function getRegionConfiguration(request: GetRegionConfigurationRequest): GetRegionConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetRegionConfiguration', 'GET', '/openapi/region', 'json', false, 'json', request);
}

model GetSuggestShrinkableNodesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  count: int32(name='count', position='Query'),
  ignoreStatus?: boolean(name='ignoreStatus', position='Query'),
  nodeType: string(name='nodeType', position='Query'),
}

model GetSuggestShrinkableNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
    }
  ](name='Result'),
}

model GetSuggestShrinkableNodesResponse = {
  headers: map[string]string(name='headers'),
  body: GetSuggestShrinkableNodesResponseBody(name='body'),
}

async function getSuggestShrinkableNodes(request: GetSuggestShrinkableNodesRequest): GetSuggestShrinkableNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSuggestShrinkableNodes', 'GET', '/openapi/instances/{InstanceId}/suggest-shrinkable-nodes', 'json', false, 'json', request);
}

model GetTransferableNodesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  count: int32(name='count', position='Query'),
  nodeType: string(name='nodeType', position='Query'),
}

model GetTransferableNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
    }
  ](name='Result'),
}

model GetTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  body: GetTransferableNodesResponseBody(name='body'),
}

async function getTransferableNodes(request: GetTransferableNodesRequest): GetTransferableNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTransferableNodes', 'GET', '/openapi/instances/{InstanceId}/transferable-nodes', 'json', false, 'json', request);
}

model InitializeOperationRoleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model InitializeOperationRoleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InitializeOperationRoleResponse = {
  headers: map[string]string(name='headers'),
  body: InitializeOperationRoleResponseBody(name='body'),
}

async function initializeOperationRole(request: InitializeOperationRoleRequest): InitializeOperationRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InitializeOperationRole', 'POST', '/openapi/user/slr', 'json', false, 'json', request);
}

model InstallAckOperatorRequest {
  clusterId: string(name='ClusterId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model InstallAckOperatorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InstallAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  body: InstallAckOperatorResponseBody(name='body'),
}

async function installAckOperator(request: InstallAckOperatorRequest): InstallAckOperatorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallAckOperator', 'POST', '/openapi/ack-clusters/{ClusterId}/operator', 'json', false, 'json', request);
}

model InstallKibanaSystemPluginRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model InstallKibanaSystemPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallKibanaSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  body: InstallKibanaSystemPluginResponseBody(name='body'),
}

async function installKibanaSystemPlugin(request: InstallKibanaSystemPluginRequest): InstallKibanaSystemPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallKibanaSystemPlugin', 'POST', '/openapi/instances/{InstanceId}/kibana-plugins/system/actions/install', 'json', false, 'json', request);
}

model InstallLogstashSystemPluginRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model InstallLogstashSystemPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallLogstashSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  body: InstallLogstashSystemPluginResponseBody(name='body'),
}

async function installLogstashSystemPlugin(request: InstallLogstashSystemPluginRequest): InstallLogstashSystemPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallLogstashSystemPlugin', 'POST', '/openapi/logstashes/{InstanceId}/plugins/system/actions/install', 'json', false, 'json', request);
}

model InstallSystemPluginRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model InstallSystemPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  body: InstallSystemPluginResponseBody(name='body'),
}

async function installSystemPlugin(request: InstallSystemPluginRequest): InstallSystemPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallSystemPlugin', 'POST', '/openapi/instances/{InstanceId}/plugins/system/actions/install', 'json', false, 'json', request);
}

model InstallUserPluginsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
}

model InstallUserPluginsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallUserPluginsResponse = {
  headers: map[string]string(name='headers'),
  body: InstallUserPluginsResponseBody(name='body'),
}

async function installUserPlugins(request: InstallUserPluginsRequest): InstallUserPluginsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallUserPlugins', 'POST', '/openapi/instances/{InstanceId}/plugins/user/actions/install', 'json', false, 'json', request);
}

model InterruptElasticsearchTaskRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model InterruptElasticsearchTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InterruptElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: InterruptElasticsearchTaskResponseBody(name='body'),
}

async function interruptElasticsearchTask(request: InterruptElasticsearchTaskRequest): InterruptElasticsearchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InterruptElasticsearchTask', 'POST', '/openapi/instances/{InstanceId}/actions/interrupt', 'json', false, 'json', request);
}

model InterruptLogstashTaskRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model InterruptLogstashTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InterruptLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  body: InterruptLogstashTaskResponseBody(name='body'),
}

async function interruptLogstashTask(request: InterruptLogstashTaskRequest): InterruptLogstashTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InterruptLogstashTask', 'POST', '/openapi/logstashes/{InstanceId}/actions/interrupt', 'json', false, 'json', request);
}

model ListAckClustersRequest {
  page?: int32(name='page', minimum=1, maximum=50, position='Query'),
  size?: int32(name='size', minimum=1, maximum=50, position='Query'),
  vpcId?: string(name='vpcId', position='Query'),
}

model ListAckClustersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      clusterId?: string(name='clusterId'),
      clusterType?: string(name='clusterType'),
      name?: string(name='name'),
      vpcId?: string(name='vpcId'),
    }
  ](name='Result'),
}

model ListAckClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListAckClustersResponseBody(name='body'),
}

async function listAckClusters(request: ListAckClustersRequest): ListAckClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAckClusters', 'GET', '/openapi/ack-clusters', 'json', false, 'json', request);
}

model ListAckNamespacesRequest {
  clusterId: string(name='ClusterId', position='Path'),
  page?: int32(name='page', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', minimum=1, maximum=500, position='Query'),
}

model ListAckNamespacesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      namespace?: string(name='namespace'),
      status?: string(name='status'),
    }
  ](name='Result'),
}

model ListAckNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAckNamespacesResponseBody(name='body'),
}

async function listAckNamespaces(request: ListAckNamespacesRequest): ListAckNamespacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAckNamespaces', 'GET', '/openapi/ack-clusters/{ClusterId}/namespaces', 'json', false, 'json', request);
}

model ListActionRecordsRequest {
  instanceId?: string(name='InstanceId', description='A short description of struct', position='Path'),
  actionNames?: string(name='actionNames', position='Query'),
  endTime?: long(name='endTime', position='Query'),
  filter?: string(name='filter', position='Query'),
  page?: int32(name='page', position='Query'),
  requestId?: string(name='requestId', position='Query'),
  size?: int32(name='size', position='Query'),
  startTime?: long(name='startTime', position='Query'),
  userId?: string(name='userId', position='Query'),
}

model ListActionRecordsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      actionName?: string(name='ActionName'),
      actionParams?: map[string]any(name='ActionParams'),
      actionResultAccessList?: [ string ](name='ActionResultAccessList'),
      endTime?: long(name='EndTime'),
      instanceId?: string(name='InstanceId'),
      metaNow?: string(name='MetaNow'),
      metaOld?: string(name='MetaOld'),
      ownerId?: string(name='OwnerId'),
      process?: string(name='Process'),
      recordDiff?: map[string]any(name='RecordDiff'),
      recordIds?: [ string ](name='RecordIds'),
      requestId?: string(name='RequestId'),
      startTime?: long(name='StartTime'),
      stateType?: string(name='StateType'),
      statusInfo?: [ 
        {
          completeNodeCount?: int32(name='completeNodeCount'),
          endTime?: long(name='endTime'),
          exception?: string(name='exception'),
          latencyMills?: long(name='latencyMills'),
          nodeCount?: int32(name='nodeCount'),
          process?: string(name='process'),
          startTime?: long(name='startTime'),
          stateType?: string(name='stateType'),
          subState?: string(name='subState'),
          subStatusInfo?: [ 
            {
              completeNodeCount?: int32(name='completeNodeCount'),
              endTime?: long(name='endTime'),
              exception?: string(name='exception'),
              latencyMills?: long(name='latencyMills'),
              nodeCount?: int32(name='nodeCount'),
              process?: string(name='process'),
              startTime?: long(name='startTime'),
              stateType?: string(name='stateType'),
              subState?: string(name='subState'),
            }
          ](name='subStatusInfo'),
        }
      ](name='StatusInfo'),
      userId?: string(name='UserId'),
      userInfo?: string(name='UserInfo'),
      userType?: string(name='UserType'),
    }
  ](name='Result'),
}

model ListActionRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: ListActionRecordsResponseBody(name='body'),
}

async function listActionRecords(request: ListActionRecordsRequest): ListActionRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListActionRecords', 'GET', '/openapi/instances/{InstanceId}/action-records', 'json', false, 'json', request);
}

model ListAllNodeRequest {
  instanceId: string(name='InstanceId', position='Path'),
  extended?: boolean(name='extended', position='Query'),
}

model ListAllNodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      cpuPercent?: string(name='cpuPercent'),
      diskUsedPercent?: string(name='diskUsedPercent'),
      health?: string(name='health'),
      heapPercent?: string(name='heapPercent'),
      host?: string(name='host'),
      loadOneM?: string(name='loadOneM'),
      nodeType?: string(name='nodeType'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='Result'),
}

model ListAllNodeResponse = {
  headers: map[string]string(name='headers'),
  body: ListAllNodeResponseBody(name='body'),
}

async function listAllNode(request: ListAllNodeRequest): ListAllNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAllNode', 'GET', '/openapi/instances/{InstanceId}/nodes', 'json', false, 'json', request);
}

model ListAlternativeSnapshotReposRequest {
  instanceId: string(name='InstanceId', position='Path'),
  alreadySetItems?: boolean(name='alreadySetItems', position='Query'),
}

model ListAlternativeSnapshotReposResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      instanceId?: string(name='instanceId'),
      repoPath?: string(name='repoPath'),
    }
  ](name='Result'),
}

model ListAlternativeSnapshotReposResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlternativeSnapshotReposResponseBody(name='body'),
}

async function listAlternativeSnapshotRepos(request: ListAlternativeSnapshotReposRequest): ListAlternativeSnapshotReposResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAlternativeSnapshotRepos', 'GET', '/openapi/instances/{InstanceId}/alternative-snapshot-repos', 'json', false, 'json', request);
}

model ListApmRequest {
  description?: string(name='description', position='Query'),
  instanceId?: string(name='instanceId', position='Query'),
  output?: string(name='output', position='Query'),
  page?: long(name='page', position='Query'),
  size?: long(name='size', position='Query'),
}

model ListApmResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createdAt?: string(name='createdAt'),
      deployedReplica?: long(name='deployedReplica'),
      description?: string(name='description'),
      instanceId?: string(name='instanceId'),
      nodeAmount?: long(name='nodeAmount'),
      outputES?: string(name='outputES'),
      outputESUserName?: string(name='outputESUserName'),
      ownerId?: string(name='ownerId'),
      paymentType?: string(name='paymentType'),
      region?: string(name='region'),
      replica?: long(name='replica'),
      resourceSpec?: string(name='resourceSpec'),
      status?: string(name='status'),
      version?: string(name='version'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }
  ](name='Result'),
}

model ListApmResponse = {
  headers: map[string]string(name='headers'),
  body: ListApmResponseBody(name='body'),
}

async function listApm(request: ListApmRequest): ListApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListApm', 'GET', '/openapi/apm', 'json', false, 'json', request);
}

model ListAvailableEsInstanceIdsRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model ListAvailableEsInstanceIdsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      endpoint?: string(name='endpoint'),
      esInstanceId?: string(name='esInstanceId'),
      kibanaEndpoint?: string(name='kibanaEndpoint'),
    }
  ](name='Result'),
}

model ListAvailableEsInstanceIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableEsInstanceIdsResponseBody(name='body'),
}

async function listAvailableEsInstanceIds(request: ListAvailableEsInstanceIdsRequest): ListAvailableEsInstanceIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAvailableEsInstanceIds', 'GET', '/openapi/logstashes/{InstanceId}/available-elasticsearch-for-centralized-management', 'json', false, 'json', request);
}

model ListCollectorsRequest {
  instanceId?: string(name='instanceId', position='Query'),
  name?: string(name='name', position='Query'),
  page?: int32(name='page', minimum=1, maximum=200, position='Query'),
  resId?: string(name='resId', position='Query'),
  size?: int32(name='size', minimum=1, maximum=500, position='Query'),
  sourceType?: string(name='sourceType', position='Query'),
}

model ListCollectorsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      collectorPaths?: [ string ](name='collectorPaths'),
      configs?: [ 
        {
          content?: string(name='content'),
          fileName?: string(name='fileName'),
        }
      ](name='configs'),
      dryRun?: boolean(name='dryRun'),
      extendConfigs?: [ 
        {
          configType?: string(name='configType'),
          enableMonitoring?: boolean(name='enableMonitoring'),
          groupId?: string(name='groupId'),
          host?: string(name='host'),
          hosts?: [ string ](name='hosts'),
          instanceId?: string(name='instanceId'),
          instanceType?: string(name='instanceType'),
          kibanaHost?: string(name='kibanaHost'),
          machines?: [ 
            {
              agentStatus?: string(name='agentStatus'),
              instanceId?: string(name='instanceId'),
            }
          ](name='machines'),
          protocol?: string(name='protocol'),
          successPodsCount?: string(name='successPodsCount'),
          totalPodsCount?: string(name='totalPodsCount'),
          type?: string(name='type'),
          userName?: string(name='userName'),
        }
      ](name='extendConfigs'),
      gmtCreatedTime?: string(name='gmtCreatedTime'),
      gmtUpdateTime?: string(name='gmtUpdateTime'),
      name?: string(name='name'),
      ownerId?: string(name='ownerId'),
      resId?: string(name='resId'),
      resType?: string(name='resType'),
      resVersion?: string(name='resVersion'),
      status?: string(name='status'),
      vpcId?: string(name='vpcId'),
    }
  ](name='Result'),
}

model ListCollectorsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCollectorsResponseBody(name='body'),
}

async function listCollectors(request: ListCollectorsRequest): ListCollectorsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListCollectors', 'GET', '/openapi/collectors', 'json', false, 'json', request);
}

model ListComponentIndicesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  name?: string(name='name', position='Query'),
  page?: int32(name='page', minimum=1, maximum=1000, position='Query'),
  size?: int32(name='size', minimum=1, maximum=1000, position='Query'),
}

model ListComponentIndicesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      composed?: [ string ](name='composed'),
      content?: {
        meta?: map[string]any(name='_meta'),
        template?: {
          settings?: {
            index?: {
              codec?: string(name='codec'),
              lifecycle?: {
                name?: string(name='name'),
              }(name='lifecycle'),
            }(name='index'),
          }(name='settings'),
        }(name='template'),
        version?: long(name='version'),
      }(name='content'),
      name?: string(name='name'),
    }
  ](name='Result'),
}

model ListComponentIndicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListComponentIndicesResponseBody(name='body'),
}

async function listComponentIndices(request: ListComponentIndicesRequest): ListComponentIndicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListComponentIndices', 'GET', '/openapi/instances/{InstanceId}/component-index', 'json', false, 'json', request);
}

model ListConnectedClustersRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model ListConnectedClustersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    result?: [ 
    {
      instances?: string(name='instances'),
      networkType?: string(name='networkType'),
    }
  ](name='Result')
  }(name='Result'),
}

model ListConnectedClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListConnectedClustersResponseBody(name='body'),
}

async function listConnectedClusters(request: ListConnectedClustersRequest): ListConnectedClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListConnectedClusters', 'GET', '/openapi/instances/{InstanceId}/connected-clusters', 'json', false, 'json', request);
}

model ListDataStreamsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  isManaged?: boolean(name='isManaged', position='Query'),
  name?: string(name='name', position='Query'),
}

model ListDataStreamsResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      health?: string(name='health'),
      ilmPolicyName?: string(name='ilmPolicyName'),
      indexTemplateName?: string(name='indexTemplateName'),
      indices?: [ 
        {
          createTime?: string(name='createTime'),
          health?: string(name='health'),
          isManaged?: boolean(name='isManaged'),
          managedStatus?: string(name='managedStatus'),
          name?: string(name='name'),
          size?: long(name='size'),
        }
      ](name='indices'),
      managedStorageSize?: long(name='managedStorageSize'),
      name?: string(name='name'),
      totalStorageSize?: long(name='totalStorageSize'),
    }
  ](name='Result'),
}

model ListDataStreamsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataStreamsResponseBody(name='body'),
}

async function listDataStreams(request: ListDataStreamsRequest): ListDataStreamsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDataStreams', 'GET', '/openapi/instances/{InstanceId}/data-streams', 'json', false, 'json', request);
}

model ListDataTasksRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model ListDataTasksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='createTime'),
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        endpoint?: string(name='endpoint'),
        index?: string(name='index'),
        type?: string(name='type'),
        vpcId?: string(name='vpcId'),
        vpcInstanceId?: string(name='vpcInstanceId'),
        vpcInstancePort?: string(name='vpcInstancePort'),
      }(name='sinkCluster'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        index?: string(name='index'),
        mapping?: string(name='mapping'),
        routing?: string(name='routing'),
        settings?: string(name='settings'),
        type?: string(name='type'),
      }(name='sourceCluster'),
      status?: string(name='status'),
      taskId?: string(name='taskId'),
    }
  ](name='Result'),
}

model ListDataTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataTasksResponseBody(name='body'),
}

async function listDataTasks(request: ListDataTasksRequest): ListDataTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDataTasks', 'GET', '/openapi/instances/{InstanceId}/data-task', 'json', false, 'json', request);
}

model ListDefaultCollectorConfigurationsRequest {
  resType: string(name='resType', position='Query'),
  resVersion: string(name='resVersion', position='Query'),
  sourceType?: string(name='sourceType', position='Query'),
}

model ListDefaultCollectorConfigurationsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      fileName?: string(name='fileName'),
    }
  ](name='Result'),
}

model ListDefaultCollectorConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDefaultCollectorConfigurationsResponseBody(name='body'),
}

async function listDefaultCollectorConfigurations(request: ListDefaultCollectorConfigurationsRequest): ListDefaultCollectorConfigurationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDefaultCollectorConfigurations', 'GET', '/openapi/beats/default-configurations', 'json', false, 'json', request);
}

model ListDeprecatedTemplatesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  name?: string(name='name', position='Query'),
  page?: int32(name='page', position='Query'),
  size?: int32(name='size', minimum=1, maximum=100, position='Query'),
}

model ListDeprecatedTemplatesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate'),
      order?: long(name='order'),
      template?: {
        aliases?: string(name='aliases'),
        mappings?: string(name='mappings'),
        settings?: string(name='settings'),
      }(name='template'),
      version?: string(name='version'),
    }
  ](name='Result'),
}

model ListDeprecatedTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDeprecatedTemplatesResponseBody(name='body'),
}

async function listDeprecatedTemplates(request: ListDeprecatedTemplatesRequest): ListDeprecatedTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDeprecatedTemplates', 'GET', '/openapi/instances/{InstanceId}/deprecated-templates', 'json', false, 'json', request);
}

model ListDiagnoseIndicesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  lang?: string(name='lang', position='Query'),
}

model ListDiagnoseIndicesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseIndicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDiagnoseIndicesResponseBody(name='body'),
}

async function listDiagnoseIndices(request: ListDiagnoseIndicesRequest): ListDiagnoseIndicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDiagnoseIndices', 'GET', '/openapi/diagnosis/instances/{InstanceId}/indices', 'json', false, 'json', request);
}

model ListDiagnoseReportRequest {
  instanceId: string(name='InstanceId', position='Path'),
  detail?: boolean(name='detail', position='Query'),
  endTime: long(name='endTime', minimum=1000000000000, maximum=2000000000000, position='Query'),
  lang?: string(name='lang', position='Query'),
  page?: int32(name='page', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', minimum=1, maximum=500, position='Query'),
  startTime: long(name='startTime', minimum=1000000000000, maximum=2000000000000, position='Query'),
  trigger?: string(name='trigger', position='Query'),
}

model ListDiagnoseReportResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: long(name='createTime'),
      diagnoseItems?: [ 
        {
          detail?: {
            desc?: string(name='desc'),
            name?: string(name='name'),
            result?: string(name='result'),
            suggest?: string(name='suggest'),
            type?: string(name='type'),
          }(name='detail'),
          health?: string(name='health'),
          item?: string(name='item'),
        }
      ](name='diagnoseItems'),
      health?: string(name='health'),
      instanceId?: string(name='instanceId'),
      reportId?: string(name='reportId'),
      state?: string(name='state'),
      trigger?: string(name='trigger'),
    }
  ](name='Result'),
}

model ListDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  body: ListDiagnoseReportResponseBody(name='body'),
}

async function listDiagnoseReport(request: ListDiagnoseReportRequest): ListDiagnoseReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDiagnoseReport', 'GET', '/openapi/diagnosis/instances/{InstanceId}/reports', 'json', false, 'json', request);
}

model ListDiagnoseReportIdsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  endTime: long(name='endTime', minimum=1000000000000, maximum=2000000000000, position='Query'),
  lang?: string(name='lang', position='Query'),
  page?: int32(name='page', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', minimum=1, maximum=500, position='Query'),
  startTime: long(name='startTime', minimum=1000000000000, maximum=2000000000000, position='Query'),
  trigger?: string(name='trigger', position='Query'),
}

model ListDiagnoseReportIdsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseReportIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDiagnoseReportIdsResponseBody(name='body'),
}

async function listDiagnoseReportIds(request: ListDiagnoseReportIdsRequest): ListDiagnoseReportIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDiagnoseReportIds', 'GET', '/openapi/diagnosis/instances/{InstanceId}/report-ids', 'json', false, 'json', request);
}

model ListDictInformationRequest {
  instanceId: string(name='InstanceId', position='Path'),
  analyzerType?: string(name='analyzerType', position='Query'),
  bucketName: string(name='bucketName', position='Query'),
  key: string(name='key', position='Query'),
}

model ListDictInformationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    fileSize?: long(name='fileSize'),
    ossObject?: {
      bucketName?: string(name='bucketName'),
      etag?: string(name='etag'),
      key?: string(name='key'),
    }(name='ossObject'),
    type?: string(name='type'),
  }(name='Result'),
}

model ListDictInformationResponse = {
  headers: map[string]string(name='headers'),
  body: ListDictInformationResponseBody(name='body'),
}

async function listDictInformation(request: ListDictInformationRequest): ListDictInformationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDictInformation', 'GET', '/openapi/instances/{InstanceId}/dict/_info', 'json', false, 'json', request);
}

model ListDictsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  analyzerType: string(name='analyzerType', position='Query'),
  name?: string(name='name', position='Query'),
}

model ListDictsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      downloadUrl?: string(name='downloadUrl'),
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model ListDictsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDictsResponseBody(name='body'),
}

async function listDicts(request: ListDictsRequest): ListDictsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDicts', 'GET', '/openapi/instances/{InstanceId}/dicts', 'json', false, 'json', request);
}

model ListEcsInstancesRequest {
  ecsInstanceIds?: string(name='ecsInstanceIds', position='Query'),
  ecsInstanceName?: string(name='ecsInstanceName', position='Query'),
  page?: int32(name='page', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', minimum=1, maximum=500, position='Query'),
  tags?: string(name='tags', position='Query'),
  vpcId?: string(name='vpcId', position='Query'),
}

model ListEcsInstancesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      cloudAssistantStatus?: string(name='cloudAssistantStatus'),
      collectors?: [ 
        {
          collectorPaths?: [ string ](name='collectorPaths'),
          configs?: [ 
            {
              content?: string(name='content'),
              fileName?: string(name='fileName'),
            }
          ](name='configs'),
          dryRun?: boolean(name='dryRun'),
          extendConfigs?: [ 
            {
              configType?: string(name='configType'),
              enableMonitoring?: boolean(name='enableMonitoring'),
              groupId?: string(name='groupId'),
              hosts?: [ string ](name='hosts'),
              instanceId?: string(name='instanceId'),
              instanceType?: string(name='instanceType'),
              machines?: [ 
                {
                  agentStatus?: string(name='agentStatus'),
                  instanceId?: string(name='instanceId'),
                }
              ](name='machines'),
              protocol?: string(name='protocol'),
              type?: string(name='type'),
              userName?: string(name='userName'),
            }
          ](name='extendConfigs'),
          gmtCreatedTime?: string(name='gmtCreatedTime'),
          gmtUpdateTime?: string(name='gmtUpdateTime'),
          name?: string(name='name'),
          ownerId?: string(name='ownerId'),
          resId?: string(name='resId'),
          resType?: string(name='resType'),
          resVersion?: string(name='resVersion'),
          status?: string(name='status'),
          vpcId?: string(name='vpcId'),
        }
      ](name='collectors'),
      ecsInstanceId?: string(name='ecsInstanceId'),
      ecsInstanceName?: string(name='ecsInstanceName'),
      ipAddress?: [ 
        {
          host?: string(name='host'),
          ipType?: string(name='ipType'),
        }
      ](name='ipAddress'),
      osType?: string(name='osType'),
      status?: string(name='status'),
      tags?: string(name='tags'),
    }
  ](name='Result'),
}

model ListEcsInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEcsInstancesResponseBody(name='body'),
}

async function listEcsInstances(request: ListEcsInstancesRequest): ListEcsInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListEcsInstances', 'GET', '/openapi/ecs', 'json', false, 'json', request);
}

model ListExtendfilesRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model ListExtendfilesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      filePath?: string(name='filePath'),
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
    }
  ](name='Result'),
}

model ListExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListExtendfilesResponseBody(name='body'),
}

async function listExtendfiles(request: ListExtendfilesRequest): ListExtendfilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListExtendfiles', 'GET', '/openapi/logstashes/{InstanceId}/extendfiles', 'json', false, 'json', request);
}

model ListILMPoliciesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  policyName?: string(name='policyName', position='Query'),
}

model ListILMPoliciesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      name?: string(name='name'),
      phases?: map[string]any(name='phases'),
    }
  ](name='Result'),
}

model ListILMPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: ListILMPoliciesResponseBody(name='body'),
}

async function listILMPolicies(request: ListILMPoliciesRequest): ListILMPoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListILMPolicies', 'GET', '/openapi/instances/{InstanceId}/ilm-policies', 'json', false, 'json', request);
}

model ListIndexTemplatesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  indexTemplate?: string(name='indexTemplate', position='Query'),
  page?: int32(name='page', position='Query'),
  size?: int32(name='size', position='Query'),
}

model ListIndexTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream'),
      ilmPolicy?: string(name='ilmPolicy'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate'),
      priority?: int32(name='priority'),
      template?: {
        aliases?: string(name='aliases'),
        mappings?: string(name='mappings'),
        settings?: string(name='settings'),
      }(name='template'),
    }
  ](name='Result'),
}

model ListIndexTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListIndexTemplatesResponseBody(name='body'),
}

async function listIndexTemplates(request: ListIndexTemplatesRequest): ListIndexTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListIndexTemplates', 'GET', '/openapi/instances/{InstanceId}/index-templates', 'json', false, 'json', request);
}

model ListInstanceRequest {
  description?: string(name='description', position='Query'),
  esVersion?: string(name='esVersion', position='Query'),
  instanceCategory?: string(name='instanceCategory', position='Query'),
  instanceId?: string(name='instanceId', position='Query'),
  page?: int32(name='page', position='Query'),
  paymentType?: string(name='paymentType', position='Query'),
  resourceGroupId?: string(name='resourceGroupId', position='Query'),
  size?: int32(name='size', position='Query'),
  tags?: string(name='tags', position='Query'),
  vpcId?: string(name='vpcId', position='Query'),
  zoneId?: string(name='zoneId', position='Query'),
}

model ListInstanceResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
      clientNodeConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='clientNodeConfiguration'),
      createdAt?: string(name='createdAt'),
      dedicateMaster?: boolean(name='dedicateMaster'),
      description?: string(name='description'),
      elasticDataNodeConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskEncryption?: boolean(name='diskEncryption'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='elasticDataNodeConfiguration'),
      esVersion?: string(name='esVersion'),
      extendConfigs?: [  map[string]any ](name='extendConfigs'),
      instanceId?: string(name='instanceId'),
      isNewDeployment?: string(name='isNewDeployment'),
      kibanaConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='kibanaConfiguration'),
      masterConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='masterConfiguration'),
      networkConfig?: {
        type?: string(name='type'),
        vpcId?: string(name='vpcId'),
        vsArea?: string(name='vsArea'),
        vswitchId?: string(name='vswitchId'),
      }(name='networkConfig'),
      nodeAmount?: int32(name='nodeAmount'),
      nodeSpec?: {
        disk?: int32(name='disk'),
        diskEncryption?: boolean(name='diskEncryption'),
        diskType?: string(name='diskType'),
        performanceLevel?: string(name='performanceLevel'),
        spec?: string(name='spec'),
      }(name='nodeSpec'),
      paymentType?: string(name='paymentType'),
      postpaidServiceStatus?: string(name='postpaidServiceStatus'),
      resourceGroupId?: string(name='resourceGroupId'),
      serviceVpc?: boolean(name='serviceVpc'),
      status?: string(name='status'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey'),
          tagValue?: string(name='tagValue'),
        }
      ](name='tags'),
      updatedAt?: string(name='updatedAt'),
      vpcInstanceId?: string(name='vpcInstanceId'),
    }
  ](name='Result'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstance', 'GET', '/openapi/instances', 'json', false, 'json', request);
}

model ListInstanceHistoryEventsRequest {
  eventCreateEndTime?: string(name='eventCreateEndTime', position='Query'),
  eventCreateStartTime?: string(name='eventCreateStartTime', position='Query'),
  eventCycleStatus?: [ string ](name='eventCycleStatus', shrink='simple', position='Query'),
  eventExecuteEndTime?: string(name='eventExecuteEndTime', position='Query'),
  eventExecuteStartTime?: string(name='eventExecuteStartTime', position='Query'),
  eventFinashEndTime?: string(name='eventFinashEndTime', position='Query'),
  eventFinashStartTime?: string(name='eventFinashStartTime', position='Query'),
  eventLevel?: [ string ](name='eventLevel', shrink='simple', position='Query'),
  eventType?: [ string ](name='eventType', shrink='simple', position='Query'),
  instanceId?: string(name='instanceId', position='Query'),
  nodeIP?: string(name='nodeIP', position='Query'),
  page?: int32(name='page', position='Query'),
  size?: int32(name='size', position='Query'),
}

model ListInstanceHistoryEventsResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count'),
    xTotalFailed?: long(name='X-Total-Failed'),
    xTotalSuccess?: long(name='X-Total-Success'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      ecsId?: string(name='ecsId'),
      eventCreateTime?: string(name='eventCreateTime'),
      eventCycleStatus?: string(name='eventCycleStatus'),
      eventExecuteTime?: string(name='eventExecuteTime'),
      eventFinashTime?: string(name='eventFinashTime'),
      eventLevel?: string(name='eventLevel'),
      eventType?: string(name='eventType'),
      instanceId?: string(name='instanceId'),
      nodeIP?: string(name='nodeIP'),
      regionId?: string(name='regionId'),
    }
  ](name='Result'),
}

model ListInstanceHistoryEventsResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceHistoryEventsResponseBody(name='body'),
}

async function listInstanceHistoryEvents(request: ListInstanceHistoryEventsRequest): ListInstanceHistoryEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstanceHistoryEvents', 'POST', '/openapi/events', 'json', false, 'json', request);
}

model ListInstanceIndicesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  all?: boolean(name='all', position='Query'),
  isManaged?: boolean(name='isManaged', position='Query'),
  isOpenstore?: boolean(name='isOpenstore', position='Query'),
  name?: string(name='name', position='Query'),
  page?: int32(name='page', position='Query'),
  size?: int32(name='size', position='Query'),
}

model ListInstanceIndicesResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize'),
    xOSSCount?: int32(name='X-OSS-Count'),
    xOSSStorageSize?: long(name='X-OSS-StorageSize'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='createTime'),
      health?: string(name='health'),
      ilmExplain?: string(name='ilmExplain'),
      isManaged?: string(name='isManaged'),
      managedStatus?: string(name='managedStatus'),
      name?: string(name='name'),
      phase?: string(name='phase'),
      size?: long(name='size'),
    }
  ](name='Result'),
}

model ListInstanceIndicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceIndicesResponseBody(name='body'),
}

async function listInstanceIndices(request: ListInstanceIndicesRequest): ListInstanceIndicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstanceIndices', 'GET', '/openapi/instances/{InstanceId}/indices', 'json', false, 'json', request);
}

model ListKibanaPluginsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  page?: string(name='page', position='Query'),
  size?: int32(name='size', position='Query'),
}

model ListKibanaPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      source?: string(name='source'),
      specificationUrl?: string(name='specificationUrl'),
      state?: string(name='state'),
    }
  ](name='Result'),
}

model ListKibanaPluginsResponse = {
  headers: map[string]string(name='headers'),
  body: ListKibanaPluginsResponseBody(name='body'),
}

async function listKibanaPlugins(request: ListKibanaPluginsRequest): ListKibanaPluginsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListKibanaPlugins', 'GET', '/openapi/instances/{InstanceId}/kibana-plugins', 'json', false, 'json', request);
}

model ListLogstashRequest {
  description?: string(name='description', position='Query'),
  instanceId?: string(name='instanceId', position='Query'),
  ownerId?: string(name='ownerId', position='Query'),
  page?: int32(name='page', position='Query'),
  resourceGroupId?: string(name='resourceGroupId', position='Query'),
  size?: int32(name='size', position='Query'),
  tags?: string(name='tags', position='Query'),
  version?: string(name='version', position='Query'),
}

model ListLogstashResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tags?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tags'),
      createdAt?: string(name='createdAt'),
      description?: string(name='description'),
      instanceId?: string(name='instanceId'),
      networkConfig?: {
        type?: string(name='type'),
        vpcId?: string(name='vpcId'),
        vsArea?: string(name='vsArea'),
        vswitchId?: string(name='vswitchId'),
      }(name='networkConfig'),
      nodeAmount?: int32(name='nodeAmount'),
      nodeSpec?: {
        disk?: int32(name='disk'),
        diskEncryption?: boolean(name='diskEncryption'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='nodeSpec'),
      paymentType?: string(name='paymentType'),
      status?: string(name='status'),
      updatedAt?: string(name='updatedAt'),
      version?: string(name='version'),
    }
  ](name='Result'),
}

model ListLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogstashResponseBody(name='body'),
}

async function listLogstash(request: ListLogstashRequest): ListLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogstash', 'GET', '/openapi/logstashes', 'json', false, 'json', request);
}

model ListLogstashLogRequest {
  instanceId: string(name='InstanceId', position='Path'),
  beginTime?: long(name='beginTime', position='Query'),
  endTime?: long(name='endTime', position='Query'),
  page?: int32(name='page', position='Query'),
  query: string(name='query', position='Query'),
  size?: int32(name='size', position='Query'),
  type: string(name='type', position='Query'),
}

model ListLogstashLogResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      host?: string(name='host'),
      instanceId?: string(name='instanceId'),
      level?: string(name='level'),
      timestamp?: long(name='timestamp'),
    }
  ](name='Result'),
}

model ListLogstashLogResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogstashLogResponseBody(name='body'),
}

async function listLogstashLog(request: ListLogstashLogRequest): ListLogstashLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogstashLog', 'GET', '/openapi/logstashes/{InstanceId}/search-log', 'json', false, 'json', request);
}

model ListLogstashPluginsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  name?: string(name='name', position='Query'),
  page?: int32(name='page', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', minimum=1, maximum=200, position='Query'),
  source?: string(name='source', position='Query'),
}

model ListLogstashPluginsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      source?: string(name='source'),
      specificationUrl?: string(name='specificationUrl'),
      state?: string(name='state'),
    }
  ](name='Result'),
}

model ListLogstashPluginsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogstashPluginsResponseBody(name='body'),
}

async function listLogstashPlugins(request: ListLogstashPluginsRequest): ListLogstashPluginsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogstashPlugins', 'GET', '/openapi/logstashes/{InstanceId}/plugins', 'json', false, 'json', request);
}

model ListNodesRequest {
  resId: string(name='ResId', position='Path'),
  ecsInstanceIds?: string(name='ecsInstanceIds', position='Query'),
  ecsInstanceName?: string(name='ecsInstanceName', position='Query'),
  page?: int32(name='page', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', minimum=1, maximum=10000, position='Query'),
  tags?: string(name='tags', position='Query'),
}

model ListNodesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      agentStatus?: string(name='agentStatus'),
      cloudAssistantStatus?: string(name='cloudAssistantStatus'),
      ecsInstanceId?: string(name='ecsInstanceId'),
      ecsInstanceName?: string(name='ecsInstanceName'),
      ipAddress?: [ 
        {
          host?: string(name='host'),
          ipType?: string(name='ipType'),
        }
      ](name='ipAddress'),
      osType?: string(name='osType'),
      status?: string(name='status'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey'),
          tagValue?: string(name='tagValue'),
        }
      ](name='tags'),
    }
  ](name='Result'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListNodes', 'GET', '/openapi/collectors/{ResId}/nodes', 'json', false, 'json', request);
}

model ListPipelineRequest {
  instanceId: string(name='InstanceId', position='Path'),
  page?: int32(name='page', minimum=1, maximum=200, position='Query'),
  pipelineId?: string(name='pipelineId', position='Query'),
  size?: int32(name='size', minimum=1, maximum=200, position='Query'),
}

model ListPipelineResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      gmtCreatedTime?: string(name='gmtCreatedTime'),
      gmtUpdateTime?: string(name='gmtUpdateTime'),
      pipelineId?: string(name='pipelineId'),
      pipelineStatus?: string(name='pipelineStatus'),
    }
  ](name='Result'),
}

model ListPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListPipelineResponseBody(name='body'),
}

async function listPipeline(request: ListPipelineRequest): ListPipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPipeline', 'GET', '/openapi/logstashes/{InstanceId}/pipelines', 'json', false, 'json', request);
}

model ListPipelineIdsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
}

model ListPipelineIdsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      available?: boolean(name='available'),
      code?: string(name='code'),
      message?: string(name='message'),
      pipelineId?: string(name='pipelineId'),
    }
  ](name='Result'),
}

model ListPipelineIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPipelineIdsResponseBody(name='body'),
}

async function listPipelineIds(request: ListPipelineIdsRequest): ListPipelineIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPipelineIds', 'POST', '/openapi/instances/{InstanceId}/pipeline-ids', 'json', false, 'json', request);
}

model ListPluginsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  name?: string(name='name', position='Query'),
  page?: string(name='page', position='Query'),
  size?: int32(name='size', position='Query'),
  source?: string(name='source', position='Query'),
}

model ListPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      source?: string(name='source'),
      specificationUrl?: string(name='specificationUrl'),
      state?: string(name='state'),
    }
  ](name='Result'),
}

model ListPluginsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPluginsResponseBody(name='body'),
}

async function listPlugins(request: ListPluginsRequest): ListPluginsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPlugins', 'GET', '/openapi/instances/{InstanceId}/plugins', 'json', false, 'json', request);
}

model ListSearchLogRequest {
  instanceId: string(name='InstanceId', position='Path'),
  beginTime?: long(name='beginTime', position='Query'),
  endTime?: long(name='endTime', position='Query'),
  page?: int32(name='page', position='Query'),
  query: string(name='query', position='Query'),
  size?: int32(name='size', minimum=1, maximum=50, position='Query'),
  type: string(name='type', position='Query'),
}

model ListSearchLogResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      contentCollection?: map[string]any(name='contentCollection'),
      host?: string(name='host'),
      instanceId?: string(name='instanceId'),
      level?: string(name='level'),
      timestamp?: long(name='timestamp'),
    }
  ](name='Result'),
}

model ListSearchLogResponse = {
  headers: map[string]string(name='headers'),
  body: ListSearchLogResponseBody(name='body'),
}

async function listSearchLog(request: ListSearchLogRequest): ListSearchLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSearchLog', 'GET', '/openapi/instances/{InstanceId}/search-log', 'json', false, 'json', request);
}

model ListShardRecoveriesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  activeOnly?: boolean(name='activeOnly', position='Query'),
}

model ListShardRecoveriesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      bytesPercent?: string(name='bytesPercent'),
      bytesTotal?: long(name='bytesTotal'),
      filesPercent?: string(name='filesPercent'),
      filesTotal?: long(name='filesTotal'),
      index?: string(name='index'),
      sourceHost?: string(name='sourceHost'),
      sourceNode?: string(name='sourceNode'),
      stage?: string(name='stage'),
      targetHost?: string(name='targetHost'),
      targetNode?: string(name='targetNode'),
      translogOps?: long(name='translogOps'),
      translogOpsPercent?: string(name='translogOpsPercent'),
    }
  ](name='Result'),
}

model ListShardRecoveriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListShardRecoveriesResponseBody(name='body'),
}

async function listShardRecoveries(request: ListShardRecoveriesRequest): ListShardRecoveriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListShardRecoveries', 'GET', '/openapi/instances/{InstanceId}/cat-recovery', 'json', false, 'json', request);
}

model ListSnapshotReposByInstanceIdRequest {
  instanceId: string(name='InstanceId', position='Path'),
}

model ListSnapshotReposByInstanceIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      instanceId?: string(name='instanceId'),
      repoPath?: string(name='repoPath'),
      snapWarehouse?: string(name='snapWarehouse'),
      status?: string(name='status'),
    }
  ](name='Result'),
}

model ListSnapshotReposByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  body: ListSnapshotReposByInstanceIdResponseBody(name='body'),
}

async function listSnapshotReposByInstanceId(request: ListSnapshotReposByInstanceIdRequest): ListSnapshotReposByInstanceIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSnapshotReposByInstanceId', 'GET', '/openapi/instances/{InstanceId}/snapshot-repos', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  page?: int32(name='Page', deprecated='true', position='Query'),
  resourceIds?: string(name='ResourceIds', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  size?: int32(name='Size', deprecated='true', position='Query'),
  tags?: string(name='Tags', position='Query'),
}

model ListTagResourcesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        tagKey?: string(name='TagKey'),
        tagValue?: string(name='TagValue'),
      }
    ](name='TagResource'),
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTagResources', 'GET', '/openapi/tags', 'json', false, 'json', request);
}

model ListTagsRequest {
  pageSize?: int32(name='pageSize', minimum=1, maximum=50, position='Query'),
  resourceType?: string(name='resourceType', position='Query'),
}

model ListTagsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Result'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagsResponseBody(name='body'),
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTags', 'GET', '/openapi/tags/all-tags', 'json', false, 'json', request);
}

model ListVpcEndpointsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  page?: int32(name='page', position='Query'),
  size?: int32(name='size', position='Query'),
}

model ListVpcEndpointsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      connectionStatus?: string(name='connectionStatus'),
      createTime?: string(name='createTime'),
      endpointBusinessStatus?: string(name='endpointBusinessStatus'),
      endpointDomain?: string(name='endpointDomain'),
      endpointId?: string(name='endpointId'),
      endpointName?: string(name='endpointName'),
      endpointStatus?: string(name='endpointStatus'),
      serviceId?: string(name='serviceId'),
      serviceName?: string(name='serviceName'),
    }
  ](name='Result'),
}

model ListVpcEndpointsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointsResponseBody(name='body'),
}

async function listVpcEndpoints(request: ListVpcEndpointsRequest): ListVpcEndpointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListVpcEndpoints', 'GET', '/openapi/instances/{InstanceId}/vpc-endpoints', 'json', false, 'json', request);
}

model MigrateToOtherZoneRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  dryRun: boolean(name='dryRun', position='Query'),
}

model MigrateToOtherZoneResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model MigrateToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  body: MigrateToOtherZoneResponseBody(name='body'),
}

async function migrateToOtherZone(request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'MigrateToOtherZone', 'POST', '/openapi/instances/{InstanceId}/actions/migrate-zones', 'json', false, 'json', request);
}

model ModifyDeployMachineRequest {
  resId: string(name='ResId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model ModifyDeployMachineResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyDeployMachineResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDeployMachineResponseBody(name='body'),
}

async function modifyDeployMachine(request: ModifyDeployMachineRequest): ModifyDeployMachineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyDeployMachine', 'POST', '/openapi/collectors/{ResId}/actions/modify-deploy-machines', 'json', false, 'json', request);
}

model ModifyElastictaskRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
}

model ModifyElastictaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model ModifyElastictaskResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyElastictaskResponseBody(name='body'),
}

async function modifyElastictask(request: ModifyElastictaskRequest): ModifyElastictaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyElastictask', 'POST', '/openapi/instances/{InstanceId}/elastic-task', 'json', false, 'json', request);
}

model ModifyInstanceMaintainTimeRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model ModifyInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyInstanceMaintainTime(request: ModifyInstanceMaintainTimeRequest): ModifyInstanceMaintainTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyInstanceMaintainTime', 'POST', '/openapi/instances/{InstanceId}/actions/modify-maintaintime', 'json', false, 'json', request);
}

model ModifyWhiteIpsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  modifyMode?: string(name='modifyMode', description='修改方式，取值含义如下：

Cover（默认值）：使用ips参数的值覆盖原IP白名单。

Append：在原IP白名单中增加ips参数中输入的IP地址。

Delete：Delete：在原IP白名单中删除ips参数中输入的IP地址，至少需要保留一个IP地址。', position='Body'),
  networkType?: string(name='networkType', description='网络类型。可选值：PRIVATE（私网）、PUBLIC（公网）。如果选填了whiteIpList参数，则该参数必填。', position='Body'),
  nodeType?: string(name='nodeType', description='节点类型。可选值：WORKER（Elasticsearch集群）、KIBANA（Kibana集群）。如果选填了whiteIpList参数，则该参数必填。', position='Body'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='白名单组的组名。如果选填了whiteIpGroup参数，则该参数必填。'),
    ips?: [ string ](name='ips', description='白名单组中的IP列表。如果选填了whiteIpGroup参数，则该参数必填。'),
    whiteIpType?: string(name='whiteIpType', description='ip白名单的类型'),
  }(name='whiteIpGroup', description='以白名单组whiteIpGroup传参方式，更新实例白名单安全配置。仅支持更新一个白名单组。', position='Body'),
  whiteIpList?: [ string ](name='whiteIpList', description='白名单列表。whiteIpGroup为空时可用，更改默认分组白名单', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model ModifyWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWhiteIpsResponseBody(name='body'),
}

async function modifyWhiteIps(request: ModifyWhiteIpsRequest): ModifyWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyWhiteIps', 'POST', '/openapi/instances/{InstanceId}/actions/modify-white-ips', 'json', false, 'json', request);
}

model MoveResourceGroupRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    esVersion?: string(name='esVersion'),
    instanceId?: string(name='instanceId'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaPort?: int32(name='kibanaPort'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    publicDomain?: string(name='publicDomain'),
    publicPort?: int32(name='publicPort'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    updatedAt?: string(name='updatedAt'),
  }(name='Result'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'MoveResourceGroup', 'POST', '/openapi/instances/{InstanceId}/resourcegroup', 'json', false, 'json', request);
}

model OpenDiagnosisRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  lang?: string(name='lang', position='Query'),
}

model OpenDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model OpenDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: OpenDiagnosisResponseBody(name='body'),
}

async function openDiagnosis(request: OpenDiagnosisRequest): OpenDiagnosisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'OpenDiagnosis', 'POST', '/openapi/diagnosis/instances/{InstanceId}/actions/open-diagnosis', 'json', false, 'json', request);
}

model OpenHttpsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model OpenHttpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model OpenHttpsResponse = {
  headers: map[string]string(name='headers'),
  body: OpenHttpsResponseBody(name='body'),
}

async function openHttps(request: OpenHttpsRequest): OpenHttpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'OpenHttps', 'POST', '/openapi/instances/{InstanceId}/actions/open-https', 'json', false, 'json', request);
}

model PostEmonTryAlarmRuleRequest {
  projectId: string(name='ProjectId', position='Path'),
  alarmGroupId: string(name='AlarmGroupId', position='Path'),
  body?: string(name='body', position='Body'),
}

model PostEmonTryAlarmRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PostEmonTryAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PostEmonTryAlarmRuleResponseBody(name='body'),
}

async function postEmonTryAlarmRule(request: PostEmonTryAlarmRuleRequest): PostEmonTryAlarmRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PostEmonTryAlarmRule', 'POST', '/openapi/emon/projects/{ProjectId}/alarm-groups/{AlarmGroupId}/alarm-rules/_test', 'json', false, 'json', request);
}

model RecommendTemplatesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  usageScenario: string(name='usageScenario', position='Query'),
}

model RecommendTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      templateName?: string(name='templateName'),
    }
  ](name='Result'),
}

model RecommendTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: RecommendTemplatesResponseBody(name='body'),
}

async function recommendTemplates(request: RecommendTemplatesRequest): RecommendTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RecommendTemplates', 'GET', '/openapi/instances/{InstanceId}/recommended-templates', 'json', false, 'json', request);
}

model ReinstallCollectorRequest {
  resId: string(name='ResId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model ReinstallCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ReinstallCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: ReinstallCollectorResponseBody(name='body'),
}

async function reinstallCollector(request: ReinstallCollectorRequest): ReinstallCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ReinstallCollector', 'POST', '/openapi/collectors/{ResId}/actions/reinstall', 'json', false, 'json', request);
}

model RemoveApmRequest {
  instanceId?: string(name='instanceId', position='Path'),
}

model RemoveApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RemoveApmResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveApmResponseBody(name='body'),
}

async function removeApm(request: RemoveApmRequest): RemoveApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveApm', 'DELETE', '/openapi/apm/{instanceId}', 'json', false, 'json', request);
}

model RenewInstanceRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model RenewInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RenewInstance', 'POST', '/openapi/instances/{InstanceId}/actions/renew', 'json', false, 'json', request);
}

model RenewLogstashRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model RenewLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RenewLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: RenewLogstashResponseBody(name='body'),
}

async function renewLogstash(request: RenewLogstashRequest): RenewLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RenewLogstash', 'POST', '/openapi/logstashes/{InstanceId}/actions/renew', 'json', false, 'json', request);
}

model RestartCollectorRequest {
  resId: string(name='ResId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model RestartCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RestartCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: RestartCollectorResponseBody(name='body'),
}

async function restartCollector(request: RestartCollectorRequest): RestartCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestartCollector', 'POST', '/openapi/collectors/{ResId}/actions/restart', 'json', false, 'json', request);
}

model RestartInstanceRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  force?: boolean(name='force', position='Query'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    esVersion?: string(name='esVersion'),
    instanceId?: string(name='instanceId'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaPort?: int32(name='kibanaPort'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    publicDomain?: string(name='publicDomain'),
    publicPort?: int32(name='publicPort'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    updatedAt?: string(name='updatedAt'),
  }(name='Result'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartInstanceResponseBody(name='body'),
}

async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestartInstance', 'POST', '/openapi/instances/{InstanceId}/actions/restart', 'json', false, 'json', request);
}

model RestartLogstashRequest {
  instanceId: string(name='InstanceId', position='Path'),
  batchCount?: double(name='batchCount', description='强制重启百分比。蓝绿重启时，无法强制重启，无需设置。', minimum=0, maximum=100, position='Body'),
  blueGreenDep?: boolean(name='blueGreenDep', description='是否蓝绿重启', position='Body'),
  nodeTypes?: [ string ](name='nodeTypes', description='角色重启时，选择的角色类型。', position='Body'),
  nodes?: [ string ](name='nodes', description='节点重启时，选择的节点IP', position='Body'),
  restartType?: string(name='restartType', description='重启类型
', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  force?: boolean(name='force', position='Query'),
}

model RestartLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: Logstash(name='Result'),
}

model RestartLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: RestartLogstashResponseBody(name='body'),
}

async function restartLogstash(request: RestartLogstashRequest): RestartLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestartLogstash', 'POST', '/openapi/logstashes/{InstanceId}/actions/restart', 'json', false, 'json', request);
}

model ResumeElasticsearchTaskRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model ResumeElasticsearchTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ResumeElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeElasticsearchTaskResponseBody(name='body'),
}

async function resumeElasticsearchTask(request: ResumeElasticsearchTaskRequest): ResumeElasticsearchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ResumeElasticsearchTask', 'POST', '/openapi/instances/{InstanceId}/actions/resume', 'json', false, 'json', request);
}

model ResumeLogstashTaskRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model ResumeLogstashTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ResumeLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeLogstashTaskResponseBody(name='body'),
}

async function resumeLogstashTask(request: ResumeLogstashTaskRequest): ResumeLogstashTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ResumeLogstashTask', 'POST', '/openapi/logstashes/{InstanceId}/actions/resume', 'json', false, 'json', request);
}

model RolloverDataStreamRequest {
  instanceId: string(name='InstanceId', position='Path'),
  dataStream: string(name='DataStream', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model RolloverDataStreamResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RolloverDataStreamResponse = {
  headers: map[string]string(name='headers'),
  body: RolloverDataStreamResponseBody(name='body'),
}

async function rolloverDataStream(request: RolloverDataStreamRequest): RolloverDataStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RolloverDataStream', 'POST', '/openapi/instances/{InstanceId}/data-streams/{DataStream}/rollover', 'json', false, 'json', request);
}

model RunPipelinesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model RunPipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RunPipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: RunPipelinesResponseBody(name='body'),
}

async function runPipelines(request: RunPipelinesRequest): RunPipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RunPipelines', 'POST', '/openapi/logstashes/{InstanceId}/pipelines/action/run', 'json', false, 'json', request);
}

model ShrinkNodeRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: [ 
    {
      host?: string(name='host'),
      hostName?: string(name='hostName'),
      nodeType?: string(name='nodeType'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  count?: int32(name='count', position='Query'),
  ignoreStatus?: boolean(name='ignoreStatus', position='Query'),
  nodeType: string(name='nodeType', position='Query'),
}

model ShrinkNodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ShrinkNodeResponse = {
  headers: map[string]string(name='headers'),
  body: ShrinkNodeResponseBody(name='body'),
}

async function shrinkNode(request: ShrinkNodeRequest): ShrinkNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ShrinkNode', 'POST', '/openapi/instances/{InstanceId}/actions/shrink', 'json', false, 'json', request);
}

model StartApmRequest {
  instanceId: string(name='instanceId', position='Path'),
}

model StartApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StartApmResponse = {
  headers: map[string]string(name='headers'),
  body: StartApmResponseBody(name='body'),
}

async function startApm(request: StartApmRequest): StartApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartApm', 'POST', '/openapi/apm/{instanceId}/actions/start', 'json', false, 'json', request);
}

model StartCollectorRequest {
  resId: string(name='ResId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model StartCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StartCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: StartCollectorResponseBody(name='body'),
}

async function startCollector(request: StartCollectorRequest): StartCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartCollector', 'POST', '/openapi/collectors/{ResId}/actions/start', 'json', false, 'json', request);
}

model StopApmRequest {
  instanceId: string(name='instanceId', position='Path'),
}

model StopApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StopApmResponse = {
  headers: map[string]string(name='headers'),
  body: StopApmResponseBody(name='body'),
}

async function stopApm(request: StopApmRequest): StopApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopApm', 'POST', '/openapi/apm/{instanceId}/actions/stop', 'json', false, 'json', request);
}

model StopCollectorRequest {
  resId: string(name='ResId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
}

model StopCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StopCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: StopCollectorResponseBody(name='body'),
}

async function stopCollector(request: StopCollectorRequest): StopCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopCollector', 'POST', '/openapi/collectors/{ResId}/actions/stop', 'json', false, 'json', request);
}

model StopPipelinesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model StopPipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StopPipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: StopPipelinesResponseBody(name='body'),
}

async function stopPipelines(request: StopPipelinesRequest): StopPipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopPipelines', 'POST', '/openapi/logstashes/{InstanceId}/pipelines/action/stop', 'json', false, 'json', request);
}

model TagResourcesRequest {
  resourceIds: [ string ](name='ResourceIds', description='实例ID列表。', position='Body'),
  resourceType: string(name='ResourceType', description='资源类型，固定为INSTANCE。', position='Body'),
  tags: [ 
    {
      key: string(name='key', description='标签Key'),
      value: string(name='value', description='标签Value'),
    }
  ](name='Tags', description='所关联的标签列表。', position='Body'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='请求ID。'),
  result?: boolean(name='Result', description='返回结果，true 标签关联资源成功。'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TagResources', 'POST', '/openapi/tags', 'json', false, 'json', request);
}

model TransferNodeRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  nodeType: string(name='nodeType', position='Query'),
}

model TransferNodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model TransferNodeResponse = {
  headers: map[string]string(name='headers'),
  body: TransferNodeResponseBody(name='body'),
}

async function transferNode(request: TransferNodeRequest): TransferNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TransferNode', 'POST', '/openapi/instances/{InstanceId}/actions/transfer', 'json', false, 'json', request);
}

model TriggerNetworkRequest {
  instanceId: string(name='InstanceId', description='实例ID', position='Path'),
  actionType?: string(name='actionType', description='动作类型。CLOSE：关闭; OPEN：开启', position='Body'),
  networkType?: string(name='networkType', description='网络类型。PUBLIC：公网；PRIVATE：私网', position='Body'),
  nodeType?: string(name='nodeType', description='实例类型。KIBANA kibana公私网/WORKER 集群公私网', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model TriggerNetworkResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model TriggerNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: TriggerNetworkResponseBody(name='body'),
}

async function triggerNetwork(request: TriggerNetworkRequest): TriggerNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TriggerNetwork', 'POST', '/openapi/instances/{InstanceId}/actions/network-trigger', 'json', false, 'json', request);
}

model UninstallKibanaPluginRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UninstallKibanaPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model UninstallKibanaPluginResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallKibanaPluginResponseBody(name='body'),
}

async function uninstallKibanaPlugin(request: UninstallKibanaPluginRequest): UninstallKibanaPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UninstallKibanaPlugin', 'POST', '/openapi/instances/{InstanceId}/kibana-plugins/actions/uninstall', 'json', false, 'json', request);
}

model UninstallLogstashPluginRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: [ string ](name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UninstallLogstashPluginResponseBody = {
  headers?: map[string]any(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model UninstallLogstashPluginResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallLogstashPluginResponseBody(name='body'),
}

async function uninstallLogstashPlugin(request: UninstallLogstashPluginRequest): UninstallLogstashPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UninstallLogstashPlugin', 'POST', '/openapi/logstashes/{InstanceId}/plugins/actions/uninstall', 'json', false, 'json', request);
}

model UninstallPluginRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UninstallPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model UninstallPluginResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallPluginResponseBody(name='body'),
}

async function uninstallPlugin(request: UninstallPluginRequest): UninstallPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UninstallPlugin', 'POST', '/openapi/instances/{InstanceId}/plugins/actions/uninstall', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  resourceIds?: string(name='ResourceIds', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  tagKeys?: string(name='TagKeys', position='Query'),
  body?: string(name='body', position='Body'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UntagResources', 'DELETE', '/openapi/tags', 'json', false, 'json', request);
}

model UpdateAdminPasswordRequest {
  instanceId: string(name='InstanceId', position='Path'),
  esAdminPassword?: string(name='esAdminPassword', description='Elasticsearch实例的elastic账号的密码。', minLength=8, maxLength=32, position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateAdminPasswordResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateAdminPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAdminPasswordResponseBody(name='body'),
}

async function updateAdminPassword(request: UpdateAdminPasswordRequest): UpdateAdminPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAdminPassword', 'POST', '/openapi/instances/{InstanceId}/admin-pwd', 'json', false, 'json', request);
}

model UpdateAdvancedSettingRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateAdvancedSettingResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateAdvancedSettingResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAdvancedSettingResponseBody(name='body'),
}

async function updateAdvancedSetting(request: UpdateAdvancedSettingRequest): UpdateAdvancedSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAdvancedSetting', 'POST', '/openapi/instances/{InstanceId}/actions/update-advanced-setting', 'json', false, 'json', request);
}

model UpdateAliwsDictRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateAliwsDictResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateAliwsDictResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAliwsDictResponseBody(name='body'),
}

async function updateAliwsDict(request: UpdateAliwsDictRequest): UpdateAliwsDictResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAliwsDict', 'PUT', '/openapi/instances/{InstanceId}/aliws-dict', 'json', false, 'json', request);
}

model UpdateApmRequest {
  instanceId: string(name='instanceId', position='Path'),
  description?: string(name='description', description='apm实例名', position='Body'),
  outputES?: string(name='outputES', description='es实例id', position='Body'),
  outputESPassword?: string(name='outputESPassword', description='es实例密码', position='Body'),
  outputESUserName?: string(name='outputESUserName', description='es实例用户名', position='Body'),
  token?: string(name='token', description='apm server密码', position='Body'),
}

model UpdateApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateApmResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApmResponseBody(name='body'),
}

async function updateApm(request: UpdateApmRequest): UpdateApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateApm', 'PUT', '/openapi/apm/{instanceId}', 'json', false, 'json', request);
}

model UpdateBlackIpsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateBlackIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
  }(name='Result'),
}

model UpdateBlackIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBlackIpsResponseBody(name='body'),
}

async function updateBlackIps(request: UpdateBlackIpsRequest): UpdateBlackIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateBlackIps', 'POST', '/openapi/instances/{InstanceId}/black-ips', 'json', false, 'json', request);
}

model UpdateCollectorRequest {
  resId: string(name='ResId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content'),
        fileName?: string(name='fileName'),
      }
    ](name='configs'),
    dryRun?: boolean(name='dryRun'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType'),
        enableMonitoring?: boolean(name='enableMonitoring'),
        groupId?: string(name='groupId'),
        host?: string(name='host'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId'),
        instanceType?: string(name='instanceType'),
        kibanaHost?: string(name='kibanaHost'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus'),
            instanceId?: string(name='instanceId'),
          }
        ](name='machines'),
        protocol?: string(name='protocol'),
        successPodsCount?: string(name='successPodsCount'),
        totalPodsCount?: string(name='totalPodsCount'),
        type?: string(name='type'),
        userName?: string(name='userName'),
      }
    ](name='extendConfigs'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    name?: string(name='name'),
    ownerId?: string(name='ownerId'),
    resId?: string(name='resId'),
    resType?: string(name='resType'),
    resVersion?: string(name='resVersion'),
    status?: string(name='status'),
    vpcId?: string(name='vpcId'),
  }(name='Result'),
}

model UpdateCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCollectorResponseBody(name='body'),
}

async function updateCollector(request: UpdateCollectorRequest): UpdateCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCollector', 'PUT', '/openapi/collectors/{ResId}', 'json', false, 'json', request);
}

model UpdateCollectorNameRequest {
  resId: string(name='ResId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateCollectorNameResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content'),
        fileName?: string(name='fileName'),
      }
    ](name='configs'),
    dryRun?: boolean(name='dryRun'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType'),
        enableMonitoring?: boolean(name='enableMonitoring'),
        groupId?: string(name='groupId'),
        host?: string(name='host'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId'),
        instanceType?: string(name='instanceType'),
        kibanaHost?: string(name='kibanaHost'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus'),
            instanceId?: string(name='instanceId'),
          }
        ](name='machines'),
        protocol?: string(name='protocol'),
        successPodsCount?: string(name='successPodsCount'),
        totalPodsCount?: string(name='totalPodsCount'),
        type?: string(name='type'),
        userName?: string(name='userName'),
      }
    ](name='extendConfigs'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    name?: string(name='name'),
    ownerId?: string(name='ownerId'),
    resId?: string(name='resId'),
    resType?: string(name='resType'),
    resVersion?: string(name='resVersion'),
    status?: string(name='status'),
    vpcId?: string(name='vpcId'),
  }(name='Result'),
}

model UpdateCollectorNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCollectorNameResponseBody(name='body'),
}

async function updateCollectorName(request: UpdateCollectorNameRequest): UpdateCollectorNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCollectorName', 'POST', '/openapi/collectors/{ResId}/actions/rename', 'json', false, 'json', request);
}

model UpdateComponentIndexRequest {
  instanceId: string(name='InstanceId', description='A short description of struct', position='Path'),
  name: string(name='name', position='Path'),
  meta?: map[string]any(name='_meta', position='Body'),
  template?: {
    aliases?: map[string]any(name='aliases'),
    mappings?: map[string]any(name='mappings'),
    settings?: map[string]any(name='settings'),
  }(name='template', position='Body'),
}

model UpdateComponentIndexResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model UpdateComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateComponentIndexResponseBody(name='body'),
}

async function updateComponentIndex(request: UpdateComponentIndexRequest): UpdateComponentIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateComponentIndex', 'PUT', '/openapi/instances/{InstanceId}/component-index/{name}', 'json', false, 'json', request);
}

model UpdateDescriptionRequest {
  instanceId: string(name='InstanceId', position='Path'),
  description?: string(name='description', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    description?: string(name='description'),
  }(name='Result'),
}

model UpdateDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDescriptionResponseBody(name='body'),
}

async function updateDescription(request: UpdateDescriptionRequest): UpdateDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDescription', 'POST', '/openapi/instances/{InstanceId}/description', 'json', false, 'json', request);
}

model UpdateDiagnosisSettingsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
  lang?: string(name='lang', position='Query'),
}

model UpdateDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDiagnosisSettingsResponseBody(name='body'),
}

async function updateDiagnosisSettings(request: UpdateDiagnosisSettingsRequest): UpdateDiagnosisSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDiagnosisSettings', 'PUT', '/openapi/diagnosis/instances/{InstanceId}/settings', 'json', false, 'json', request);
}

model UpdateDictRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateDictResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateDictResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDictResponseBody(name='body'),
}

async function updateDict(request: UpdateDictRequest): UpdateDictResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDict', 'PUT', '/openapi/instances/{InstanceId}/dict', 'json', false, 'json', request);
}

model UpdateDynamicSettingsRequest {
  instanceId?: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', description='幂等参数', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  body?: string(name='body', position='Body'),
  mode?: string(name='mode', position='Query'),
}

model UpdateDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateDynamicSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDynamicSettingsResponseBody(name='body'),
}

async function updateDynamicSettings(request: UpdateDynamicSettingsRequest): UpdateDynamicSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDynamicSettings', 'PUT', '/openapi/instances/{InstanceId}/dynamic-settings', 'json', false, 'json', request);
}

model UpdateExtendConfigRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateExtendConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateExtendConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExtendConfigResponseBody(name='body'),
}

async function updateExtendConfig(request: UpdateExtendConfigRequest): UpdateExtendConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateExtendConfig', 'POST', '/openapi/instances/{InstanceId}/extend-configs/actions/update', 'json', false, 'json', request);
}

model UpdateExtendfilesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateExtendfilesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
    }
  ](name='Result'),
}

model UpdateExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExtendfilesResponseBody(name='body'),
}

async function updateExtendfiles(request: UpdateExtendfilesRequest): UpdateExtendfilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateExtendfiles', 'PUT', '/openapi/logstashes/{InstanceId}/extendfiles', 'json', false, 'json', request);
}

model UpdateHotIkDictsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateHotIkDictsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateHotIkDictsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateHotIkDictsResponseBody(name='body'),
}

async function updateHotIkDicts(request: UpdateHotIkDictsRequest): UpdateHotIkDictsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateHotIkDicts', 'PUT', '/openapi/instances/{InstanceId}/ik-hot-dict', 'json', false, 'json', request);
}

model UpdateILMPolicyRequest {
  instanceId: string(name='InstanceId', position='Path'),
  policyName: string(name='PolicyName', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateILMPolicyResponseBody(name='body'),
}

async function updateILMPolicy(request: UpdateILMPolicyRequest): UpdateILMPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateILMPolicy', 'PUT', '/openapi/instances/{InstanceId}/ilm-policies/{PolicyName}', 'json', false, 'json', request);
}

model UpdateIndexTemplateRequest {
  instanceId: string(name='InstanceId', position='Path'),
  indexTemplate: string(name='IndexTemplate', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIndexTemplateResponseBody(name='body'),
}

async function updateIndexTemplate(request: UpdateIndexTemplateRequest): UpdateIndexTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateIndexTemplate', 'PUT', '/openapi/instances/{InstanceId}/index-templates/{IndexTemplate}', 'json', false, 'json', request);
}

model UpdateInstanceRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration', position='Body'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration', position='Body'),
  instanceCategory?: string(name='instanceCategory', position='Body'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration', position='Body'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration', position='Body'),
  nodeAmount?: int32(name='nodeAmount', position='Body'),
  nodeSpec?: NodeSpec(name='nodeSpec', position='Body'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  force?: boolean(name='force', position='Query'),
  orderActionType?: string(name='orderActionType', position='Query'),
}

model UpdateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    domain?: string(name='domain'),
    esVersion?: string(name='esVersion'),
    instanceId?: string(name='instanceId'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    status?: string(name='status'),
  }(name='Result'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstance(request: UpdateInstanceRequest): UpdateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateInstance', 'PUT', '/openapi/instances/{InstanceId}', 'json', false, 'json', request);
}

model UpdateInstanceChargeTypeRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateInstanceChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateInstanceChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceChargeTypeResponseBody(name='body'),
}

async function updateInstanceChargeType(request: UpdateInstanceChargeTypeRequest): UpdateInstanceChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateInstanceChargeType', 'POST', '/openapi/instances/{InstanceId}/actions/convert-pay-type', 'json', false, 'json', request);
}

model UpdateInstanceSettingsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateInstanceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceSettingsResponseBody(name='body'),
}

async function updateInstanceSettings(request: UpdateInstanceSettingsRequest): UpdateInstanceSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateInstanceSettings', 'POST', '/openapi/instances/{InstanceId}/instance-settings', 'json', false, 'json', request);
}

model UpdateKibanaSettingsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateKibanaSettingsResponseBody(name='body'),
}

async function updateKibanaSettings(request: UpdateKibanaSettingsRequest): UpdateKibanaSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateKibanaSettings', 'POST', '/openapi/instances/{InstanceId}/actions/update-kibana-settings', 'json', false, 'json', request);
}

model UpdateKibanaWhiteIpsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist', description='kibana节点IP访问白名单。不可与分组同时设置。', position='Body'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='分组名称'),
    ips?: [ string ](name='ips', description='分组白名单列表'),
    whiteIpType?: string(name='whiteIpType', description='白名单类型，固定设置PUBLIC_KIBANA'),
  }(name='whiteIpGroup', description='Kibana 访问白名单分组设置', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  modifyMode?: string(name='modifyMode', description='修改方式，覆盖/新增/删除，针对设置分组时使用。不设置分组，默认覆盖default分组值', position='Query'),
}

model UpdateKibanaWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
  }(name='Result'),
}

model UpdateKibanaWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateKibanaWhiteIpsResponseBody(name='body'),
}

async function updateKibanaWhiteIps(request: UpdateKibanaWhiteIpsRequest): UpdateKibanaWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateKibanaWhiteIps', 'POST', '/openapi/instances/{InstanceId}/kibana-white-ips', 'json', false, 'json', request);
}

model UpdateLogstashRequest {
  instanceId: string(name='InstanceId', position='Path'),
  nodeAmount?: int32(name='nodeAmount', description='实例节点数量。', minimum=1, maximum=20, position='Body'),
  nodeSpec?: {
    disk?: int32(name='disk', description='实例磁盘大小。单位GB。步长为20，最大值受磁盘规格影响', minimum=20, maximum=2048),
    diskType?: string(name='diskType', description='磁盘存储类型'),
    spec?: string(name='spec', description='实例规格'),
  }(name='nodeSpec', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLogstashResponseBody(name='body'),
}

async function updateLogstash(request: UpdateLogstashRequest): UpdateLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogstash', 'PUT', '/openapi/logstashes/{InstanceId}', 'json', false, 'json', request);
}

model UpdateLogstashChargeTypeRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateLogstashChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateLogstashChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLogstashChargeTypeResponseBody(name='body'),
}

async function updateLogstashChargeType(request: UpdateLogstashChargeTypeRequest): UpdateLogstashChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogstashChargeType', 'POST', '/openapi/logstashes/{InstanceId}/actions/convert-pay-type', 'json', false, 'json', request);
}

model UpdateLogstashDescriptionRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateLogstashDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    description?: string(name='description'),
  }(name='Result'),
}

model UpdateLogstashDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLogstashDescriptionResponseBody(name='body'),
}

async function updateLogstashDescription(request: UpdateLogstashDescriptionRequest): UpdateLogstashDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogstashDescription', 'POST', '/openapi/logstashes/{InstanceId}/description', 'json', false, 'json', request);
}

model UpdateLogstashSettingsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateLogstashSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLogstashSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLogstashSettingsResponseBody(name='body'),
}

async function updateLogstashSettings(request: UpdateLogstashSettingsRequest): UpdateLogstashSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogstashSettings', 'POST', '/openapi/logstashes/{InstanceId}/instance-settings', 'json', false, 'json', request);
}

model UpdatePipelineManagementConfigRequest {
  instanceId: string(name='InstanceId', position='Path'),
  endpoints?: [ string ](name='endpoints', description='开启Kibana管理管道后，Kibana所在Elasticsearch实例的访问地址列表。', position='Body'),
  password?: string(name='password', description='Kibana的密码。管理方式为ES设置', position='Body'),
  pipelineIds?: [ string ](name='pipelineIds', description='Kibana管理的管道列表。管理方式为ES设置', position='Body'),
  pipelineManagementType?: string(name='pipelineManagementType', description='管道管理方式', position='Body'),
  userName?: string(name='userName', description='Kibana的用户名。管理方式为ES设置', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdatePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdatePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePipelineManagementConfigResponseBody(name='body'),
}

async function updatePipelineManagementConfig(request: UpdatePipelineManagementConfigRequest): UpdatePipelineManagementConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePipelineManagementConfig', 'POST', '/openapi/logstashes/{InstanceId}/pipeline-management-config', 'json', false, 'json', request);
}

model UpdatePipelinesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  trigger?: boolean(name='trigger', position='Query'),
}

model UpdatePipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePipelinesResponseBody(name='body'),
}

async function updatePipelines(request: UpdatePipelinesRequest): UpdatePipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePipelines', 'PUT', '/openapi/logstashes/{InstanceId}/pipelines', 'json', false, 'json', request);
}

model UpdatePrivateNetworkWhiteIpsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  modifyMode?: string(name='modifyMode', position='Query'),
}

model UpdatePrivateNetworkWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  }(name='Result'),
}

model UpdatePrivateNetworkWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePrivateNetworkWhiteIpsResponseBody(name='body'),
}

async function updatePrivateNetworkWhiteIps(request: UpdatePrivateNetworkWhiteIpsRequest): UpdatePrivateNetworkWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePrivateNetworkWhiteIps', 'POST', '/openapi/instances/{InstanceId}/private-network-white-ips', 'json', false, 'json', request);
}

model UpdatePublicNetworkRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdatePublicNetworkResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enablePublic?: boolean(name='enablePublic'),
  }(name='Result'),
}

model UpdatePublicNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePublicNetworkResponseBody(name='body'),
}

async function updatePublicNetwork(request: UpdatePublicNetworkRequest): UpdatePublicNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePublicNetwork', 'POST', '/openapi/instances/{InstanceId}/public-network', 'json', false, 'json', request);
}

model UpdatePublicWhiteIpsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  modifyMode?: string(name='modifyMode', position='Query'),
}

model UpdatePublicWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  }(name='Result'),
}

model UpdatePublicWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePublicWhiteIpsResponseBody(name='body'),
}

async function updatePublicWhiteIps(request: UpdatePublicWhiteIpsRequest): UpdatePublicWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePublicWhiteIps', 'POST', '/openapi/instances/{InstanceId}/public-white-ips', 'json', false, 'json', request);
}

model UpdateReadWritePolicyRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateReadWritePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateReadWritePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateReadWritePolicyResponseBody(name='body'),
}

async function updateReadWritePolicy(request: UpdateReadWritePolicyRequest): UpdateReadWritePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateReadWritePolicy', 'POST', '/openapi/instances/{InstanceId}/actions/update-read-write-policy', 'json', false, 'json', request);
}

model UpdateSnapshotSettingRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
}

model UpdateSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='enable'),
    quartzRegex?: string(name='quartzRegex'),
  }(name='Result'),
}

model UpdateSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSnapshotSettingResponseBody(name='body'),
}

async function updateSnapshotSetting(request: UpdateSnapshotSettingRequest): UpdateSnapshotSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateSnapshotSetting', 'POST', '/openapi/instances/{InstanceId}/snapshot-setting', 'json', false, 'json', request);
}

model UpdateSynonymsDictsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateSynonymsDictsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateSynonymsDictsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSynonymsDictsResponseBody(name='body'),
}

async function updateSynonymsDicts(request: UpdateSynonymsDictsRequest): UpdateSynonymsDictsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateSynonymsDicts', 'PUT', '/openapi/instances/{InstanceId}/synonymsDict', 'json', false, 'json', request);
}

model UpdateTemplateRequest {
  instanceId: string(name='InstanceId', position='Path'),
  templateName: string(name='TemplateName', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTemplate', 'POST', '/openapi/instances/{InstanceId}/templates/{TemplateName}', 'json', false, 'json', request);
}

model UpdateWhiteIpsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  esIPWhitelist?: [ string ](name='esIPWhitelist', position='Body'),
  whiteIpGroup?: {
    groupName?: string(name='groupName'),
    ips?: [ string ](name='ips'),
    whiteIpType?: string(name='whiteIpType'),
  }(name='whiteIpGroup', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  modifyMode?: string(name='modifyMode', position='Query'),
}

model UpdateWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    esIPWhitelist?: [ string ](name='esIPWhitelist'),
    networkConfig?: {
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
  }(name='Result'),
}

model UpdateWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWhiteIpsResponseBody(name='body'),
}

async function updateWhiteIps(request: UpdateWhiteIpsRequest): UpdateWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateWhiteIps', 'POST', '/openapi/instances/{InstanceId}/white-ips', 'json', false, 'json', request);
}

model UpdateXpackMonitorConfigRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  enable?: boolean(name='enable', description='xpack 监控是否启用。设置为false时，无需设置其他参数', position='Body'),
  endpoints?: [ string ](name='endpoints', description='Elasticsearch实例的访问地址。', position='Body'),
  password?: string(name='password', description='Elasticsearch实例的访问密码。', position='Body'),
  userName?: string(name='userName', description='Elasticsearch实例的用户名。', position='Body'),
}

model UpdateXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateXpackMonitorConfigResponseBody(name='body'),
}

async function updateXpackMonitorConfig(request: UpdateXpackMonitorConfigRequest): UpdateXpackMonitorConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateXpackMonitorConfig', 'POST', '/openapi/logstashes/{InstanceId}/xpack-monitor-config', 'json', false, 'json', request);
}

model UpgradeEngineVersionRequest {
  instanceId: string(name='InstanceId', position='Path'),
  type?: string(name='type', description='升级类型。', position='Body'),
  version?: string(name='version', description='升级后的版本', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
  dryRun?: boolean(name='dryRun', description='是否为升级校验', position='Query'),
}

model UpgradeEngineVersionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      status?: string(name='status'),
      validateResult?: [ 
        {
          errorCode?: string(name='errorCode'),
          errorMsg?: string(name='errorMsg'),
          errorType?: string(name='errorType'),
        }
      ](name='validateResult'),
      validateType?: string(name='validateType'),
    }
  ](name='Result'),
}

model UpgradeEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeEngineVersionResponseBody(name='body'),
}

async function upgradeEngineVersion(request: UpgradeEngineVersionRequest): UpgradeEngineVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpgradeEngineVersion', 'POST', '/openapi/instances/{InstanceId}/actions/upgrade-version', 'json', false, 'json', request);
}

model ValidateConnectionRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  body?: string(name='body', position='Body'),
}

model ValidateConnectionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateConnectionResponseBody(name='body'),
}

async function validateConnection(request: ValidateConnectionRequest): ValidateConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ValidateConnection', 'POST', '/openapi/logstashes/{InstanceId}/validate-connection', 'json', false, 'json', request);
}

model ValidateShrinkNodesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: [ 
    {
      host?: string(name='host'),
      hostName?: string(name='hostName'),
      nodeType?: string(name='nodeType'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='body', position='Body'),
  count?: int32(name='count', position='Query'),
  ignoreStatus?: boolean(name='ignoreStatus', position='Query'),
  nodeType: string(name='nodeType', position='Query'),
}

model ValidateShrinkNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateShrinkNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateShrinkNodesResponseBody(name='body'),
}

async function validateShrinkNodes(request: ValidateShrinkNodesRequest): ValidateShrinkNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ValidateShrinkNodes', 'POST', '/openapi/instances/{InstanceId}/validate-shrink-nodes', 'json', false, 'json', request);
}

model ValidateSlrPermissionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  rolename: string(name='rolename', position='Query'),
}

model ValidateSlrPermissionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateSlrPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateSlrPermissionResponseBody(name='body'),
}

async function validateSlrPermission(request: ValidateSlrPermissionRequest): ValidateSlrPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ValidateSlrPermission', 'GET', '/openapi/user/servicerolepermission', 'json', false, 'json', request);
}

model ValidateTransferableNodesRequest {
  instanceId: string(name='InstanceId', position='Path'),
  body?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='body', position='Body'),
  nodeType: string(name='nodeType', position='Query'),
}

model ValidateTransferableNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateTransferableNodesResponseBody(name='body'),
}

async function validateTransferableNodes(request: ValidateTransferableNodesRequest): ValidateTransferableNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ValidateTransferableNodes', 'POST', '/openapi/instances/{InstanceId}/validate-transfer-nodes', 'json', false, 'json', request);
}

model CreateInstanceRequest {
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration', position='Body'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration', position='Body'),
  esAdminPassword?: string(name='esAdminPassword', position='Body'),
  esVersion?: string(name='esVersion', position='Body'),
  instanceCategory?: string(name='instanceCategory', position='Body'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration', position='Body'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration', position='Body'),
  networkConfig?: NetworkConfig(name='networkConfig', position='Body'),
  nodeAmount?: int32(name='nodeAmount', position='Body'),
  nodeSpec?: NodeSpec(name='nodeSpec', position='Body'),
  paymentInfo?: PaymentInfo(name='paymentInfo', position='Body'),
  paymentType?: string(name='paymentType', position='Body'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration', position='Body'),
  zoneCount?: int32(name='zoneCount', position='Body'),
  clientToken?: string(name='clientToken', position='Query'),
}

model CreateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    instanceId?: string(name='instanceId'),
  }(name='Result'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'createInstance', 'POST', '/openapi/instances', 'json', false, 'json', request);
}

