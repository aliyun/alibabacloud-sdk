/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'elasticsearch';
  @version = '2017-06-13';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model ClientNodeConfiguration {
  amount: long(name='amount', minimum=2, maximum=25),
  disk: long(name='disk', minimum=20, maximum=20),
  diskType: string(name='diskType'),
  spec: string(name='spec'),
}

model CollectorDeployMachine {
  configType: string(name='configType', example='collectorDeployMachine'),
  groupId?: string(name='groupId', example='default_ct-cn-f3t0dq5p97199ru3z'),
  instanceId?: string(name='instanceId', example='ce93d7566df2141f490f0f60f646252c3'),
  machines?: [ 
    {
      agentStatus?: string(name='agentStatus', example='UNINSTALLED'),
      instanceId?: string(name='instanceId', example='i-xs34****'),
    }
  ](name='machines'),
  successPodsCount?: string(name='successPodsCount', example='1'),
  totalPodsCount?: string(name='totalPodsCount', example='2'),
  type: string(name='type', example='ACKCluster'),
}

model CollectorKibanaInstance {
  configType: string(name='configType', example='collectorElasticsearchForKibana'),
  host: string(name='host', example='es-cn-*****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
  instanceId: string(name='instanceId', example='es-cn-45dfy****'),
  kibanaHost: string(name='kibanaHost', example='https://es-cn-****.kibana.elasticsearch.aliyuncs.com:5601'),
  password: string(name='password', example='password'),
  protocol: string(name='protocol', example='HTTP'),
  userName: string(name='userName', example='username'),
}

model CollectorTargetInstance {
  configType: string(name='configType', example='collectorTargetInstance'),
  enableMonitoring: boolean(name='enableMonitoring', example='false'),
  hosts?: [ string ](name='hosts'),
  instanceId: string(name='instanceId', example='es-cn-ks8x****'),
  instanceType: string(name='instanceType', example='elasticsearch'),
  password: string(name='password', example='password'),
  protocol: string(name='protocol', example='HTTP'),
  userName: string(name='userName', example='username'),
}

model DictInfo {
  fileSize?: long(name='fileSize'),
  name?: string(name='name'),
  sourceType?: string(name='sourceType'),
  type?: string(name='type'),
}

model ElasticDataNodeConfiguration {
  amount?: long(name='amount', minimum=2, maximum=50),
  disk?: long(name='disk', minimum=20, maximum=20480),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec: string(name='spec'),
}

model Elasticsearch {
  advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
  advancedSetting?: {
    gcName?: string(name='gcName'),
  }(name='advancedSetting'),
  aliwsDicts?: [
    DictInfo
  ](name='aliwsDicts'),
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration'),
  createdAt?: string(name='createdAt'),
  dataNode?: boolean(name='dataNode'),
  dedicateMaster?: boolean(name='dedicateMaster'),
  description?: string(name='description'),
  dictList?: [
    DictInfo
  ](name='dictList'),
  domain?: string(name='domain'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork'),
  enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork'),
  enablePublic?: boolean(name='enablePublic'),
  endTime?: long(name='endTime'),
  esConfig?: map[string]string(name='esConfig'),
  esIPWhitelist?: [ string ](name='esIPWhitelist'),
  esVersion?: string(name='esVersion'),
  extendConfigs?: [  map[string]any ](name='extendConfigs'),
  haveClientNode?: boolean(name='haveClientNode'),
  haveElasticDataNode?: boolean(name='haveElasticDataNode'),
  haveKibana?: boolean(name='haveKibana'),
  ikHotDicts?: [
    DictInfo
  ](name='ikHotDicts'),
  instanceId?: string(name='instanceId'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  kibanaDomain?: string(name='kibanaDomain'),
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
  kibanaPort?: long(name='kibanaPort'),
  kibanaPrivateDomain?: string(name='kibanaPrivateDomain'),
  kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
  kibanaPrivatePort?: long(name='kibanaPrivatePort'),
  kibanaProtocol?: string(name='kibanaProtocol'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  networkConfig?: NetworkConfig(name='networkConfig'),
  nodeAmount?: long(name='nodeAmount'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  paymentType?: string(name='paymentType'),
  port?: long(name='port'),
  privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  productType?: string(name='productType'),
  protocol?: string(name='protocol'),
  publicDomain?: string(name='publicDomain'),
  publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  publicPort?: long(name='publicPort'),
  readWritePolicy?: ReadWritePolicy(name='readWritePolicy'),
  resourceGroupId?: string(name='resourceGroupId'),
  serviceVpc?: boolean(name='serviceVpc'),
  status?: string(name='status'),
  synonymsDicts?: [
    DictInfo
  ](name='synonymsDicts'),
  tags?: [
    Tag
  ](name='tags'),
  updatedAt?: string(name='updatedAt'),
  warmNode?: boolean(name='warmNode'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  zoneCount?: long(name='zoneCount'),
  zoneInfos?: [
    ZoneInfo
  ](name='zoneInfos'),
}

model KibanaNodeConfiguration {
  amount?: long(name='amount', minimum=1, maximum=1),
  disk?: long(name='disk'),
  spec: string(name='spec'),
}

model Logstash {
  config?: map[string]string(name='config'),
  createdAt?: string(name='createdAt'),
  dataNode?: boolean(name='dataNode'),
  description?: string(name='description'),
  endTime?: long(name='endTime'),
  endpointList?: [ 
    {
      host?: string(name='host'),
      port?: long(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='endpointList'),
  instanceId?: string(name='instanceId'),
  networkConfig?: {
    type?: string(name='type'),
    vpcId?: string(name='vpcId'),
    vsArea?: string(name='vsArea'),
    vswitchId?: string(name='vswitchId'),
  }(name='networkConfig'),
  nodeAmount?: long(name='nodeAmount'),
  nodeSpec?: {
    disk?: long(name='disk'),
    diskType?: string(name='diskType'),
    spec?: string(name='spec'),
  }(name='nodeSpec'),
  paymentType?: string(name='paymentType'),
  protocol?: string(name='protocol'),
  resourceGroupId?: string(name='resourceGroupId'),
  status?: string(name='status'),
  tags?: [ 
    {
      tagKey?: string(name='tagKey'),
      tagValue?: string(name='tagValue'),
    }
  ](name='tags'),
  updatedAt?: string(name='updatedAt'),
  version?: string(name='version'),
  zoneCount?: long(name='zoneCount'),
  zoneInfos?: [ 
    {
      status?: string(name='status'),
      zoneId?: string(name='zoneId'),
    }
  ](name='zoneInfos'),
}

model MasterNodeConfiguration {
  amount: long(name='amount', minimum=3, maximum=3),
  disk: long(name='disk', minimum=20, maximum=20),
  diskType: string(name='diskType'),
  spec: string(name='spec'),
}

model MigrationJob {
  currentState?: string(name='currentState'),
  disableSourceClusterAuth?: boolean(name='disableSourceClusterAuth'),
  disableTargetClusterAuth?: boolean(name='disableTargetClusterAuth'),
  endTime?: long(name='endTime'),
  migrationJobId?: string(name='migrationJobId'),
  phase?: string(name='phase'),
  sourceCluster?: {
    instanceId?: string(name='instanceId'),
    type?: string(name='type'),
  }(name='sourceCluster'),
  startTime?: long(name='startTime'),
  statusResult?: [ 
    {
      code?: string(name='code'),
      success?: boolean(name='success'),
    }
  ](name='statusResult'),
  targetCluster?: {
    instanceId?: string(name='instanceId'),
    type?: string(name='type'),
  }(name='targetCluster'),
  updateTime?: long(name='updateTime'),
}

model NetworkConfig {
  type?: string(name='type'),
  vpcId?: string(name='vpcId'),
  vsArea?: string(name='vsArea'),
  vswitchId?: string(name='vswitchId'),
  whiteIpGroupList?: [
    WhiteIpGroup
  ](name='whiteIpGroupList'),
}

model NodeInfo {
  host?: string(name='host'),
  hostName?: string(name='hostName'),
  port?: long(name='port'),
  zoneId?: string(name='zoneId'),
}

model NodeSpec {
  disk?: int32(name='disk', minimum=20, maximum=20480),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec: string(name='spec'),
}

model PaymentInfo {
  autoRenewDuration?: long(name='autoRenewDuration'),
  duration?: long(name='duration'),
  isAutoRenew?: boolean(name='isAutoRenew'),
  pricingCycle?: string(name='pricingCycle'),
}

model ReadWritePolicy {
  autoGeneratePk?: boolean(name='autoGeneratePk'),
  writeHa?: boolean(name='writeHa'),
  writePolicy?: string(name='writePolicy'),
}

model Tag {
  tagKey?: string(name='tagKey'),
  tagValue?: string(name='tagValue'),
}

model WarmNodeConfiguration {
  amount?: long(name='amount', minimum=1, maximum=50),
  disk?: long(name='disk', minimum=500, maximum=20480),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec: string(name='spec'),
}

model WhiteIpGroup {
  whiteIpType?: string(name='WhiteIpType'),
  groupName?: string(name='groupName'),
  ips?: [ string ](name='ips'),
}

model ZoneInfo {
  status?: string(name='status'),
  zoneId?: string(name='zoneId'),
}

model ActivateZonesRequest {
  instanceId: string(name='InstanceId', description='The cluster ID.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model ActivateZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A5D8E74-565C-43DC-B031-29289FA****'),
  result?: boolean(name='Result', description='Indicates whether the nodes in disabled zones are restored. Valid values:

*   true
*   false', example='true'),
}

model ActivateZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActivateZonesResponseBody(name='body'),
}

async function activateZones(request: ActivateZonesRequest): ActivateZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ActivateZones', 'POST', '/openapi/instances/{InstanceId}/actions/recover-zones', 'json', false, 'json', request);
}

model AddConnectableClusterRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', example='{     "instanceId":"es-cn-09k1rgid9000g****" }', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model AddConnectableClusterResponseBody = {
  requestId?: string(name='RequestId', example='5A5D8E74-565C-43DC-B031-29289FA****'),
  result?: boolean(name='Result', example='true'),
}

model AddConnectableClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddConnectableClusterResponseBody(name='body'),
}

async function addConnectableCluster(request: AddConnectableClusterRequest): AddConnectableClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AddConnectableCluster', 'POST', '/openapi/instances/{InstanceId}/connected-clusters', 'json', false, 'json', request);
}

model AddSnapshotRepoRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance for which you want to access OSS repositories across clusters.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
}

model AddSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: Reference warehouse created successfully
*   false: Reference warehouse created failed', example='true'),
}

model AddSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSnapshotRepoResponseBody(name='body'),
}

async function addSnapshotRepo(request: AddSnapshotRepoRequest): AddSnapshotRepoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AddSnapshotRepo', 'POST', '/openapi/instances/{InstanceId}/snapshot-repos', 'json', false, 'json', request);
}

model CancelDeletionRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='es-cn-z2q1wk6z00007****', position='Path'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model CancelDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D682B6B3-B425-46DA-A5FC-5F5C60553622'),
  result?: boolean(name='Result', description='Indicates whether the cluster is restored. Valid values:

*   true: The cluster is restored.
*   false: The cluster fails to be restored.', example='true'),
}

model CancelDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelDeletionResponseBody(name='body'),
}

async function cancelDeletion(request: CancelDeletionRequest): CancelDeletionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelDeletion', 'POST', '/openapi/instances/{InstanceId}/actions/cancel-deletion', 'json', false, 'json', request);
}

model CancelLogstashDeletionRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='ls-cn-m7r1vsi2****', position='Path'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model CancelLogstashDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='23EBF56B-2DC0-4507-8BE5-B87395DB0FEB'),
  result?: boolean(name='Result', description='Indicates whether the cluster is restored. Valid values:

*   true: The cluster is restored.
*   false: The cluster is not restored.', example='true'),
}

model CancelLogstashDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelLogstashDeletionResponseBody(name='body'),
}

async function cancelLogstashDeletion(request: CancelLogstashDeletionRequest): CancelLogstashDeletionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelLogstashDeletion', 'POST', '/openapi/logstashes/{InstanceId}/actions/cancel-deletion', 'json', false, 'json', request);
}

model CancelTaskRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-nif1q9o8r0008****', position='Path'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  taskType: string(name='taskType', description='The type of the data migration task. Set the value to MigrateData.', example='MigrateData', position='Query'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: the task was cancelled successfully
*   false: the task was cancelled successfully failed', example='true'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelTask', 'POST', '/openapi/instances/{InstanceId}/actions/cancel-task', 'json', false, 'json', request);
}

model CapacityPlanRequest {
  complexQueryAvailable?: boolean(name='complexQueryAvailable', example='true', position='Body'),
  dataInfo?: [ 
    {
      code?: string(name='code', example='totalRawData'),
      size?: long(name='size', example='100'),
      totalCount?: int32(name='totalCount', example='10000'),
      type?: string(name='type', example='hot'),
      unit?: string(name='unit', example='MiB'),
    }
  ](name='dataInfo', position='Body'),
  metric?: [ 
    {
      averageQps?: int32(name='averageQps', example='30'),
      code?: string(name='code', example='write'),
      concurrent?: long(name='concurrent', example='2'),
      peakQps?: int32(name='peakQps', example='30'),
      responseTime?: int32(name='responseTime', example='100'),
      throughput?: long(name='throughput', example='100'),
      type?: string(name='type', example='common'),
    }
  ](name='metric', position='Body'),
  usageScenario?: string(name='usageScenario', example='general', position='Body'),
}

model CapacityPlanResponseBody = {
  requestId?: string(name='RequestId', description='The response of the request.', example='E91B7129-A669-4D9D-A743-F90A0FF1F5EF'),
  result?: {
    extendConfigs?: [ 
      {
        configType?: string(name='ConfigType', description='The size of the disk. Unit: GiB.', example='sharedDisk'),
        disk?: long(name='Disk', description='The type of the disk. Valid value: CPFS_PREMIUM.

>  The extendConfigs attribute that may occur when the planned instance type is enhanced (advanced).', example='2048'),
        diskType?: string(name='DiskType', description='The version type. Valid values:

*   advanced: enhanced edition
*   x-pack: Commercial Edition
*   community: community version', example='CPFS_PREMIUM'),
      }
    ](name='ExtendConfigs', description='The type of the configuration. Set the value to sharedDisk.

>  The extendConfigs attribute that may occur when the planned instance type is enhanced (advanced).'),
    instanceCategory?: string(name='InstanceCategory', description='The node information.', example='advanced'),
    nodeConfigurations?: [ 
      {
        amount?: long(name='Amount', description='The number of CPUs of the cloud desktop.', example='10'),
        cpu?: long(name='Cpu', description='The size of the disk. Unit: GiB.', example='1'),
        disk?: long(name='Disk', description='The type of the hard disk. Valid values:

*   cloud_essd: enhanced SSD (ESSD)
*   cloud_ssd: standard SSD
*   cloud_efficiency: ultra disk
*   local_ssd: local SSD
*   local_efficiency: local ultra disk', example='20'),
        diskType?: string(name='DiskType', description='The memory size of the current node role.', example='cloud_ssd'),
        memory?: long(name='Memory', description='The type of the node. Supported types are as follows:

*   WORKER: data node
*   WORKER_WARM: cold data node
*   MASTER: dedicated master node
*   KIBANA: Kibana node
*   COORDINATING: client node
*   ELASTIC_WORKER: elastic node', example='2'),
        nodeType?: string(name='NodeType', description='The result calculated based on the capacity planning. No default value is available. The values are as follows:

*   true: indicates that the number of data nodes calculated by capacity planning exceeds the threshold of 50.
*   false: The number of data nodes calculated by capacity planning is less than 50.', example='WORKER'),
      }
    ](name='NodeConfigurations', description='The number of cores.'),
    oversizedCluster?: boolean(name='OversizedCluster', example='true'),
  }(name='Result', description='The extension configuration information.'),
}

model CapacityPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CapacityPlanResponseBody(name='body'),
}

async function capacityPlan(request: CapacityPlanRequest): CapacityPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CapacityPlan', 'POST', '/openapi/assist/actions/capacity-plan', 'json', false, 'json', request);
}

model CloseDiagnosisRequest {
  instanceId: string(name='InstanceId', description='Indicates whether intelligent O\\&M is successfully disabled. Valid values:

*   true: The call was successful.
*   false: The call failed.', example='es-cn-s9dsk3k4k****', position='Path'),
  clientToken?: string(name='ClientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  lang?: string(name='lang', example='spanish', position='Query'),
}

model CloseDiagnosisResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model CloseDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseDiagnosisResponseBody(name='body'),
}

async function closeDiagnosis(request: CloseDiagnosisRequest): CloseDiagnosisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CloseDiagnosis', 'POST', '/openapi/diagnosis/instances/{InstanceId}/actions/close-diagnosis', 'json', false, 'json', request);
}

model CloseHttpsRequest {
  instanceId: string(name='InstanceId', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B350****', position='Query'),
}

model CloseHttpsResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: boolean(name='Result', example='true'),
}

model CloseHttpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseHttpsResponseBody(name='body'),
}

async function closeHttps(request: CloseHttpsRequest): CloseHttpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CloseHttps', 'POST', '/openapi/instances/{InstanceId}/actions/close-https', 'json', false, 'json', request);
}

model CloseManagedIndexRequest {
  instanceId: string(name='InstanceId', example='es-cn-m7r24d27d007q****', position='Path'),
  index: string(name='Index', example='test-index1', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model CloseManagedIndexResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model CloseManagedIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseManagedIndexResponseBody(name='body'),
}

async function closeManagedIndex(request: CloseManagedIndexRequest): CloseManagedIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CloseManagedIndex', 'POST', '/openapi/instances/{InstanceId}/indices/{Index}/close-managed', 'json', false, 'json', request);
}

model CreateCollectorRequest {
  collectorPaths?: [ string ](name='collectorPaths', position='Body'),
  configs: [ 
    {
      content: string(name='content', example='"filebeat.inputs:xxx"'),
      fileName: string(name='fileName', example='filebeat.yml'),
    }
  ](name='configs', position='Body'),
  dryRun: boolean(name='dryRun', example='true', position='Body'),
  extendConfigs: [  map[string]any ](name='extendConfigs', position='Body'),
  name: string(name='name', example='ct-test', position='Body'),
  resType: string(name='resType', example='fileBeat', position='Body'),
  resVersion: string(name='resVersion', example='6.8.5_with_community', position='Body'),
  vpcId: string(name='vpcId', example='vpc-bp12nu14urf0upaf*****', position='Body'),
  clientToken?: string(name='clientToken', description='The ID of the created crawer.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model CreateCollectorResponseBody = {
  requestId?: string(name='RequestId', example='8466BDFB-C513-4B8D-B4E3-5AB256AB****'),
  result?: {
    resId?: string(name='resId', example='ct-cn-4135is2tj194p****'),
  }(name='Result'),
}

model CreateCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCollectorResponseBody(name='body'),
}

async function createCollector(request: CreateCollectorRequest): CreateCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCollector', 'POST', '/openapi/collectors', 'json', false, 'json', request);
}

model CreateComponentIndexRequest {
  instanceId: string(name='InstanceId', example='es-cn-tl329rbpc0001****', position='Path'),
  name: string(name='name', example='template', position='Path'),
  meta?: map[string]any(name='_meta', example='{       "description": "set number of shards to one"   }', position='Body'),
  template?: {
    aliases?: map[string]any(name='aliases', example='{}'),
    mappings?: map[string]any(name='mappings', example='{ 			"properties": { 				"@timestamp": { 					"type": "date" 				} 			} 		}'),
    settings?: map[string]any(name='settings', example='{ 			"index.number_of_replicas": 0 		}'),
  }(name='template', position='Body'),
}

model CreateComponentIndexResponseBody = {
  requestId?: string(name='RequestId', example='C20022BA-5382-4339-89FB-30AF48A05431'),
  result?: boolean(name='Result', example='true'),
}

model CreateComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateComponentIndexResponseBody(name='body'),
}

async function createComponentIndex(request: CreateComponentIndexRequest): CreateComponentIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateComponentIndex', 'POST', '/openapi/instances/{InstanceId}/component-index/{name}', 'json', false, 'json', request);
}

model CreateDataStreamRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif24adwc0082****', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF***', position='Query'),
  body?: string(name='body', position='Body'),
}

model CreateDataStreamResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: {
    name?: string(name='name', example='ds-'),
  }(name='Result'),
}

model CreateDataStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataStreamResponseBody(name='body'),
}

async function createDataStream(request: CreateDataStreamRequest): CreateDataStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateDataStream', 'POST', '/openapi/instances/{InstanceId}/data-streams', 'json', false, 'json', request);
}

model CreateDataTasksRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='ClientToken', description='es-cn-n6w1o1x0w001c\\*\\*\\*\\*', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: [ 
    {
      migrateConfig?: {
        sourceFilterParams?: string(name='sourceFilterParams', example='index=111'),
      }(name='migrateConfig'),
      sinkCluster?: {
        dataSourceType: string(name='dataSourceType', example='elasticsearch'),
        index: string(name='index', example='index_001'),
        mapping: string(name='mapping', example='{\\"doc\\":{\\"properties\\":{\\"interval_ms\\":{\\"type\\":\\"long\\"},....}'),
        password: string(name='password', example='xxxxx'),
        routing?: string(name='routing', example='_id'),
        settings: string(name='settings', example='{\\n \\"index\\": {\\n \\"replication\\": {\\n \\"type\\": .....}'),
        type: string(name='type', example='index_001'),
        username: string(name='username', example='elastic'),
      }(name='sinkCluster'),
      sourceCluster?: {
        dataSourceType: string(name='dataSourceType', example='elasticsearch'),
        endpoint?: string(name='endpoint', example='http://yourdomain.com'),
        index: string(name='index', example='index_001'),
        password?: string(name='password', example='es_password'),
        type: string(name='type', example='index_001'),
        username?: string(name='username', example='elastic'),
        vpcId?: string(name='vpcId', example='vpc-xxx'),
        vpcInstanceId?: string(name='vpcInstanceId', example='es-xxx-worker'),
        vpcInstancePort?: int32(name='vpcInstancePort', example='9200'),
      }(name='sourceCluster'),
    }
  ](name='body', position='Body'),
}

model CreateDataTasksResponseBody = {
  requestId?: string(name='RequestId', description='The result of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType', example='elasticsearch'),
        index?: string(name='index', description='The settings configuration.', example='index_001'),
        mapping?: string(name='mapping', description='The type of the target index.', example='{\\"doc\\":{\\"properties\\":{\\"interval_ms\\":{\\"type\\":\\"long\\"},....}'),
        password?: string(name='password', description='The name of the target index.', example='xxxxx'),
        routing?: string(name='routing', description='The username of the destination cluster.', example='cluster_name'),
        settings?: string(name='settings', description='Mapping configuration.', example='{\\n  \\"index\\": {\\n    \\"replication\\": {\\n      \\"type\\": .....}'),
        type?: string(name='type', description='The routing field. The primary key field is used by default.', example='index_001'),
        username?: string(name='username', description='The ID of the Virtual Private Cloud to which the cluster belongs. If the cluster access address is a public domain name, you can not specify the private endpoint.', example='elastic'),
        vpcId?: string(name='vpcId', description='The access port number of the cluster.', example='vpc-2ze55voww95g82gak****'),
        vpcInstanceId?: string(name='vpcInstanceId', description='The type of the target cluster.', example='es-cn-oew1oxiro000f****-worker'),
        vpcInstancePort?: string(name='vpcInstancePort', description='The instance ID of the cluster under the Virtual Private Cloud, or the ID of the SLB instance.', example='9200'),
      }(name='sinkCluster', description='The access password of the target cluster.'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType', description='The information about the target cluster.', example='elasticsearch'),
        endpoint?: string(name='endpoint', description='The username of the source cluster.', example='http://10.20.xx.xx:9200'),
        index?: string(name='index', description='The type of the specified index.', example='index_001'),
        password?: string(name='password', description='Specifies the indexes to be migrated.', example='xxxxxx'),
        type?: string(name='type', description='The public domain name of the cluster.', example='index_001'),
        username?: string(name='username', description='The ID of the Virtual Private Cloud where the source cluster resides. If the cluster access address is a public domain name, you can not specify the private endpoint.', example='elastic'),
        vpcId?: string(name='vpcId', description='The instance ID of the cluster under the Virtual Private Cloud, or the ID of the SLB instance.', example='vpc-2ze55voww95g82gak****'),
        vpcInstanceId?: string(name='vpcInstanceId', description='The access port number of the source cluster.', example='es-cn-oew1oxiro000f****-worker'),
        vpcInstancePort?: int32(name='vpcInstancePort', description='The type of the source cluster. Default value: Elasticsearch.', example='9200'),
      }(name='sourceCluster', description='The access password of the source cluster.'),
    }
  ](name='Result', description='The information about the source cluster.'),
}

model CreateDataTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataTasksResponseBody(name='body'),
}

/**
  * @deprecated
  * Before you call this operation, note that:
  * *   Currently, the one-click index migration feature only supports the China (Beijing) region.
  * *   The source and destination Elasticsearch clusters must meet the following requirements: a user-created or Alibaba Cloud Elasticsearch Elasticsearch cluster with a source of version 6.7.0 and a Alibaba Cloud Elasticsearch Elasticsearch cluster with a destination of version 6.3.2 or 6.7.0.
  *
 */
// Deprecated
async function createDataTasks(request: CreateDataTasksRequest): CreateDataTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateDataTasks', 'POST', '/openapi/instances/{InstanceId}/data-task', 'json', false, 'json', request);
}

model CreateILMPolicyRequest {
  instanceId: string(name='InstanceId', example='es-cn-m7r23wodb006n****', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model CreateILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='my-policy'),
}

model CreateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateILMPolicyResponseBody(name='body'),
}

async function createILMPolicy(request: CreateILMPolicyRequest): CreateILMPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateILMPolicy', 'POST', '/openapi/instances/{InstanceId}/ilm-policies', 'json', false, 'json', request);
}

model CreateIndexTemplateRequest {
  instanceId: string(name='InstanceId', example='es-cn-n6w24n9u900am****', position='Path'),
  clientToken?: string(name='ClientToken', example='E1136AE9-4E49-4585-9358-6FDD2A6D****', position='Query'),
  dataStream: boolean(name='dataStream', position='Body'),
  ilmPolicy?: string(name='ilmPolicy', example='policy-1', position='Body'),
  indexPatterns: [ string ](name='indexPatterns', position='Body'),
  indexTemplate: string(name='indexTemplate', example='index-template', position='Body'),
  priority?: int32(name='priority', example='100', minimum=0, maximum=2147483647, position='Body'),
  template?: {
    aliases?: string(name='aliases', example='{"mydata": {}}'),
    mappings?: string(name='mappings', example='{"properties": {"created_at": {"type": "date","format": "EEE MMM dd HH:mm:ss Z yyyy"},"host_name": {"type": "keyword"}}}'),
    settings?: string(name='settings', example='{\\"index.refresh_interval\\":\\"1s\\"}'),
  }(name='template', position='Body'),
}

model CreateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='index-template'),
}

model CreateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIndexTemplateResponseBody(name='body'),
}

async function createIndexTemplate(request: CreateIndexTemplateRequest): CreateIndexTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateIndexTemplate', 'POST', '/openapi/instances/{InstanceId}/index-templates', 'json', false, 'json', request);
}

model CreateLogstashRequest {
  description?: string(name='description', example='ls-cn-abc', position='Body'),
  networkConfig: {
    type?: string(name='type', example='vpc'),
    vpcId: string(name='vpcId', example='vpc-bp16k1dvzxtmagcva****'),
    vsArea: string(name='vsArea', example='cn-hangzhou-i'),
    vswitchId: string(name='vswitchId', example='vsw-bp1k4ec6s7sjdbudw****'),
  }(name='networkConfig', position='Body'),
  nodeAmount: int32(name='nodeAmount', example='2', position='Body'),
  nodeSpec: {
    disk?: long(name='disk', example='50'),
    diskType?: string(name='diskType', example='cloud_ssd'),
    spec: string(name='spec', example='logstash.n4.small'),
  }(name='nodeSpec', position='Body'),
  paymentInfo?: {
    autoRenewDuration?: long(name='autoRenewDuration', example='3'),
    duration?: long(name='duration', example='1'),
    isAutoRenew?: boolean(name='isAutoRenew', example='false'),
    pricingCycle?: string(name='pricingCycle', example='Month'),
  }(name='paymentInfo', position='Body'),
  paymentType?: string(name='paymentType', example='prepaid', position='Body'),
  resourceGroupId?: string(name='resourceGroupId', position='Body'),
  version: string(name='version', example='6.7_with_X-Pack', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model CreateLogstashResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE*****'),
  result?: Logstash(name='Result'),
}

model CreateLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLogstashResponseBody(name='body'),
}

async function createLogstash(request: CreateLogstashRequest): CreateLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLogstash', 'POST', '/openapi/logstashes', 'json', false, 'json', request);
}

model CreatePipelinesRequest {
  instanceId: string(name='InstanceId', example='ls-cn-oew1qbgl****', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: [ 
    {
      batchDelay?: int32(name='batchDelay', example='50'),
      batchSize?: int32(name='batchSize', example='125'),
      config: string(name='config', example='input { } filter { } output { }'),
      description?: string(name='description', example='this is a test'),
      pipelineId: string(name='pipelineId', example='pipeline-test'),
      queueCheckPointWrites?: int32(name='queueCheckPointWrites', example='1024'),
      queueMaxBytes?: int32(name='queueMaxBytes', example='1024'),
      queueType?: string(name='queueType', example='MEMORY'),
      workers?: int32(name='workers', example='2'),
    }
  ](name='body', position='Body'),
  trigger?: boolean(name='trigger', example='false', position='Query'),
}

model CreatePipelinesResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model CreatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePipelinesResponseBody(name='body'),
}

async function createPipelines(request: CreatePipelinesRequest): CreatePipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreatePipelines', 'POST', '/openapi/logstashes/{InstanceId}/pipelines', 'json', false, 'json', request);
}

model CreateSnapshotRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-nif1q9o8r0008****', position='Path'),
  clientToken: string(name='ClientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='Return results:

*   true: manual snapshot backup successfully
*   false: manual snapshot backup failed', example='true'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSnapshot', 'POST', '/openapi/instances/{InstanceId}/snapshots', 'json', false, 'json', request);
}

model CreateVpcEndpointRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-2r429tctl000d****', position='Path'),
  clientToken?: string(name='ClientToken', description='The returned result details.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***', position='Query'),
  serviceId?: string(name='serviceId', example='epsrv-hp3xdsq46ael67lo****', position='Body'),
  zoneId?: string(name='zoneId', example='cn-hangzhou-i', position='Body'),
  dryRun?: boolean(name='dryRun', description='The ID of the user endpoint service associated with the endpoint.', example='false', position='Query'),
}

model CreateVpcEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The endpoint domain name, which is used to configure the connection.', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: {
    endpointDomain?: string(name='endpointDomain', example='ep-bp1tah7zbrwmkjef****.epsrv-bp1w0p3jdirbfmt6****.cn-hangzhou.privatelink.aliyuncs.com'),
    endpointId?: string(name='endpointId', example='ep-bp1tah7zbrwmkjef****'),
    endpointName?: string(name='endpointName', example='vpcElasticSearchABC'),
    serviceId?: string(name='serviceId', description='The name of the service VPC-side endpoint.', example='epsrv-bp1w0p3jdirbfmt6****'),
  }(name='Result', description='The ID of the endpoint on the service VPC side.'),
}

model CreateVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpcEndpointResponseBody(name='body'),
}

/**
  * 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D\\*\\*\\*
  *
 */
async function createVpcEndpoint(request: CreateVpcEndpointRequest): CreateVpcEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateVpcEndpoint', 'POST', '/openapi/instances/{InstanceId}/vpc-endpoints', 'json', false, 'json', request);
}

model DeactivateZonesRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model DeactivateZonesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: offline zone successfully
*   false: offline zone successfully failed', example='true'),
}

model DeactivateZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeactivateZonesResponseBody(name='body'),
}

async function deactivateZones(request: DeactivateZonesRequest): DeactivateZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeactivateZones', 'POST', '/openapi/instances/{InstanceId}/actions/down-zones', 'json', false, 'json', request);
}

model DeleteCollectorRequest {
  resId: string(name='ResId', description='The ID of the shipper.', example='ct-cn-92z1h38882dal****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model DeleteCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Indicates whether the shipper is deleted. Valid values:

*   true: The shipper is deleted.
*   false: The shipper fails to be deleted.', example='true'),
}

model DeleteCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCollectorResponseBody(name='body'),
}

async function deleteCollector(request: DeleteCollectorRequest): DeleteCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCollector', 'DELETE', '/openapi/collectors/{ResId}', 'json', false, 'json', request);
}

model DeleteComponentIndexRequest {
  instanceId: string(name='InstanceId', example='es-cn-tl329rbpc0001****', position='Path'),
  name: string(name='name', example='template', position='Path'),
}

model DeleteComponentIndexResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: boolean(name='Result', example='true'),
}

model DeleteComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteComponentIndexResponseBody(name='body'),
}

async function deleteComponentIndex(request: DeleteComponentIndexRequest): DeleteComponentIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteComponentIndex', 'DELETE', '/openapi/instances/{InstanceId}/component-index/{name}', 'json', false, 'json', request);
}

model DeleteConnectedClusterRequest {
  instanceId: string(name='InstanceId', description='The ID of the current instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  connectedInstanceId: string(name='connectedInstanceId', description='The ID of the remote instance for which the network connection is established.', example='es-cn-09k1rgid9000g****', position='Query'),
}

model DeleteConnectedClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='Return results:

*   true: remove the interworking instance successfully
*   false: remove the interworking instance failed', example='true'),
}

model DeleteConnectedClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConnectedClusterResponseBody(name='body'),
}

async function deleteConnectedCluster(request: DeleteConnectedClusterRequest): DeleteConnectedClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteConnectedCluster', 'DELETE', '/openapi/instances/{InstanceId}/connected-clusters', 'json', false, 'json', request);
}

model DeleteDataStreamRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif24adwc0082****', position='Path'),
  dataStream: string(name='DataStream', example='ds-001', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model DeleteDataStreamResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model DeleteDataStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataStreamResponseBody(name='body'),
}

async function deleteDataStream(request: DeleteDataStreamRequest): DeleteDataStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDataStream', 'DELETE', '/openapi/instances/{InstanceId}/data-streams/{DataStream}', 'json', false, 'json', request);
}

model DeleteDataTaskRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-oew1oxiro000f****', position='Path'),
  clientToken: string(name='ClientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  taskId: string(name='taskId', description='The ID of the index migration task.', example='et_cn_0oyg09o96ib40****', position='Query'),
}

model DeleteDataTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='The returned results.', example='true'),
}

model DeleteDataTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataTaskResponseBody(name='body'),
}

async function deleteDataTask(request: DeleteDataTaskRequest): DeleteDataTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDataTask', 'DELETE', '/openapi/instances/{InstanceId}/data-task', 'json', false, 'json', request);
}

model DeleteDeprecatedTemplateRequest {
  instanceId: string(name='InstanceId', example='es-cn-tl329rbpc0001****', position='Path'),
  name: string(name='name', example='template', position='Path'),
}

model DeleteDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: boolean(name='Result', example='true'),
}

model DeleteDeprecatedTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeprecatedTemplateResponseBody(name='body'),
}

async function deleteDeprecatedTemplate(request: DeleteDeprecatedTemplateRequest): DeleteDeprecatedTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDeprecatedTemplate', 'DELETE', '/openapi/instances/{InstanceId}/deprecated-templates/{name}', 'json', false, 'json', request);
}

model DeleteILMPolicyRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif24adwc0082****', position='Path'),
  policyName: string(name='PolicyName', example='slm-history-ilm-policy', position='Path'),
}

model DeleteILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='694FDC20-0FDD-47C4-B921-BFF902FA****'),
  result?: boolean(name='Result', example='true'),
}

model DeleteILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteILMPolicyResponseBody(name='body'),
}

async function deleteILMPolicy(request: DeleteILMPolicyRequest): DeleteILMPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteILMPolicy', 'DELETE', '/openapi/instances/{InstanceId}/ilm-policies/{PolicyName}', 'json', false, 'json', request);
}

model DeleteIndexTemplateRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif24adwc0082****', position='Path'),
  indexTemplate: string(name='IndexTemplate', example='index-name', position='Path'),
}

model DeleteIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='A0761F7E-0B50-46B9-8CAA-EBB3A420****'),
  result?: boolean(name='Result', example='true'),
}

model DeleteIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIndexTemplateResponseBody(name='body'),
}

async function deleteIndexTemplate(request: DeleteIndexTemplateRequest): DeleteIndexTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteIndexTemplate', 'DELETE', '/openapi/instances/{InstanceId}/index-templates/{IndexTemplate}', 'json', false, 'json', request);
}

model DeleteInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-t57p81n7ai89v****', position='Path'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  deleteType?: string(name='deleteType', example='protective', position='Query'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='94B03BBA-A132-42C3-8367-0A0C1C45****'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteInstance', 'DELETE', '/openapi/instances/{InstanceId}', 'json', false, 'json', request);
}

model DeleteLogstashRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='ls-cn-n6w1o5jq****', position='Path'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  deleteType?: string(name='deleteType', description='The type of the release operation. Valid values:

*   immediate: The cluster is immediately deleted when it is released. After the cluster is deleted, the data stored in the cluster is deleted, and the system removes the cluster from the Logstash cluster list.
*   protective: The cluster is released 24 hours later. During the period of 24 hours, you can still find the cluster in the Logstash cluster list, and [restore the cluster](~~202205~~) or [immediately release the cluster](~~160591~~). After 24 hours elapse, the data stored in the cluster is deleted.', example='protective', position='Query'),
}

model DeleteLogstashResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='94B03BBA-A132-42C3-8367-0A0C1C45****'),
}

model DeleteLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLogstashResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following information: After the cluster is released, the physical resources used by the cluster are reclaimed. The data stored in the cluster is deleted and cannot be recovered. The disks attached to the nodes in the cluster and the snapshots created for the cluster are released.
  *
 */
async function deleteLogstash(request: DeleteLogstashRequest): DeleteLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLogstash', 'DELETE', '/openapi/logstashes/{InstanceId}', 'json', false, 'json', request);
}

model DeletePipelinesRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-oew1qbgl****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  pipelineIds?: string(name='pipelineIds', description='The ID of the pipeline.', example='pipeline-test', position='Query'),
}

model DeletePipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Indicates whether the pipeline is deleted. Valid values:

*   true: The pipeline is deleted.
*   false: The pipeline fails to be deleted.', example='true'),
}

model DeletePipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePipelinesResponseBody(name='body'),
}

async function deletePipelines(request: DeletePipelinesRequest): DeletePipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeletePipelines', 'DELETE', '/openapi/logstashes/{InstanceId}/pipelines', 'json', false, 'json', request);
}

model DeleteSnapshotRepoRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  repoPath: string(name='repoPath', description='Reference instance ID.', example='es-cn-n6w1rux8i000w****', position='Query'),
}

model DeleteSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: reference warehouse deleted successfully
*   false: reference warehouse deleted successfully failed', example='true'),
}

model DeleteSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSnapshotRepoResponseBody(name='body'),
}

async function deleteSnapshotRepo(request: DeleteSnapshotRepoRequest): DeleteSnapshotRepoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteSnapshotRepo', 'DELETE', '/openapi/instances/{InstanceId}/snapshot-repos', 'json', false, 'json', request);
}

model DeleteVpcEndpointRequest {
  instanceId: string(name='InstanceId', example='es-cn-2r429tctl000d****', position='Path'),
  endpointId: string(name='EndpointId', example='ep-bp18s6wy9420wdi4****', position='Path'),
  clientToken?: string(name='ClientToken', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***', position='Query'),
}

model DeleteVpcEndpointResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: boolean(name='Result', example='true'),
}

model DeleteVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpcEndpointResponseBody(name='body'),
}

async function deleteVpcEndpoint(request: DeleteVpcEndpointRequest): DeleteVpcEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteVpcEndpoint', 'DELETE', '/openapi/instances/{InstanceId}/vpc-endpoints/{EndpointId}', 'json', false, 'json', request);
}

model DescribeAckOperatorRequest {
  clusterId: string(name='ClusterId', description='The ID of the ACK cluster.', example='c79acd3fbf462423fb6450e513bb6****', position='Path'),
}

model DescribeAckOperatorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6615EE8D-FD9D-4FD3-997E-6FEA5B8D82ED'),
  result?: {
    status?: string(name='status', description='The installation status of ES-operator. Valid values:

*   deployed: ES-operator is installed.
*   not-deploy: ES-operator is not installed.
*   failed: ES-operator fails to be installed.
*   unknown: The installation status of ES-operator is unknown.', example='deployed'),
    version?: string(name='version', description='The version of ES-operator.', example='1'),
  }(name='Result', description='The returned result.'),
}

model DescribeAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAckOperatorResponseBody(name='body'),
}

/**
  * > Before you install a shipper on an ACK cluster, you can call this operation to query the installation status of ES-operator for the ACK cluster.
  *
 */
async function describeAckOperator(request: DescribeAckOperatorRequest): DescribeAckOperatorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeAckOperator', 'GET', '/openapi/ack-clusters/{ClusterId}/operator', 'json', false, 'json', request);
}

model DescribeApmRequest {
  instanceId: string(name='instanceId', example='apm-cn-2r42fhp5****', position='Path'),
}

model DescribeApmResponseBody = {
  requestId?: string(name='RequestId', example='97597D87-8066-5493-B692-5C50DA236D68'),
  result?: {
    apmServerDomain?: string(name='apmServerDomain', example='apm-cn-i7m2fuae****.apm.elasticsearch.aliyuncs.com:8200'),
    createdAt?: string(name='createdAt', example='2021-11-16T07:15:51.967Z'),
    deployedReplica?: long(name='deployedReplica', example='1'),
    description?: string(name='description', example='APMtest'),
    endTime?: long(name='endTime', example='4792752000000'),
    instanceId?: string(name='instanceId', example='apm-cn-i7m2fuae****'),
    nodeAmount?: long(name='nodeAmount', example='1'),
    outputES?: string(name='outputES', example='es-cn-i7m2fsfhc001x****'),
    outputESUserName?: string(name='outputESUserName', example='elastic'),
    ownerId?: string(name='ownerId', example='133071096032****'),
    paymentType?: string(name='paymentType', example='postpaid'),
    region?: string(name='region', example='cn-hangzhou'),
    replica?: int32(name='replica', example='1'),
    resourceSpec?: string(name='resourceSpec', example='C1M2'),
    status?: string(name='status', example='active'),
    version?: string(name='version', example='7.10.2'),
    vpcId?: string(name='vpcId', example='vpc-bp1530vdhqkamm9s0****'),
    vsArea?: string(name='vsArea', example='cn-hangzhou-i'),
    vswitchId?: string(name='vswitchId', example='vsw-bp1j1mql6r9g5vfb4****'),
  }(name='Result'),
}

model DescribeApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApmResponseBody(name='body'),
}

async function describeApm(request: DescribeApmRequest): DescribeApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApm', 'GET', '/openapi/apm/{instanceId}', 'json', false, 'json', request);
}

model DescribeCollectorRequest {
  resId: string(name='ResId', description='The ID of the shipper.', example='ct-cn-rg31ahn82m0qd****', position='Path'),
}

model DescribeCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content', description='The content of the file.', example='fileBeat.inputs:xxx'),
        fileName?: string(name='fileName', description='The name of the file.', example='filebeat.yml'),
      }
    ](name='configs', description='The information about the configuration file of the shipper.'),
    dryRun?: boolean(name='dryRun', description='Indicates whether a dry run is performed. Valid values:

*   true
*   false', example='false'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType', description='The configuration type. Valid values:

*   collectorTargetInstance
*   collectorDeployMachine
*   collectorElasticsearchForKibana', example='collectorDeployMachine'),
        enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether monitoring is enabled. This parameter is returned if the value of **configType** is **collectorTargetInstance**. Valid values:

*   true
*   false', example='true'),
        groupId?: string(name='groupId', description='The ID of the machine group. This parameter is returned if the value of **configType** is **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
        host?: string(name='host', description='The private endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId', description='The ID of the resource that is associated with the shipper. If the value of **configType** is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType** is **collectorDeployMachines** and the value of **type** is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='es-cn-n6w1o1****'),
        instanceType?: string(name='instanceType', description='The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='elasticsearch'),
        kibanaHost?: string(name='kibanaHost', description='The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values:

*   heartOk: The heartbeat is normal.
*   heartLost: The heartbeat is abnormal.
*   uninstalled: The shipper is not installed.
*   failed: The shipper fails to be installed.', example='heartOk'),
            instanceId?: string(name='instanceId', description='The IDs of the ECS instances.', example='i-bp1gyhphjaj73jsr****'),
          }
        ](name='machines', description='The information about the Elastic Compute Service (ECS) instances on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachines** and the value of **type** is **ECSInstanceId**.'),
        protocol?: string(name='protocol', description='The transmission protocol, which must be the same as the access protocol of the resource specified in the output configuration part of the shipper. Valid values: HTTP and HTTPS. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='HTTP'),
        successPodsCount?: string(name='successPodsCount', description='The number of pods from which data is succcessfully collected in the Container Service for Kubernetes (ACK) cluster.', example='8'),
        totalPodsCount?: string(name='totalPodsCount', description='The total number of pods from which data is collected in the ACK cluster.', example='10'),
        type?: string(name='type', description='The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
        userName?: string(name='userName', description='The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
      }
    ](name='extendConfigs', description='The extended configurations of the shipper.'),
    gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-06-20T07:26:47.000+0000'),
    name?: string(name='name', description='The name of the shipper.', example='ct-cn-4135is2tj194p****'),
    ownerId?: string(name='ownerId', description='The account ID.', example='16852099488*****'),
    resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-rg31ahn82m0qd****'),
    resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.', example='fileBeat'),
    resVersion?: string(name='resVersion', description='The version of the shipper.', example='6.8.5_with_community'),
    status?: string(name='status', description='The status of the shipper. Valid values:

*   activating
*   active', example='active'),
    vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) where the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
  }(name='Result', description='The returned result.'),
}

model DescribeCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCollectorResponseBody(name='body'),
}

async function describeCollector(request: DescribeCollectorRequest): DescribeCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeCollector', 'GET', '/openapi/collectors/{ResId}', 'json', false, 'json', request);
}

model DescribeComponentIndexRequest {
  instanceId: string(name='InstanceId', example='es-cn-tl329rbpc0001****', position='Path'),
  name?: string(name='name', example='template', position='Path'),
}

model DescribeComponentIndexResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: {
    meta?: map[string]any(name='_meta', example='{ "description": "set number of shards to one" }'),
    template?: {
      aliases?: map[string]any(name='aliases', example='{}'),
      mappings?: map[string]any(name='mappings', example='{ "properties": { "@timestamp": { "type": "date" } } }'),
      settings?: map[string]any(name='settings', example='{ "index.number_of_replicas": 0 }'),
    }(name='template'),
  }(name='Result'),
}

model DescribeComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeComponentIndexResponseBody(name='body'),
}

async function describeComponentIndex(request: DescribeComponentIndexRequest): DescribeComponentIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeComponentIndex', 'GET', '/openapi/instances/{InstanceId}/component-index/{name}', 'json', false, 'json', request);
}

model DescribeConnectableClustersRequest {
  instanceId: string(name='InstanceId', description='The network type of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  alreadySetItems?: boolean(name='alreadySetItems', description='The ID of the instance that can communicate with each other.', example='true', position='Query'),
}

model DescribeConnectableClustersResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      instances?: string(name='instances', example='es-cn-xxx'),
      networkType?: string(name='networkType', example='vpc'),
    }
  ](name='Result'),
}

model DescribeConnectableClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeConnectableClustersResponseBody(name='body'),
}

async function describeConnectableClusters(request: DescribeConnectableClustersRequest): DescribeConnectableClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeConnectableClusters', 'GET', '/openapi/instances/{InstanceId}/connectable-clusters', 'json', false, 'json', request);
}

model DescribeDeprecatedTemplateRequest {
  instanceId: string(name='InstanceId', example='es-cn-tl329rbpc0001****', position='Path'),
  name: string(name='name', example='template', position='Path'),
}

model DescribeDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: {
    dataStream?: boolean(name='dataStream', example='false'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate', example='openstore-index-template'),
    order?: long(name='order', example='100'),
    template?: {
      aliases?: string(name='aliases', example='"{}"'),
      mappings?: string(name='mappings', example='"{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}"'),
      settings?: string(name='settings', example='"{\\"index.number_of_shards\\":\\"1\\"}"'),
    }(name='template'),
    version?: string(name='version', example='70000'),
  }(name='Result'),
}

model DescribeDeprecatedTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeprecatedTemplateResponseBody(name='body'),
}

async function describeDeprecatedTemplate(request: DescribeDeprecatedTemplateRequest): DescribeDeprecatedTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeDeprecatedTemplate', 'GET', '/openapi/instances/{InstanceId}/deprecated-templates/{name}', 'json', false, 'json', request);
}

model DescribeDiagnoseReportRequest {
  instanceId: string(name='InstanceId', example='es-cn-mp91kzb8m0009****', position='Path'),
  reportId: string(name='ReportId', example='scheduled__2020-09-15T00:40:00', position='Path'),
  lang?: string(name='lang', example='en', position='Query'),
}

model DescribeDiagnoseReportResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    createTime?: long(name='createTime', example='1535745731000'),
    diagnoseItems?: [ 
      {
        detail?: {
          desc?: string(name='desc', example='Check whether the number of replica shards is optimal and easy to maintain'),
          name?: string(name='name', example='Number of Replica Shards'),
          result?: string(name='result', example='You may need to adjust the numbers of replica shards of some indices as follows: [geoname08 : 0 -&gt; 1][geoname09 : 0 -&gt; 1][geonametest01 : 0 -&gt; 1]'),
          suggest?: string(name='suggest', example='You can call the following function in the Elasticsearch API....'),
          type?: string(name='type', example='ES_API'),
        }(name='detail'),
        health?: string(name='health', example='YELLOW'),
        item?: string(name='item', example='IndexAliasUseDiagnostic'),
      }
    ](name='diagnoseItems'),
    health?: string(name='health', example='YELLOW'),
    instanceId?: string(name='instanceId', example='es-cn-abc'),
    reportId?: string(name='reportId', example='trigger__2020-08-17T17:09:02'),
    state?: string(name='state', example='SUCCESS'),
    trigger?: string(name='trigger', example='SYSTEM'),
  }(name='Result'),
}

model DescribeDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDiagnoseReportResponseBody(name='body'),
}

async function describeDiagnoseReport(request: DescribeDiagnoseReportRequest): DescribeDiagnoseReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeDiagnoseReport', 'GET', '/openapi/diagnosis/instances/{InstanceId}/reports/{ReportId}', 'json', false, 'json', request);
}

model DescribeDiagnosisSettingsRequest {
  instanceId: string(name='InstanceId', description='The ID of an instance.', example='es-cn-68n1n8b7f000a****', position='Path'),
  lang?: string(name='lang', description='The language of the returned result. Default value: en.', example='en', position='Query'),
}

model DescribeDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5E82B8A8-EED7-4557-A6E9-D1AD3E58****'),
  result?: {
    scene?: string(name='scene', description='Scenarios of intelligent maintenance.', example='Business Search'),
    updateTime?: long(name='updateTime', description='The timestamp of the last update for Intelligent Maintenance scenarios.', example='1588994035385'),
  }(name='Result', description='The return results.'),
}

model DescribeDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDiagnosisSettingsResponseBody(name='body'),
}

async function describeDiagnosisSettings(request: DescribeDiagnosisSettingsRequest): DescribeDiagnosisSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeDiagnosisSettings', 'GET', '/openapi/diagnosis/instances/{InstanceId}/settings', 'json', false, 'json', request);
}

model DescribeDynamicSettingsRequest {
  instanceId?: string(name='InstanceId', position='Path'),
}

model DescribeDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeDynamicSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDynamicSettingsResponseBody(name='body'),
}

async function describeDynamicSettings(request: DescribeDynamicSettingsRequest): DescribeDynamicSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeDynamicSettings', 'GET', '/openapi/instances/{InstanceId}/dynamic-settings', 'json', false, 'json', request);
}

model DescribeElasticsearchHealthRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-tl325wxga000l****', position='Path'),
}

model DescribeElasticsearchHealthResponseBody = {
  code?: string(name='Code', description='The response code returned.', example='200'),
  message?: string(name='Message', description='The response message returned.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0731F217-2C8A-4D42-8BCD-5C352866E3B7'),
  result?: string(name='Result', description='The color that indicates the health status of the cluster.', example='GREEN'),
}

model DescribeElasticsearchHealthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeElasticsearchHealthResponseBody(name='body'),
}

/**
  * An Elasticsearch cluster can be in a health state indicated by one of the following colors:
  * *   GREEN: Primary shards and replica shards for the primary shards are normally allocated.
  * *   YELLOW: Primary shards are normally allocated, but replica shards for the primary shards are not normally allocated.
  * *   RED: Primary shards are not normally allocated.
  *
 */
async function describeElasticsearchHealth(request: DescribeElasticsearchHealthRequest): DescribeElasticsearchHealthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeElasticsearchHealth', 'GET', '/openapi/instances/{InstanceId}/elasticsearch-health', 'json', false, 'json', request);
}

model DescribeILMPolicyRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif24adwc0082****', position='Path'),
  policyName: string(name='PolicyName', example='policy-1', position='Path'),
}

model DescribeILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='FF44681E-FD41-4FDE-B8DF-295DCDD6****'),
  result?: {
    name?: string(name='name', example='ilm-history-ilm-policy'),
    phases?: map[string]any(name='phases', example='{"cold":{"minAge":"30d","actions":{"allocate":{"numberOfReplicas":1,"require":{"boxType":"warm"}},"setPriority":{"priority":100}}},"hot":{"minAge":"0s","actions":{"rollover":{"maxAge":"30d","maxDocs":10000,"maxSize":"50gb"},"setPriority":{"priority":1000}}},"delete":{"minAge":"30d","actions":{"delete":{}}}}'),
  }(name='Result'),
}

model DescribeILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeILMPolicyResponseBody(name='body'),
}

async function describeILMPolicy(request: DescribeILMPolicyRequest): DescribeILMPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeILMPolicy', 'GET', '/openapi/instances/{InstanceId}/ilm-policies/{PolicyName}', 'json', false, 'json', request);
}

model DescribeIndexTemplateRequest {
  instanceId: string(name='InstanceId', example='es-cn-n6w24n9u900am****', position='Path'),
  indexTemplate: string(name='IndexTemplate', example='data-stream-default', position='Path'),
}

model DescribeIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='25DB38F8-82E4-4D16-82BB-FF077C7F****'),
  result?: {
    dataStream?: boolean(name='dataStream', example='true'),
    ilmPolicy?: string(name='ilmPolicy', example='cube_default_ilm_policy'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate', example='data-stream-default'),
    priority?: int32(name='priority', example='0'),
    template?: {
      aliases?: string(name='aliases', example='{\\"mydata\\":{}}'),
      mappings?: string(name='mappings', example='{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}'),
      settings?: string(name='settings', example='{\\"index.refresh_interval\\":\\"1s\\"}'),
    }(name='template'),
  }(name='Result'),
}

model DescribeIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIndexTemplateResponseBody(name='body'),
}

async function describeIndexTemplate(request: DescribeIndexTemplateRequest): DescribeIndexTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeIndexTemplate', 'GET', '/openapi/instances/{InstanceId}/index-templates/{IndexTemplate}', 'json', false, 'json', request);
}

model DescribeInstanceRequest {
  instanceId: string(name='InstanceId', example='es-cn-3h4k3axh33th9****', position='Path'),
}

model DescribeInstanceResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    advancedDedicateMaster?: boolean(name='advancedDedicateMaster', example='true'),
    advancedSetting?: {
      gcName?: string(name='gcName', example='CMS'),
    }(name='advancedSetting'),
    aliwsDicts?: [ 
      {
        fileSize?: long(name='fileSize', example='2782602'),
        name?: string(name='name', example='aliws_ext_dict.txt'),
        sourceType?: string(name='sourceType', example='OSS'),
        type?: string(name='type', example='ALI_WS'),
      }
    ](name='aliwsDicts'),
    clientNodeConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='40'),
      diskType?: string(name='diskType', example='cloud_efficiency'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='clientNodeConfiguration'),
    createdAt?: string(name='createdAt', example='2018-07-13T03:58:07.253Z'),
    dedicateMaster?: boolean(name='dedicateMaster', example='false'),
    description?: string(name='description', example='es-cn-abc'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize', example='2782602'),
        name?: string(name='name', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', example='ORIGIN'),
        type?: string(name='type', example='MAIN'),
      }
    ](name='dictList'),
    domain?: string(name='domain', example='es-cn-3h4k3axh33th9****.elasticsearch.aliyuncs.com'),
    elasticDataNodeConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='20'),
      diskEncryption?: boolean(name='diskEncryption', example='true'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      spec?: string(name='spec', example='elasticsearch.sn2ne.large'),
    }(name='elasticDataNodeConfiguration'),
    enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork', example='false'),
    enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork', example='true'),
    enablePublic?: boolean(name='enablePublic', example='true'),
    esConfig?: map[string]any(name='esConfig', example='{"http.cors.allow-credentials":"false"}'),
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
    esIPWhitelist?: [ string ](name='esIPWhitelist'),
    esVersion?: string(name='esVersion', example='6.3.2_with_X-Pack'),
    extendConfigs?: [  map[string]any ](name='extendConfigs'),
    haveClientNode?: boolean(name='haveClientNode', example='true'),
    haveKibana?: boolean(name='haveKibana', example='true'),
    ikHotDicts?: [ 
      {
        fileSize?: int32(name='fileSize', example='6'),
        name?: string(name='name', example='deploy_0.dic'),
        sourceType?: string(name='sourceType', example='OSS'),
        type?: string(name='type', example='MAIN'),
      }
    ](name='ikHotDicts'),
    instanceCategory?: string(name='instanceCategory', example='advanced'),
    instanceId?: string(name='instanceId', example='es-cn-3h4k3axh33th9****'),
    isNewDeployment?: boolean(name='isNewDeployment', example='true'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', example='1'),
      disk?: int32(name='disk', example='20'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain', example='es-cn-3h4k3axh33th9****.kibana.elasticsearch.aliyuncs.com'),
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
    kibanaPort?: int32(name='kibanaPort', example='5601'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
    masterConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='40'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type', example='vpc'),
      vpcId?: string(name='vpcId', example='vpc-abc'),
      vsArea?: string(name='vsArea', example='cn-hangzhou-b'),
      vswitchId?: string(name='vswitchId', example='vsw-abc'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName', example='default'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType', example='PRIVATE_ES'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', example='0'),
      diskEncryption?: boolean(name='diskEncryption', example='true'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      performanceLevel?: string(name='performanceLevel', example='PL1'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType', example='postpaid'),
    port?: int32(name='port', example='9200'),
    postpaidServiceStatus?: string(name='postpaidServiceStatus', example='active'),
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
    protocol?: string(name='protocol', example='HTTP'),
    publicDomain?: string(name='publicDomain', example='es-cn-3h4k3axh33th9****.elasticsearch.aliyuncs.com'),
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
    publicPort?: int32(name='publicPort', example='9200'),
    resourceGroupId?: string(name='resourceGroupId', example='rg-aekzvowej3i****'),
    serviceVpc?: boolean(name='serviceVpc', example='true'),
    status?: string(name='status', example='active'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize', example='2782602'),
        name?: string(name='name', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', example='ORIGIN'),
        type?: string(name='type', example='STOP'),
      }
    ](name='synonymsDicts'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey', example='env'),
        tagValue?: string(name='tagValue', example='dev'),
      }
    ](name='tags'),
    updatedAt?: string(name='updatedAt', example='2018-07-13T03:58:07.253Z'),
    vpcInstanceId?: string(name='vpcInstanceId', example='vpc-bp1uag5jj38c****'),
    warmNode?: boolean(name='warmNode', example='true'),
    warmNodeConfiguration?: {
      amount?: int32(name='amount', example='6'),
      disk?: int32(name='disk', example='500'),
      diskEncryption?: boolean(name='diskEncryption', example='true'),
      diskType?: string(name='diskType', example='cloud_efficiency'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='warmNodeConfiguration'),
    zoneCount?: int32(name='zoneCount', example='2'),
    zoneInfos?: [ 
      {
        status?: string(name='status', example='NORMAL'),
        zoneId?: string(name='zoneId', example='cn-hangzhou-b'),
      }
    ](name='zoneInfos'),
  }(name='Result'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstance(request: DescribeInstanceRequest): DescribeInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeInstance', 'GET', '/openapi/instances/{InstanceId}', 'json', false, 'json', request);
}

model DescribeKibanaSettingsRequest {
  instanceId: string(name='InstanceId', example='es-cn-n6w1o1x0w001c****', position='Path'),
}

model DescribeKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6D*****'),
  result?: map[string]any(name='Result', example='{"map.includeElasticMapsService": "false", "server.ssl.cert": "/home/admin/packages/kibana/config/cert/client.crt", "server.ssl.enabled": "true", "server.ssl.key": "/home/admin/packages/kibana/config/cert/client.key", "xpack.reporting.capture.browser.chromium.disableSandbox": "true"}'),
}

model DescribeKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeKibanaSettingsResponseBody(name='body'),
}

async function describeKibanaSettings(request: DescribeKibanaSettingsRequest): DescribeKibanaSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeKibanaSettings', 'GET', '/openapi/instances/{InstanceId}/kibana-settings', 'json', false, 'json', request);
}

model DescribeLogstashRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='ls-cn-s9dsk3k4k****', position='Path'),
}

model DescribeLogstashResponseBody = {
  requestId?: string(name='RequestId', description='Detailed information about the instance.', example='C9334241-4837-46C2-B24B-9BDC517318DE'),
  result?: {
    extendConfigs?: [  map[string]any ](name='ExtendConfigs', description='The configuration information of the node.'),
    resourceGroupId?: string(name='ResourceGroupId', description='The number of data nodes.', example='rg-aekzvowej3i****'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey', description='The value of the tag.', example='env'),
        tagValue?: string(name='tagValue', description='The information about the zones.', example='dev'),
      }
    ](name='Tags', description='The key of the tag.'),
    zoneInfos?: [ 
      {
        status?: string(name='status', description='The zone ID of the new instance.', example='NORMAL'),
        zoneId?: string(name='zoneId', description='The configuration of cluster extension parameters.', example='cn-hangzhou-b'),
      }
    ](name='ZoneInfos', description='The status of the zone. Valid values:

*   ISOLATION: offline
*   NORMAL'),
    config?: map[string]any(name='config', description='The billing method of the instance. Valid values:

*   prepaid: subscription
*   postpaid: pay-as-you-go', example='{"slowlog.threshold.warn": "2s","slowlog.threshold.info": "1s","slowlog.threshold.debug": "500ms","slowlog.threshold.trace": "100ms" }'),
    createdAt?: string(name='createdAt', description='The state of the instance. Four states are supported:

*   Normal: active
*   Active: activating
*   Freeze: inactive
*   Invalid: invalid', example='2020-02-06T14:12:03.672Z'),
    description?: string(name='description', description='The time when the instance was created.', example='ls-cn-abc'),
    endpointList?: [ 
      {
        host?: string(name='host', description='The tags added to the ALB instance.', example='172.16.**.**'),
        port?: string(name='port', description='The IP address of the node.', example='9600'),
        zoneId?: string(name='zoneId', description='The port number.', example='cn-hangzhou-b'),
      }
    ](name='endpointList', description='The ID of the zone where the node resides.'),
    instanceId?: string(name='instanceId', description='The access information of the node.', example='ls-cn-abc'),
    networkConfig?: {
      type?: string(name='type', description='The ID of the vSwitch to which the instance is connected.', example='vpc'),
      vpcId?: string(name='vpcId', description='The zone where the cluster resides.', example='vpc-bp16k1dvzxtmagcva****'),
      vsArea?: string(name='vsArea', description='The network type of the instance. Valid values: Currently, only Virtual Private Cloud (VPC) are supported.', example='cn-hangzhou-*'),
      vswitchId?: string(name='vswitchId', example='vsw-bp1k4ec6s7sjdbudw****'),
    }(name='networkConfig', description='The ID of the virtual private cloud (VPC).'),
    nodeAmount?: int32(name='nodeAmount', description='The name of the instance.', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='Whether to use disk encryption:

*   true
*   false', example='20'),
      diskEncryption?: boolean(name='diskEncryption', description='The disk type of the node.', example='true'),
      diskType?: string(name='diskType', description='The network configurations.', example='cloud_ssd'),
      spec?: string(name='spec', description='The disk size of the node.', example='elasticsearch.sn1ne.large'),
    }(name='nodeSpec', description='The specifications of the node.'),
    paymentType?: string(name='paymentType', description='The ID of the resource group to which the instance belongs.', example='prepaid'),
    status?: string(name='status', description='The ID of the virtual private cloud (VPC) to which the elastic container instances belong.', example='active'),
    updatedAt?: string(name='updatedAt', description='The edition of the dedicated KMS instance.', example='2020-02-06T14:22:36.850Z'),
    version?: string(name='version', description='The ID of the instance.', example='7.4.0_with_X-Pack'),
    vpcInstanceId?: string(name='vpcInstanceId', description='The time when the instance was last updated.', example='vpc-bp16k1dvzxtmagcva****'),
  }(name='Result', description='The configurations of the instance.'),
}

model DescribeLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogstashResponseBody(name='body'),
}

async function describeLogstash(request: DescribeLogstashRequest): DescribeLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeLogstash', 'GET', '/openapi/logstashes/{InstanceId}', 'json', false, 'json', request);
}

model DescribePipelineRequest {
  instanceId: string(name='InstanceId', description='The information about the returned pipeline. For more information, see [logstash.yml](https://www.elastic.co/guide/en/logstash/6.7/logstash-settings-file.html).', example='ls-cn-oew1qbgl****', position='Path'),
  pipelineId: string(name='PipelineId', description='The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job.', example='pipeline_test', position='Path'),
}

model DescribePipelineResponseBody = {
  requestId?: string(name='RequestId', description='The time when the pipeline was updated.', example='829F38F6-E2D6-4109-90A6-888160BD1***'),
  result?: {
    batchDelay?: int32(name='batchDelay', description='The time when the pipeline was created.', example='50'),
    batchSize?: int32(name='batchSize', example='125'),
    config?: string(name='config', description='The description of the pipeline.', example='input {  }  filter {  }  output {  }'),
    description?: string(name='description', description='The state of the MPS queue. Valid values:

*   NOT_DEPLOYED: The node is not deployed.
*   RUNNING
*   DELETED: Deleted. The console does not display this status.', example='this is a test'),
    gmtCreatedTime?: string(name='gmtCreatedTime', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The total capacity of the queue in bytes. Unit: MB.', example='2020-06-20T07:26:47.000+0000'),
    pipelineId?: string(name='pipelineId', description='Number of queue checkpoint writes.', example='pipeline_test'),
    pipelineStatus?: string(name='pipelineStatus', example='RUNNING'),
    queueCheckPointWrites?: int32(name='queueCheckPointWrites', description='Pipeline batch delay. Unit: milliseconds.', example='1024'),
    queueMaxBytes?: int32(name='queueMaxBytes', description='The number of pipeline workers.', example='1024'),
    queueType?: string(name='queueType', description='The specific configuration of the pipeline.', example='MEMORY'),
    workers?: int32(name='workers', description='The size of the pipeline batch.', example='2'),
  }(name='Result', description='The type of the queue. Valid values:

*   MEMORY: a traditional memory-based queue.
*   PERSISTED: disk-based ACKed queue (persistent queue).'),
}

model DescribePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePipelineResponseBody(name='body'),
}

async function describePipeline(request: DescribePipelineRequest): DescribePipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePipeline', 'GET', '/openapi/logstashes/{InstanceId}/pipelines/{PipelineId}', 'json', false, 'json', request);
}

model DescribePipelineManagementConfigRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-oew1qbgl****', position='Path'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model DescribePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    endpoints?: string(name='endpoints', description='The access addresses of the Elasticsearch cluster. Specify each address in the `http://Endpoint of the Elasticsearch cluster:Port number` format.', example='["http://es-cn-n6w1o1x0w001c****.elasticsearch.aliyuncs.com:9200"]'),
    esInstanceId?: string(name='esInstanceId', description='The ID of the Elasticsearch cluster.', example='es-cn-n6w1o1x0w001c****'),
    pipelineIds?: [ string ](name='pipelineIds'),
    pipelineManagementType?: string(name='pipelineManagementType', description='The pipeline management method. Valid values: Kibana and MULTIPLE_PIPELINE.', example='MULTIPLE_PIPELINE'),
    userName?: string(name='userName', description='The username that is used to access the Elasticsearch cluster.', example='elastic'),
  }(name='Result', description='The returned result.'),
}

model DescribePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePipelineManagementConfigResponseBody(name='body'),
}

async function describePipelineManagementConfig(request: DescribePipelineManagementConfigRequest): DescribePipelineManagementConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePipelineManagementConfig', 'GET', '/openapi/logstashes/{InstanceId}/pipeline-management-config', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId', description='The available status of the region.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1ADFG'),
  result?: [ 
    {
      consoleEndpoint?: string(name='consoleEndpoint', example='https://elasticsearch-cn-hangzhou.console.aliyun.com'),
      localName?: string(name='localName', example='China (Hangzhou)'),
      regionEndpoint?: string(name='regionEndpoint', example='elasticsearch.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='regionId', description='The name of the region.', example='cn-hangzhou'),
      status?: string(name='status', description='The endpoint of the region that is exposed in the console.', example='available'),
    }
  ](name='Result', description='The endpoint of the region.'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeRegions', 'GET', '/openapi/regions', 'json', false, 'json', request);
}

model DescribeSnapshotSettingRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-0pp1jxvcl000z****', position='Path'),
}

model DescribeSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: {
    enable?: boolean(name='Enable', description='Whether to enable automatic backup.', example='true'),
    quartzRegex?: string(name='QuartzRegex', description='Automatic backup time configuration, using Quartz Cron expression.', example='0 0 01 ? * * *'),
  }(name='Result', description='The return results.'),
}

model DescribeSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSnapshotSettingResponseBody(name='body'),
}

async function describeSnapshotSetting(request: DescribeSnapshotSettingRequest): DescribeSnapshotSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeSnapshotSetting', 'GET', '/openapi/instances/{InstanceId}/snapshot-setting', 'json', false, 'json', request);
}

model DescribeTemplatesRequest {
  instanceId: string(name='InstanceId', example='es-cn-n6w1o1x0w001c****', position='Path'),
}

model DescribeTemplatesResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      content?: string(name='content', example='{\\n\\t\\"persistent\\":{\\n\\t\\t\\"search\\":{\\n\\t\\t\\t\\"max_buckets\\":\\"10000\\"\\n\\t\\t}\\n\\t}\\n}'),
      templateName?: string(name='templateName', example='dynamicSettings'),
    }
  ](name='Result'),
}

model DescribeTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTemplatesResponseBody(name='body'),
}

async function describeTemplates(request: DescribeTemplatesRequest): DescribeTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeTemplates', 'GET', '/openapi/instances/{InstanceId}/templates', 'json', false, 'json', request);
}

model DescribeXpackMonitorConfigRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-oew1qbgl****', position='Path'),
}

model DescribeXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    enable?: boolean(name='enable', description='Indicates whether the X-Pack Monitoring feature is enabled. Valid values:

*   true: enabled
*   false: disabled', example='true'),
    endpoints?: [ string ](name='endpoints'),
    esInstanceId?: string(name='esInstanceId', description='The ID of the associated Elasticsearch cluster.', example='es-cn-n6w1o1x0w001c****'),
    pipelineIds?: [ string ](name='pipelineIds'),
    userName?: string(name='userName', description='The username that is used to access the associated Elasticsearch cluster.', example='elastic'),
  }(name='Result', description='The returned result.'),
}

model DescribeXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeXpackMonitorConfigResponseBody(name='body'),
}

async function describeXpackMonitorConfig(request: DescribeXpackMonitorConfigRequest): DescribeXpackMonitorConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeXpackMonitorConfig', 'GET', '/openapi/logstashes/{InstanceId}/xpack-monitor-config', 'json', false, 'json', request);
}

model DiagnoseInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='ClientToken', description='The timestamp when the diagnostic report was generated.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  diagnoseItems?: [ string ](name='diagnoseItems', position='Body'),
  indices?: [ string ](name='indices', position='Body'),
  type?: string(name='type', example='ALL', position='Body'),
  lang?: string(name='lang', description='The returned data.', example='en', position='Query'),
}

model DiagnoseInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the report.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    createTime?: long(name='createTime', description='The ID of the diagnostic instance.', example='1535745731000'),
    instanceId?: string(name='instanceId', example='es-cn-n6w1o1x0w001c****'),
    reportId?: string(name='reportId', example='trigger__2020-08-17T17:09:02'),
    state?: string(name='state', example='RUNNING'),
  }(name='Result', description='The diagnosis status. Valid values: Supported: SUCCESS, FAILED, and RUNNING.'),
}

model DiagnoseInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DiagnoseInstanceResponseBody(name='body'),
}

async function diagnoseInstance(request: DiagnoseInstanceRequest): DiagnoseInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DiagnoseInstance', 'POST', '/openapi/diagnosis/instances/{InstanceId}/actions/diagnose', 'json', false, 'json', request);
}

model EstimatedLogstashRestartTimeRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='ls-cn-oew1qbgl****', position='Path'),
  body?: string(name='body', position='Body'),
  force?: boolean(name='force', description='Specifies whether to forcibly restart the cluster. Default value: false.', example='false', position='Query'),
}

model EstimatedLogstashRestartTimeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    unit?: string(name='unit', description='The unit.', example='second'),
    value?: long(name='value', description='The estimated restart time.', example='600'),
  }(name='Result', description='The returned result.'),
}

model EstimatedLogstashRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EstimatedLogstashRestartTimeResponseBody(name='body'),
}

async function estimatedLogstashRestartTime(request: EstimatedLogstashRestartTimeRequest): EstimatedLogstashRestartTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'EstimatedLogstashRestartTime', 'POST', '/openapi/logstashes/{InstanceId}/estimated-time/restart-time', 'json', false, 'json', request);
}

model EstimatedRestartTimeRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  force?: boolean(name='force', description='Specifies whether to forcibly restart the cluster. Default value: false.', example='false', position='Query'),
}

model EstimatedRestartTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    unit?: string(name='unit', description='The unit.', example='second'),
    value?: long(name='value', description='The estimated restart time.', example='50'),
  }(name='Result', description='The returned result.'),
}

model EstimatedRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EstimatedRestartTimeResponseBody(name='body'),
}

async function estimatedRestartTime(request: EstimatedRestartTimeRequest): EstimatedRestartTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'EstimatedRestartTime', 'POST', '/openapi/instances/{InstanceId}/estimated-time/restart-time', 'json', false, 'json', request);
}

model GetClusterDataInformationRequest {
  body?: string(name='body', position='Body'),
}

model GetClusterDataInformationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    connectable?: boolean(name='connectable', description='Whether it is connectable.', example='true'),
    metaInfo?: {
      fields?: [ string ](name='fields', description='The fields in the Mapping for the index.'),
      indices?: [ string ](name='indices', description='The index list of the cluster.'),
      mapping?: string(name='mapping', description='The Mapping configuration of the cluster.', example='{\\"_doc\\":{\\"properties\\":{\\"user\\":{\\"properties\\":{\\"last\\":{\\"type\\":\\"text\\",...}}}}}}'),
      settings?: string(name='settings', description='The Settings of the cluster.', example='{\\n  \\"index\\": {\\n    \\"replication\\": {\\n}.....}}'),
      typeName?: [ string ](name='typeName', description='Specifies the type of the index.'),
    }(name='metaInfo', description='The metadata of the cluster.'),
  }(name='Result', description='The return results.'),
}

model GetClusterDataInformationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterDataInformationResponseBody(name='body'),
}

async function getClusterDataInformation(request: GetClusterDataInformationRequest): GetClusterDataInformationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetClusterDataInformation', 'POST', '/openapi/cluster/data-information', 'json', false, 'json', request);
}

model GetElastictaskRequest {
  instanceId: string(name='InstanceId', example='es-cn-6ja1ro4jt000c****', position='Path'),
}

model GetElastictaskResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression', example='0 0 0 ? * MON'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression', example='4 4 4 ? * WED'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model GetElastictaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetElastictaskResponseBody(name='body'),
}

async function getElastictask(request: GetElastictaskRequest): GetElastictaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetElastictask', 'GET', '/openapi/instances/{InstanceId}/elastic-task', 'json', false, 'json', request);
}

model GetEmonGrafanaAlertsRequest {
  projectId: string(name='ProjectId', example='es-133071096032****', position='Path'),
  body?: string(name='body', position='Body'),
}

model GetEmonGrafanaAlertsResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='08FA74C7-5654-4309-9729-D555AF587B7F'),
  success?: boolean(name='Success', example='true'),
}

model GetEmonGrafanaAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmonGrafanaAlertsResponseBody(name='body'),
}

async function getEmonGrafanaAlerts(request: GetEmonGrafanaAlertsRequest): GetEmonGrafanaAlertsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetEmonGrafanaAlerts', 'GET', '/openapi/emon/projects/{ProjectId}/grafana/proxy/api/alerts', 'json', false, 'json', request);
}

model GetEmonGrafanaDashboardsRequest {
  projectId: string(name='ProjectId', example='es-133071096032****', position='Path'),
  body?: string(name='body', position='Body'),
}

model GetEmonGrafanaDashboardsResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='1E9D9827-2092-4385-9DA1-FC5A8D1DB3F5'),
  success?: boolean(name='Success', example='true'),
}

model GetEmonGrafanaDashboardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmonGrafanaDashboardsResponseBody(name='body'),
}

async function getEmonGrafanaDashboards(request: GetEmonGrafanaDashboardsRequest): GetEmonGrafanaDashboardsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetEmonGrafanaDashboards', 'GET', '/openapi/emon/projects/{ProjectId}/grafana/proxy/api/search', 'json', false, 'json', request);
}

model GetEmonMonitorDataRequest {
  projectId: string(name='ProjectId', example='es-185320276651****', position='Path'),
  body?: string(name='body', position='Body'),
}

model GetEmonMonitorDataResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='2D184B55-FA51-43F7-A1EF-E68A0545****'),
  result?: [ 
    {
      dps?: map[string]any(name='dps', example='{ "1586249280": 465.1980465119913, "1586249300": 213.45243650423305 }'),
      integrity?: float(name='integrity', example='1.0'),
      messageWatermark?: long(name='messageWatermark', example='1522127381471'),
      metric?: string(name='metric', example='elasticbuild.elasticsearch.source.total_doc_count'),
      summary?: float(name='summary', example='10'),
      tags?: map[string]any(name='tags', example='{"taskName":"et-xxx","userId":"123456"}'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model GetEmonMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmonMonitorDataResponseBody(name='body'),
}

async function getEmonMonitorData(request: GetEmonMonitorDataRequest): GetEmonMonitorDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetEmonMonitorData', 'POST', '/openapi/emon/projects/{ProjectId}/metrics/query', 'json', false, 'json', request);
}

model GetOpenStoreUsageRequest {
  instanceId: string(name='InstanceId', description='es-cn-zvp2cqw1f0020\\*\\*\\*\\*', example='es-cn-zvp2cqw1f0020****', position='Path'),
}

model GetOpenStoreUsageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1DE2491-804F-4C86-BAB4-548DD70B****'),
  result?: {
    currentUsage?: long(name='currentUsage', description='The current OpenStore storage capacity (estimated value based on actual indexes). Unit: Byte.', example='204800'),
    lastDayUsage?: long(name='lastDayUsage', description='The storage capacity of OpenStore yesterday. Unit: bytes.', example='184320'),
  }(name='Result', description='The current request result.'),
}

model GetOpenStoreUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOpenStoreUsageResponseBody(name='body'),
}

async function getOpenStoreUsage(request: GetOpenStoreUsageRequest): GetOpenStoreUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetOpenStoreUsage', 'GET', '/openapi/instances/{InstanceId}/openstore/usage', 'json', false, 'json', request);
}

model GetRegionConfigurationRequest {
  zoneId?: string(name='zoneId', example='cn-hangzhou-f', position='Query'),
}

model GetRegionConfigurationResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6F******'),
  result?: {
    clientNodeAmountRange?: {
      maxAmount?: int32(name='maxAmount', example='25'),
      minAmount?: int32(name='minAmount', example='2'),
    }(name='clientNodeAmountRange'),
    clientNodeDiskList?: [ 
      {
        diskType?: string(name='diskType', example='cloud_efficiency'),
        maxSize?: int32(name='maxSize', example='20'),
        minSize?: int32(name='minSize', example='20'),
        scaleLimit?: int32(name='scaleLimit', example='18'),
      }
    ](name='clientNodeDiskList'),
    clientNodeSpec?: [ string ](name='clientNodeSpec'),
    createUrl?: string(name='createUrl', example='https://common-buy.aliyun.com/?commodityCode=elasticsearch&orderType=BUY#/buy'),
    dataDiskList?: [ 
      {
        diskType?: string(name='diskType', example='cloud_ssd'),
        maxSize?: int32(name='maxSize', example='5120'),
        minSize?: int32(name='minSize', example='20'),
        scaleLimit?: int32(name='scaleLimit', example='2048'),
        valueLimitSet?: [ string ](name='valueLimitSet'),
      }
    ](name='dataDiskList'),
    elasticNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount', example='25'),
        minAmount?: int32(name='minAmount', example='2'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption', example='true'),
          diskType?: string(name='diskType', example='cloud_ssd'),
          maxSize?: int32(name='maxSize', example='5120'),
          minSize?: int32(name='minSize', example='500'),
          scaleLimit?: int32(name='scaleLimit', example='2048'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='elasticNodeProperties'),
    env?: string(name='env', example='production'),
    esVersions?: [ string ](name='esVersions'),
    esVersionsLatestList?: [ 
      {
        key?: string(name='key', example='5.5_with_X-Pack'),
        value?: string(name='value', example='5.5.3_with_X-Pack'),
      }
    ](name='esVersionsLatestList'),
    instanceSupportNodes?: [ string ](name='instanceSupportNodes'),
    jvmConfine?: {
      memory?: int32(name='memory', example='32'),
      supportEsVersions?: [ string ](name='supportEsVersions'),
      supportGcs?: [ string ](name='supportGcs'),
    }(name='jvmConfine'),
    kibanaNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount', example='20'),
        minAmount?: int32(name='minAmount', example='1'),
      }(name='amountRange'),
      spec?: [ string ](name='spec'),
    }(name='kibanaNodeProperties'),
    masterDiskList?: [ 
      {
        diskType?: string(name='diskType', example='cloud_ssd'),
        maxSize?: int32(name='maxSize', example='20'),
        minSize?: int32(name='minSize', example='20'),
        scaleLimit?: int32(name='scaleLimit', example='20'),
      }
    ](name='masterDiskList'),
    masterSpec?: [ string ](name='masterSpec'),
    node?: {
      maxAmount?: int32(name='maxAmount', example='50'),
      minAmount?: int32(name='minAmount', example='2'),
    }(name='node'),
    nodeSpecList?: [ 
      {
        cpuCount?: int32(name='cpuCount', example='16'),
        disk?: int32(name='disk', example='44000'),
        diskType?: string(name='diskType', example='local_efficiency'),
        enable?: boolean(name='enable', example='true'),
        memorySize?: int32(name='memorySize', example='64'),
        spec?: string(name='spec', example='elasticsearch.sn2ne.large'),
        specGroupType?: string(name='specGroupType', example='local_efficiency'),
      }
    ](name='nodeSpecList'),
    regionId?: string(name='regionId', example='cn-hangzhou'),
    supportVersions?: [ 
      {
        instanceCategory?: string(name='instanceCategory', example='x-pack'),
        supportVersionList?: [ 
          {
            key?: string(name='key', example='5.5'),
            value?: string(name='value', example='5.5.3'),
          }
        ](name='supportVersionList'),
      }
    ](name='supportVersions'),
    warmNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount', example='50'),
        minAmount?: int32(name='minAmount', example='2'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption', example='true'),
          diskType?: string(name='diskType', example='cloud_efficiency'),
          maxSize?: int32(name='maxSize', example='5120'),
          minSize?: int32(name='minSize', example='500'),
          scaleLimit?: int32(name='scaleLimit', example='2048'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='warmNodeProperties'),
    zones?: [ string ](name='zones'),
  }(name='Result'),
}

model GetRegionConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegionConfigurationResponseBody(name='body'),
}

async function getRegionConfiguration(request: GetRegionConfigurationRequest): GetRegionConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetRegionConfiguration', 'GET', '/openapi/region', 'json', false, 'json', request);
}

model GetSuggestShrinkableNodesRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-nif1q9o8r0008****', position='Path'),
  count: int32(name='count', description='The number of nodes that you want to remove.', example='1', position='Query'),
  ignoreStatus?: boolean(name='ignoreStatus', description='Specifies whether to ignore the instance status. Default value: false.', example='false', position='Query'),
  nodeType: string(name='nodeType', description='The type of removing nodes. WORKER indicates hot node and WORKER_WARM indicates warm node.', example='WORKER', position='Query'),
}

model GetSuggestShrinkableNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      host?: string(name='host', description='The IP address of the node.', example='192.168.**.**'),
      port?: int32(name='port', description='The access port number of the node.', example='9200'),
    }
  ](name='Result', description='The return results.'),
}

model GetSuggestShrinkableNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSuggestShrinkableNodesResponseBody(name='body'),
}

async function getSuggestShrinkableNodes(request: GetSuggestShrinkableNodesRequest): GetSuggestShrinkableNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetSuggestShrinkableNodes', 'GET', '/openapi/instances/{InstanceId}/suggest-shrinkable-nodes', 'json', false, 'json', request);
}

model GetTransferableNodesRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-nif1q9o8r0008****', position='Path'),
  count: int32(name='count', description='The number of nodes to be migrated.', example='1', position='Query'),
  nodeType: string(name='nodeType', description='The type of nodes.**WORKER**represents a hot node,**WORKER_WARM** represents a warm node.', example='WORKER', position='Query'),
}

model GetTransferableNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      host?: string(name='host', description='The IP address of the node.', example='192.168.**.**'),
      port?: int32(name='port', description='The access port of the node.', example='9200'),
    }
  ](name='Result', description='The return results.'),
}

model GetTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTransferableNodesResponseBody(name='body'),
}

async function getTransferableNodes(request: GetTransferableNodesRequest): GetTransferableNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTransferableNodes', 'GET', '/openapi/instances/{InstanceId}/transferable-nodes', 'json', false, 'json', request);
}

model InitializeOperationRoleRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model InitializeOperationRoleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29101430-4797-4D1D-96C3-9FCBCCA8F845'),
  result?: boolean(name='Result', description='Indicates whether the service-linked role is created. Valid values:

*   true: The service-linked role is created.
*   false: The service-linked role fails to be created.', example='true'),
}

model InitializeOperationRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InitializeOperationRoleResponseBody(name='body'),
}

/**
  * > Before you perform auto scaling for a cluster at the China site (aliyun.com) or you use shippers to collect logs, you must create a service-linked role.
  *
 */
async function initializeOperationRole(request: InitializeOperationRoleRequest): InitializeOperationRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InitializeOperationRole', 'POST', '/openapi/user/slr', 'json', false, 'json', request);
}

model InstallAckOperatorRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.', example='c79acd3fbf462423fb6450e513bb6****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model InstallAckOperatorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EFA88951-7A6F-4A8E-AB8F-2BB7132BA751'),
  result?: boolean(name='Result', description='Indicates whether ES-operator is installed. Valid values:

*   true
*   false', example='true'),
}

model InstallAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallAckOperatorResponseBody(name='body'),
}

/**
  * > Before you install a shipper for an ACK cluster, you must call this operation to install ES-operator for the cluster.
  *
 */
async function installAckOperator(request: InstallAckOperatorRequest): InstallAckOperatorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallAckOperator', 'POST', '/openapi/ack-clusters/{ClusterId}/operator', 'json', false, 'json', request);
}

model InstallKibanaSystemPluginRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w00******', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model InstallKibanaSystemPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: [ string ](name='Result', description='The list of plug-ins to be installed.'),
}

model InstallKibanaSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallKibanaSystemPluginResponseBody(name='body'),
}

async function installKibanaSystemPlugin(request: InstallKibanaSystemPluginRequest): InstallKibanaSystemPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallKibanaSystemPlugin', 'POST', '/openapi/instances/{InstanceId}/kibana-plugins/system/actions/install', 'json', false, 'json', request);
}

model InstallLogstashSystemPluginRequest {
  instanceId: string(name='InstanceId', example='ls-cn-oew1qbgl****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model InstallLogstashSystemPluginResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC4****'),
  result?: [ string ](name='Result'),
}

model InstallLogstashSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallLogstashSystemPluginResponseBody(name='body'),
}

/**
  * ls-cn-oew1qbgl\\*\\*\\*\\*
  *
 */
async function installLogstashSystemPlugin(request: InstallLogstashSystemPluginRequest): InstallLogstashSystemPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallLogstashSystemPlugin', 'POST', '/openapi/logstashes/{InstanceId}/plugins/system/actions/install', 'json', false, 'json', request);
}

model InstallSystemPluginRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model InstallSystemPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ string ](name='Result', description='The list of plug-ins to be installed.'),
}

model InstallSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallSystemPluginResponseBody(name='body'),
}

async function installSystemPlugin(request: InstallSystemPluginRequest): InstallSystemPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallSystemPlugin', 'POST', '/openapi/instances/{InstanceId}/plugins/system/actions/install', 'json', false, 'json', request);
}

model InstallUserPluginsRequest {
  instanceId: string(name='InstanceId', description='The cluster ID.', example='es-cn-i7m27ausp001l****', position='Path'),
  body?: string(name='body', position='Body'),
}

model InstallUserPluginsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6F*****'),
  result?: [ string ](name='Result'),
}

model InstallUserPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallUserPluginsResponseBody(name='body'),
}

async function installUserPlugins(request: InstallUserPluginsRequest): InstallUserPluginsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InstallUserPlugins', 'POST', '/openapi/instances/{InstanceId}/plugins/user/actions/install', 'json', false, 'json', request);
}

model InterruptElasticsearchTaskRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model InterruptElasticsearchTaskResponseBody = {
  code?: string(name='Code', description='The error code. Only displayed if an exception is returned.', example='InstanceStatusNotSupportCurrentAction'),
  message?: string(name='Message', description='The error message. Only displayed if an exception is returned.', example='The cluster is running tasks or in an error status. Try again later.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: boolean(name='Result', description='Return results:

*   true: interrupted change successfully
*   false: interrupted change failed', example='true'),
}

model InterruptElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InterruptElasticsearchTaskResponseBody(name='body'),
}

async function interruptElasticsearchTask(request: InterruptElasticsearchTaskRequest): InterruptElasticsearchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InterruptElasticsearchTask', 'POST', '/openapi/instances/{InstanceId}/actions/interrupt', 'json', false, 'json', request);
}

model InterruptLogstashTaskRequest {
  instanceId: string(name='InstanceId', description='The cluster ID.', example='ls-cn-4591f1y6****', position='Path'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model InterruptLogstashTaskResponseBody = {
  code?: string(name='Code', description='The error code returned. If the API operation is successfully called, this parameter is not returned.', example='.'),
  message?: string(name='Message', description='The error message returned. If the API operation is successfully called, this parameter is not returned.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0FA05123-745C-42FD-A69B-AFF48EF9****'),
  result?: boolean(name='Result', description='Indicates whether the task is suspended. Valid values:

*   true
*   false', example='true'),
}

model InterruptLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InterruptLogstashTaskResponseBody(name='body'),
}

async function interruptLogstashTask(request: InterruptLogstashTaskRequest): InterruptLogstashTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InterruptLogstashTask', 'POST', '/openapi/logstashes/{InstanceId}/actions/interrupt', 'json', false, 'json', request);
}

model ListAckClustersRequest {
  page?: int32(name='page', description='The number of the page to return.', example='3', minimum=1, maximum=50, position='Query'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='20', minimum=1, maximum=50, position='Query'),
  vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) to which the ACK clusters belong.', example='vpc-bp12nu14urf0upaf4****', position='Query'),
}

model ListAckClustersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F93EAA49-284F-4FCE-9E67-FA23FB4BB512'),
  result?: [ 
    {
      clusterId?: string(name='clusterId', description='The ID of cluster.', example='c5ea2c2d9a3cf499481292f60425d****'),
      clusterType?: string(name='clusterType', description='The type of the cluster. The value is fixed as ManagedKubernetes.', example='ManagedKubernetes'),
      name?: string(name='name', description='The name of the cluster.', example='test'),
      vpcId?: string(name='vpcId', description='The ID of the VPC to which the cluster belongs.', example='vpc-bp12nu14urf0upaf4****'),
    }
  ](name='Result', description='The returned result.'),
}

model ListAckClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAckClustersResponseBody(name='body'),
}

async function listAckClusters(request: ListAckClustersRequest): ListAckClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAckClusters', 'GET', '/openapi/ack-clusters', 'json', false, 'json', request);
}

model ListAckNamespacesRequest {
  clusterId: string(name='ClusterId', description='The ID of the cluster.', example='c79acd3fbf462423fb6450e513bb6****', position='Path'),
  page?: int32(name='page', description='The number of the page to return.', example='1', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='10', minimum=1, maximum=500, position='Query'),
}

model ListAckNamespacesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='95789100-A329-473B-9D14-9E0B7DB4BD5A'),
  result?: [ 
    {
      namespace?: string(name='namespace', description='The namespace of the cluster.', example='logging'),
      status?: string(name='status', description='The status of the namespace.', example='Active'),
    }
  ](name='Result', description='The returned result.'),
}

model ListAckNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAckNamespacesResponseBody(name='body'),
}

/**
  * > When you install a shipper on an ACK cluster, you must specify a namespace. You can call this operation to query all namespaces in the ACK cluster, and select a namespace based on your business requirements.
  *
 */
async function listAckNamespaces(request: ListAckNamespacesRequest): ListAckNamespacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAckNamespaces', 'GET', '/openapi/ack-clusters/{ClusterId}/namespaces', 'json', false, 'json', request);
}

model ListActionRecordsRequest {
  instanceId?: string(name='InstanceId', position='Path'),
  actionNames?: string(name='actionNames', position='Query'),
  endTime?: long(name='endTime', position='Query'),
  filter?: string(name='filter', position='Query'),
  page?: int32(name='page', position='Query'),
  requestId?: string(name='requestId', position='Query'),
  size?: int32(name='size', position='Query'),
  startTime?: long(name='startTime', position='Query'),
  userId?: string(name='userId', position='Query'),
}

model ListActionRecordsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      actionName?: string(name='ActionName'),
      actionParams?: map[string]any(name='ActionParams'),
      actionResultAccessList?: [ string ](name='ActionResultAccessList'),
      endTime?: long(name='EndTime'),
      instanceId?: string(name='InstanceId'),
      metaNow?: string(name='MetaNow'),
      metaOld?: string(name='MetaOld'),
      ownerId?: string(name='OwnerId'),
      process?: string(name='Process'),
      recordDiff?: map[string]any(name='RecordDiff'),
      recordIds?: [ string ](name='RecordIds'),
      requestId?: string(name='RequestId'),
      startTime?: long(name='StartTime'),
      stateType?: string(name='StateType'),
      statusInfo?: [ 
        {
          completeNodeCount?: int32(name='completeNodeCount'),
          endTime?: long(name='endTime'),
          exception?: string(name='exception'),
          latencyMills?: long(name='latencyMills'),
          nodeCount?: int32(name='nodeCount'),
          process?: string(name='process'),
          startTime?: long(name='startTime'),
          stateType?: string(name='stateType'),
          subState?: string(name='subState'),
          subStatusInfo?: [ 
            {
              completeNodeCount?: int32(name='completeNodeCount'),
              endTime?: long(name='endTime'),
              exception?: string(name='exception'),
              latencyMills?: long(name='latencyMills'),
              nodeCount?: int32(name='nodeCount'),
              process?: string(name='process'),
              startTime?: long(name='startTime'),
              stateType?: string(name='stateType'),
              subState?: string(name='subState'),
            }
          ](name='subStatusInfo'),
        }
      ](name='StatusInfo'),
      userId?: string(name='UserId'),
      userInfo?: string(name='UserInfo'),
      userType?: string(name='UserType'),
    }
  ](name='Result'),
}

model ListActionRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListActionRecordsResponseBody(name='body'),
}

async function listActionRecords(request: ListActionRecordsRequest): ListActionRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListActionRecords', 'GET', '/openapi/instances/{InstanceId}/action-records', 'json', false, 'json', request);
}

model ListAllNodeRequest {
  instanceId: string(name='InstanceId', description='The return results.', example='es-cn-tl32cpgwa002l****', position='Path'),
  extended?: boolean(name='extended', description='The Java Virtual Machine (JVM) heap memory usage of the node.', example='false', position='Query'),
}

model ListAllNodeResponseBody = {
  requestId?: string(name='RequestId', description='The zone ID of the node.', example='0D71B597-F3FF-5B56-88D7-74F9D3F7****'),
  result?: [ 
    {
      cpuPercent?: string(name='cpuPercent', description='The disk usage.', example='4.2%'),
      diskUsedPercent?: string(name='diskUsedPercent', description='The health status of the node. Valid values: GREEN, YELLOW, RED, and GRAY.', example='1.0%'),
      health?: string(name='health', example='GREEN'),
      heapPercent?: string(name='heapPercent', description='The IP address of the node.', example='21.6%'),
      host?: string(name='host', description='The port that is used to connect to the node.', example='10.15.XX.XX'),
      loadOneM?: string(name='loadOneM', example='0.12'),
      nodeType?: string(name='nodeType', description='The 1-minute load of the node.', example='WORKER'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', description='The type of the nodes. Valid values:

*   MASTER: dedicated master node
*   WORKER: hot node
*   WORKER_WARM: warm node
*   COORDINATING: client node
*   KIBANA: Kibana node', example='cn-hangzhou-i'),
    }
  ](name='Result', description='The CPU utilization.

>  If the **extended** request parameter is set to **true** and the monitoring information of the nodes in the cluster is being synchronized, the value of the cpuPercent parameter is null. In this case, you need to send a request again after 10 seconds to obtain the value of the cpuPercent parameter.'),
}

model ListAllNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAllNodeResponseBody(name='body'),
}

async function listAllNode(request: ListAllNodeRequest): ListAllNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAllNode', 'GET', '/openapi/instances/{InstanceId}/nodes', 'json', false, 'json', request);
}

model ListAlternativeSnapshotReposRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-0pp1jxvcl000z****', position='Path'),
  alreadySetItems?: boolean(name='alreadySetItems', description='Indicates whether to return the OSS reference repository added. The return value. Valid values: true and false.', example='true', position='Query'),
}

model ListAlternativeSnapshotReposResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      instanceId?: string(name='instanceId', description='The ID of the instance.', example='es-cn-6ja1ro4jt000c****'),
      repoPath?: string(name='repoPath', description='The address of the repository.', example='RepoPath'),
    }
  ](name='Result', description='The return results.'),
}

model ListAlternativeSnapshotReposResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlternativeSnapshotReposResponseBody(name='body'),
}

async function listAlternativeSnapshotRepos(request: ListAlternativeSnapshotReposRequest): ListAlternativeSnapshotReposResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAlternativeSnapshotRepos', 'GET', '/openapi/instances/{InstanceId}/alternative-snapshot-repos', 'json', false, 'json', request);
}

model ListApmRequest {
  description?: string(name='description', example='APMtest', position='Query'),
  instanceId?: string(name='instanceId', example='apm-cn-i7m2fuae****', position='Query'),
  output?: string(name='output', example='es-cn-i7m2fsfhc001x****', position='Query'),
  page?: long(name='page', example='1', position='Query'),
  size?: long(name='size', example='10', position='Query'),
}

model ListApmResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='1'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='080D3399-76CF-519D-A540-2C44BC056EB7'),
  result?: [ 
    {
      createdAt?: string(name='createdAt', example='2021-11-16T07:15:51.967Z'),
      deployedReplica?: long(name='deployedReplica', example='1'),
      description?: string(name='description', example='APMtest'),
      instanceId?: string(name='instanceId', example='apm-cn-i7m2fuae****'),
      nodeAmount?: long(name='nodeAmount', example='1'),
      outputES?: string(name='outputES', example='es-cn-i7m2fsfhc001x****'),
      outputESUserName?: string(name='outputESUserName', example='elastic'),
      ownerId?: string(name='ownerId', example='133071096032****'),
      paymentType?: string(name='paymentType', example='postpaid'),
      region?: string(name='region', example='cn-hangzhou'),
      replica?: long(name='replica', example='1'),
      resourceSpec?: string(name='resourceSpec', example='C1M2'),
      status?: string(name='status', example='active'),
      version?: string(name='version', example='7.10.2'),
      vpcId?: string(name='vpcId', example='vpc-bp1530vdhqkamm9s0****'),
      vsArea?: string(name='vsArea', example='cn-hangzhou-i'),
      vswitchId?: string(name='vswitchId', example='vsw-bp1j1mql6r9g5vfb4****'),
    }
  ](name='Result'),
}

model ListApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApmResponseBody(name='body'),
}

async function listApm(request: ListApmRequest): ListApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListApm', 'GET', '/openapi/apm', 'json', false, 'json', request);
}

model ListAvailableEsInstanceIdsRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-oew1qbgl****', position='Path'),
}

model ListAvailableEsInstanceIdsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      description?: string(name='description', description='The name of the Elasticsearch cluster.', example='instanceName'),
      endpoint?: string(name='endpoint', description='The address that is used to access the Elasticsearch cluster over the Internet.', example='http://es-cn-n6w1o1x0w001c****.elasticsearch.aliyuncs.com:9200'),
      esInstanceId?: string(name='esInstanceId', description='The ID of the Elasticsearch cluster.', example='es-cn-n6w1o1x0w001c****'),
      kibanaEndpoint?: string(name='kibanaEndpoint', description='The address that is used to access the Kibana console of the Elasticsearch cluster over the Internet.', example='https://es-cn-n6w1o1x0w001c****.kibana.elasticsearch.aliyuncs.com:5601'),
    }
  ](name='Result', description='The returned result.'),
}

model ListAvailableEsInstanceIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAvailableEsInstanceIdsResponseBody(name='body'),
}

async function listAvailableEsInstanceIds(request: ListAvailableEsInstanceIdsRequest): ListAvailableEsInstanceIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAvailableEsInstanceIds', 'GET', '/openapi/logstashes/{InstanceId}/available-elasticsearch-for-centralized-management', 'json', false, 'json', request);
}

model ListCollectorsRequest {
  instanceId?: string(name='instanceId', description='The ID of the resource with which the shipper is associated.', example='es-cn-nif1q8auz0003****', position='Query'),
  name?: string(name='name', description='The name of the shipper.', example='collectorName1', position='Query'),
  page?: int32(name='page', description='The number of the page to return. Valid values: 1 to 200. Default value: 1.', example='1', minimum=1, maximum=200, position='Query'),
  resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-77uqof2s7rg5c****', position='Query'),
  size?: int32(name='size', description='The number of entries to return on each page. Valid values: 1 to 500. Default value: 20.', example='10', minimum=1, maximum=500, position='Query'),
  sourceType?: string(name='sourceType', description='The type of the machine on which the shipper is deployed. If you leave this parameter empty, shippers deployed on all types of machines are returned. Valid values:

*   ECS
*   ACK', example='ECS', position='Query'),
}

model ListCollectorsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='5'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      collectorPaths?: [ string ](name='collectorPaths'),
      configs?: [ 
        {
          content?: string(name='content', description='The content of the file.', example='- key: log\\n title: Log file content\\n description: >\\n Contains log file lines.\\n ....'),
          fileName?: string(name='fileName', description='The name of the file.', example='fields.yml'),
        }
      ](name='configs', description='The information about the configuration file of the shipper.'),
      dryRun?: boolean(name='dryRun', description='Indicates whether a dry run is performed. Valid values:

*   true
*   false', example='false'),
      extendConfigs?: [ 
        {
          configType?: string(name='configType', description='The configuration type. Valid values:

*   collectorTargetInstance
*   collectorDeployMachine
*   collectorElasticsearchForKibana', example='collectorDeployMachine'),
          enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether monitoring is enabled. This parameter is returned if the value of **configType** is **collectorTargetInstance** and the value of **instanceType** is **elasticsearch**. Valid values:

*   true
*   false', example='true'),
          groupId?: string(name='groupId', description='The ID of the machine group. This parameter is returned if the value of **configType** is **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
          host?: string(name='host', description='The internal endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
          hosts?: [ string ](name='hosts'),
          instanceId?: string(name='instanceId', description='The ID of the resource with which the shipper is associated. If the value of **configType** is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='es-cn-nif1z89fz003i****'),
          instanceType?: string(name='instanceType', description='The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='elasticsearch'),
          kibanaHost?: string(name='kibanaHost', description='The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601'),
          machines?: [ 
            {
              agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values:

*   heartOk
*   heartLost
*   uninstalled
*   failed', example='heartOk'),
              instanceId?: string(name='instanceId', description='The IDs of the ECS instances.', example='i-bp13y63575oypr9d****'),
            }
          ](name='machines', description='The information about the ECS instances on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ECSInstanceId**.'),
          protocol?: string(name='protocol', description='The transmission protocol, which must be the same as the access protocol of the resource specified in the output configuration part of the shipper. Valid values: HTTP and HTTPS. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='HTTP'),
          successPodsCount?: string(name='successPodsCount', description='The number of pods from which data is successfully collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='8'),
          totalPodsCount?: string(name='totalPodsCount', description='The total number of pods from which data is collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='10'),
          type?: string(name='type', description='The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
          userName?: string(name='userName', description='The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
        }
      ](name='extendConfigs', description='The extended configurations of the shipper.'),
      gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-08-18T02:06:12.000+0000'),
      gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-08-18T09:40:43.000+0000'),
      name?: string(name='name', description='The name of the shipper.', example='FileBeat001'),
      ownerId?: string(name='ownerId', description='The account ID.', example='168520994880****'),
      resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-0v3xj86085dvq****'),
      resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.', example='fileBeat'),
      resVersion?: string(name='resVersion', description='The version of the shipper.', example='6.8.5_with_community'),
      status?: string(name='status', description='The status of the shipper. Valid values:

*   activating
*   active', example='active'),
      vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) where the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
    }
  ](name='Result', description='The returned result.'),
}

model ListCollectorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCollectorsResponseBody(name='body'),
}

async function listCollectors(request: ListCollectorsRequest): ListCollectorsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListCollectors', 'GET', '/openapi/collectors', 'json', false, 'json', request);
}

model ListComponentIndicesRequest {
  instanceId: string(name='InstanceId', example='es-cn-tl329rbpc0001****', position='Path'),
  name?: string(name='name', example='template', position='Query'),
  page?: int32(name='page', example='5', minimum=1, maximum=1000, position='Query'),
  size?: int32(name='size', example='10', minimum=1, maximum=1000, position='Query'),
}

model ListComponentIndicesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='10'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      composed?: [ string ](name='composed'),
      content?: {
        meta?: map[string]any(name='_meta', example='{ "description": "set number of shards to one" }'),
        template?: {
          settings?: {
            index?: {
              codec?: string(name='codec', example='best_compression'),
              lifecycle?: {
                name?: string(name='name', example='synthetics'),
              }(name='lifecycle'),
            }(name='index'),
          }(name='settings'),
        }(name='template'),
        version?: long(name='version', example='0'),
      }(name='content'),
      name?: string(name='name', example='synthetics-settings'),
    }
  ](name='Result'),
}

model ListComponentIndicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListComponentIndicesResponseBody(name='body'),
}

async function listComponentIndices(request: ListComponentIndicesRequest): ListComponentIndicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListComponentIndices', 'GET', '/openapi/instances/{InstanceId}/component-index', 'json', false, 'json', request);
}

model ListConnectedClustersRequest {
  instanceId: string(name='InstanceId', description='The ID of the current instance.', example='es-cn-0pp1jxvcl000z****', position='Path'),
}

model ListConnectedClustersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    result?: [ 
    {
      instances?: string(name='instances', description='The ID of the remote instance that is connected to the network of the current instance.', example='es-cn-09k1rocex0006****'),
      networkType?: string(name='networkType', description='The network type of the instance.', example='vpc'),
    }
  ](name='Result')
  }(name='Result', description='The return results.'),
}

model ListConnectedClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConnectedClustersResponseBody(name='body'),
}

async function listConnectedClusters(request: ListConnectedClustersRequest): ListConnectedClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListConnectedClusters', 'GET', '/openapi/instances/{InstanceId}/connected-clusters', 'json', false, 'json', request);
}

model ListDataStreamsRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif24adwc0082****', position='Path'),
  isManaged?: boolean(name='isManaged', example='false', position='Query'),
  name?: string(name='name', example='Log1', position='Query'),
}

model ListDataStreamsResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count', example='100'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize', example='143993923932990'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      health?: string(name='health', example='Green'),
      ilmPolicyName?: string(name='ilmPolicyName', example='rollver1'),
      indexTemplateName?: string(name='indexTemplateName', example='template1'),
      indices?: [ 
        {
          createTime?: string(name='createTime', example='2018-07-13T03:58:07.253Z'),
          health?: string(name='health', example='Green'),
          isManaged?: boolean(name='isManaged', example='false'),
          managedStatus?: string(name='managedStatus', example='following'),
          name?: string(name='name', example='Log1'),
          size?: long(name='size', example='15393899'),
        }
      ](name='indices'),
      managedStorageSize?: long(name='managedStorageSize', example='1788239393298'),
      name?: string(name='name', example='my-index-0001'),
      totalStorageSize?: long(name='totalStorageSize', example='1788239393298'),
    }
  ](name='Result'),
}

model ListDataStreamsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataStreamsResponseBody(name='body'),
}

async function listDataStreams(request: ListDataStreamsRequest): ListDataStreamsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDataStreams', 'GET', '/openapi/instances/{InstanceId}/data-streams', 'json', false, 'json', request);
}

model ListDataTasksRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-oew1oxiro000f****', position='Path'),
}

model ListDataTasksResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The time when the site monitoring task was created.', example='2020-07-30 06:32:18'),
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType', description='The type of the target cluster. Default value: elasticsearch.', example='1'),
        endpoint?: string(name='endpoint', description='The public network access address of the target cluster.', example='http://192.168.xx.xx:4101'),
        index?: string(name='index', description='The target index.', example='product_info'),
        type?: string(name='type', description='The type of the destination index.', example='_doc'),
        vpcId?: string(name='vpcId', description='The ID of the VPC to which the cluster belongs.', example='vpc-2ze55voww95g82gak****'),
        vpcInstanceId?: string(name='vpcInstanceId', description='The instance ID or Server Load Balancer (SLB) ID of the current cluster.', example='es-cn-09k1rnu3g0002****-worker'),
        vpcInstancePort?: string(name='vpcInstancePort', description='The access port number of the cluster.', example='9200'),
      }(name='sinkCluster', description='The information of the target cluster.'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType', description='The type of the source cluster. Default value: elasticsearch.', example='1'),
        index?: string(name='index', description='The index whose data you want to migrate.', example='product_info'),
        mapping?: string(name='mapping', description='The Mapping configuration of the cluster.', example='{\\"_doc\\":{\\"properties\\":{\\"user\\":{\\"properties\\":{\\"last\\":{\\"type\\":\\"text\\",...}}}}}}'),
        routing?: string(name='routing', description='The routing field to index the table. It is set to the primary key by default.', example='_id'),
        settings?: string(name='settings', description='The Settings of the cluster.', example='{\\n  \\"index\\": {\\n    \\"replication\\": {\\n}.....}}'),
        type?: string(name='type', description='The type of the destination index.', example='_doc'),
      }(name='sourceCluster', description='The information about the source cluster.'),
      status?: string(name='status', description='The status of the task.', example='SUCCESS'),
      taskId?: string(name='taskId', description='The ID of the task.', example='et_cn_mfv1233r47272****'),
    }
  ](name='Result', description='The return results.'),
}

model ListDataTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataTasksResponseBody(name='body'),
}

async function listDataTasks(request: ListDataTasksRequest): ListDataTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDataTasks', 'GET', '/openapi/instances/{InstanceId}/data-task', 'json', false, 'json', request);
}

model ListDefaultCollectorConfigurationsRequest {
  resType: string(name='resType', description='The shipper type. Valid values:

*   fileBeat
*   metricBeat
*   heartBeat
*   auditBeat', example='fileBeat', position='Query'),
  resVersion: string(name='resVersion', description='The shipper version. The shipper version varies based on the type of the machine on which the shipper is deployed. Valid values:

*   ECS: 6.8.5\\_with_community
*   ACK: 6.8.13\\_with_community', example='6.8.5_with_community', position='Query'),
  sourceType?: string(name='sourceType', description='The type of the machine on which the shipper is deployed. If you do not configure this parameter, the default configuration files of shippers deployed on all types of machines are returned. Valid values:

*   ECS: ECS instance
*   ACK: ACK cluster', example='ECS', position='Query'),
}

model ListDefaultCollectorConfigurationsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8BAE3C32-8E4A-47D6-B4B0-95B5DE643BF5'),
  result?: [ 
    {
      content?: string(name='content', description='The content of the configuration file.', example='- key: log\\n  title: Log file content\\n  description: >\\n    Contains log file lines.\\n  fields:\\n ......'),
      fileName?: string(name='fileName', description='The name of the configuration file.', example='fields.yml'),
    }
  ](name='Result', description='The returned result.'),
}

model ListDefaultCollectorConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDefaultCollectorConfigurationsResponseBody(name='body'),
}

async function listDefaultCollectorConfigurations(request: ListDefaultCollectorConfigurationsRequest): ListDefaultCollectorConfigurationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDefaultCollectorConfigurations', 'GET', '/openapi/beats/default-configurations', 'json', false, 'json', request);
}

model ListDeprecatedTemplatesRequest {
  instanceId: string(name='InstanceId', example='es-cn-t57p81n7ai89v****', position='Path'),
  name?: string(name='name', example='component-openstore-index-template', position='Query'),
  page?: int32(name='page', example='5', position='Query'),
  size?: int32(name='size', example='10', minimum=1, maximum=100, position='Query'),
}

model ListDeprecatedTemplatesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='5'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream', example='false'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate', example='openstore-index-template'),
      order?: long(name='order', example='100'),
      template?: {
        aliases?: string(name='aliases', example='"{}"'),
        mappings?: string(name='mappings', example='"{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}"'),
        settings?: string(name='settings', example='"{\\"index.number_of_shards\\":\\"1\\"}"'),
      }(name='template'),
      version?: string(name='version', example='70000'),
    }
  ](name='Result'),
}

model ListDeprecatedTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeprecatedTemplatesResponseBody(name='body'),
}

async function listDeprecatedTemplates(request: ListDeprecatedTemplatesRequest): ListDeprecatedTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDeprecatedTemplates', 'GET', '/openapi/instances/{InstanceId}/deprecated-templates', 'json', false, 'json', request);
}

model ListDiagnoseIndicesRequest {
  instanceId: string(name='InstanceId', description='The cluster ID.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  lang?: string(name='lang', description='The language. Multiple languages are supported.', example='en', position='Query'),
}

model ListDiagnoseIndicesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F05ED12E-140A-4ACB-B059-3A508A69F2E1'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseIndicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnoseIndicesResponseBody(name='body'),
}

async function listDiagnoseIndices(request: ListDiagnoseIndicesRequest): ListDiagnoseIndicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDiagnoseIndices', 'GET', '/openapi/diagnosis/instances/{InstanceId}/indices', 'json', false, 'json', request);
}

model ListDiagnoseReportRequest {
  instanceId: string(name='InstanceId', description='spanish', example='es-cn-n6w1qu7ei000p****', position='Path'),
  detail?: boolean(name='detail', description='SYSTEM', example='true', position='Query'),
  endTime: long(name='endTime', description='1', example='1595174399999', minimum=1000000000000, maximum=2000000000000, position='Query'),
  lang?: string(name='lang', description='1594569600000', example='spanish', position='Query'),
  page?: int32(name='page', description='20', example='1', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', description='true', example='20', minimum=1, maximum=500, position='Query'),
  startTime: long(name='startTime', description='1595174399999', example='1594569600000', minimum=1000000000000, maximum=2000000000000, position='Query'),
  trigger?: string(name='trigger', description='The ID of the request.', example='SYSTEM', position='Query'),
}

model ListDiagnoseReportResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The returned results.', example='15'),
  }(name='Headers', description='The total number of entries returned.'),
  requestId?: string(name='RequestId', description='The header of the response.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      createTime?: long(name='createTime', description='The ID of the report.', example='1535745731000'),
      diagnoseItems?: [ 
        {
          detail?: {
            desc?: string(name='desc', description='The diagnosis.', example='Check whether the number of replica shards is optimal and easy to maintain'),
            name?: string(name='name', description='The description of the diagnostic item.', example='Number of Replica Shards'),
            result?: string(name='result', description='The suggestion for the diagnosis.', example='You may need to adjust the numbers of replica shards of some indices as follows:  [geoname08 : 0 -&gt; 1][geoname09 : 0 -&gt; 1][geonametest01 : 0 -&gt; 1]'),
            suggest?: string(name='suggest', example='You can call the following function in the Elasticsearch API....'),
            type?: string(name='type', description='The full name of the diagnostic item.', example='ES_API'),
          }(name='detail', description='The type of the diagnostic result. Valid values:

*   TEXT: text description
*   CONSOLE_API: console-triggered
*   ES_API: API triggered'),
          health?: string(name='health', description='The details of the diagnostic item.', example='YELLOW'),
          item?: string(name='item', description='The health of the diagnostic item. Supported: GREEN, YELLOW, RED, and UNKNOWN.', example='IndexAliasUseDiagnostic'),
        }
      ](name='diagnoseItems', description='The name of the item.'),
      health?: string(name='health', description='Reports the list of diagnostic item information.', example='YELLOW'),
      instanceId?: string(name='instanceId', description='The overall health of the cluster in the report. Supported: GREEN, YELLOW, RED, and UNKNOWN.', example='es-cn-abc'),
      reportId?: string(name='reportId', description='The diagnosis status. Valid values: Supported: SUCCESS, FAILED, and RUNNING.', example='trigger__2020-08-17T17:09:02f'),
      state?: string(name='state', description='The ID of the instance for diagnosis.', example='SUCCESS'),
      trigger?: string(name='trigger', description='The timestamp when the report was created.', example='USER'),
    }
  ](name='Result', description='The trigger mode of health diagnostics. Valid values:

*   SYSTEM: The system is automatically triggered.
*   INNER: internal trigger
*   USER: manually triggered by the user'),
}

model ListDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnoseReportResponseBody(name='body'),
}

async function listDiagnoseReport(request: ListDiagnoseReportRequest): ListDiagnoseReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDiagnoseReport', 'GET', '/openapi/diagnosis/instances/{InstanceId}/reports', 'json', false, 'json', request);
}

model ListDiagnoseReportIdsRequest {
  instanceId: string(name='InstanceId', description='The cluster ID.', example='es-cn-n6w1qu7ei000p****', position='Path'),
  endTime: long(name='endTime', description='The end of the time range to query. The value must be a UNIX timestamp.', example='1595174399999', minimum=1000000000000, maximum=2000000000000, position='Query'),
  lang?: string(name='lang', description='The language of the reports.', example='spanish', position='Query'),
  page?: int32(name='page', description='The number of the page to return. Valid values: 1 to 200. Default value: 1.', example='1', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', description='The number of entries to return on each page. Valid values: 1 to 500. Default value: 10.', example='15', minimum=1, maximum=500, position='Query'),
  startTime: long(name='startTime', description='The beginning of the time range to query. The value must be a UNIX timestamp.', example='1595088000000', minimum=1000000000000, maximum=2000000000000, position='Query'),
  trigger?: string(name='trigger', description='The method that is used to trigger health diagnostics. Valid values: SYSTEM, INNER, and USER.', example='SYSTEM', position='Query'),
}

model ListDiagnoseReportIdsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='1'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseReportIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnoseReportIdsResponseBody(name='body'),
}

async function listDiagnoseReportIds(request: ListDiagnoseReportIdsRequest): ListDiagnoseReportIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDiagnoseReportIds', 'GET', '/openapi/diagnosis/instances/{InstanceId}/report-ids', 'json', false, 'json', request);
}

model ListDiagnosisItemsRequest {
  lang?: string(name='lang', example='en', position='Query'),
}

model ListDiagnosisItemsResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ 
    {
      description?: string(name='description', example='BulkReject'),
      key?: string(name='key', example='ClusterBulkRejectDiagnostic'),
      name?: string(name='name', example='BulkReject'),
    }
  ](name='Result'),
}

model ListDiagnosisItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnosisItemsResponseBody(name='body'),
}

async function listDiagnosisItems(request: ListDiagnosisItemsRequest): ListDiagnosisItemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDiagnosisItems', 'GET', '/openapi/diagnosis/items', 'json', false, 'json', request);
}

model ListDictInformationRequest {
  instanceId: string(name='InstanceId', example='es-cn-n6w1o1x0w001c****', position='Path'),
  analyzerType?: string(name='analyzerType', example='ALIWS', position='Query'),
  bucketName: string(name='bucketName', example='search-cloud-test-cn-****', position='Query'),
  key: string(name='key', example='oss/dic_0.dic', position='Query'),
}

model ListDictInformationResponseBody = {
  requestId?: string(name='RequestId', example='7C4334EA-D22B-48BD-AE28-08EE68******'),
  result?: {
    fileSize?: long(name='fileSize', example='2202301'),
    ossObject?: {
      bucketName?: string(name='bucketName', example='es-osstest*'),
      etag?: string(name='etag', example='2ABAB5E70BBF631145647F6BE533****'),
      key?: string(name='key', example='oss/dict_0*.dic'),
    }(name='ossObject'),
    type?: string(name='type', example='STOP'),
  }(name='Result'),
}

model ListDictInformationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDictInformationResponseBody(name='body'),
}

async function listDictInformation(request: ListDictInformationRequest): ListDictInformationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDictInformation', 'GET', '/openapi/instances/{InstanceId}/dict/_info', 'json', false, 'json', request);
}

model ListDictsRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='es-cn-0ju29ifnc0005****', position='Path'),
  analyzerType: string(name='analyzerType', description='The type of the dictionary. Valid values:

*   IK: IK dictionary after a standard update
*   IK_HOT: IK dictionary after a rolling update
*   SYNONYMS: synonym dictionary
*   ALIWS: Alibaba Cloud dictionary', example='IK', position='Query'),
  name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic', position='Query'),
}

model ListDictsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='1'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2937F832-F39E-41EF-89BA-B528342A2A3A'),
  result?: [ 
    {
      downloadUrl?: string(name='downloadUrl', description='The link that is used to download the dictionary over the Internet. The link is valid for 90s.', example='http://test_bucket.oss-cn-hangzhou.aliyuncs.com/AliyunEs/test.dic?Expires=162573****&OSSAccessKeyId=LTAI*****V9&Signature=PNPO********BBGsJDO4V3VfU4sE%3D'),
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: byte.', example='2782602'),
      name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
      sourceType?: string(name='sourceType', description='The source type.', example='ORIGIN'),
      type?: string(name='type', description='The type of the IK dictionary. Valid values:

*   MAIN: main dictionary
*   STOP: stopword list', example='MAIN'),
    }
  ](name='Result', description='The returned result.'),
}

model ListDictsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDictsResponseBody(name='body'),
}

async function listDicts(request: ListDictsRequest): ListDictsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDicts', 'GET', '/openapi/instances/{InstanceId}/dicts', 'json', false, 'json', request);
}

model ListEcsInstancesRequest {
  ecsInstanceIds?: string(name='ecsInstanceIds', description='test', example='["i-bp13y63575oypr9d****","i-bp1gyhphjaj73jsr****"]', position='Query'),
  ecsInstanceName?: string(name='ecsInstanceName', description='\\[{ "tagKey":"a","tagValue":"b"}]', example='test', position='Query'),
  page?: int32(name='page', description='10', example='1', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', description='\\["i-bp13y63575oypr9d\\*\\*\\*\\*","i-bp1gyhphjaj73jsr\\*\\*\\*\\*"]', example='10', minimum=1, maximum=500, position='Query'),
  tags?: string(name='tags', description='vpc-bp16k1dvzxtmagcva\\*\\*\\*\\*', example='[{ "tagKey":"a","tagValue":"b"}]', position='Query'),
  vpcId?: string(name='vpcId', description='The ID of the request.', example='vpc-bp16k1dvzxtmagcva****', position='Query'),
}

model ListEcsInstancesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The returned data.', example='11'),
  }(name='Headers', description='The number of returned records.'),
  requestId?: string(name='RequestId', description='The header of the response.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      cloudAssistantStatus?: string(name='cloudAssistantStatus', description='The name of the ECS instance.', example='true'),
      collectors?: [ 
        {
          collectorPaths?: [ string ](name='collectorPaths'),
          configs?: [ 
            {
              content?: string(name='content', description='The name of the file.', example='- key: log\\n title: Log file content\\n description: >\\n Contains log file lines.\\n ....'),
              fileName?: string(name='fileName', description='The information about the extended parameter.', example='fields.yml'),
            }
          ](name='configs', description='The content of the file.'),
          dryRun?: boolean(name='dryRun', description='The ID of the Alibaba Cloud account.', example='false'),
          extendConfigs?: [ 
            {
              configType?: string(name='configType', description='The instance type specified by Collector Output. Supports Elasticsearch and Logstash. Displayed when the **configType** is **collectorTargetInstance**.', example='collectorDeployMachine'),
              enableMonitoring?: boolean(name='enableMonitoring', description='The ID of the host group. Displayed when the **configType** is **collectorDeployMachine**.', example='true'),
              groupId?: string(name='groupId', description='The configuration type. Valid values:

*   collectorTargetInstance: Collector Output
*   collectorDeployMachine: Collector Deployment Machine
*   Collector Elasticsearch ForKibana: Elasticsearch instance information that supports the Kibana dashboard', example='default_ct-cn-5i2l75bz4776****'),
              hosts?: [ string ](name='hosts', description='The path in which Filebeat is collected.'),
              instanceId?: string(name='instanceId', description='The list of ECS instances on which the collector is deployed. Displayed when the **configType** is **collectorDeployMachines** and the **type** is **ECSInstanceId**.', example='es-cn-nif1z89fz003i****'),
              instanceType?: string(name='instanceType', description='The transmission protocol, which must be the same as the access protocol of the instance specified by Output. HTTP and HTTPS. Displayed when the **configType** is **collectorTargetInstance**.', example='elasticsearch'),
              machines?: [ 
                {
                  agentStatus?: string(name='agentStatus', description='The IDs of ECS instances.', example='heartOk'),
                  instanceId?: string(name='instanceId', description='The list of access addresses of the specified instance for the output of the collector. Displayed when the **configType** is **collectorTargetInstance**.', example='i-bp13y63575oypr9d****'),
                }
              ](name='machines', description='The status of each crawl on the ECS instance. Valid values:

*   heartOk: The heartbeat is normal.
*   heartLost: The heartbeat is abnormal.
*   uninstalled
*   failed: The installation failed.'),
              protocol?: string(name='protocol', description='The username that is used to access the instance. The default value is elastic. Displayed when the **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='HTTP'),
              type?: string(name='type', description='The ID of the instance that is associated with the crawker. If the **configType** parameter is set to **collectorTargetInstance**, the value of this parameter is the ID of the output collector. If the **configType** parameter is set to **collectorDeployMachines** and the **type** parameter is set to **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='ECSInstanceId'),
              userName?: string(name='userName', description='The type of the machine on which the Collector is deployed. This parameter is displayed when the **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId:ECS
*   ACKCluster: Container Kubernetes', example='elastic'),
            }
          ](name='extendConfigs', description='Whether Monitoring is enabled. This field is displayed when the **configType** is **collectorTargetInstance** and the **instanceType** is **Elasticsearch**. Valid values:

*   true
*   false'),
          gmtCreatedTime?: string(name='gmtCreatedTime', description='The status of the collector. Valid values:

*   activating: The project is taking effect.
*   active: The instance has taken effect.', example='2020-06-20T07:26:47.000+0000'),
          gmtUpdateTime?: string(name='gmtUpdateTime', description='Specifies whether to verify and create a crawer. Valid values:

*   true: only verifies and does not create a
*   false: verifies and creates a', example='2020-06-20T07:26:47.000+0000'),
          name?: string(name='name', description='The configuration file information of the collector.', example='ct-testAbc'),
          ownerId?: string(name='ownerId', description='The ID of the Virtual Private Cloud to which the collector belongs.', example='16852***488*****'),
          resId?: string(name='resId', description='The time when the collector was updated.', example='ct-cn-0v3xj86085dvq****'),
          resType?: string(name='resType', description='The version of the collector. If the machine type of the collector is ECS, only **6.8.5\\_with_community** is supported.', example='fileBeat'),
          resVersion?: string(name='resVersion', description='The time when the crawl collector was created.', example='6.8.5_with_community'),
          status?: string(name='status', description='The name of the collector.', example='activing'),
          vpcId?: string(name='vpcId', description='The type of the collector. FileBeat, metricBeat, heartBeat, and auditBeat are supported.', example='vpc-bp16k1dvzxtm******'),
        }
      ](name='collectors', description='The ID of the collector instance.'),
      ecsInstanceId?: string(name='ecsInstanceId', description='The tags of the ECS instance.', example='i-bp14ncqge8wy3l3d****'),
      ecsInstanceName?: string(name='ecsInstanceName', description='The ID of the ECS instance.', example='ecsTestName'),
      ipAddress?: [ 
        {
          host?: string(name='host', description='The information about the collectors on the ECS instance.', example='172.16.xx.xx'),
          ipType?: string(name='ipType', description='The IP address of the endpoint.', example='private'),
        }
      ](name='ipAddress', description='The type of the IP address that is used by the instance. Valid values:

*   public: public endpoint
*   private: private network address'),
      osType?: string(name='osType', description='The status of the ECS instance. Valid values:

*   running: The master instance is running
*   starting
*   stopping: The task is being stopped.
*   stopped: The node is stopped.', example='linux'),
      status?: string(name='status', description='The IP address of the ECS instance.', example='running'),
      tags?: string(name='tags', description='The operating system type of the ECS instance. Valid values:

*   windows:Windows operating system
*   linux:Linux operating system', example='[ { "tagKey": "a", "tagValue": "b" } ]'),
    }
  ](name='Result', description='Cloud Assistant the installation status, support:

*   true: The Prometheus agent was installed.
*   false: The Prometheus agent was not installed.'),
}

model ListEcsInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEcsInstancesResponseBody(name='body'),
}

/**
  * **Important** To call this operation, you must create the Aliyun Elasticsearch AccessingOOSRole and the system service role AliyunOOSAccessingECS 4ESRole to Elasticsearch the service account to obtain the ECS access permissions of the primary account. For more information, see [Collect ECS service logs](~~146446~~).
  *
 */
async function listEcsInstances(request: ListEcsInstancesRequest): ListEcsInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListEcsInstances', 'GET', '/openapi/ecs', 'json', false, 'json', request);
}

model ListExtendfilesRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-oew1qbgl****', position='Path'),
}

model ListExtendfilesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      filePath?: string(name='filePath', description='The path of the driver file.', example='/ssd/1/share/ls-cn-oew1qbgl****/logstash/current/config/custom/mysql-connector-java-5.1.35.jar'),
      fileSize?: long(name='fileSize', description='The size of the driver file.', example='968668'),
      name?: string(name='name', description='The name of the driver file.', example='mysql-connector-java-5.1.35.jar'),
      sourceType?: string(name='sourceType', description='The source type.', example='ORIGIN'),
    }
  ](name='Result', description='The returned result.'),
}

model ListExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExtendfilesResponseBody(name='body'),
}

async function listExtendfiles(request: ListExtendfilesRequest): ListExtendfilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListExtendfiles', 'GET', '/openapi/logstashes/{InstanceId}/extendfiles', 'json', false, 'json', request);
}

model ListILMPoliciesRequest {
  instanceId: string(name='InstanceId', example='es-cn-m7r23wodb006n****', position='Path'),
  policyName?: string(name='policyName', example='policy-1', position='Query'),
}

model ListILMPoliciesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      name?: string(name='name', example='policy-1'),
      phases?: map[string]any(name='phases', example='{"hot":{"minAge":"0ms","actions":{"rollover":{"maxSize":"50gb","maxAge":"30d"},"setPriority":{"priority":100}}},"delete":{"minAge":"3d","actions":{"delete":{}}}}'),
    }
  ](name='Result'),
}

model ListILMPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListILMPoliciesResponseBody(name='body'),
}

async function listILMPolicies(request: ListILMPoliciesRequest): ListILMPoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListILMPolicies', 'GET', '/openapi/instances/{InstanceId}/ilm-policies', 'json', false, 'json', request);
}

model ListIndexTemplatesRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif24adwc0082****', position='Path'),
  indexTemplate?: string(name='indexTemplate', example='my-template', position='Query'),
  page?: int32(name='page', example='5', position='Query'),
  size?: int32(name='size', example='50', position='Query'),
}

model ListIndexTemplatesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream', example='true'),
      ilmPolicy?: string(name='ilmPolicy', example='my_ilm_policy'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate', example='my-template'),
      priority?: int32(name='priority', example='100'),
      template?: {
        aliases?: string(name='aliases', example='{\\"index.number_of_shards\\":\\"1\\"}'),
        mappings?: string(name='mappings', example='{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}'),
        settings?: string(name='settings', example='{\\"mydata\\":{}}'),
      }(name='template'),
    }
  ](name='Result'),
}

model ListIndexTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIndexTemplatesResponseBody(name='body'),
}

async function listIndexTemplates(request: ListIndexTemplatesRequest): ListIndexTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListIndexTemplates', 'GET', '/openapi/instances/{InstanceId}/index-templates', 'json', false, 'json', request);
}

model ListInstanceRequest {
  description?: string(name='description', description='cn-hangzhou-i', example='aliyunes_test1', position='Query'),
  esVersion?: string(name='esVersion', description='advanced', example='6.7_with_X-Pack', position='Query'),
  instanceCategory?: string(name='instanceCategory', description='The number of data nodes.', example='advanced', position='Query'),
  instanceId?: string(name='instanceId', description='postpaid', example='es-cn-v641a0ta3000g****', position='Query'),
  page?: int32(name='page', description='\\[{"tagKey":"key1","tagValue":"value1"}]', example='1', position='Query'),
  paymentType?: string(name='paymentType', description='Specifies whether to include dedicated master nodes. Valid values:

*   true: The files contain data that is dumped to the IA storage medium.
*   false: The files do not contain data that is dumped to the IA storage medium.', example='postpaid', position='Query'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the request.', example='rg-aekzvowej3i****', position='Query'),
  size?: int32(name='size', description='vpc-bp16k1dvzxtmagcva\\*\\*\\*\\*', example='10', position='Query'),
  tags?: string(name='tags', description='The header of the response.', example='[{"tagKey":"key1","tagValue":"value1"}]', position='Query'),
  vpcId?: string(name='vpcId', description='The number of entries returned per page.', example='vpc-bp16k1dvzxtmagcva****', position='Query'),
  zoneId?: string(name='zoneId', description='The returned data.', example='cn-hangzhou-i', position='Query'),
}

model ListInstanceResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='Specifies whether to include dedicated master nodes (obsolete). Valid values:

*   true: The files contain data that is dumped to the IA storage medium.
*   false: The files do not contain data that is dumped to the IA storage medium.', example='10'),
  }(name='Headers', description='The status of the instance. Valid values:

*   active: normal
*   activating: taking effect
*   inactive: frozen
*   invalid: invalid'),
  requestId?: string(name='RequestId', description='The time when the node is created.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      advancedDedicateMaster?: boolean(name='advancedDedicateMaster', description='The billing method of the instance. Valid values:

*   **prepaid**: subscription
*   **postpaid**: pay-as-you-go', example='false'),
      clientNodeConfiguration?: {
        amount?: int32(name='amount', description='The size of the node storage space. Unit: GB.', example='3'),
        disk?: int32(name='disk', description='Specifies whether to enable disk encryption for the node. Valid values:

*   true: enables instant image cache.
*   false: disables reuse of image cache layers.', example='20'),
        diskType?: string(name='diskType', description='The storage type of the node. Valid values:

*   cloud_ssd: SSD.
*   cloud_essd: ESSD.
*   cloud_efficiency: ultra disk', example='cloud_efficiency'),
        spec?: string(name='spec', description='The number of nodes.', example='elasticsearch.sn2ne.large'),
      }(name='clientNodeConfiguration', description='The instance type of the node. For more information, see [Specifications](~~271718~~).'),
      createdAt?: string(name='createdAt', description='The status of the pay-as-you-go service that is overlaid on a subscription instance. Valid values:

*   **active**: normal
*   **closed**: Close
*   **indebt**: Overdue payments are frozen', example='2018-07-13T03:58:07.253Z'),
      dedicateMaster?: boolean(name='dedicateMaster', description='The edition of the dedicated KMS instance.', example='false'),
      description?: string(name='description', description='The key of the tag.', example='es-cn-abc'),
      elasticDataNodeConfiguration?: {
        amount?: int32(name='amount', description='The number of nodes.', example='3'),
        disk?: int32(name='disk', description='The size of the node storage space. Unit: GB.', example='20'),
        diskEncryption?: boolean(name='diskEncryption', description='The storage type of the node.', example='true'),
        diskType?: string(name='diskType', description='The configuration of dedicated master nodes.', example='cloud_ssd'),
        spec?: string(name='spec', description='The instance type of the node. For more information, see [Specifications](~~271718~~).', example='elasticsearch.sn2ne.large'),
      }(name='elasticDataNodeConfiguration', description='The configuration of Kibana nodes.'),
      esVersion?: string(name='esVersion', description='The value of the tag.', example='6.7_with_X-Pack'),
      extendConfigs?: [  map[string]any ](name='extendConfigs', description='The configurations of elastic data nodes.'),
      instanceId?: string(name='instanceId', description='The instance type of the node. For more information, see [Specifications](~~271718~~).', example='es-cn-v641a0ta3000g****'),
      isNewDeployment?: string(name='isNewDeployment', description='The configuration of cluster extension parameters.', example='true'),
      kibanaConfiguration?: {
        amount?: int32(name='amount', description='The size of the node storage space. Unit: GB.', example='1'),
        disk?: int32(name='disk', description='The storage type of the node. Only cloud_ssd(SSD cloud disk) is supported.', example='20'),
        diskType?: string(name='diskType', description='The network configurations.', example='cloud_ssd'),
        spec?: string(name='spec', description='The number of nodes.', example='elasticsearch.n4.small'),
      }(name='kibanaConfiguration', description='The instance type of the node. For more information, see [Specifications](~~271718~~).'),
      kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
      kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
      masterConfiguration?: {
        amount?: int32(name='amount', description='The network type. Only Virtual Private Cloud (VPC) is supported.', example='3'),
        disk?: int32(name='disk', description='The vSwitch ID of the cluster.', example='20'),
        diskType?: string(name='diskType', description='The configuration of data nodes.', example='cloud_ssd'),
        spec?: string(name='spec', description='The zone where the cluster resides.', example='elasticsearch.sn2ne.large'),
      }(name='masterConfiguration', description='The VPC ID of the cluster.'),
      networkConfig?: {
        type?: string(name='type', description='The storage type of the node. Valid values:

*   cloud_ssd: standard SSD
*   cloud_efficiency: ultra disk', example='vpc'),
        vpcId?: string(name='vpcId', description='The storage space of the node. Unit: GB.', example='vpc-abc'),
        vsArea?: string(name='vsArea', description='Specifies whether to use disk encryption. Valid values:

*   true
*   false', example='cn-hangzhou-e'),
        vswitchId?: string(name='vswitchId', description='The performance level of the ESSD. This parameter is required when the diskType parameter is set to cloud_essd. Valid values: PL1, PL2, and PL3.', example='vsw-def'),
        whiteIpGroupList?: [ 
          {
            groupName?: string(name='groupName', example='default'),
            ips?: [ string ](name='ips'),
            whiteIpType?: string(name='whiteIpType', example='PUBLIC_KIBANA'),
          }
        ](name='whiteIpGroupList'),
      }(name='networkConfig', description='The instance type of the node. For more information, see [Specifications](~~271718~~).'),
      nodeAmount?: int32(name='nodeAmount', description='The ID of the resource group.', example='2'),
      nodeSpec?: {
        disk?: int32(name='disk', example='50'),
        diskEncryption?: boolean(name='diskEncryption', example='false'),
        diskType?: string(name='diskType', example='cloud_ssd'),
        performanceLevel?: string(name='performanceLevel', example='PL1'),
        spec?: string(name='spec', example='elasticsearch.n4.small'),
      }(name='nodeSpec', description='The VPC ID of the cluster.'),
      paymentType?: string(name='paymentType', description='The time when the instance was last updated.', example='postpaid'),
      postpaidServiceStatus?: string(name='postpaidServiceStatus', description='The tags of the instance. Each tag is a key-value pair.', example='active'),
      privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
      publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
      resourceGroupId?: string(name='resourceGroupId', description='The ID of the instance.', example='rg-aekzvowej3i****'),
      serviceVpc?: boolean(name='serviceVpc', description='Specifies whether to deploy the new architecture.', example='true'),
      status?: string(name='status', description='The name of the instance.', example='active'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey', description='The size of the node storage space. Unit: GB.', example='env'),
          tagValue?: string(name='tagValue', description='The storage type of the node. Only ultra disks (cloud_efficiency) are supported.', example='dev'),
        }
      ](name='tags', description='The number of nodes.'),
      updatedAt?: string(name='updatedAt', description='Coordination node configuration.', example='2018-07-18T10:10:04.484Z'),
      vpcInstanceId?: string(name='vpcInstanceId', example='vpc-bp1uag5jj38c****'),
    }
  ](name='Result', description='Indicates whether it is a service VPC.'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstance', 'GET', '/openapi/instances', 'json', false, 'json', request);
}

model ListInstanceHistoryEventsRequest {
  body?: [ 
    {
      desc?: boolean(name='desc', example='true'),
      sortField?: string(name='sortField', example='event_time'),
    }
  ](name='body', position='Body'),
  eventCreateEndTime?: string(name='eventCreateEndTime', example='1645596516000', position='Query'),
  eventCreateStartTime?: string(name='eventCreateStartTime', example='1645596516000', position='Query'),
  eventCycleStatus?: [ string ](name='eventCycleStatus', shrink='simple', position='Query'),
  eventExecuteEndTime?: string(name='eventExecuteEndTime', example='1645596516000', position='Query'),
  eventExecuteStartTime?: string(name='eventExecuteStartTime', example='1645596516000', position='Query'),
  eventFinashEndTime?: string(name='eventFinashEndTime', example='1645596516000', position='Query'),
  eventFinashStartTime?: string(name='eventFinashStartTime', example='1645596516000', position='Query'),
  eventLevel?: [ string ](name='eventLevel', shrink='simple', position='Query'),
  eventType?: [ string ](name='eventType', shrink='simple', position='Query'),
  instanceId?: string(name='instanceId', example='es-cn-2r42l7a740005****', position='Query'),
  nodeIP?: string(name='nodeIP', example='10.1.xx.xx', position='Query'),
  page?: int32(name='page', example='0', position='Query'),
  size?: int32(name='size', example='10', position='Query'),
}

model ListInstanceHistoryEventsResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='15'),
    xTotalFailed?: long(name='X-Total-Failed', example='2'),
    xTotalSuccess?: long(name='X-Total-Success', example='13'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='D1A6830A-F59B-4E05-BFAC-9496C21DBBA7'),
  result?: [ 
    {
      ecsId?: string(name='ecsId', example='i-2ze8s9cjdf2cv969****'),
      eventCreateTime?: string(name='eventCreateTime', example='2017-12-07T00:00:00Z'),
      eventCycleStatus?: string(name='eventCycleStatus', example='EXECUTED'),
      eventExecuteTime?: string(name='eventExecuteTime', example='2017-12-07T00:00:00Z'),
      eventFinashTime?: string(name='eventFinashTime', example='2017-12-07T00:00:00Z'),
      eventLevel?: string(name='eventLevel', example='INFO'),
      eventType?: string(name='eventType', example='ECS:AUTO_RESTART'),
      instanceId?: string(name='instanceId', example='es-cn-2r42l7a740005****'),
      nodeIP?: string(name='nodeIP', example='10.1.xx.xx'),
      regionId?: string(name='regionId', example='cn-hangzhou'),
    }
  ](name='Result'),
}

model ListInstanceHistoryEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceHistoryEventsResponseBody(name='body'),
}

async function listInstanceHistoryEvents(request: ListInstanceHistoryEventsRequest): ListInstanceHistoryEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstanceHistoryEvents', 'POST', '/openapi/events', 'json', false, 'json', request);
}

model ListInstanceIndicesRequest {
  instanceId: string(name='InstanceId', description='false', example='es-cn-tl329rbpc0001****', position='Path'),
  all?: boolean(name='all', description='false', example='false', position='Query'),
  isManaged?: boolean(name='isManaged', description='15', example='false', position='Query'),
  isOpenstore?: boolean(name='isOpenstore', description='The ID of the request.', example='false', position='Query'),
  name?: string(name='name', description='1', example='log-0001', position='Query'),
  page?: int32(name='page', description='The header of the response.', example='1', position='Query'),
  size?: int32(name='size', description='The total size of the index in Cloud Hosting. Unit: bytes.', example='15', position='Query'),
}

model ListInstanceIndicesResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count', description='The details of the index list.', example='15'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize', description='The total number of indexes in the OpenStore cold phase.', example='18093942932'),
    xOSSCount?: int32(name='X-OSS-Count', description='The time when the index list was queried.', example='5'),
    xOSSStorageSize?: long(name='X-OSS-StorageSize', description='This parameter is deprecated.', example='9093942932'),
  }(name='Headers', description='The total size of the OpenStore cold stage index for this instance. Unit: bytes.'),
  requestId?: string(name='RequestId', description='The total number of indexes in Cloud Hosting.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The name of the Elasticsearch index.', example='2021-01-11T05:49:41.114Z'),
      health?: string(name='health', example='green'),
      ilmExplain?: string(name='ilmExplain', example='{    "indices": {         ".ds-console-2021.08.18-000002": {             "index": ".ds-console-2021.08.18-000002",             "managed": true,             "policy": "console",             "lifecycle_date_millis": 1629277498775,             "age": "2.64h",             "phase": "hot",             "phase_time_millis": 1629277450334,             "action": "complete",             "action_time_millis": 1629278605586,             "step": "complete",             "step_time_millis": 1629278605586,             "phase_execution": {                 "policy": "console",                 "phase_definition": {                     "min_age": "0s",                     "actions": {                         "rollover": {                             "max_size": "1gb",                             "max_age": "1d",                             "max_docs": 10000                         },                         "set_priority": {                             "priority": 1000                         }                     }                 },                 "version": 1,                 "modified_date_in_millis": 1629277370953             }         }     } }'),
      isManaged?: string(name='isManaged', description='The managed status of the index. The following three statuses are supported:

*   following: Hosting.
*   closing: The instance is being unhosted.
*   closed: unmanaged.', example='false'),
      managedStatus?: string(name='managedStatus', description='The current storage lifecycle. Value meaning:

*   warm: warm.
*   cold: the cold phase.
*   hot: hot phase.
*   delete: deletes a stage.

>  If this parameter is empty, the current index is not managed by the lifecycle.', example='closing'),
      name?: string(name='name', description='The full lifecycle status of the current index.', example='.kibana_task_manager_1'),
      phase?: string(name='phase', example='warm'),
      size?: long(name='size', description='The running status of the index. The following three statuses are supported:

*   green: healthy.
*   yellow: alerts.
*   red: an exception.', example='49298589'),
    }
  ](name='Result', description='The total storage space occupied by the current index. Unit: bytes.'),
}

model ListInstanceIndicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceIndicesResponseBody(name='body'),
}

async function listInstanceIndices(request: ListInstanceIndicesRequest): ListInstanceIndicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstanceIndices', 'GET', '/openapi/instances/{InstanceId}/indices', 'json', false, 'json', request);
}

model ListKibanaPluginsRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='es-cn-oew1q8bev0002****', position='Path'),
  page?: string(name='page', description='The number of the page to return. Default value: 1.', example='1', position='Query'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='10', position='Query'),
}

model ListKibanaPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='3'),
  }(name='Headers', description='The request header.'),
  requestId?: string(name='RequestId', description='The request ID.', example='11234B4A-34CE-473B-8E61-AD95702E****'),
  result?: [ 
    {
      description?: string(name='description', description='The description of the plug-in.', example='Customize DSL statements to query data.'),
      name?: string(name='name', description='The name of the plug-in.', example='bsearch_querybuilder'),
      source?: string(name='source', description='The source of the plug-in.', example='SYSTEM'),
      specificationUrl?: string(name='specificationUrl', description='The URL of the introduction to the plug-in. The value null is supported.', example='https://xxxx'),
      state?: string(name='state', description='The installation status of the plug-in.', example='INSTALLED'),
    }
  ](name='Result', description='The information about the plug-ins.'),
}

model ListKibanaPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListKibanaPluginsResponseBody(name='body'),
}

async function listKibanaPlugins(request: ListKibanaPluginsRequest): ListKibanaPluginsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListKibanaPlugins', 'GET', '/openapi/instances/{InstanceId}/kibana-plugins', 'json', false, 'json', request);
}

model ListLogstashRequest {
  description?: string(name='description', description='rg-acfm2h5vbzd\\*\\*\\*\\*', example='ls-cn-abc', position='Query'),
  instanceId?: string(name='instanceId', description='\\[{"tagKey":"key1","tagValue":"value1"}]', example='ls-cn-n6w1o5jq****', position='Query'),
  page?: int32(name='page', description='ls-cn-n6w1o5jq\\*\\*\\*\\*', example='1', position='Query'),
  resourceGroupId?: string(name='resourceGroupId', description='Details of the request header.', example='rg-acfm2h5vbzd****', position='Query'),
  size?: int32(name='size', description='5.5.3\\_with_X-Pack', example='10', position='Query'),
  tags?: string(name='tags', description='The number of entries returned per page.', example='[{"tagKey":"key1","tagValue":"value1"}]', position='Query'),
  version?: string(name='version', description='The ID of the request.', example='5.5.3_with_X-Pack', position='Query'),
}

model ListLogstashResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The number of data nodes.', example='10'),
  }(name='Headers', description='The billing method of the instance. Supported: prepaid (subscription) and postpaid (pay-as-you-go).'),
  requestId?: string(name='RequestId', description='Detailed information about the matching instances.', example='AC442F2F-5068-4434-AA21-E78947A9****'),
  result?: [ 
    {
      tags?: [ 
        {
          tagKey?: string(name='TagKey', description='The disk size of the node.', example='env'),
          tagValue?: string(name='TagValue', description='The instance type of the ECS instance.', example='dev'),
        }
      ](name='Tags', description='The configuration information of the data node.'),
      createdAt?: string(name='createdAt', description='The ID of the instance.', example='2018-07-13T03:58:07.253Z'),
      description?: string(name='description', description='The time when the instance was last updated.', example='ls-cn-abc'),
      instanceId?: string(name='instanceId', description='The tag value of the cloud disk.', example='ls-cn-n6w1o5jq****'),
      networkConfig?: {
        type?: string(name='type', example='vpc'),
        vpcId?: string(name='vpcId', description='The ID of the vSwitch.', example='vpc-abc'),
        vsArea?: string(name='vsArea', example='cn-hangzhou-*'),
        vswitchId?: string(name='vswitchId', example='vsw-def'),
      }(name='networkConfig', description='The network type. Currently, only Virtual Private Cloud (VPC) is supported.'),
      nodeAmount?: int32(name='nodeAmount', description='The state of the instance. Valid values: Normal, Active, Inactive, and Invalid.', example='2'),
      nodeSpec?: {
        disk?: int32(name='disk', description='The network configurations.', example='50'),
        diskEncryption?: boolean(name='diskEncryption', description='The ID of the VPC.', example='false'),
        diskType?: string(name='diskType', description='The zone where the cluster resides.', example='cloud_ssd'),
        spec?: string(name='spec', description='The type of the disk.', example='logstash.n4.small'),
      }(name='nodeSpec', description='Specifies whether to use disk encryption. Valid values:

*   true: Enables the concurrent query feature for queries other than aggregate queries.
*   false: Disables the concurrent query feature for queries other than aggregate queries.'),
      paymentType?: string(name='paymentType', description='The time when the instance was created.', example='postpaid'),
      resourceGroupId?: string(name='resourceGroupId'),
      status?: string(name='status', description='The version of the instance. Currently, only 6.7.0\\_with_X-Pack and 7.4.0\\_with_X-Pack are supported.', example='active'),
      updatedAt?: string(name='updatedAt', description='The tag of the instance. Valid values:', example='2018-07-18T10:10:04.484Z'),
      version?: string(name='version', description='The tag key of the cloud disk.', example='6.7.0_with_X-Pack'),
    }
  ](name='Result', description='The name of the VPC.'),
}

model ListLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogstashResponseBody(name='body'),
}

async function listLogstash(request: ListLogstashRequest): ListLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogstash', 'GET', '/openapi/logstashes', 'json', false, 'json', request);
}

model ListLogstashLogRequest {
  instanceId: string(name='InstanceId', description='1531910852074', example='ls-cn-v0h1kzca****', position='Path'),
  beginTime?: long(name='beginTime', description='20', example='1531910852074', position='Query'),
  endTime?: long(name='endTime', description='The ID of the request.', example='1531910852074', position='Query'),
  page?: int32(name='page', description='The returned data.', example='1', position='Query'),
  query: string(name='query', description='1', example='host:10.7.xx.xx AND level:info AND content:opening', position='Query'),
  size?: int32(name='size', description='The severity level of the log entry. Including trace, debug, info, warn, error, etc. (GC logs have no level).', example='20', position='Query'),
  type: string(name='type', description='1531910852074', example='LOGSTASH_INSTANCE_LOG', position='Query'),
}

model ListLogstashLogResponseBody = {
  requestId?: string(name='RequestId', description='The details of the log.', example='7F40EAA1-6F1D-4DD9-8DB8-C5F00C4E****'),
  result?: [ 
    {
      content?: string(name='content', description='The IP address of the node that generates the log.', example='[logstash.outputs.fileextend] Opening file {:path=>\\"/ssd/1/ls-cn-v0h1kzca****/logstash/logs/debug/test\\"}'),
      host?: string(name='host', example='192.168.xx.xx'),
      instanceId?: string(name='instanceId', example='ls-cn-v0h1kzca****'),
      level?: string(name='level', description='The ID of the instance.', example='info'),
      timestamp?: long(name='timestamp', example='1531985112420'),
    }
  ](name='Result', description='The timestamp of log generation. Unit: ms.'),
}

model ListLogstashLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogstashLogResponseBody(name='body'),
}

async function listLogstashLog(request: ListLogstashLogRequest): ListLogstashLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogstashLog', 'GET', '/openapi/logstashes/{InstanceId}/search-log', 'json', false, 'json', request);
}

model ListLogstashPluginsRequest {
  instanceId: string(name='InstanceId', description='3', example='ls-cn-oew1qbgl****', position='Path'),
  name?: string(name='name', description='USER', example='logstash-filter-clone', position='Query'),
  page?: int32(name='page', description='The ID of the request.', example='10', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', description='The returned results.', example='3', minimum=1, maximum=200, position='Query'),
  source?: string(name='source', description='The description of the plug-in.', example='USER', position='Query'),
}

model ListLogstashPluginsResponseBody = {
  requestId?: string(name='RequestId', description='The address of the documentation for the plug-in.', example='99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      description?: string(name='description', description='The source of the plug-in.', example='The clone filter is for duplicating events.'),
      name?: string(name='name', example='logstash-filter-clone'),
      source?: string(name='source', example='SYSTEM'),
      specificationUrl?: string(name='specificationUrl', description='The name of the plug-in.', example='https://xxx.html'),
      state?: string(name='state', example='INSTALLED'),
    }
  ](name='Result', description='The status of the plug-in. Valid values:

*   INSTALLED: Installed
*   UNINSTALLED: Not installed
*   INSTALLING: The instance is being installed.
*   UNINSTALLING: The instance is being uninstalled.
*   UPGRADING: The backup gateway is being upgraded.
*   FAILED: Installation failed
*   UNKNOWN: The cluster is lost and cannot be created.'),
}

model ListLogstashPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogstashPluginsResponseBody(name='body'),
}

async function listLogstashPlugins(request: ListLogstashPluginsRequest): ListLogstashPluginsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogstashPlugins', 'GET', '/openapi/logstashes/{InstanceId}/plugins', 'json', false, 'json', request);
}

model ListNodesRequest {
  resId: string(name='ResId', description='The ID of the shipper.', example='ct-cn-l871nd0u73c45****', position='Path'),
  ecsInstanceIds?: string(name='ecsInstanceIds', description='The IDs of the ECS instances.', example='i-bp1ei8ysh7orb6eq****', position='Query'),
  ecsInstanceName?: string(name='ecsInstanceName', description='The name of the ECS instance.', example='test', position='Query'),
  page?: int32(name='page', description='The number of the page to return.', example='1', minimum=1, maximum=200, position='Query'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='10', minimum=1, maximum=10000, position='Query'),
  tags?: string(name='tags', description='The tags of the ECS instance. You must configure tagKey and tagValue.', example='[{"tagKey":"abc","tagValue":"xyz"}]', position='Query'),
}

model ListNodesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The number of entries returned.', example='10'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1FD7642-7C40-4FF2-9C0F-21F1A1746F70'),
  result?: [ 
    {
      agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values:

*   heartOk: The heartbeat is normal.
*   heartLost: The heartbeat is abnormal.
*   uninstalled: The shipper is not installed.
*   failed: The shipper fails to be installed.', example='heartOk'),
      cloudAssistantStatus?: string(name='cloudAssistantStatus', description='Indicates whether the Cloud Assistant client is installed. Valid values:

*   true: installed
*   false: not installed', example='true'),
      ecsInstanceId?: string(name='ecsInstanceId', description='The ID of the ECS instance.', example='i-bp13y63575oypr****'),
      ecsInstanceName?: string(name='ecsInstanceName', description='The name of the ECS instance.', example='ECS_beat'),
      ipAddress?: [ 
        {
          host?: string(name='host', description='The IP address.', example='192.168.xx.xx'),
          ipType?: string(name='ipType', description='The type of the IP address. Valid values:

*   public: public IP address
*   private: private IP address', example='public'),
        }
      ](name='ipAddress', description='The IP addresses of the ECS instance.'),
      osType?: string(name='osType', description='The operating system type of the ECS instance. Valid values:

*   windows: Windows Server
*   linux: Linux', example='linux'),
      status?: string(name='status', description='The status of the ECS instance. Valid values:

*   running: The instance is running.
*   starting: The instance is being started.
*   stopping: The instance is being stopped.
*   stopped: The instance is stopped.', example='running'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey', description='The key of the tag.', example='abc'),
          tagValue?: string(name='tagValue', description='The value of the tag.', example='xyz'),
        }
      ](name='tags', description='The tags of the ECS instance.'),
    }
  ](name='Result', description='The returned result.'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodes(request: ListNodesRequest): ListNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListNodes', 'GET', '/openapi/collectors/{ResId}/nodes', 'json', false, 'json', request);
}

model ListPipelineRequest {
  instanceId: string(name='InstanceId', description='15', example='ls-cn-oew1qbgl****', position='Path'),
  page?: int32(name='page', description='The header of the response.', example='1', minimum=1, maximum=200, position='Query'),
  pipelineId?: string(name='pipelineId', description='The ID of the request.', example='pipeline_test', position='Query'),
  size?: int32(name='size', description='The total number of returned entries.', example='15', minimum=1, maximum=200, position='Query'),
}

model ListPipelineResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The time when the pipeline was updated.', example='2'),
  }(name='Headers', description='The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job.'),
  requestId?: string(name='RequestId', description='The response.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      gmtCreatedTime?: string(name='gmtCreatedTime', example='2020-08-05T03:10:38.188Z'),
      gmtUpdateTime?: string(name='gmtUpdateTime', example='2020-08-05T08:43:31.757Z'),
      pipelineId?: string(name='pipelineId', description='The status of the pipeline. Supported:

*   NOT_DEPLOYED: The node is not deployed.
*   RUNNING
*   DELETED: Deleted. The console does not display this status.', example='pipeline_test'),
      pipelineStatus?: string(name='pipelineStatus', example='NOT_DEPLOYED'),
    }
  ](name='Result', description='The time when the pipeline was created.'),
}

model ListPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineResponseBody(name='body'),
}

async function listPipeline(request: ListPipelineRequest): ListPipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPipeline', 'GET', '/openapi/logstashes/{InstanceId}/pipelines', 'json', false, 'json', request);
}

model ListPipelineIdsRequest {
  instanceId: string(name='InstanceId', example='ls-cn-7g1umu96oit2e****', position='Path'),
  body?: string(name='body', example='{     "userName":"elastic",     "password":"xxxxxx" }', position='Body'),
}

model ListPipelineIdsResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      available?: boolean(name='available', example='true'),
      code?: string(name='code', example='OK'),
      message?: string(name='message', example='OK'),
      pipelineId?: string(name='pipelineId', example='testKibanaManagement'),
    }
  ](name='Result'),
}

model ListPipelineIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineIdsResponseBody(name='body'),
}

async function listPipelineIds(request: ListPipelineIdsRequest): ListPipelineIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPipelineIds', 'POST', '/openapi/instances/{InstanceId}/pipeline-ids', 'json', false, 'json', request);
}

model ListPluginsRequest {
  instanceId: string(name='InstanceId', description='10', example='es-cn-nif1q9o8r0008****', position='Path'),
  name?: string(name='name', description='SYSTEM', example='analysis-ik', position='Query'),
  page?: string(name='page', description='The ID of the request.', example='1', position='Query'),
  size?: int32(name='size', description='The header of the response.', example='10', position='Query'),
  source?: string(name='source', description='The total number of entries returned.', example='SYSTEM', position='Query'),
}

model ListPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The address of the plug-in description document.', example='2'),
  }(name='Headers', description='The description of the plug-in.'),
  requestId?: string(name='RequestId', description='The return results.', example='5A5D8E74-565C-43DC-B031-29289FA9****'),
  result?: [ 
    {
      description?: string(name='description', description='The source type of the plug-in.', example='IK analysis plug-in for Elasticsearch.'),
      name?: string(name='name', example='analysis-ik'),
      source?: string(name='source', example='SYSTEM'),
      specificationUrl?: string(name='specificationUrl', description='The name of the plug-in.', example='https://xxxx.html'),
      state?: string(name='state', example='INSTALLED'),
    }
  ](name='Result', description='The status of the plug-in.'),
}

model ListPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPluginsResponseBody(name='body'),
}

async function listPlugins(request: ListPluginsRequest): ListPluginsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPlugins', 'GET', '/openapi/instances/{InstanceId}/plugins', 'json', false, 'json', request);
}

model ListSearchLogRequest {
  instanceId: string(name='InstanceId', description='1531910852074', example='es-cn-n6w1o1x0w001c****', position='Path'),
  beginTime?: long(name='beginTime', description='20', example='1531910852074', position='Query'),
  endTime?: long(name='endTime', description='The ID of the request.', example='1531910852074', position='Query'),
  page?: int32(name='page', description='The header of the response.', example='1', position='Query'),
  query: string(name='query', description='1', example='host:172.16.**.** AND content:netty', position='Query'),
  size?: int32(name='size', description='The number of entries returned per page.', example='20', minimum=1, maximum=50, position='Query'),
  type: string(name='type', description='1531910852074', example='INSTANCELOG', position='Query'),
}

model ListSearchLogResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The IP address of the node that generates the log.', example='1000'),
  }(name='Headers', description='The level of the log. Valid values:

*   warn: warning log
*   info: information log
*   error: error log
*   trace: trace logs
*   debug: debug logs

The level information has been migrated to the contentCollection field.'),
  requestId?: string(name='RequestId', description='The list of logs returned by the request.', example='7F40EAA1-6F1D-4DD9-8DB8-C5F00C4E****'),
  result?: [ 
    {
      content?: string(name='content', description='The ID of the instance.', example='[GC (Allocation Failure) 2018-07-19T17:24:20.682+0800: 7516.513: [ParNew: 6604768K->81121K(7341504K), 0.0760606 secs] 7226662K->703015K(31813056K), 0.0762507 secs] [Times: user=0.52 sys=0.00, real=0.07 secs]'),
      contentCollection?: map[string]any(name='contentCollection', example='{"level": "info", "host": "192.168.**.**", "time": "2019-03-18T08:16:12.741Z","content": "[o.e.c.r.a.AllocationService] [MnNASM_] Cluster health status changed from [YELLOW] to [GREEN] (reason: [shards started [[my_index][3]] ...])."}'),
      host?: string(name='host', description='Details of the log entry. Different content fields are returned for different log types.', example='192.168.**.**'),
      instanceId?: string(name='instanceId', example='es-cn-n6w1o1x0w001c****'),
      level?: string(name='level', description='The timestamp when the log is generated. Unit: ms.', example='info'),
      timestamp?: long(name='timestamp', example='1531985112420'),
    }
  ](name='Result', description='The content of the log entry. Migrated to the contentCollection field.'),
}

model ListSearchLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSearchLogResponseBody(name='body'),
}

async function listSearchLog(request: ListSearchLogRequest): ListSearchLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSearchLog', 'GET', '/openapi/instances/{InstanceId}/search-log', 'json', false, 'json', request);
}

model ListShardRecoveriesRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='es-cn-7mz293m9a003j****', position='Path'),
  activeOnly?: boolean(name='activeOnly', description='Specifies whether to return information about data restoration of shards. Valid values:

*   true: returns information about data restoration of shards that are being restored.
*   false: returns information about data restoration of all shards.', example='true', position='Query'),
}

model ListShardRecoveriesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      bytesPercent?: string(name='bytesPercent', description='The data restoration progress.', example='80%'),
      bytesTotal?: long(name='bytesTotal', description='The total amount of data that is restored.', example='12086'),
      filesPercent?: string(name='filesPercent', description='The file execution progress.', example='80.0%'),
      filesTotal?: long(name='filesTotal', description='The total number of files.', example='79'),
      index?: string(name='index', description='The name of the index.', example='my-index-000001'),
      sourceHost?: string(name='sourceHost', description='The IP address of the source node.', example='192.168.XX.XX'),
      sourceNode?: string(name='sourceNode', description='The name of the source node.', example='2Kni3dJ'),
      stage?: string(name='stage', description='The data restoration status. Valid values:

*   done: Data restoration is complete.
*   finalize: Data is being cleared.
*   index: Index metadata is being read, and bytes are being copied from source to destination.
*   init: Data restoration is not started.
*   start: Data restoration is started.
*   translog: Translogs are being redone.', example='done'),
      targetHost?: string(name='targetHost', description='The IP address of the destination node.', example='192.168.XX.XX'),
      targetNode?: string(name='targetNode', description='The name of the destination node.', example='YVVKLmW'),
      translogOps?: long(name='translogOps', description='The number of translog operations to be restored.', example='12086'),
      translogOpsPercent?: string(name='translogOpsPercent', description='The restoration progress of translog operations.', example='80%'),
    }
  ](name='Result', description='The returned result.'),
}

model ListShardRecoveriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListShardRecoveriesResponseBody(name='body'),
}

/**
  * > The restoration of a shard is a process of synchronizing data from a primary shard to a replica shard. After the restoration is complete, the replica shard is available for data searches.
  *
 */
async function listShardRecoveries(request: ListShardRecoveriesRequest): ListShardRecoveriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListShardRecoveries', 'GET', '/openapi/instances/{InstanceId}/cat-recovery', 'json', false, 'json', request);
}

model ListSnapshotReposByInstanceIdRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-0pp1jxvcl000z****', position='Path'),
}

model ListSnapshotReposByInstanceIdResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ 
    {
      instanceId?: string(name='instanceId', description='Reference instance ID.', example='es-cn-6ja1ro4jt000c****'),
      repoPath?: string(name='repoPath', description='The address of the repository.', example='es-cn-6ja1ro4jt000c****'),
      snapWarehouse?: string(name='snapWarehouse', description='Reference warehouse name.', example='aliyun_snapshot_from_es-cn-6ja1ro4jt000c****'),
      status?: string(name='status', description='Reference warehouse status. available indicates that it is valid. unavailable indicates that it is invalid.', example='available'),
    }
  ](name='Result', description='The return results.'),
}

model ListSnapshotReposByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSnapshotReposByInstanceIdResponseBody(name='body'),
}

async function listSnapshotReposByInstanceId(request: ListSnapshotReposByInstanceIdRequest): ListSnapshotReposByInstanceIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListSnapshotReposByInstanceId', 'GET', '/openapi/instances/{InstanceId}/snapshot-repos', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The number of the returned page.', example='1d2db86sca4384811e0b5e8707e******', position='Query'),
  page?: int32(name='Page', description='1d2db86sca4384811e0b5e8707e\\*\\*\\*\\*\\*\\*', example='1', deprecated='true', position='Query'),
  resourceIds?: string(name='ResourceIds', description='The ID of the request.', example='["es-cn-aaa","es-cn-bbb"]', position='Query'),
  resourceType: string(name='ResourceType', description='\\[{"key":"env","value","dev"},{"key":"dev", "value":"IT"}]', example='INSTANCE', position='Query'),
  size?: int32(name='Size', description='\\["es-cn-aaa","es-cn-bbb"]', example='10', deprecated='true', position='Query'),
  tags?: string(name='Tags', description='The header of the response. This parameter is empty and is for reference only. You cannot force this parameter to be relied on in the program.

>  The return examples does not contain this parameter.', example='[{"key":"env","value","dev"},{"key":"dev",  "value":"IT"}]', position='Query'),
}

model ListTagResourcesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The value of the tag.', example='10'),
  }(name='Headers', description='The labels of the resource.'),
  pageSize?: int32(name='PageSize', description='The number of resources to query.', example='1'),
  requestId?: string(name='RequestId', description='A list of resources that have tags.', example='F99407AB-2FA9-489E-A259-40CF6D******'),
  tagResources?: {
    tagResource?: [ 
      {
        resourceId?: string(name='ResourceId', example='es-cn-oew1q8bev0002****'),
        resourceType?: string(name='ResourceType', example='ALIYUN::ELASTICSEARCH::INSTANCE'),
        tagKey?: string(name='TagKey', example='env'),
        tagValue?: string(name='TagValue', description='The tag key.', example='dev'),
      }
    ](name='TagResource', description='Indicates the ID of a resource.'),
  }(name='TagResources', description='The type of the resource. Fixed to `ALIYUN::ELASTICSEARCH::INSTANCE`.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTagResources', 'GET', '/openapi/tags', 'json', false, 'json', request);
}

model ListTagsRequest {
  pageSize?: int32(name='pageSize', description='The return results.', example='20', minimum=1, maximum=50, position='Query'),
  resourceType?: string(name='resourceType', description='The tag value of the ENI.', example='INSTANCE', position='Query'),
}

model ListTagsResponseBody = {
  requestId?: string(name='RequestId', description='The key of the tag.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      tagKey?: string(name='TagKey', example='env'),
      tagValue?: string(name='TagValue', example='dev'),
    }
  ](name='Result'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagsResponseBody(name='body'),
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTags', 'GET', '/openapi/tags/all-tags', 'json', false, 'json', request);
}

model ListVpcEndpointsRequest {
  instanceId: string(name='InstanceId', description='The cluster ID.', example='es-cn-2r429tctl000d****', position='Path'),
  page?: int32(name='page', description='The number of the page to return.

Pages start from page 1. Default value: 1.', example='1', position='Query'),
  size?: int32(name='size', description='The number of entries to return on each page. Default value: 20.', example='10', position='Query'),
}

model ListVpcEndpointsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      connectionStatus?: string(name='connectionStatus', description='The status of the endpoint connection. Valid values:

*   Pending
*   Connecting
*   Connected
*   Disconnecting
*   Disconnected
*   Deleting
*   ServiceDeleted', example='Disconnected'),
      createTime?: string(name='createTime', description='The time when the endpoint was created.', example='2021-07-22T01:19:24Z'),
      endpointBusinessStatus?: string(name='endpointBusinessStatus', description='The business status of the endpoint. Valid values:

*   Normal
*   FinancialLocked', example='Normal'),
      endpointDomain?: string(name='endpointDomain', description='The domain name of the endpoint. The domain name is used for connection configuration.', example='ep-bp18s6wy9420wdi4****.epsrv-bp1bz3efowa4kc0****.cn-hangzhou.privatelink.aliyuncs.com'),
      endpointId?: string(name='endpointId', description='The ID of the endpoint.', example='ep-bp1tah7zbrwmkjef****'),
      endpointName?: string(name='endpointName', description='The name of the endpoint.', example='test'),
      endpointStatus?: string(name='endpointStatus', description='The status of the endpoint. Valid values:

*   Creating
*   Active
*   Pending
*   Deleting', example='Active'),
      serviceId?: string(name='serviceId', description='The ID of the endpoint service with which the endpoint is associated.', example='epsrv-bp1w0p3jdirbfmt6****'),
      serviceName?: string(name='serviceName', description='The name of the endpoint service with which the endpoint is associated.', example='com.aliyuncs.privatelink.cn-hangzhou.epsrv-bp1w0p3jdirbfmt6****'),
    }
  ](name='Result', description='The details of the endpoints.'),
}

model ListVpcEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcEndpointsResponseBody(name='body'),
}

async function listVpcEndpoints(request: ListVpcEndpointsRequest): ListVpcEndpointsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListVpcEndpoints', 'GET', '/openapi/instances/{InstanceId}/vpc-endpoints', 'json', false, 'json', request);
}

model MigrateToOtherZoneRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  dryRun: boolean(name='dryRun', description='Verify whether the zone node can be migrated. true indicates that the data is only verified and the migration task is not executed. false indicates that the migration task is executed after the verification is successful.', example='false', position='Query'),
}

model MigrateToOtherZoneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: migration succeeded
*   false: The migration fails', example='true'),
}

model MigrateToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateToOtherZoneResponseBody(name='body'),
}

/**
  * If the specifications in your zone are insufficient, you can upgrade your instance to nodes in another zone. Before calling this interface, you must ensure that:
  * *   The error message returned because the current account is in a zone that has sufficient resources.
  *     After migrating nodes with current specifications to another zone, you need to manually [upgrade cluster](~~96650~~) because the cluster will not be upgraded during the migration process. Therefore, select a zone with sufficient resources to avoid cluster upgrade failure. We recommend that you choose new zones that are in lower alphabetical order. For example, for cn-hangzhou-e and cn-hangzhou-h zones, choose cn-hangzhou-h first.
  * *   The cluster is in the healthy state.
  *     Can be passed`  GET _cat/health?v  `command to view the health status of the cluster.
  *
 */
async function migrateToOtherZone(request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'MigrateToOtherZone', 'POST', '/openapi/instances/{InstanceId}/actions/migrate-zones', 'json', false, 'json', request);
}

model ModifyDeployMachineRequest {
  resId: string(name='ResId', description='The shipper ID.', example='ct-cn-xb1i7q79u65nk****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model ModifyDeployMachineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C37CE536-6C0F-4778-9B59-6D94C7F7EB63'),
  result?: boolean(name='Result', description='Indicates whether the ECS instances are changed. Valid values:

*   true
*   false', example='true'),
}

model ModifyDeployMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDeployMachineResponseBody(name='body'),
}

async function modifyDeployMachine(request: ModifyDeployMachineRequest): ModifyDeployMachineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyDeployMachine', 'POST', '/openapi/collectors/{ResId}/actions/modify-deploy-machines', 'json', false, 'json', request);
}

model ModifyElastictaskRequest {
  instanceId: string(name='InstanceId', example='es-cn-6ja1ro4jt000c****', position='Path'),
  body?: string(name='body', position='Body'),
}

model ModifyElastictaskResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression', example='0 0 0 ? * MON'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression', example='4 4 4 ? * WED'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model ModifyElastictaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyElastictaskResponseBody(name='body'),
}

async function modifyElastictask(request: ModifyElastictaskRequest): ModifyElastictaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyElastictask', 'POST', '/openapi/instances/{InstanceId}/elastic-task', 'json', false, 'json', request);
}

model ModifyInstanceMaintainTimeRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', example='{     "openMaintainTime": true,     "maintainStartTime": "03:00Z",     "maintainEndTime": "04:00Z" }', position='Body'),
}

model ModifyInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model ModifyInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceMaintainTimeResponseBody(name='body'),
}

/**
  * es-cn-n6w1o1x0w001c\\*\\*\\*\\*
  *
 */
async function modifyInstanceMaintainTime(request: ModifyInstanceMaintainTimeRequest): ModifyInstanceMaintainTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyInstanceMaintainTime', 'POST', '/openapi/instances/{InstanceId}/actions/modify-maintaintime', 'json', false, 'json', request);
}

model ModifyWhiteIpsRequest {
  instanceId: string(name='InstanceId', description='The node type. This parameter is required if you configure the whiteIpList parameter. Valid values:

*   WORKER
*   KIBANA', example='es-cn-0pp1jxvcl000z****', position='Path'),
  modifyMode?: string(name='modifyMode', description='The information about the IP address whitelist that you want to update. You can specify only one whitelist.

> You cannot configure both the whiteIpList and whiteIpGroup parameters.', example='Cover', position='Body'),
  networkType?: string(name='networkType', description='The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.

> You cannot configure both the whiteIpList and whiteIpGroup parameters.', example='PUBLIC', position='Body'),
  nodeType?: string(name='nodeType', description='The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.', example='WORKER', position='Body'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='The type of the IP address whitelist. Valid values:

*   PRIVATE_KIBANA
*   PRIVATE_ES
*   PUBLIC_ES
*   PUBLIC_KIBANA', example='test_group'),
    ips?: [ string ](name='ips', description='The returned result.'),
    whiteIpType?: string(name='whiteIpType', description='The request ID.', example='PRIVATE_ES'),
  }(name='whiteIpGroup', description='The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.', position='Body'),
  whiteIpList?: [ string ](name='whiteIpList', description='The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.', position='Body'),
  clientToken?: string(name='clientToken', description='The network type. This parameter is required if you configure the whiteIpList parameter. Valid values:

*   PRIVATE
*   PUBLIC', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model ModifyWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1DERFG'),
  result?: boolean(name='Result', example='true'),
}

model ModifyWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWhiteIpsResponseBody(name='body'),
}

/**
  * The ID of the cluster.
  *
 */
async function modifyWhiteIps(request: ModifyWhiteIpsRequest): ModifyWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ModifyWhiteIps', 'POST', '/openapi/instances/{InstanceId}/actions/modify-white-ips', 'json', false, 'json', request);
}

model MoveResourceGroupRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    createdAt?: string(name='createdAt', description='The time when the cluster was created.', example='2020-07-06T10:18:48.662Z'),
    description?: string(name='description', description='The name of the cluster.', example='es-cn-abc'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The type of the source of the dictionary file. Valid values:

*   OSS: Object Storage Service (OSS). You must make sure that the access control list (ACL) of the related OSS bucket is public read.
*   ORIGIN: previously uploaded dictionary.', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: stopword list
*   MAIN: main dictionary
*   SYNONYMS: synonym dictionary
*   ALI_WS: Alibaba Cloud dictionary', example='MAIN'),
      }
    ](name='dictList', description='The configurations of IK dictionaries.'),
    domain?: string(name='domain', description='The internal endpoint of the cluster.', example='es-cn-nif1q8auz0003****.elasticsearch.aliyuncs.com'),
    esVersion?: string(name='esVersion', description='The version of the cluster.', example='6.7.0_with_X-Pack'),
    instanceId?: string(name='instanceId', description='The ID of the cluster.', example='es-cn-n6w1o1x0w001c****'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', description='The number of nodes.', example='1'),
      disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification category.', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration', description='The configurations of Kibana nodes.'),
    kibanaDomain?: string(name='kibanaDomain', description='The public endpoint of the Kibana console of the cluster.', example='es-cn-nif1q8auz0003****.kibana.elasticsearch.aliyuncs.com'),
    kibanaPort?: int32(name='kibanaPort', description='The port number that is used to access the Kibana console of the cluster over the Internet.', example='5601'),
    masterConfiguration?: {
      amount?: int32(name='amount', description='The number of nodes.', example='3'),
      disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification category.', example='elasticsearch.sn2ne.large'),
    }(name='masterConfiguration', description='The configurations of dedicated master nodes.'),
    networkConfig?: {
      type?: string(name='type', description='The network type. Only the VPC is supported.', example='vpc'),
      vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp16k1dvzxtmagcva****'),
      vsArea?: string(name='vsArea', description='The zone where the cluster resides.', example='cn-hangzhou-i'),
      vswitchId?: string(name='vswitchId', description='The ID of the vSwitch.', example='vsw-bp1k4ec6s7sjdbudw****'),
    }(name='networkConfig', description='The network configurations.'),
    nodeAmount?: int32(name='nodeAmount', description='The number of data nodes in the cluster.', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='50'),
      diskType?: string(name='diskType', description='The storage type.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification category.', example='elasticsearch.n4.small'),
    }(name='nodeSpec', description='The configurations of data nodes.'),
    paymentType?: string(name='paymentType', description='The billing method of the cluster. Valid values:

*   prepaid: subscription
*   postpaid: pay-as-you-go', example='postpaid'),
    publicDomain?: string(name='publicDomain', description='The public endpoint of the cluster.', example='es-cn-n6w1o1x0w001c****.public.elasticsearch.aliyuncs.com'),
    publicPort?: int32(name='publicPort', description='The port number that is used to access the cluster over the Internet.', example='9200'),
    status?: string(name='status', description='The status of the cluster. Valid values:

*   active: The cluster is normal.
*   activating: The cluster is being activated.
*   Inactive: The cluster is frozen.
*   invalid: The cluster is valid.', example='active'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The type of the source of the dictionary file. Valid values:

*   OSS: Object Storage Service (OSS). You must make sure that the ACL of the related OSS bucket is public read.
*   ORIGIN: previously uploaded dictionary.', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: stopword list
*   MAIN: main dictionary
*   SYNONYMS: synonym dictionary
*   ALI_WS: Alibaba Cloud dictionary', example='STOP'),
      }
    ](name='synonymsDicts', description='The configurations of synonym dictionaries.'),
    updatedAt?: string(name='updatedAt', description='The time when the cluster was last updated.', example='2018-07-18T10:10:04.484Z'),
  }(name='Result', description='The returned result.'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'MoveResourceGroup', 'POST', '/openapi/instances/{InstanceId}/resourcegroup', 'json', false, 'json', request);
}

model OpenDiagnosisRequest {
  instanceId: string(name='InstanceId', description='Indicates whether the intelligent O\\&M feature is enabled. Valid values:

*   true: The call was successful.
*   false: The call failed.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='ClientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  lang?: string(name='lang', example='en', position='Query'),
}

model OpenDiagnosisResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model OpenDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenDiagnosisResponseBody(name='body'),
}

async function openDiagnosis(request: OpenDiagnosisRequest): OpenDiagnosisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'OpenDiagnosis', 'POST', '/openapi/diagnosis/instances/{InstanceId}/actions/open-diagnosis', 'json', false, 'json', request);
}

model OpenHttpsRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model OpenHttpsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: open the HTTPS protocol successfully
*   false: open the HTTPS protocol failed', example='true'),
}

model OpenHttpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenHttpsResponseBody(name='body'),
}

/**
  * >  To ensure data security, we recommend that you enable HTTPS.
  *
 */
async function openHttps(request: OpenHttpsRequest): OpenHttpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'OpenHttps', 'POST', '/openapi/instances/{InstanceId}/actions/open-https', 'json', false, 'json', request);
}

model PostEmonTryAlarmRuleRequest {
  projectId: string(name='ProjectId', example='es-133071096032****', position='Path'),
  alarmGroupId: string(name='AlarmGroupId', example='123', position='Path'),
  body?: string(name='body', position='Body'),
}

model PostEmonTryAlarmRuleResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='3EC5731F-0944-4E4F-9DD5-1F976B3FCC3D'),
  success?: boolean(name='Success', example='true'),
}

model PostEmonTryAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PostEmonTryAlarmRuleResponseBody(name='body'),
}

async function postEmonTryAlarmRule(request: PostEmonTryAlarmRuleRequest): PostEmonTryAlarmRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PostEmonTryAlarmRule', 'POST', '/openapi/emon/projects/{ProjectId}/alarm-groups/{AlarmGroupId}/alarm-rules/_test', 'json', false, 'json', request);
}

model RecommendTemplatesRequest {
  instanceId: string(name='InstanceId', example='es-cn-oew20apwz0007****', position='Path'),
  usageScenario: string(name='usageScenario', description='*
*
*
*
*

**

****', example='general', position='Query'),
}

model RecommendTemplatesResponseBody = {
  requestId?: string(name='RequestId', example='66B060CF-7381-49C7-9B89-7757927FDA16'),
  result?: [ 
    {
      content?: string(name='content', example='{\\n\\t\\"persistent\\": {\\n\\t\\t\\"search\\": {\\n\\t\\t\\t\\"max_buckets\\": \\"10000\\"\\n\\t\\t}\\n\\t}\\n}'),
      templateName?: string(name='templateName', description='*
*
*
*

**

****', example='dynamicSettings'),
    }
  ](name='Result'),
}

model RecommendTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecommendTemplatesResponseBody(name='body'),
}

async function recommendTemplates(request: RecommendTemplatesRequest): RecommendTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RecommendTemplates', 'GET', '/openapi/instances/{InstanceId}/recommended-templates', 'json', false, 'json', request);
}

model ReinstallCollectorRequest {
  resId: string(name='ResId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='ct-cn-l871nd0u73c45****', position='Path'),
  clientToken?: string(name='ClientToken', description='The request body parameters. For more information, see the Request body section in this topic.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', description='Indicates whether the shipper is installed. Valid values:

*   true: The shipper is installed.
*   false: The shipper fails to be installed.', example='{
  "restartType": "nodeEcsId",
  "nodes":["i-bp1gyhphjaj73jsr****","i-bp10piq1mkfnyw9t****"]
}', position='Body'),
}

model ReinstallCollectorResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The ID of the request.', example='true'),
}

model ReinstallCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReinstallCollectorResponseBody(name='body'),
}

async function reinstallCollector(request: ReinstallCollectorRequest): ReinstallCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ReinstallCollector', 'POST', '/openapi/collectors/{ResId}/actions/reinstall', 'json', false, 'json', request);
}

model RemoveApmRequest {
  instanceId?: string(name='instanceId', example='apm-cn-7pp2fsi2****', position='Path'),
}

model RemoveApmResponseBody = {
  requestId?: string(name='RequestId', example='29A879FB-86BF-54CA-9426-B769A099E1A1'),
  result?: boolean(name='Result', example='true'),
}

model RemoveApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveApmResponseBody(name='body'),
}

async function removeApm(request: RemoveApmRequest): RemoveApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveApm', 'DELETE', '/openapi/apm/{instanceId}', 'json', false, 'json', request);
}

model RenewInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='This parameter is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B350****', position='Query'),
}

model RenewInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: renewal successfully
*   false: renewal failed', example='true'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RenewInstance', 'POST', '/openapi/instances/{InstanceId}/actions/renew', 'json', false, 'json', request);
}

model RenewLogstashRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='ls-cn-n6w1o5jq****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model RenewLogstashResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: boolean(name='Result', description='The returned result. Valid values:

*   true: The cluster is renewed.
*   false: The cluster fails to be renewed.', example='true'),
}

model RenewLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewLogstashResponseBody(name='body'),
}

async function renewLogstash(request: RenewLogstashRequest): RenewLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RenewLogstash', 'POST', '/openapi/logstashes/{InstanceId}/actions/renew', 'json', false, 'json', request);
}

model RestartCollectorRequest {
  resId: string(name='ResId', description='The ID of the shipper.', example='ct-cn-77uqof2s7rg5c****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model RestartCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='84B4038A-AF38-4BF4-9FAD-EA92A4FFF00A'),
  result?: boolean(name='Result', description='Indicates whether the shipper is restarted. Valid values:

*   true: The shipper is restarted.
*   false: The shipper fails to be restarted.', example='true'),
}

model RestartCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartCollectorResponseBody(name='body'),
}

async function restartCollector(request: RestartCollectorRequest): RestartCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestartCollector', 'POST', '/openapi/collectors/{ResId}/actions/restart', 'json', false, 'json', request);
}

model RestartInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-nif1q8auz0003****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. The maximum length of the token is 64 ASCII characters.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  force?: boolean(name='force', description='Specifies whether to ignore the status of the instance and forcibly restart the instance.', example='false', position='Query'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: {
    createdAt?: string(name='createdAt', description='The time when the instance was created.', example='2020-07-06T10:18:48.662Z'),
    description?: string(name='description', description='The name of the instance.', example='es-cn-abc'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the Dictionary File. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The source type. Valid values:

*   OSS: OSS open storage (need to ensure that OSS storage space is public readable.)
*   ORIGIN: Open source Elasticsearch
*   UPLOAD: Uploaded files', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: The STOP word.
*   MAIN: MAIN Dictionary
*   SYNONYMS: SYNONYMS
*   ALI_WS: an Alibaba Dictionary.', example='MAIN'),
      }
    ](name='dictList', description='The configuration of the IK dictionaries.'),
    domain?: string(name='domain', description='The intranet access address of the instance.', example='es-cn-nif1q8auz0003****.elasticsearch.aliyuncs.com'),
    esVersion?: string(name='esVersion', description='The version of the instance.', example='6.7.0_with_X-Pack'),
    instanceId?: string(name='instanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', description='The number of performance metrics.', example='1'),
      disk?: int32(name='disk', description='The size of the node storage space. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type of the node.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification of data nodes.', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration', description='The configuration of Kibana nodes.'),
    kibanaDomain?: string(name='kibanaDomain', description='The public network access address of Kibana.', example='es-cn-nif1q8auz0003****.kibana.elasticsearch.aliyuncs.com'),
    kibanaPort?: int32(name='kibanaPort', description='The public port of the Kibana network.', example='5601'),
    masterConfiguration?: {
      amount?: int32(name='amount', description='The number of nodes in the cluster.', example='3'),
      disk?: int32(name='disk', description='The size of the node storage space. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type of the node. This tool only supports cloud_ssd (cloud SSD) disks.', example='cloud_ssd'),
      spec?: string(name='spec', description='The node specifications of the cluster.', example='elasticsearch.sn2ne.large'),
    }(name='masterConfiguration', description='The configuration of dedicated master nodes.'),
    networkConfig?: {
      type?: string(name='type', description='The network type. Only Virtual Private Cloud (VPC) is supported.', example='vpc'),
      vpcId?: string(name='vpcId', description='The ID of the VPC.', example='vpc-bp16k1dvzxtmagcva****'),
      vsArea?: string(name='vsArea', description='The zone where the instance is deployed.', example='cn-hangzhou-i'),
      vswitchId?: string(name='vswitchId', description='The ID of the vSwitch associated with the specified VPC.', example='vsw-bp1k4ec6s7sjdbudw****'),
    }(name='networkConfig', description='The network configuration.'),
    nodeAmount?: int32(name='nodeAmount', description='The number of data nodes.', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='The storage space size per data node. Unit: GB.', example='50'),
      diskType?: string(name='diskType', description='The storage type of the node. Valid values: cloud_ssd and cloud_efficiency.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification of data nodes.', example='elasticsearch.n4.small'),
    }(name='nodeSpec', description='The configuration of data nodes.'),
    paymentType?: string(name='paymentType', description='The billing method of the created ECS instance.

Valid values: prepaid and postpaid.', example='postpaid'),
    publicDomain?: string(name='publicDomain', description='The public network access address.', example='es-cn-n6w1o1x0w001c****.public.elasticsearch.aliyuncs.com'),
    publicPort?: int32(name='publicPort', description='The public network port.', example='9200'),
    status?: string(name='status', description='The state of the cluster.

Supported: active (normal), activating (initializing), inactive (blocked), and invalid (expired).', example='active'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the Dictionary File. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The source type. Valid values:

*   OSS:OSS open storage (the OSS storage space must be publicly readable.)
*   ORIGIN: open-source Elasticsearch
*   UPLOAD', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: The STOP word.
*   MAIN: MAIN Dictionary
*   SYNONYMS: SYNONYMS
*   ALI_WS: an Alibaba Dictionary.', example='STOP'),
      }
    ](name='synonymsDicts', description='The configuration of the synonym dictionaries.'),
    updatedAt?: string(name='updatedAt', description='The time when the instance was last updated.', example='2018-07-18T10:10:04.484Z'),
  }(name='Result', description='The return results.'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartInstanceResponseBody(name='body'),
}

/**
  * >  After the instance is restarted, the instance enters the activating state. After the instance is restarted, its status changes to active. Alibaba Cloud Elasticsearch supports restarting a single node. Restarting a node can be divided into normal restart and blue-green restart.
  *
 */
async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestartInstance', 'POST', '/openapi/instances/{InstanceId}/actions/restart', 'json', false, 'json', request);
}

model RestartLogstashRequest {
  instanceId: string(name='InstanceId', example='ls-cn-v0h1kzca****', position='Path'),
  batchCount?: double(name='batchCount', example='20%', minimum=0, maximum=100, position='Body'),
  blueGreenDep?: boolean(name='blueGreenDep', example='false', position='Body'),
  nodeTypes?: [ string ](name='nodeTypes', position='Body'),
  nodes?: [ string ](name='nodes', position='Body'),
  restartType?: string(name='restartType', example='instance', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  force?: boolean(name='force', example='true', position='Query'),
}

model RestartLogstashResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: Logstash(name='Result'),
}

model RestartLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartLogstashResponseBody(name='body'),
}

async function restartLogstash(request: RestartLogstashRequest): RestartLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestartLogstash', 'POST', '/openapi/logstashes/{InstanceId}/actions/restart', 'json', false, 'json', request);
}

model ResumeElasticsearchTaskRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model ResumeElasticsearchTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: resume the interrupted change successfully
*   false: resume the interrupted change successfully failed', example='true'),
}

model ResumeElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeElasticsearchTaskResponseBody(name='body'),
}

async function resumeElasticsearchTask(request: ResumeElasticsearchTaskRequest): ResumeElasticsearchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ResumeElasticsearchTask', 'POST', '/openapi/instances/{InstanceId}/actions/resume', 'json', false, 'json', request);
}

model ResumeLogstashTaskRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-4591f1y6****', position='Path'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model ResumeLogstashTaskResponseBody = {
  code?: string(name='Code', description='The error code returned. If the API operation is successfully called, this parameter is not returned.', example='InstanceNotFound'),
  message?: string(name='Message', description='The error message returned. If the API operation is successfully called, this parameter is not returned.', example='The specified cluster does not exist. Check the cluster status and try again.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0FA05123-745C-42FD-A69B-AFF48EF9****'),
  result?: boolean(name='Result', description='Indicates whether the change task is resumed. Valid values:

*   true: The change task is resumed.
*   false: The change task fails to be resumed.', example='true'),
}

model ResumeLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeLogstashTaskResponseBody(name='body'),
}

async function resumeLogstashTask(request: ResumeLogstashTaskRequest): ResumeLogstashTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ResumeLogstashTask', 'POST', '/openapi/logstashes/{InstanceId}/actions/resume', 'json', false, 'json', request);
}

model RolloverDataStreamRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif24adwc0082****', position='Path'),
  dataStream: string(name='DataStream', example='ds-001', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model RolloverDataStreamResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model RolloverDataStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RolloverDataStreamResponseBody(name='body'),
}

async function rolloverDataStream(request: RolloverDataStreamRequest): RolloverDataStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RolloverDataStream', 'POST', '/openapi/instances/{InstanceId}/data-streams/{DataStream}/rollover', 'json', false, 'json', request);
}

model RunPipelinesRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-oew1qbgl****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model RunPipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result. Valid values:

*   true: successful
*   false: failed', example='true'),
}

model RunPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunPipelinesResponseBody(name='body'),
}

async function runPipelines(request: RunPipelinesRequest): RunPipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RunPipelines', 'POST', '/openapi/logstashes/{InstanceId}/pipelines/action/run', 'json', false, 'json', request);
}

model ShrinkNodeRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif1q9o8r0008****', position='Path'),
  body?: [ 
    {
      host?: string(name='host', example='192.168.xx.xx'),
      hostName?: string(name='hostName', example='es-cn-pl32xxxxxxx-data-f-1'),
      nodeType?: string(name='nodeType', example='WORKER'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  count?: int32(name='count', example='2', position='Query'),
  ignoreStatus?: boolean(name='ignoreStatus', example='false', position='Query'),
  nodeType: string(name='nodeType', example='WORKER', position='Query'),
}

model ShrinkNodeResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model ShrinkNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ShrinkNodeResponseBody(name='body'),
}

async function shrinkNode(request: ShrinkNodeRequest): ShrinkNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ShrinkNode', 'POST', '/openapi/instances/{InstanceId}/actions/shrink', 'json', false, 'json', request);
}

model StartApmRequest {
  instanceId: string(name='instanceId', example='apm-cn-7mz2ffhq****', position='Path'),
}

model StartApmResponseBody = {
  requestId?: string(name='RequestId', example='526F30AB-4A43-55BA-910F-ACD275FD5F14'),
  result?: boolean(name='Result', example='true'),
}

model StartApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartApmResponseBody(name='body'),
}

async function startApm(request: StartApmRequest): StartApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartApm', 'POST', '/openapi/apm/{instanceId}/actions/start', 'json', false, 'json', request);
}

model StartCollectorRequest {
  resId: string(name='ResId', description='The ID of the collector.', example='ct-cn-77uqof2s7rg5c****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model StartCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result.', example='true'),
}

model StartCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartCollectorResponseBody(name='body'),
}

async function startCollector(request: StartCollectorRequest): StartCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartCollector', 'POST', '/openapi/collectors/{ResId}/actions/start', 'json', false, 'json', request);
}

model StopApmRequest {
  instanceId: string(name='instanceId', example='apm-cn-7mz2ffhq****', position='Path'),
}

model StopApmResponseBody = {
  requestId?: string(name='RequestId', example='FEC32FE6-4697-5110-9668-C6016EAEB5DE'),
  result?: boolean(name='Result', example='true'),
}

model StopApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopApmResponseBody(name='body'),
}

async function stopApm(request: StopApmRequest): StopApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopApm', 'POST', '/openapi/apm/{instanceId}/actions/stop', 'json', false, 'json', request);
}

model StopCollectorRequest {
  resId: string(name='ResId', description='The shipper ID.', example='ct-cn-77uqof2s7rg5c****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model StopCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result.', example='true'),
}

model StopCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopCollectorResponseBody(name='body'),
}

async function stopCollector(request: StopCollectorRequest): StopCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopCollector', 'POST', '/openapi/collectors/{ResId}/actions/stop', 'json', false, 'json', request);
}

model StopPipelinesRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-oew1qbgl****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model StopPipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result. Valid values:

*   true: The pipelines are stopped.
*   false: The pipelines fail to be stopped.', example='true'),
}

model StopPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopPipelinesResponseBody(name='body'),
}

async function stopPipelines(request: StopPipelinesRequest): StopPipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopPipelines', 'POST', '/openapi/logstashes/{InstanceId}/pipelines/action/stop', 'json', false, 'json', request);
}

model TagResourcesRequest {
  resourceIds: [ string ](name='ResourceIds', description='A tag.', position='Body'),
  resourceType: string(name='ResourceType', description='The request ID.', example='INSTANCE', position='Body'),
  tags: [ 
    {
      key: string(name='key', description='The returned object.', example='env'),
      value: string(name='value', description='Indicates whether tags are added to the clusters. Valid values:

*   true
*   false', example='IT'),
    }
  ](name='Tags', description='The value of the tag.', position='Body'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', example='3D8795D9-8FF5-46B2-86E6-E3B407*******'),
  result?: boolean(name='Result', example='true'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TagResources', 'POST', '/openapi/tags', 'json', false, 'json', request);
}

model TransferNodeRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif1q9o8r0008****', position='Path'),
  body?: [ 
    {
      host?: string(name='host', example='192.168.xx.xx'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  nodeType: string(name='nodeType', example='WORKER', position='Query'),
}

model TransferNodeResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model TransferNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferNodeResponseBody(name='body'),
}

async function transferNode(request: TransferNodeRequest): TransferNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TransferNode', 'POST', '/openapi/instances/{InstanceId}/actions/transfer', 'json', false, 'json', request);
}

model TriggerNetworkRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  actionType: string(name='actionType', example='OPEN', position='Body'),
  networkType: string(name='networkType', example='PUBLIC', position='Body'),
  nodeType: string(name='nodeType', example='KIBANA', position='Body'),
  clientToken?: string(name='clientToken', example='407d02b74c49beb5bfdac7ec8bde2488', position='Query'),
}

model TriggerNetworkResponseBody = {
  requestId?: string(name='RequestId', example='5A5D8E74-565C-43DC-B031-29289FA****'),
  result?: boolean(name='Result', example='true'),
}

model TriggerNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TriggerNetworkResponseBody(name='body'),
}

async function triggerNetwork(request: TriggerNetworkRequest): TriggerNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TriggerNetwork', 'POST', '/openapi/instances/{InstanceId}/actions/network-trigger', 'json', false, 'json', request);
}

model UninstallKibanaPluginRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-6ja1ro4jt000c****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UninstallKibanaPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ string ](name='Result', description='The returned result shows a list of uninstalled plug-ins.'),
}

model UninstallKibanaPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallKibanaPluginResponseBody(name='body'),
}

async function uninstallKibanaPlugin(request: UninstallKibanaPluginRequest): UninstallKibanaPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UninstallKibanaPlugin', 'POST', '/openapi/instances/{InstanceId}/kibana-plugins/actions/uninstall', 'json', false, 'json', request);
}

model UninstallLogstashPluginRequest {
  instanceId: string(name='InstanceId', description='The list of plug-ins that have been uninstalled.', example='ls-cn-oew1qbgl****', position='Path'),
  body?: [ string ](name='body', example='["logstash-input-datahub", "logstash-input-maxcompute" ]', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UninstallLogstashPluginResponseBody = {
  headers?: map[string]any(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ string ](name='Result'),
}

model UninstallLogstashPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallLogstashPluginResponseBody(name='body'),
}

async function uninstallLogstashPlugin(request: UninstallLogstashPluginRequest): UninstallLogstashPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UninstallLogstashPlugin', 'POST', '/openapi/logstashes/{InstanceId}/plugins/actions/uninstall', 'json', false, 'json', request);
}

model UninstallPluginRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  force?: boolean(name='force', position='Query'),
}

model UninstallPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ string ](name='Result', description='The list of plug-ins to be unloaded. If the unloading fails, an exception is returned.'),
}

model UninstallPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallPluginResponseBody(name='body'),
}

async function uninstallPlugin(request: UninstallPluginRequest): UninstallPluginResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UninstallPlugin', 'POST', '/openapi/instances/{InstanceId}/plugins/actions/uninstall', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to delete all parts. Default value: **false** . This parameter is valid only when **TagKeys** is not specified.', example='false', position='Query'),
  resourceIds?: string(name='ResourceIds', description='The resource list that you want to delete.', example='["es-cn-09k1rocex0006****","es-cn-oew1rgiev0009****"]', position='Query'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Fixed to **INSTANCE** .', example='INSTANCE', position='Query'),
  tagKeys?: string(name='TagKeys', description='The list of tags that you want to delete. The list can contain up to 20 subitems.', example='["tagKey1","tagKey2"]', position='Query'),
  body?: string(name='body', position='Body'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6D******'),
  result?: boolean(name='Result', description='Return results:

*   true: deleted
*   false: Failed', example='true'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * *   You can only delete user tags.
  * > User labels are manually added to instances by users. A system Tag is a tag that Alibaba Cloud services add to instances. System labels are divided into visible labels and invisible labels.
  * *   If you delete a resource tag relationship that is not associated with any resources, you must delete the tags.
  *
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UntagResources', 'DELETE', '/openapi/tags', 'json', false, 'json', request);
}

model UpdateAdminPasswordRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-nif1q9o8r0008****', position='Path'),
  esAdminPassword?: string(name='esAdminPassword', example='es_password', minLength=8, maxLength=32, position='Body'),
  clientToken?: string(name='clientToken', description='Indicates whether the password was updated. Valid values:

*   true: The call was successful.
*   false: The call failed.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateAdminPasswordResponseBody = {
  requestId?: string(name='RequestId', example='0FA05123-745C-42FD-A69B-AFF48EF9****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateAdminPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAdminPasswordResponseBody(name='body'),
}

/**
  * 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
  *
 */
async function updateAdminPassword(request: UpdateAdminPasswordRequest): UpdateAdminPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAdminPassword', 'POST', '/openapi/instances/{InstanceId}/admin-pwd', 'json', false, 'json', request);
}

model UpdateAdvancedSettingRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-09k1ruw79000u****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateAdvancedSettingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: boolean(name='Result', description='Return results:

*   true: garbage collector configuration changed successfully
*   false: garbage collector configuration changed successfully failed', example='true'),
}

model UpdateAdvancedSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAdvancedSettingResponseBody(name='body'),
}

async function updateAdvancedSetting(request: UpdateAdvancedSettingRequest): UpdateAdvancedSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAdvancedSetting', 'POST', '/openapi/instances/{InstanceId}/actions/update-advanced-setting', 'json', false, 'json', request);
}

model UpdateAliwsDictRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateAliwsDictResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='6226'),
      name?: string(name='name', description='The name of the uploaded dictionary file.', example='aliws_ext_dict.txt'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='OSS'),
      type?: string(name='type', description='The dictionary type. The value is fixed as ALI_WS.', example='ALI_WS'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateAliwsDictResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAliwsDictResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following items:
  * *   Elasticsearch V5.X clusters do not support the analysis-aliws plug-in.
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
 */
async function updateAliwsDict(request: UpdateAliwsDictRequest): UpdateAliwsDictResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAliwsDict', 'PUT', '/openapi/instances/{InstanceId}/aliws-dict', 'json', false, 'json', request);
}

model UpdateApmRequest {
  instanceId: string(name='instanceId', example='apm-cn-i7m2fuae****', position='Path'),
  description?: string(name='description', example='APMtest', position='Body'),
  outputES?: string(name='outputES', example='es-cn-i7m2fsfhc001x****', position='Body'),
  outputESPassword?: string(name='outputESPassword', example='ESPassword****', position='Body'),
  outputESUserName?: string(name='outputESUserName', example='elastic', position='Body'),
  token?: string(name='token', example='AMPPassword****', position='Body'),
}

model UpdateApmResponseBody = {
  requestId?: string(name='RequestId', example='18061926-CC50-5F9B-9600-034C29F1D5B0'),
  result?: boolean(name='Result', example='true'),
}

model UpdateApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApmResponseBody(name='body'),
}

async function updateApm(request: UpdateApmRequest): UpdateApmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateApm', 'PUT', '/openapi/apm/{instanceId}', 'json', false, 'json', request);
}

model UpdateBlackIpsRequest {
  instanceId: string(name='InstanceId', position='Path'),
  clientToken?: string(name='clientToken', position='Query'),
}

model UpdateBlackIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
  }(name='Result'),
}

model UpdateBlackIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBlackIpsResponseBody(name='body'),
}

/**
  * @deprecated
  *
 */
// Deprecated
async function updateBlackIps(request: UpdateBlackIpsRequest): UpdateBlackIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateBlackIps', 'POST', '/openapi/instances/{InstanceId}/black-ips', 'json', false, 'json', request);
}

model UpdateCollectorRequest {
  resId: string(name='ResId', description='The shipper ID.', example='ct-cn-77uqof2s7rg5c****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content', description='The content of the configuration file.', example='filebeat.inputs:xxx'),
        fileName?: string(name='fileName', description='The name of the configuration file.', example='filebeat.yml'),
      }
    ](name='configs', description='The information about the configuration file for the shipper.'),
    dryRun?: boolean(name='dryRun', description='Indicates whether the shipper is checked and updated. Valid values:

*   true: The shipper is only checked.
*   false: The shipper is checked and updated.', example='false'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType', description='The type of the configuration items. Valid values:

*   collectorTargetInstance: indicates the information about the output of the shipper.
*   collectorDeployMachine: indicates the information about the machine on which the shipper is installed.
*   collectorElasticsearchForKibana: indicates the information about the Elasticsearch cluster for which Kibana Dashboard is enabled.', example='collectorDeployMachine'),
        enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether Kibana Monitoring is enabled. This parameter is returned only when **configType** is set to **collectorTargetInstance** and **instanceType** is set to **elasticsearch**. Valid values: true and false.', example='true'),
        groupId?: string(name='groupId', description='The machine group ID. This parameter is returned only when **configType** is set to **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
        host?: string(name='host', description='The address that is used to access Kibana over an internal network after you enable Kibana Dashboard. This parameter is returned only when **configType** is set to **collectorElasticsearchForKibana**.', example='es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId', description='The ID of the object that is associated with the shipper. If **configType** is set to **collectorTargetInstance**, the value of this parameter is the ID of the output of the shipper. If **configType** is set to **collectorDeployMachines** and **type** is set to **ACKCluster**, the value of this parameter is the ID of an ACK cluster.', example='es-cn-nif1z89fz003i****'),
        instanceType?: string(name='instanceType', description='The type of the output of the shipper. Valid values: elasticsearch and logstash. This parameter is returned only when **configType** is set to **collectorTargetInstance**.', example='elasticsearch'),
        kibanaHost?: string(name='kibanaHost', description='The address that is used to access Kibana over the Internet after you enable Kibana Dashboard. This parameter is returned only when **configType** is set to **collectorElasticsearchForKibana**.', example='https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus', description='The installation status of the shipper on an ECS instance. Valid values:

*   heartOk
*   heartLost
*   uninstalled
*   failed', example='heartOk'),
            instanceId?: string(name='instanceId', description='The ID of the ECS instance on which the shipper is installed.', example='i-bp13y63575oypr9d****'),
          }
        ](name='machines', description='This parameter is returned only when configType is set to collectorDeployMachine.

This parameter indicates the information about the ECS instances or ACK clusters on which the shipper is installed.'),
        protocol?: string(name='protocol', description='The transfer protocol that is used. It is the same as the protocol over which you can access the output of the shipper. Valid values: HTTP and HTTPS. This parameter is returned only when **configType** is set to **collectorTargetInstance**.', example='HTTP'),
        successPodsCount?: string(name='successPodsCount', description='The number of pods from which logs are successfully collected in the ACK cluster. This parameter is returned only when **configType** is set to **collectorDeployMachines** and **type** is set to **ACKCluster**.', example='8'),
        totalPodsCount?: string(name='totalPodsCount', description='The number of pods from which logs needed to be collected in the ACK cluster. This parameter is returned only when **configType** is set to **collectorDeployMachines** and **type** is set to **ACKCluster**.', example='10'),
        type?: string(name='type', description='The type of the machine on which the shipper is installed. This parameter is returned only when **configType** is set to **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
        userName?: string(name='userName', description='The username that is used to access the output of the shipper. Default value: elastic. This parameter is returned only when **configType** is set to **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
      }
    ](name='extendConfigs', description='The extended parameters that are configured for the shipper.'),
    gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-06-20T07:26:47.000+0000'),
    name?: string(name='name', description='The name of the shipper.', example='ct-test'),
    ownerId?: string(name='ownerId', description='The account ID.', example='16852099488*****'),
    resId?: string(name='resId', description='The shipper ID.', example='ct-cn-0v3xj86085dvq****'),
    resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.', example='fileBeat'),
    resVersion?: string(name='resVersion', description='The version of the shipper.', example='6.8.5_with_community'),
    status?: string(name='status', description='The status of the shipper. Valid values:

*   activing: The shipper is being initialized.
*   active: The shipper is in effect.', example='active'),
    vpcId?: string(name='vpcId', description='The ID of the VPC in which the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
  }(name='Result', description='The returned result.'),
}

model UpdateCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCollectorResponseBody(name='body'),
}

async function updateCollector(request: UpdateCollectorRequest): UpdateCollectorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCollector', 'PUT', '/openapi/collectors/{ResId}', 'json', false, 'json', request);
}

model UpdateCollectorNameRequest {
  resId: string(name='ResId', description='The ID of the shipper.', example='ct-cn-77uqof2s7rg5c****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateCollectorNameResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content', description='The content of the file.', example='- key: log\\n title: Log file content\\n description: >\\n Contains log file lines.\\n ....'),
        fileName?: string(name='fileName', description='The name of the file.', example='fields.yml'),
      }
    ](name='configs', description='The information about the configuration file of the shipper.'),
    dryRun?: boolean(name='dryRun', description='Indicates whether a dry run is performed. Valid values:

*   true
*   false', example='false'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType', description='The configuration type. Valid values:

*   collectorTargetInstance
*   collectorDeployMachine
*   collectorElasticsearchForKibana', example='collectorDeployMachine'),
        enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether monitoring is enabled. This parameter is returned if the value of **configType** is **collectorTargetInstance** and the value of **instanceType** is **elasticsearch**. Valid values:

*   true
*   false', example='true'),
        groupId?: string(name='groupId', description='The ID of the machine group. This parameter is returned if the value of **configType** is **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
        host?: string(name='host', description='The private endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='es-cn-4591jumei000u****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId', description='The ID of the resource that is associated with the shipper. If the value of **configType** is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='es-cn-n6w1o1****'),
        instanceType?: string(name='instanceType', description='The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='elasticsearch'),
        kibanaHost?: string(name='kibanaHost', description='The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='https://es-cn-4591jumei000u****.kibana.elasticsearch.aliyuncs.com:5601'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values: **heartOk**, **heartLost**, **uninstalled**, and **failed**.', example='heartOk'),
            instanceId?: string(name='instanceId', description='The IDs of the ECS instances.', example='c1b9fde5172b84f82b9928e825a7b8988'),
          }
        ](name='machines', description='The information about the ECS instances on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ECSInstanceId**.'),
        protocol?: string(name='protocol', description='The transmission protocol. Valid values: **HTTP** and **HTTPS**.', example='HTTP'),
        successPodsCount?: string(name='successPodsCount', description='The number of pods from which data is successfully collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='8'),
        totalPodsCount?: string(name='totalPodsCount', description='The total number of pods from which data is collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='10'),
        type?: string(name='type', description='The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
        userName?: string(name='userName', description='The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
      }
    ](name='extendConfigs', description='The extended configurations of the shipper.'),
    gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-06-20T07:26:47.000+0000'),
    name?: string(name='name', description='The name of the shipper.', example='ct-test'),
    ownerId?: string(name='ownerId', description='The account ID.', example='16852099488*****'),
    resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-77uqof2s7rg5c****'),
    resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and audiBeat.', example='fileBeat'),
    resVersion?: string(name='resVersion', description='The version of the shipper. The version of a shipper depends on the type of the machine on which the shipper is deployed.

*   Elastic Compute Service (ECS) instance: 6.8.5\\_with_community
*   Container Service for Kubernetes (ACK) cluster: 6.8.13\\_with_community', example='6.8.5_with_community'),
    status?: string(name='status', description='The status of the shipper. Valid values: activating and active.', example='active'),
    vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) where the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
  }(name='Result', description='The returned result.'),
}

model UpdateCollectorNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCollectorNameResponseBody(name='body'),
}

async function updateCollectorName(request: UpdateCollectorNameRequest): UpdateCollectorNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCollectorName', 'POST', '/openapi/collectors/{ResId}/actions/rename', 'json', false, 'json', request);
}

model UpdateComponentIndexRequest {
  instanceId: string(name='InstanceId', example='es-cn-t57p81n7ai89v****', position='Path'),
  name: string(name='name', example='component-openstore-index-template', position='Path'),
  meta?: map[string]any(name='_meta', example='{ "description": "set number of shards to one" }', position='Body'),
  template?: {
    aliases?: map[string]any(name='aliases', example='{}'),
    mappings?: map[string]any(name='mappings', example='{ "properties": { "@timestamp": { "type": "date" } } }'),
    settings?: map[string]any(name='settings', example='{ "index.number_of_replicas": 0 }'),
  }(name='template', position='Body'),
}

model UpdateComponentIndexResponseBody = {
  requestId?: string(name='requestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
}

model UpdateComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateComponentIndexResponseBody(name='body'),
}

async function updateComponentIndex(request: UpdateComponentIndexRequest): UpdateComponentIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateComponentIndex', 'PUT', '/openapi/instances/{InstanceId}/component-index/{name}', 'json', false, 'json', request);
}

model UpdateDescriptionRequest {
  instanceId: string(name='InstanceId', description='The return results.', example='es-cn-n6w1ptcb30009****', position='Path'),
  description?: string(name='description', example='aliyunes_name_test', position='Body'),
  clientToken?: string(name='clientToken', description='The new name of the instance.', example='5A2CFF0E-5718-45B5-9D4D-70B350****', position='Query'),
}

model UpdateDescriptionResponseBody = {
  requestId?: string(name='RequestId', example='FDF34727-1664-44C1-A8DA-3EB72D60****'),
  result?: {
    description?: string(name='description', example='aliyunes_test_name'),
  }(name='Result'),
}

model UpdateDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDescriptionResponseBody(name='body'),
}

async function updateDescription(request: UpdateDescriptionRequest): UpdateDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDescription', 'POST', '/openapi/instances/{InstanceId}/description', 'json', false, 'json', request);
}

model UpdateDiagnosisSettingsRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-45914gy290009****', position='Path'),
  clientToken?: string(name='ClientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
  lang?: string(name='lang', description='The language of the response. Default value: en.', example='en', position='Query'),
}

model UpdateDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: update successfully
*   false: update failed', example='true'),
}

model UpdateDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDiagnosisSettingsResponseBody(name='body'),
}

async function updateDiagnosisSettings(request: UpdateDiagnosisSettingsRequest): UpdateDiagnosisSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDiagnosisSettings', 'PUT', '/openapi/diagnosis/instances/{InstanceId}/settings', 'json', false, 'json', request);
}

model UpdateDictRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='es-cn-nif1q9o8r0008****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateDictResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='2782602'),
      name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='ORIGIN'),
      type?: string(name='type', description='The dictionary type. Valid values:

*   MAIN: IK main dicrionary
*   STOP: IK stopword list', example='MAIN'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateDictResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDictResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following items:
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
 */
async function updateDict(request: UpdateDictRequest): UpdateDictResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDict', 'PUT', '/openapi/instances/{InstanceId}/dict', 'json', false, 'json', request);
}

model UpdateDynamicSettingsRequest {
  instanceId?: string(name='InstanceId', position='Path'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  body?: string(name='body', position='Body'),
  mode?: string(name='mode', position='Query'),
}

model UpdateDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateDynamicSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDynamicSettingsResponseBody(name='body'),
}

async function updateDynamicSettings(request: UpdateDynamicSettingsRequest): UpdateDynamicSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDynamicSettings', 'PUT', '/openapi/instances/{InstanceId}/dynamic-settings', 'json', false, 'json', request);
}

model UpdateExtendConfigRequest {
  instanceId: string(name='InstanceId', example='es-cn-n6w1o1x0w001c****', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateExtendConfigResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', example='true'),
}

model UpdateExtendConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExtendConfigResponseBody(name='body'),
}

async function updateExtendConfig(request: UpdateExtendConfigRequest): UpdateExtendConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateExtendConfig', 'POST', '/openapi/instances/{InstanceId}/extend-configs/actions/update', 'json', false, 'json', request);
}

model UpdateExtendfilesRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='ls-cn-oew1qbgl****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateExtendfilesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the driver file. Unit: byte.', example='1853083'),
      name?: string(name='name', description='The name of the driver file.', example='mysql-connector-java-6.0.2.jar'),
      sourceType?: string(name='sourceType', description='The source of the driver file. This parameter is fixed as ORIGIN, which indicates that the driver file is retained.', example='ORIGIN'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExtendfilesResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items: You can call this operation only to delete the driver files that are uploaded to a Logstash cluster in the Alibaba Cloud Management Console. You can add or modify driver files only in the Alibaba Cloud Management Console.
  *
 */
async function updateExtendfiles(request: UpdateExtendfilesRequest): UpdateExtendfilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateExtendfiles', 'PUT', '/openapi/logstashes/{InstanceId}/extendfiles', 'json', false, 'json', request);
}

model UpdateHotIkDictsRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='es-cn-oew1q8bev0002****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateHotIkDictsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='6'),
      name?: string(name='name', description='The name of the dictionary file.', example='deploy_0.dic'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='OSS'),
      type?: string(name='type', description='The type of the dictionaries. Valid values:

*   MAIN: IK main dictionary
*   STOP: IK stopword list', example='MAIN'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateHotIkDictsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHotIkDictsResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following items:
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
 */
async function updateHotIkDicts(request: UpdateHotIkDictsRequest): UpdateHotIkDictsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateHotIkDicts', 'PUT', '/openapi/instances/{InstanceId}/ik-hot-dict', 'json', false, 'json', request);
}

model UpdateILMPolicyRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif24adwc0082w2ka****', position='Path'),
  policyName: string(name='PolicyName', example='my-policy', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='my-policy'),
}

model UpdateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateILMPolicyResponseBody(name='body'),
}

async function updateILMPolicy(request: UpdateILMPolicyRequest): UpdateILMPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateILMPolicy', 'PUT', '/openapi/instances/{InstanceId}/ilm-policies/{PolicyName}', 'json', false, 'json', request);
}

model UpdateIndexTemplateRequest {
  instanceId: string(name='InstanceId', example='es-cn-n6w24n9u900am****', position='Path'),
  indexTemplate: string(name='IndexTemplate', example='my-template', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='my-template'),
}

model UpdateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIndexTemplateResponseBody(name='body'),
}

async function updateIndexTemplate(request: UpdateIndexTemplateRequest): UpdateIndexTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateIndexTemplate', 'PUT', '/openapi/instances/{InstanceId}/index-templates/{IndexTemplate}', 'json', false, 'json', request);
}

model UpdateInstanceRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-n6w1ptcb30009****', position='Path'),
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration', position='Body'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration', position='Body'),
  instanceCategory?: string(name='instanceCategory', example='advanced', position='Body'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration', position='Body'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration', position='Body'),
  nodeAmount?: int32(name='nodeAmount', example='3', position='Body'),
  nodeSpec?: NodeSpec(name='nodeSpec', position='Body'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration', position='Body'),
  clientToken?: string(name='clientToken', description='The result of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  force?: boolean(name='force', example='false', position='Query'),
  orderActionType?: string(name='orderActionType', description='The number of data nodes.', example='upgrade', position='Query'),
}

model UpdateInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='The time when the instance was created.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    createdAt?: string(name='createdAt', description='The private domain name of the instance.', example='2018-07-13T03:58:07.253Z'),
    description?: string(name='description', description='The configuration of data nodes.', example='test'),
    domain?: string(name='domain', description='The ID of the instance.', example='es-cn-abc.elasticsearch.aliyuncs.com'),
    esVersion?: string(name='esVersion', description='The node specifications.', example='5.5.3_with_X-Pack'),
    instanceId?: string(name='instanceId', description='The storage space of the node. Unit: GB.', example='es-cn-abc'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', description='The configuration of dedicated master nodes.', example='1'),
      disk?: int32(name='disk', description='The node specifications.', example='20'),
      diskType?: string(name='diskType', description='The number of nodes.', example='cloud_ssd'),
      spec?: string(name='spec', description='The storage type of the node. This parameter can be ignored.', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration', description='The size of the node storage space.'),
    masterConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='20'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      spec?: string(name='spec', description='The storage type of the node. Only cloud_ssd(SSD cloud disk) is supported.', example='elasticsearch.sn2ne.large'),
    }(name='masterConfiguration', description='The storage space of the node. Unit: GB.'),
    nodeAmount?: int32(name='nodeAmount', description='The billing method of the instance. Valid values:

*   prepaid: subscription
*   postpaid: pay-as-you-go', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='The node specifications.', example='40'),
      diskType?: string(name='diskType', description='The number of nodes.', example='cloud_ssd'),
      spec?: string(name='spec', description='The configuration of Kibana nodes.', example='elasticsearch.sn2ne.xlarge'),
    }(name='nodeSpec', description='The storage type of the node. Valid values:

*   cloud_ssd: standard SSD
*   cloud_efficiency: ultra disk'),
    paymentType?: string(name='paymentType', description='The edition of the dedicated KMS instance.', example='postpaid'),
    status?: string(name='status', description='The name of the instance.', example='active'),
  }(name='Result', description='The state of the instance. Valid values:

*   active: normal
*   activating: taking effect
*   inactive: frozen
*   invalid: invalid'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceResponseBody(name='body'),
}

/**
  * es-cn-n6w1ptcb30009\\*\\*\\*\\*
  *
 */
async function updateInstance(request: UpdateInstanceRequest): UpdateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateInstance', 'PUT', '/openapi/instances/{InstanceId}', 'json', false, 'json', request);
}

model UpdateInstanceChargeTypeRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-0pp1jxvcl000z****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateInstanceChargeTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: boolean(name='Result', description='Return results:

*   true: conversion successful
*   false: conversion failed', example='true'),
}

model UpdateInstanceChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceChargeTypeResponseBody(name='body'),
}

async function updateInstanceChargeType(request: UpdateInstanceChargeTypeRequest): UpdateInstanceChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateInstanceChargeType', 'POST', '/openapi/instances/{InstanceId}/actions/convert-pay-type', 'json', false, 'json', request);
}

model UpdateInstanceSettingsRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-nif1q9o8r0008****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateInstanceSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BB1C321A-211C-4FD7-BD8B-7F2FABE2****'),
}

model UpdateInstanceSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceSettingsResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * When the instance is in the activating, invalid, or inactive state, you cannot update the configuration.
  *
 */
async function updateInstanceSettings(request: UpdateInstanceSettingsRequest): UpdateInstanceSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateInstanceSettings', 'POST', '/openapi/instances/{InstanceId}/instance-settings', 'json', false, 'json', request);
}

model UpdateKibanaSettingsRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='This parameter is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B350****', position='Query'),
}

model UpdateKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC*****'),
  result?: boolean(name='Result', description='Return results:

*   true: The Kibana language modified successfully
*   false: The Kibana language modified failed', example='true'),
}

model UpdateKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateKibanaSettingsResponseBody(name='body'),
}

async function updateKibanaSettings(request: UpdateKibanaSettingsRequest): UpdateKibanaSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateKibanaSettings', 'POST', '/openapi/instances/{InstanceId}/actions/update-kibana-settings', 'json', false, 'json', request);
}

model UpdateKibanaWhiteIpsRequest {
  instanceId: string(name='InstanceId', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='es-cn-tl329rbpc0001****', position='Path'),
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist', description='The IP address whitelists. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.

You cannot configure both the kibanaIPWhitelist and whiteIpGroup parameters.', position='Body'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='The type of the whitelist. Set the value to PUBLIC_KIBANA. This value indicates a public IP address whitelist.', example='test_group_name'),
    ips?: [ string ](name='ips', description='The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
    whiteIpType?: string(name='whiteIpType', description='The IP addresses in the whitelist.', example='PUBLIC_KIBANA'),
  }(name='whiteIpGroup', description='The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.', position='Body'),
  clientToken?: string(name='clientToken', description='The update mode. Valid values:

*   Cover: overwrites the IP addresses in the specified IP address whitelist with the IP addresses specified by using the ips parameter. This is the default value.
*   Append: adds the IP addresses specified by using the ips parameter to the specified IP address whitelist.
*   Delete: deletes the IP addresses specified by using the ips parameter from the specified IP address whitelist. At least one IP address must be retained for the whitelist.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  modifyMode?: string(name='modifyMode', description='The body of the request.', example='Cover', position='Query'),
}

model UpdateKibanaWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', description='The details of the Elasticsearch cluster.', example='E5EF11F1-DBAE-4020-AC24-DFA6C4345CAE'),
  result?: {
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist', description='The public IP address whitelists for access to the Kibana console of the cluster.'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist', description='The private IP address whitelists for access to the Kibana console of the cluster.'),
    networkConfig?: {
      type?: string(name='type', description='The IP address whitelists.', example='vpc'),
      vpcId?: string(name='vpcId', description='The ID of the vSwitch.', example='vpc-bp1jy348ibzulk6hn****'),
      vsArea?: string(name='vsArea', description='The network type.', example='cn-hangzhou-h'),
      vswitchId?: string(name='vswitchId', description='The region ID.', example='vsw-bp1a0mifpletdd1da****'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName', description='The IP addresses in the whitelist.', example='test_group_name'),
          ips?: [ string ](name='ips', description='The IP addresses in the whitelist.'),
          whiteIpType?: string(name='whiteIpType', example='PUBLIC_KIBANA'),
        }
      ](name='whiteIpGroupList', description='The IP address whitelists.'),
    }(name='networkConfig', description='The ID of the virtual private cloud (VPC).'),
  }(name='Result', description='The private IP address whitelists for access to the Kibana console of the cluster.'),
}

model UpdateKibanaWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateKibanaWhiteIpsResponseBody(name='body'),
}

/**
  * *   Before you call this operation, you must make sure that the cluster is not in the activating, invalid, or inactive state.
  * *   You can update an IP address whitelist by using the following parameters:
  *     *   kibanaIPWhitelist
  *     *   modifyMode and whiteIpGroup
  * *   You cannot specify private IP addresses for public IP address whitelists and cannot specify public IP addresses for private IP address whitelists.
  *
 */
async function updateKibanaWhiteIps(request: UpdateKibanaWhiteIpsRequest): UpdateKibanaWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateKibanaWhiteIps', 'POST', '/openapi/instances/{InstanceId}/kibana-white-ips', 'json', false, 'json', request);
}

model UpdateLogstashRequest {
  instanceId: string(name='InstanceId', example='ls-cn-n6w1o5jq****', position='Path'),
  nodeAmount?: int32(name='nodeAmount', example='3', minimum=1, maximum=20, position='Body'),
  nodeSpec?: {
    disk?: int32(name='disk', example='20', minimum=20, maximum=2048),
    diskType?: string(name='diskType', example='cloud_efficiency'),
    spec?: string(name='spec', example='elasticsearch.sn1ne.large'),
  }(name='nodeSpec', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateLogstashResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashResponseBody(name='body'),
}

async function updateLogstash(request: UpdateLogstashRequest): UpdateLogstashResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogstash', 'PUT', '/openapi/logstashes/{InstanceId}', 'json', false, 'json', request);
}

model UpdateLogstashChargeTypeRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='ls-cn-n6w1o5jq****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateLogstashChargeTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Indicates whether the billing method of the cluster is switched. Valid values:

*   true: The billing method is switched.
*   false: The billing method fails to be switched.', example='true'),
}

model UpdateLogstashChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashChargeTypeResponseBody(name='body'),
}

async function updateLogstashChargeType(request: UpdateLogstashChargeTypeRequest): UpdateLogstashChargeTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogstashChargeType', 'POST', '/openapi/logstashes/{InstanceId}/actions/convert-pay-type', 'json', false, 'json', request);
}

model UpdateLogstashDescriptionRequest {
  instanceId: string(name='InstanceId', description='The ID of the cluster.', example='ls-cn-n6w1o5jq****', position='Path'),
  description?: string(name='description', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateLogstashDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    description?: string(name='description', description='The name of the cluster.', example='logstash_name'),
  }(name='Result', description='The result returned.'),
}

model UpdateLogstashDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashDescriptionResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items: You cannot change the name of a cluster that is in the activating, invalid, or inactive state.
  *
 */
async function updateLogstashDescription(request: UpdateLogstashDescriptionRequest): UpdateLogstashDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogstashDescription', 'POST', '/openapi/logstashes/{InstanceId}/description', 'json', false, 'json', request);
}

model UpdateLogstashSettingsRequest {
  instanceId: string(name='InstanceId', description='ls-cn-2r42btxr\\*\\*\\*\\*', example='ls-cn-2r42btxr****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateLogstashSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='71D0D1DA-B22F-58CB-AF5B-D1657A6A****'),
}

model UpdateLogstashSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashSettingsResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * If the instance is in the Active (activating), Invalid (invalid), and Inactive (inactive) state, the information cannot be updated.
  *
 */
async function updateLogstashSettings(request: UpdateLogstashSettingsRequest): UpdateLogstashSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLogstashSettings', 'POST', '/openapi/logstashes/{InstanceId}/instance-settings', 'json', false, 'json', request);
}

model UpdatePipelineManagementConfigRequest {
  instanceId: string(name='InstanceId', example='ls-cn-oew1qbgl****', position='Path'),
  endpoints?: [ string ](name='endpoints', position='Body'),
  password?: string(name='password', example='******', position='Body'),
  pipelineIds?: [ string ](name='pipelineIds', position='Body'),
  pipelineManagementType?: string(name='pipelineManagementType', example='ES', position='Body'),
  userName?: string(name='userName', example='elastic', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdatePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdatePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelineManagementConfigResponseBody(name='body'),
}

async function updatePipelineManagementConfig(request: UpdatePipelineManagementConfigRequest): UpdatePipelineManagementConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePipelineManagementConfig', 'POST', '/openapi/logstashes/{InstanceId}/pipeline-management-config', 'json', false, 'json', request);
}

model UpdatePipelinesRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-oew1qbgl****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  trigger?: boolean(name='trigger', description='Specifies whether to deploy the pipeline immediately.', example='false', position='Query'),
}

model UpdatePipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Indicates whether the pipeline is updated. Valid values:

*   true: The pipeline is updated.
*   false: The pipeline fails to be updated.', example='true'),
}

model UpdatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelinesResponseBody(name='body'),
}

async function updatePipelines(request: UpdatePipelinesRequest): UpdatePipelinesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePipelines', 'PUT', '/openapi/logstashes/{InstanceId}/pipelines', 'json', false, 'json', request);
}

model UpdatePrivateNetworkWhiteIpsRequest {
  instanceId: string(name='InstanceId', description='Cover', example='es-cn-tl329rbpc0001****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  modifyMode?: string(name='modifyMode', description='The results that are returned.', example='Cover', position='Query'),
}

model UpdatePrivateNetworkWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', example='6DEBE5EE-0368-4757-8F82-EF9C3972****'),
  result?: {
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  }(name='Result'),
}

model UpdatePrivateNetworkWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePrivateNetworkWhiteIpsResponseBody(name='body'),
}

/**
  * >  In the following returned example, only the parameters in the returned data list are guaranteed to be included, and the parameters not mentioned are for reference only. For more information about the parameters, see [ListInstance](~~142230~~). You cannot force a dependency in a program to get these parameters.
  *
 */
async function updatePrivateNetworkWhiteIps(request: UpdatePrivateNetworkWhiteIpsRequest): UpdatePrivateNetworkWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePrivateNetworkWhiteIps', 'POST', '/openapi/instances/{InstanceId}/private-network-white-ips', 'json', false, 'json', request);
}

model UpdatePublicNetworkRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-nif1q9o8r0008****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdatePublicNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2A88ECA1-D827-4581-AD39-05149586****'),
  result?: {
    enablePublic?: boolean(name='enablePublic', description='The status of the public network access switch.', example='false'),
  }(name='Result', description='The return results.'),
}

model UpdatePublicNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicNetworkResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * When the instance is in the activating, invalid, or inactive state, its configuration cannot be updated.
  *
 */
async function updatePublicNetwork(request: UpdatePublicNetworkRequest): UpdatePublicNetworkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePublicNetwork', 'POST', '/openapi/instances/{InstanceId}/public-network', 'json', false, 'json', request);
}

model UpdatePublicWhiteIpsRequest {
  instanceId: string(name='InstanceId', description='Cover', example='es-cn-tl329rbpc0001****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  modifyMode?: string(name='modifyMode', description='The results that are returned.', example='Cover', position='Query'),
}

model UpdatePublicWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', example='C82758DD-282F-4D48-934F-92170A33****'),
  result?: {
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  }(name='Result'),
}

model UpdatePublicWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicWhiteIpsResponseBody(name='body'),
}

/**
  * >  In the following example, only the parameters in the returned data list are guaranteed to be included. The parameters that are not mentioned are for reference only. For more information about the parameters, see [ListInstance](~~142230~~). You cannot force a dependency in a program to get these parameters.
  *
 */
async function updatePublicWhiteIps(request: UpdatePublicWhiteIpsRequest): UpdatePublicWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdatePublicWhiteIps', 'POST', '/openapi/instances/{InstanceId}/public-white-ips', 'json', false, 'json', request);
}

model UpdateReadWritePolicyRequest {
  instanceId: string(name='InstanceId', example='es-cn-oew1oxiro000f****', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model UpdateReadWritePolicyResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateReadWritePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateReadWritePolicyResponseBody(name='body'),
}

async function updateReadWritePolicy(request: UpdateReadWritePolicyRequest): UpdateReadWritePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateReadWritePolicy', 'POST', '/openapi/instances/{InstanceId}/actions/update-read-write-policy', 'json', false, 'json', request);
}

model UpdateSnapshotSettingRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance.', example='es-cn-oew1rgiev0009****', position='Path'),
  body?: string(name='body', position='Body'),
}

model UpdateSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: {
    enable?: boolean(name='enable', description='Specifies whether to enable automatic backup.', example='true'),
    quartzRegex?: string(name='quartzRegex', description='The start time of automatic backup.', example='0 0 01 ? * * *'),
  }(name='Result', description='The return results.'),
}

model UpdateSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSnapshotSettingResponseBody(name='body'),
}

async function updateSnapshotSetting(request: UpdateSnapshotSettingRequest): UpdateSnapshotSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateSnapshotSetting', 'POST', '/openapi/instances/{InstanceId}/snapshot-setting', 'json', false, 'json', request);
}

model UpdateSynonymsDictsRequest {
  instanceId: string(name='InstanceId', description='The cluster ID.', example='es-cn-nif1q9o8r0008****', position='Path'),
  body?: string(name='body', position='Body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model UpdateSynonymsDictsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7C5622CC-B312-426F-85AA-B0271*******'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='220'),
      name?: string(name='name', description='The name of the dictionary file.', example='deploy_0.txt'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='OSS'),
      type?: string(name='type', description='The dictionary type. The value is fixed as SYNONYMS.', example='SYNONYMS'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateSynonymsDictsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSynonymsDictsResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following items:
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
 */
async function updateSynonymsDicts(request: UpdateSynonymsDictsRequest): UpdateSynonymsDictsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateSynonymsDicts', 'PUT', '/openapi/instances/{InstanceId}/synonymsDict', 'json', false, 'json', request);
}

model UpdateTemplateRequest {
  instanceId: string(name='InstanceId', example='es-cn-n6w1o1x0w001c****', position='Path'),
  templateName: string(name='TemplateName', example='dynamicSettings', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', example='{     "content": "{\\n\\t\\"persistent\\":{\\n\\t\\t\\"search\\":{\\n\\t\\t\\t\\"max_buckets\\":\\"10000\\"\\n\\t\\t}\\n\\t}\\n}" }', position='Body'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTemplate', 'POST', '/openapi/instances/{InstanceId}/templates/{TemplateName}', 'json', false, 'json', request);
}

model UpdateWhiteIpsRequest {
  instanceId: string(name='InstanceId', description='The request body.', example='es-cn-npk2154oi000b****', position='Path'),
  esIPWhitelist?: [ string ](name='esIPWhitelist', description='The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.', position='Body'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='The type of the whitelist. Set the value to **PRIVATE_ES**. This value indicates a private IP address whitelist.', example='test_group'),
    ips?: [ string ](name='ips', description='The returned result.'),
    whiteIpType?: string(name='whiteIpType', description='The returned result.', example='PRIVATE_ES'),
  }(name='whiteIpGroup', description='The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.', position='Body'),
  clientToken?: string(name='clientToken', description='The IP addresses in the whitelist.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  modifyMode?: string(name='modifyMode', description='The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.

>  You cannot configure both the esIPWhitelist and whiteIpGroup parameters.', example='Cover', position='Query'),
}

model UpdateWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', description='The updated whitelist.', example='8D58B014-BBD7-4D80-B219-00B9D5C6860C'),
  result?: {
    esIPWhitelist?: [ string ](name='esIPWhitelist', description='The list of whitelists.'),
    networkConfig?: {
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName', description='The type of the whitelist. The value of this parameter is fixed as PRIVATE_ES, which indicates a private IP address whitelist.', example='test_group'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType', example='PRIVATE_ES'),
        }
      ](name='whiteIpGroupList', description='The IP addresses in the whitelist.'),
    }(name='networkConfig', description='The name of the whitelist. By default, the default whitelist is included.'),
  }(name='Result', description='The network configurations.'),
}

model UpdateWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWhiteIpsResponseBody(name='body'),
}

/**
  * > For more information about the parameters displayed in the following sample code but not provided in the preceding tables, see [ListInstance](~~142230~~). You cannot force your program to obtain these parameters.
  *
 */
async function updateWhiteIps(request: UpdateWhiteIpsRequest): UpdateWhiteIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateWhiteIps', 'POST', '/openapi/instances/{InstanceId}/white-ips', 'json', false, 'json', request);
}

model UpdateXpackMonitorConfigRequest {
  instanceId: string(name='InstanceId', example='ls-cn-oew1qbgl****', position='Path'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  enable?: boolean(name='enable', example='true', position='Body'),
  endpoints?: [ string ](name='endpoints', position='Body'),
  password?: string(name='password', example='******', position='Body'),
  userName?: string(name='userName', example='elastic', position='Body'),
}

model UpdateXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', example='true'),
}

model UpdateXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateXpackMonitorConfigResponseBody(name='body'),
}

async function updateXpackMonitorConfig(request: UpdateXpackMonitorConfigRequest): UpdateXpackMonitorConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateXpackMonitorConfig', 'POST', '/openapi/logstashes/{InstanceId}/xpack-monitor-config', 'json', false, 'json', request);
}

model UpgradeEngineVersionRequest {
  instanceId: string(name='InstanceId', description='The ID of the request.', example='es-cn-n6w1o1x0w001c****', position='Path'),
  type?: string(name='type', example='engineVersion', position='Body'),
  version?: string(name='version', example='6.7', position='Body'),
  clientToken?: string(name='clientToken', description='The moderation results.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  dryRun?: boolean(name='dryRun', description='The monitoring type. Valid values:

*   checkClusterHealth: Cluster Health Status
*   checkConfigCompatible: Configuration Compatibility Status
*   checkClusterResource: resource space status
*   checkClusterSnapshot: Whether a snapshot exists', example='false', position='Query'),
}

model UpgradeEngineVersionResponseBody = {
  requestId?: string(name='RequestId', description='The verification information.', example='F99407AB-2FA9-489E-A259-40CF6DC*****'),
  result?: [ 
    {
      status?: string(name='status', example='success'),
      validateResult?: [ 
        {
          errorCode?: string(name='errorCode', example='ClusterStatusNotHealth'),
          errorMsg?: string(name='errorMsg', example='The cluster status is not health'),
          errorType?: string(name='errorType', description='The verification is passed. Valid values:

*   success: through
*   failed: failed', example='clusterStatus'),
        }
      ](name='validateResult', description='The error message returned.'),
      validateType?: string(name='validateType', description='The error code returned if the request failed.', example='checkClusterHealth'),
    }
  ](name='Result', description='The type of the error. Valid values:

*   clusterStatus: the health status of the cluster.
*   clusterConfigYml: Cluster YML File
*   clusterConfigPlugins: Cluster Configuration File
*   clusterResource: cluster resources
*   clusterSnapshot: cluster snapshot'),
}

model UpgradeEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeEngineVersionResponseBody(name='body'),
}

/**
  * 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
  *
 */
async function upgradeEngineVersion(request: UpgradeEngineVersionRequest): UpgradeEngineVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpgradeEngineVersion', 'POST', '/openapi/instances/{InstanceId}/actions/upgrade-version', 'json', false, 'json', request);
}

model ValidateConnectionRequest {
  instanceId: string(name='InstanceId', description='The ID of the Logstash cluster.', example='ls-cn-oew1qbgl****', position='Path'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  body?: string(name='body', position='Body'),
}

model ValidateConnectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='Indicates whether the connectivity is normal. Valid values:

*   true
*   false', example='true'),
}

model ValidateConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateConnectionResponseBody(name='body'),
}

/**
  * > Before you enable the X-Pack Monitoring feature for a Logstash cluster, you must associate the Logstash cluster with an Elasticsearch cluster. This way, you can view the monitoring data of the Logstash cluster in the Kibana console of the Elasticsearch cluster.
  *
 */
async function validateConnection(request: ValidateConnectionRequest): ValidateConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ValidateConnection', 'POST', '/openapi/logstashes/{InstanceId}/validate-connection', 'json', false, 'json', request);
}

model ValidateShrinkNodesRequest {
  instanceId: string(name='InstanceId', description='2', example='es-cn-nif1q9o8r0008****', position='Path'),
  body?: [ 
    {
      host?: string(name='host', example='192.168.xx.xx'),
      hostName?: string(name='hostName', example='es-cn-pl32xxxxxxx-data-f-1'),
      nodeType?: string(name='nodeType', example='WORKER'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body', position='Body'),
  count?: int32(name='count', example='2', position='Query'),
  ignoreStatus?: boolean(name='ignoreStatus', description='The ID of the request.', example='false', position='Query'),
  nodeType: string(name='nodeType', description='Returned results:

*   true: can be scaled in
*   false: cannot be scaled in.', example='WORKER', position='Query'),
}

model ValidateShrinkNodesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model ValidateShrinkNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateShrinkNodesResponseBody(name='body'),
}

async function validateShrinkNodes(request: ValidateShrinkNodesRequest): ValidateShrinkNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ValidateShrinkNodes', 'POST', '/openapi/instances/{InstanceId}/validate-shrink-nodes', 'json', false, 'json', request);
}

model ValidateSlrPermissionRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
  rolename: string(name='rolename', example='AliyunServiceRoleForElasticsearchCollector', position='Query'),
}

model ValidateSlrPermissionResponseBody = {
  requestId?: string(name='RequestId', example='BC4ED7DD-8C84-49B5-8A95-456F82E44D13'),
  result?: boolean(name='Result', example='true'),
}

model ValidateSlrPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateSlrPermissionResponseBody(name='body'),
}

async function validateSlrPermission(request: ValidateSlrPermissionRequest): ValidateSlrPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ValidateSlrPermission', 'GET', '/openapi/user/servicerolepermission', 'json', false, 'json', request);
}

model ValidateTransferableNodesRequest {
  instanceId: string(name='InstanceId', example='es-cn-nif1q9o8r0008****', position='Path'),
  body?: [ 
    {
      host?: string(name='host', example='172.16.xx.xx'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body', position='Body'),
  nodeType: string(name='nodeType', example='WORKER', position='Query'),
}

model ValidateTransferableNodesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model ValidateTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateTransferableNodesResponseBody(name='body'),
}

async function validateTransferableNodes(request: ValidateTransferableNodesRequest): ValidateTransferableNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ValidateTransferableNodes', 'POST', '/openapi/instances/{InstanceId}/validate-transfer-nodes', 'json', false, 'json', request);
}

model CreateInstanceRequest {
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration', position='Body'),
  description?: string(name='description', example='es', position='Body'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration', position='Body'),
  esAdminPassword: string(name='esAdminPassword', example='es_password', position='Body'),
  esVersion: string(name='esVersion', example='5.5.3_with_X-Pack', position='Body'),
  instanceCategory?: string(name='instanceCategory', example='advanced', position='Body'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration', position='Body'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration', position='Body'),
  networkConfig: NetworkConfig(name='networkConfig', position='Body'),
  nodeAmount: int32(name='nodeAmount', example='3', position='Body'),
  nodeSpec?: NodeSpec(name='nodeSpec', position='Body'),
  paymentInfo?: PaymentInfo(name='paymentInfo', position='Body'),
  paymentType?: string(name='paymentType', example='postpaid', position='Body'),
  resourceGroupId?: string(name='resourceGroupId', example='rg-aekzu7tsu4nem4q', position='Body'),
  tags?: [ 
    {
      tagKey?: string(name='tagKey'),
      tagValue?: string(name='tagValue'),
    }
  ](name='tags', position='Body'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration', position='Body'),
  zoneCount?: int32(name='zoneCount', example='2', position='Body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****', position='Query'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * The configurations of warm nodes.
  *
 */
async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'createInstance', 'POST', '/openapi/instances', 'none', false, 'json', request);
}

