/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('elasticsearch', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ClientNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskType?: string(name='diskType'),
  spec?: string(name='spec'),
}

model CollectorDeployMachine {
  configType?: string(name='configType', example='collectorDeployMachine'),
  groupId?: string(name='groupId', example='default_ct-cn-f3t0dq5p97199ru3z'),
  instanceId?: string(name='instanceId', example='ce93d7566df2141f490f0f60f646252c3'),
  machines?: [ 
    {
      agentStatus?: string(name='agentStatus', example='UNINSTALLED'),
      instanceId?: string(name='instanceId', example='i-xs34****'),
    }
  ](name='machines'),
  successPodsCount?: string(name='successPodsCount', example='1'),
  totalPodsCount?: string(name='totalPodsCount', example='2'),
  type?: string(name='type', example='ACKCluster'),
}

model CollectorKibanaInstance {
  configType?: string(name='configType', example='collectorElasticsearchForKibana'),
  host?: string(name='host', example='es-cn-*****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
  instanceId?: string(name='instanceId', example='es-cn-45dfy****'),
  kibanaHost?: string(name='kibanaHost', example='https://es-cn-****.kibana.elasticsearch.aliyuncs.com:5601'),
  password?: string(name='password', example='password'),
  protocol?: string(name='protocol', example='HTTP'),
  userName?: string(name='userName', example='username'),
}

model CollectorTargetInstance {
  configType?: string(name='configType', example='collectorTargetInstance'),
  enableMonitoring?: boolean(name='enableMonitoring', example='false'),
  hosts?: [ string ](name='hosts'),
  instanceId?: string(name='instanceId', example='es-cn-ks8x****'),
  instanceType?: string(name='instanceType', example='elasticsearch'),
  password?: string(name='password', example='password'),
  protocol?: string(name='protocol', example='HTTP'),
  userName?: string(name='userName', example='username'),
}

model DictInfo {
  fileSize?: long(name='fileSize'),
  name?: string(name='name'),
  sourceType?: string(name='sourceType'),
  type?: string(name='type'),
}

model ElasticDataNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec?: string(name='spec'),
}

model Elasticsearch {
  advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
  advancedSetting?: {
    gcName?: string(name='gcName'),
  }(name='advancedSetting'),
  aliwsDicts?: [
    DictInfo
  ](name='aliwsDicts'),
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration'),
  createdAt?: string(name='createdAt'),
  dataNode?: boolean(name='dataNode'),
  dedicateMaster?: boolean(name='dedicateMaster'),
  description?: string(name='description'),
  dictList?: [
    DictInfo
  ](name='dictList'),
  domain?: string(name='domain'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork'),
  enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork'),
  enablePublic?: boolean(name='enablePublic'),
  endTime?: long(name='endTime'),
  esConfig?: map[string]string(name='esConfig'),
  esIPWhitelist?: [ string ](name='esIPWhitelist'),
  esVersion?: string(name='esVersion'),
  extendConfigs?: [  map[string]any ](name='extendConfigs'),
  haveClientNode?: boolean(name='haveClientNode'),
  haveElasticDataNode?: boolean(name='haveElasticDataNode'),
  haveKibana?: boolean(name='haveKibana'),
  ikHotDicts?: [
    DictInfo
  ](name='ikHotDicts'),
  instanceId?: string(name='instanceId'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  kibanaDomain?: string(name='kibanaDomain'),
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
  kibanaPort?: long(name='kibanaPort'),
  kibanaPrivateDomain?: string(name='kibanaPrivateDomain'),
  kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
  kibanaPrivatePort?: long(name='kibanaPrivatePort'),
  kibanaProtocol?: string(name='kibanaProtocol'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  networkConfig?: NetworkConfig(name='networkConfig'),
  nodeAmount?: long(name='nodeAmount'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  paymentType?: string(name='paymentType'),
  port?: long(name='port'),
  privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  productType?: string(name='productType'),
  protocol?: string(name='protocol'),
  publicDomain?: string(name='publicDomain'),
  publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  publicPort?: long(name='publicPort'),
  readWritePolicy?: ReadWritePolicy(name='readWritePolicy'),
  resourceGroupId?: string(name='resourceGroupId'),
  serviceVpc?: boolean(name='serviceVpc'),
  status?: string(name='status'),
  synonymsDicts?: [
    DictInfo
  ](name='synonymsDicts'),
  tags?: [
    Tag
  ](name='tags'),
  updatedAt?: string(name='updatedAt'),
  warmNode?: boolean(name='warmNode'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  zoneCount?: long(name='zoneCount'),
  zoneInfos?: [
    ZoneInfo
  ](name='zoneInfos'),
}

model KibanaNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  spec?: string(name='spec'),
}

model Logstash {
  config?: map[string]string(name='config'),
  createdAt?: string(name='createdAt'),
  dataNode?: boolean(name='dataNode'),
  description?: string(name='description'),
  endTime?: long(name='endTime'),
  endpointList?: [ 
    {
      host?: string(name='host'),
      port?: long(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='endpointList'),
  instanceId?: string(name='instanceId'),
  networkConfig?: {
    type?: string(name='type'),
    vpcId?: string(name='vpcId'),
    vsArea?: string(name='vsArea'),
    vswitchId?: string(name='vswitchId'),
  }(name='networkConfig'),
  nodeAmount?: long(name='nodeAmount'),
  nodeSpec?: {
    disk?: long(name='disk'),
    diskType?: string(name='diskType'),
    spec?: string(name='spec'),
  }(name='nodeSpec'),
  paymentType?: string(name='paymentType'),
  protocol?: string(name='protocol'),
  resourceGroupId?: string(name='resourceGroupId'),
  status?: string(name='status'),
  tags?: [ 
    {
      tagKey?: string(name='tagKey'),
      tagValue?: string(name='tagValue'),
    }
  ](name='tags'),
  updatedAt?: string(name='updatedAt'),
  version?: string(name='version'),
  zoneCount?: long(name='zoneCount'),
  zoneInfos?: [ 
    {
      status?: string(name='status'),
      zoneId?: string(name='zoneId'),
    }
  ](name='zoneInfos'),
}

model MasterNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskType?: string(name='diskType'),
  spec?: string(name='spec'),
}

model MigrationJob {
  currentState?: string(name='currentState'),
  disableSourceClusterAuth?: boolean(name='disableSourceClusterAuth'),
  disableTargetClusterAuth?: boolean(name='disableTargetClusterAuth'),
  endTime?: long(name='endTime'),
  migrationJobId?: string(name='migrationJobId'),
  phase?: string(name='phase'),
  sourceCluster?: {
    instanceId?: string(name='instanceId'),
    type?: string(name='type'),
  }(name='sourceCluster'),
  startTime?: long(name='startTime'),
  statusResult?: [ 
    {
      code?: string(name='code'),
      success?: boolean(name='success'),
    }
  ](name='statusResult'),
  targetCluster?: {
    instanceId?: string(name='instanceId'),
    type?: string(name='type'),
  }(name='targetCluster'),
  updateTime?: long(name='updateTime'),
}

model NetworkConfig {
  type?: string(name='type'),
  vpcId?: string(name='vpcId'),
  vsArea?: string(name='vsArea'),
  vswitchId?: string(name='vswitchId'),
  whiteIpGroupList?: [
    WhiteIpGroup
  ](name='whiteIpGroupList'),
}

model NodeInfo {
  host?: string(name='host'),
  hostName?: string(name='hostName'),
  port?: long(name='port'),
  zoneId?: string(name='zoneId'),
}

model NodeSpec {
  disk?: int32(name='disk'),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec?: string(name='spec'),
}

model PaymentInfo {
  autoRenewDuration?: long(name='autoRenewDuration'),
  duration?: long(name='duration'),
  isAutoRenew?: boolean(name='isAutoRenew'),
  pricingCycle?: string(name='pricingCycle'),
}

model ReadWritePolicy {
  autoGeneratePk?: boolean(name='autoGeneratePk'),
  writeHa?: boolean(name='writeHa'),
  writePolicy?: string(name='writePolicy'),
}

model Tag {
  tagKey?: string(name='tagKey'),
  tagValue?: string(name='tagValue'),
}

model WarmNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec?: string(name='spec'),
}

model WhiteIpGroup {
  whiteIpType?: string(name='WhiteIpType'),
  groupName?: string(name='groupName'),
  ips?: [ string ](name='ips'),
}

model ZoneInfo {
  status?: string(name='status'),
  zoneId?: string(name='zoneId'),
}

model ActivateZonesRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model ActivateZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A5D8E74-565C-43DC-B031-29289FA****'),
  result?: boolean(name='Result', description='Indicates whether the nodes in disabled zones are restored. Valid values:

*   true
*   false', example='true'),
}

model ActivateZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActivateZonesResponseBody(name='body'),
}

async function activateZonesWithOptions(InstanceId: string, request: ActivateZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ActivateZonesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ActivateZones',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/recover-zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activateZones(InstanceId: string, request: ActivateZonesRequest): ActivateZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return activateZonesWithOptions(InstanceId, request, headers, runtime);
}

model AddConnectableClusterRequest {
  body?: string(name='body', example='{     "instanceId":"es-cn-09k1rgid9000g****" }'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model AddConnectableClusterResponseBody = {
  requestId?: string(name='RequestId', example='5A5D8E74-565C-43DC-B031-29289FA****'),
  result?: boolean(name='Result', example='true'),
}

model AddConnectableClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddConnectableClusterResponseBody(name='body'),
}

async function addConnectableClusterWithOptions(InstanceId: string, request: AddConnectableClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddConnectableClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'AddConnectableCluster',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connected-clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addConnectableCluster(InstanceId: string, request: AddConnectableClusterRequest): AddConnectableClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addConnectableClusterWithOptions(InstanceId, request, headers, runtime);
}

model AddSnapshotRepoRequest {
  body?: string(name='body'),
}

model AddSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: Reference warehouse created successfully
*   false: Reference warehouse created failed', example='true'),
}

model AddSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSnapshotRepoResponseBody(name='body'),
}

async function addSnapshotRepoWithOptions(InstanceId: string, request: AddSnapshotRepoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddSnapshotRepoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'AddSnapshotRepo',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-repos`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSnapshotRepo(InstanceId: string, request: AddSnapshotRepoRequest): AddSnapshotRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addSnapshotRepoWithOptions(InstanceId, request, headers, runtime);
}

model CancelDeletionRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CancelDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D682B6B3-B425-46DA-A5FC-5F5C60553622'),
  result?: boolean(name='Result', description='Indicates whether the cluster is restored. Valid values:

*   true: The cluster is restored.
*   false: The cluster fails to be restored.', example='true'),
}

model CancelDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelDeletionResponseBody(name='body'),
}

async function cancelDeletionWithOptions(InstanceId: string, request: CancelDeletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelDeletionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelDeletion',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/cancel-deletion`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelDeletion(InstanceId: string, request: CancelDeletionRequest): CancelDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelDeletionWithOptions(InstanceId, request, headers, runtime);
}

model CancelLogstashDeletionRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CancelLogstashDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='23EBF56B-2DC0-4507-8BE5-B87395DB0FEB'),
  result?: boolean(name='Result', description='Indicates whether the cluster is restored. Valid values:

*   true: The cluster is restored.
*   false: The cluster is not restored.', example='true'),
}

model CancelLogstashDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelLogstashDeletionResponseBody(name='body'),
}

async function cancelLogstashDeletionWithOptions(InstanceId: string, request: CancelLogstashDeletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelLogstashDeletionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelLogstashDeletion',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/cancel-deletion`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelLogstashDeletion(InstanceId: string, request: CancelLogstashDeletionRequest): CancelLogstashDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelLogstashDeletionWithOptions(InstanceId, request, headers, runtime);
}

model CancelTaskRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  taskType?: string(name='taskType', description='The type of the data migration task. Set the value to MigrateData.', example='MigrateData'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: the task was cancelled successfully
*   false: the task was cancelled successfully failed', example='true'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTaskWithOptions(InstanceId: string, request: CancelTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.taskType)) {
    query['taskType'] = request.taskType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/cancel-task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelTask(InstanceId: string, request: CancelTaskRequest): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelTaskWithOptions(InstanceId, request, headers, runtime);
}

model CapacityPlanRequest {
  complexQueryAvailable?: boolean(name='complexQueryAvailable', example='true'),
  dataInfo?: [ 
    {
      code?: string(name='code', example='totalRawData'),
      size?: long(name='size', example='100'),
      totalCount?: int32(name='totalCount', example='10000'),
      type?: string(name='type', example='hot'),
      unit?: string(name='unit', example='MiB'),
    }
  ](name='dataInfo'),
  metric?: [ 
    {
      averageQps?: int32(name='averageQps', example='30'),
      code?: string(name='code', example='write'),
      concurrent?: long(name='concurrent', example='2'),
      peakQps?: int32(name='peakQps', example='30'),
      responseTime?: int32(name='responseTime', example='100'),
      throughput?: long(name='throughput', example='100'),
      type?: string(name='type', example='common'),
    }
  ](name='metric'),
  usageScenario?: string(name='usageScenario', example='general'),
}

model CapacityPlanResponseBody = {
  requestId?: string(name='RequestId', description='The response of the request.', example='E91B7129-A669-4D9D-A743-F90A0FF1F5EF'),
  result?: {
    extendConfigs?: [ 
      {
        configType?: string(name='ConfigType', description='The size of the disk. Unit: GiB.', example='sharedDisk'),
        disk?: long(name='Disk', description='The type of the disk. Valid value: CPFS_PREMIUM.

>  The extendConfigs attribute that may occur when the planned instance type is enhanced (advanced).', example='2048'),
        diskType?: string(name='DiskType', description='The version type. Valid values:

*   advanced: enhanced edition
*   x-pack: Commercial Edition
*   community: community version', example='CPFS_PREMIUM'),
      }
    ](name='ExtendConfigs', description='The type of the configuration. Set the value to sharedDisk.

>  The extendConfigs attribute that may occur when the planned instance type is enhanced (advanced).'),
    instanceCategory?: string(name='InstanceCategory', description='The node information.', example='advanced'),
    nodeConfigurations?: [ 
      {
        amount?: long(name='Amount', description='The number of CPUs of the cloud desktop.', example='10'),
        cpu?: long(name='Cpu', description='The size of the disk. Unit: GiB.', example='1'),
        disk?: long(name='Disk', description='The type of the hard disk. Valid values:

*   cloud_essd: enhanced SSD (ESSD)
*   cloud_ssd: standard SSD
*   cloud_efficiency: ultra disk
*   local_ssd: local SSD
*   local_efficiency: local ultra disk', example='20'),
        diskType?: string(name='DiskType', description='The memory size of the current node role.', example='cloud_ssd'),
        memory?: long(name='Memory', description='The type of the node. Supported types are as follows:

*   WORKER: data node
*   WORKER_WARM: cold data node
*   MASTER: dedicated master node
*   KIBANA: Kibana node
*   COORDINATING: client node
*   ELASTIC_WORKER: elastic node', example='2'),
        nodeType?: string(name='NodeType', description='The result calculated based on the capacity planning. No default value is available. The values are as follows:

*   true: indicates that the number of data nodes calculated by capacity planning exceeds the threshold of 50.
*   false: The number of data nodes calculated by capacity planning is less than 50.', example='WORKER'),
      }
    ](name='NodeConfigurations', description='The number of cores.'),
    oversizedCluster?: boolean(name='OversizedCluster', example='true'),
  }(name='Result', description='The extension configuration information.'),
}

model CapacityPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CapacityPlanResponseBody(name='body'),
}

async function capacityPlanWithOptions(request: CapacityPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CapacityPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.complexQueryAvailable)) {
    body['complexQueryAvailable'] = request.complexQueryAvailable;
  }
  if (!Util.isUnset(request.dataInfo)) {
    body['dataInfo'] = request.dataInfo;
  }
  if (!Util.isUnset(request.metric)) {
    body['metric'] = request.metric;
  }
  if (!Util.isUnset(request.usageScenario)) {
    body['usageScenario'] = request.usageScenario;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CapacityPlan',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/assist/actions/capacity-plan`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function capacityPlan(request: CapacityPlanRequest): CapacityPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return capacityPlanWithOptions(request, headers, runtime);
}

model CloseDiagnosisRequest {
  clientToken?: string(name='ClientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  lang?: string(name='lang', example='spanish'),
}

model CloseDiagnosisResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model CloseDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseDiagnosisResponseBody(name='body'),
}

async function closeDiagnosisWithOptions(InstanceId: string, request: CloseDiagnosisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseDiagnosisResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseDiagnosis',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/close-diagnosis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeDiagnosis(InstanceId: string, request: CloseDiagnosisRequest): CloseDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeDiagnosisWithOptions(InstanceId, request, headers, runtime);
}

model CloseHttpsRequest {
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B350****'),
}

model CloseHttpsResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: boolean(name='Result', example='true'),
}

model CloseHttpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseHttpsResponseBody(name='body'),
}

async function closeHttpsWithOptions(InstanceId: string, request: CloseHttpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseHttpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseHttps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/close-https`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeHttps(InstanceId: string, request: CloseHttpsRequest): CloseHttpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeHttpsWithOptions(InstanceId, request, headers, runtime);
}

model CloseManagedIndexRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CloseManagedIndexResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model CloseManagedIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseManagedIndexResponseBody(name='body'),
}

async function closeManagedIndexWithOptions(InstanceId: string, Index: string, request: CloseManagedIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseManagedIndexResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseManagedIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/indices/${OpenApiUtil.getEncodeParam(Index)}/close-managed`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeManagedIndex(InstanceId: string, Index: string, request: CloseManagedIndexRequest): CloseManagedIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeManagedIndexWithOptions(InstanceId, Index, request, headers, runtime);
}

model CreateCollectorRequest {
  collectorPaths?: [ string ](name='collectorPaths'),
  configs?: [ 
    {
      content?: string(name='content', example='"filebeat.inputs:xxx"'),
      fileName?: string(name='fileName', example='filebeat.yml'),
    }
  ](name='configs'),
  dryRun?: boolean(name='dryRun', example='true'),
  extendConfigs?: [  map[string]any ](name='extendConfigs'),
  name?: string(name='name', example='ct-test'),
  resType?: string(name='resType', example='fileBeat'),
  resVersion?: string(name='resVersion', example='6.8.5_with_community'),
  vpcId?: string(name='vpcId', example='vpc-bp12nu14urf0upaf*****'),
  clientToken?: string(name='clientToken', description='The ID of the created crawer.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CreateCollectorResponseBody = {
  requestId?: string(name='RequestId', example='8466BDFB-C513-4B8D-B4E3-5AB256AB****'),
  result?: {
    resId?: string(name='resId', example='ct-cn-4135is2tj194p****'),
  }(name='Result'),
}

model CreateCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCollectorResponseBody(name='body'),
}

async function createCollectorWithOptions(request: CreateCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.collectorPaths)) {
    body['collectorPaths'] = request.collectorPaths;
  }
  if (!Util.isUnset(request.configs)) {
    body['configs'] = request.configs;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['dryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.extendConfigs)) {
    body['extendConfigs'] = request.extendConfigs;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.resType)) {
    body['resType'] = request.resType;
  }
  if (!Util.isUnset(request.resVersion)) {
    body['resVersion'] = request.resVersion;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['vpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCollector(request: CreateCollectorRequest): CreateCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCollectorWithOptions(request, headers, runtime);
}

model CreateComponentIndexRequest {
  meta?: map[string]any(name='_meta', example='{       "description": "set number of shards to one"   }'),
  template?: {
    aliases?: map[string]any(name='aliases', example='{}'),
    mappings?: map[string]any(name='mappings', example='{ 			"properties": { 				"@timestamp": { 					"type": "date" 				} 			} 		}'),
    settings?: map[string]any(name='settings', example='{ 			"index.number_of_replicas": 0 		}'),
  }(name='template'),
}

model CreateComponentIndexResponseBody = {
  requestId?: string(name='RequestId', example='C20022BA-5382-4339-89FB-30AF48A05431'),
  result?: boolean(name='Result', example='true'),
}

model CreateComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateComponentIndexResponseBody(name='body'),
}

async function createComponentIndexWithOptions(InstanceId: string, name: string, request: CreateComponentIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateComponentIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meta)) {
    body['_meta'] = request.meta;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createComponentIndex(InstanceId: string, name: string, request: CreateComponentIndexRequest): CreateComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createComponentIndexWithOptions(InstanceId, name, request, headers, runtime);
}

model CreateDataStreamRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF***'),
  body?: string(name='body'),
}

model CreateDataStreamResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: {
    name?: string(name='name', example='ds-'),
  }(name='Result'),
}

model CreateDataStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataStreamResponseBody(name='body'),
}

async function createDataStreamWithOptions(InstanceId: string, request: CreateDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDataStreamResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateDataStream',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataStream(InstanceId: string, request: CreateDataStreamRequest): CreateDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDataStreamWithOptions(InstanceId, request, headers, runtime);
}

model CreateDataTasksRequest {
  clientToken?: string(name='ClientToken', description='es-cn-n6w1o1x0w001c\\*\\*\\*\\*', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: [ 
    {
      migrateConfig?: {
        sourceFilterParams?: string(name='sourceFilterParams', example='index=111'),
      }(name='migrateConfig'),
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType', example='elasticsearch'),
        index?: string(name='index', example='index_001'),
        mapping?: string(name='mapping', example='{\\"doc\\":{\\"properties\\":{\\"interval_ms\\":{\\"type\\":\\"long\\"},....}'),
        password?: string(name='password', example='xxxxx'),
        routing?: string(name='routing', example='_id'),
        settings?: string(name='settings', example='{\\n \\"index\\": {\\n \\"replication\\": {\\n \\"type\\": .....}'),
        type?: string(name='type', example='index_001'),
        username?: string(name='username', example='elastic'),
      }(name='sinkCluster'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType', example='elasticsearch'),
        endpoint?: string(name='endpoint', example='http://yourdomain.com'),
        index?: string(name='index', example='index_001'),
        password?: string(name='password', example='es_password'),
        type?: string(name='type', example='index_001'),
        username?: string(name='username', example='elastic'),
        vpcId?: string(name='vpcId', example='vpc-xxx'),
        vpcInstanceId?: string(name='vpcInstanceId', example='es-xxx-worker'),
        vpcInstancePort?: int32(name='vpcInstancePort', example='9200'),
      }(name='sourceCluster'),
    }
  ](name='body'),
}

model CreateDataTasksResponseBody = {
  requestId?: string(name='RequestId', description='The result of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType', example='elasticsearch'),
        index?: string(name='index', description='The settings configuration.', example='index_001'),
        mapping?: string(name='mapping', description='The type of the target index.', example='{\\"doc\\":{\\"properties\\":{\\"interval_ms\\":{\\"type\\":\\"long\\"},....}'),
        password?: string(name='password', description='The name of the target index.', example='xxxxx'),
        routing?: string(name='routing', description='The username of the destination cluster.', example='cluster_name'),
        settings?: string(name='settings', description='Mapping configuration.', example='{\\n  \\"index\\": {\\n    \\"replication\\": {\\n      \\"type\\": .....}'),
        type?: string(name='type', description='The routing field. The primary key field is used by default.', example='index_001'),
        username?: string(name='username', description='The ID of the Virtual Private Cloud to which the cluster belongs. If the cluster access address is a public domain name, you can not specify the private endpoint.', example='elastic'),
        vpcId?: string(name='vpcId', description='The access port number of the cluster.', example='vpc-2ze55voww95g82gak****'),
        vpcInstanceId?: string(name='vpcInstanceId', description='The type of the target cluster.', example='es-cn-oew1oxiro000f****-worker'),
        vpcInstancePort?: string(name='vpcInstancePort', description='The instance ID of the cluster under the Virtual Private Cloud, or the ID of the SLB instance.', example='9200'),
      }(name='sinkCluster', description='The access password of the target cluster.'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType', description='The information about the target cluster.', example='elasticsearch'),
        endpoint?: string(name='endpoint', description='The username of the source cluster.', example='http://10.20.xx.xx:9200'),
        index?: string(name='index', description='The type of the specified index.', example='index_001'),
        password?: string(name='password', description='Specifies the indexes to be migrated.', example='xxxxxx'),
        type?: string(name='type', description='The public domain name of the cluster.', example='index_001'),
        username?: string(name='username', description='The ID of the Virtual Private Cloud where the source cluster resides. If the cluster access address is a public domain name, you can not specify the private endpoint.', example='elastic'),
        vpcId?: string(name='vpcId', description='The instance ID of the cluster under the Virtual Private Cloud, or the ID of the SLB instance.', example='vpc-2ze55voww95g82gak****'),
        vpcInstanceId?: string(name='vpcInstanceId', description='The access port number of the source cluster.', example='es-cn-oew1oxiro000f****-worker'),
        vpcInstancePort?: int32(name='vpcInstancePort', description='The type of the source cluster. Default value: Elasticsearch.', example='9200'),
      }(name='sourceCluster', description='The access password of the source cluster.'),
    }
  ](name='Result', description='The information about the source cluster.'),
}

model CreateDataTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataTasksResponseBody(name='body'),
}

/**
  * @deprecated
  * Before you call this operation, note that:
  * *   Currently, the one-click index migration feature only supports the China (Beijing) region.
  * *   The source and destination Elasticsearch clusters must meet the following requirements: a user-created or Alibaba Cloud Elasticsearch Elasticsearch cluster with a source of version 6.7.0 and a Alibaba Cloud Elasticsearch Elasticsearch cluster with a destination of version 6.3.2 or 6.7.0.
  *
  * @param request CreateDataTasksRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDataTasksResponse
 */
// Deprecated
async function createDataTasksWithOptions(InstanceId: string, request: CreateDataTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDataTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataTasks',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  * Before you call this operation, note that:
  * *   Currently, the one-click index migration feature only supports the China (Beijing) region.
  * *   The source and destination Elasticsearch clusters must meet the following requirements: a user-created or Alibaba Cloud Elasticsearch Elasticsearch cluster with a source of version 6.7.0 and a Alibaba Cloud Elasticsearch Elasticsearch cluster with a destination of version 6.3.2 or 6.7.0.
  *
  * @param request CreateDataTasksRequest
  * @return CreateDataTasksResponse
 */
// Deprecated
async function createDataTasks(InstanceId: string, request: CreateDataTasksRequest): CreateDataTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDataTasksWithOptions(InstanceId, request, headers, runtime);
}

model CreateILMPolicyRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model CreateILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='my-policy'),
}

model CreateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateILMPolicyResponseBody(name='body'),
}

async function createILMPolicyWithOptions(InstanceId: string, request: CreateILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateILMPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createILMPolicy(InstanceId: string, request: CreateILMPolicyRequest): CreateILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createILMPolicyWithOptions(InstanceId, request, headers, runtime);
}

model CreateIndexTemplateRequest {
  clientToken?: string(name='ClientToken', example='E1136AE9-4E49-4585-9358-6FDD2A6D****'),
  dataStream?: boolean(name='dataStream'),
  ilmPolicy?: string(name='ilmPolicy', example='policy-1'),
  indexPatterns?: [ string ](name='indexPatterns'),
  indexTemplate?: string(name='indexTemplate', example='index-template'),
  priority?: int32(name='priority', example='100'),
  template?: {
    aliases?: string(name='aliases', example='{"mydata": {}}'),
    mappings?: string(name='mappings', example='{"properties": {"created_at": {"type": "date","format": "EEE MMM dd HH:mm:ss Z yyyy"},"host_name": {"type": "keyword"}}}'),
    settings?: string(name='settings', example='{\\"index.refresh_interval\\":\\"1s\\"}'),
  }(name='template'),
}

model CreateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='index-template'),
}

model CreateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIndexTemplateResponseBody(name='body'),
}

async function createIndexTemplateWithOptions(InstanceId: string, request: CreateIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.dataStream)) {
    body['dataStream'] = request.dataStream;
  }
  if (!Util.isUnset(request.ilmPolicy)) {
    body['ilmPolicy'] = request.ilmPolicy;
  }
  if (!Util.isUnset(request.indexPatterns)) {
    body['indexPatterns'] = request.indexPatterns;
  }
  if (!Util.isUnset(request.indexTemplate)) {
    body['indexTemplate'] = request.indexTemplate;
  }
  if (!Util.isUnset(request.priority)) {
    body['priority'] = request.priority;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIndexTemplate(InstanceId: string, request: CreateIndexTemplateRequest): CreateIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexTemplateWithOptions(InstanceId, request, headers, runtime);
}

model CreateLogstashRequest {
  description?: string(name='description', example='ls-cn-abc'),
  networkConfig?: {
    type?: string(name='type', example='vpc'),
    vpcId?: string(name='vpcId', example='vpc-bp16k1dvzxtmagcva****'),
    vsArea?: string(name='vsArea', example='cn-hangzhou-i'),
    vswitchId?: string(name='vswitchId', example='vsw-bp1k4ec6s7sjdbudw****'),
  }(name='networkConfig'),
  nodeAmount?: int32(name='nodeAmount', example='2'),
  nodeSpec?: {
    disk?: long(name='disk', example='50'),
    diskType?: string(name='diskType', example='cloud_ssd'),
    spec?: string(name='spec', example='logstash.n4.small'),
  }(name='nodeSpec'),
  paymentInfo?: {
    autoRenewDuration?: long(name='autoRenewDuration', example='3'),
    duration?: long(name='duration', example='1'),
    isAutoRenew?: boolean(name='isAutoRenew', example='false'),
    pricingCycle?: string(name='pricingCycle', example='Month'),
  }(name='paymentInfo'),
  paymentType?: string(name='paymentType', example='prepaid'),
  resourceGroupId?: string(name='resourceGroupId'),
  version?: string(name='version', example='6.7_with_X-Pack'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CreateLogstashResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE*****'),
  result?: Logstash(name='Result'),
}

model CreateLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLogstashResponseBody(name='body'),
}

async function createLogstashWithOptions(request: CreateLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.networkConfig)) {
    body['networkConfig'] = request.networkConfig;
  }
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }
  if (!Util.isUnset(request.paymentInfo)) {
    body['paymentInfo'] = request.paymentInfo;
  }
  if (!Util.isUnset(request.paymentType)) {
    body['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLogstash(request: CreateLogstashRequest): CreateLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogstashWithOptions(request, headers, runtime);
}

model CreatePipelinesRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: [ 
    {
      batchDelay?: int32(name='batchDelay', example='50'),
      batchSize?: int32(name='batchSize', example='125'),
      config?: string(name='config', example='input { } filter { } output { }'),
      description?: string(name='description', example='this is a test'),
      pipelineId?: string(name='pipelineId', example='pipeline-test'),
      queueCheckPointWrites?: int32(name='queueCheckPointWrites', example='1024'),
      queueMaxBytes?: int32(name='queueMaxBytes', example='1024'),
      queueType?: string(name='queueType', example='MEMORY'),
      workers?: int32(name='workers', example='2'),
    }
  ](name='body'),
  trigger?: boolean(name='trigger', example='false'),
}

model CreatePipelinesResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model CreatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePipelinesResponseBody(name='body'),
}

async function createPipelinesWithOptions(InstanceId: string, request: CreatePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPipelines(InstanceId: string, request: CreatePipelinesRequest): CreatePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPipelinesWithOptions(InstanceId, request, headers, runtime);
}

model CreateSnapshotRequest {
  clientToken?: string(name='ClientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='Return results:

*   true: manual snapshot backup successfully
*   false: manual snapshot backup failed', example='true'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshotWithOptions(InstanceId: string, request: CreateSnapshotRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSnapshotResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateSnapshot',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshots`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSnapshot(InstanceId: string, request: CreateSnapshotRequest): CreateSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSnapshotWithOptions(InstanceId, request, headers, runtime);
}

model CreateVpcEndpointRequest {
  clientToken?: string(name='ClientToken', description='The returned result details.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  serviceId?: string(name='serviceId', example='epsrv-hp3xdsq46ael67lo****'),
  zoneId?: string(name='zoneId', example='cn-hangzhou-i'),
  dryRun?: boolean(name='dryRun', description='The ID of the user endpoint service associated with the endpoint.', example='false'),
}

model CreateVpcEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The endpoint domain name, which is used to configure the connection.', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: {
    endpointDomain?: string(name='endpointDomain', example='ep-bp1tah7zbrwmkjef****.epsrv-bp1w0p3jdirbfmt6****.cn-hangzhou.privatelink.aliyuncs.com'),
    endpointId?: string(name='endpointId', example='ep-bp1tah7zbrwmkjef****'),
    endpointName?: string(name='endpointName', example='vpcElasticSearchABC'),
    serviceId?: string(name='serviceId', description='The name of the service VPC-side endpoint.', example='epsrv-bp1w0p3jdirbfmt6****'),
  }(name='Result', description='The ID of the endpoint on the service VPC side.'),
}

model CreateVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpcEndpointResponseBody(name='body'),
}

/**
  * 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D\\*\\*\\*
  *
  * @param request CreateVpcEndpointRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateVpcEndpointResponse
 */
async function createVpcEndpointWithOptions(InstanceId: string, request: CreateVpcEndpointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVpcEndpointResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceId)) {
    body['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.zoneId)) {
    body['zoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcEndpoint',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/vpc-endpoints`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D\\*\\*\\*
  *
  * @param request CreateVpcEndpointRequest
  * @return CreateVpcEndpointResponse
 */
async function createVpcEndpoint(InstanceId: string, request: CreateVpcEndpointRequest): CreateVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVpcEndpointWithOptions(InstanceId, request, headers, runtime);
}

model DeactivateZonesRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model DeactivateZonesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: offline zone successfully
*   false: offline zone successfully failed', example='true'),
}

model DeactivateZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeactivateZonesResponseBody(name='body'),
}

async function deactivateZonesWithOptions(InstanceId: string, request: DeactivateZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeactivateZonesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeactivateZones',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/down-zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deactivateZones(InstanceId: string, request: DeactivateZonesRequest): DeactivateZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deactivateZonesWithOptions(InstanceId, request, headers, runtime);
}

model DeleteCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model DeleteCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Indicates whether the shipper is deleted. Valid values:

*   true: The shipper is deleted.
*   false: The shipper fails to be deleted.', example='true'),
}

model DeleteCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCollectorResponseBody(name='body'),
}

async function deleteCollectorWithOptions(ResId: string, request: DeleteCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCollector(ResId: string, request: DeleteCollectorRequest): DeleteCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCollectorWithOptions(ResId, request, headers, runtime);
}

model DeleteComponentIndexResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: boolean(name='Result', example='true'),
}

model DeleteComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteComponentIndexResponseBody(name='body'),
}

async function deleteComponentIndexWithOptions(InstanceId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteComponentIndexResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteComponentIndex(InstanceId: string, name: string): DeleteComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteComponentIndexWithOptions(InstanceId, name, headers, runtime);
}

model DeleteConnectedClusterRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  connectedInstanceId?: string(name='connectedInstanceId', description='The ID of the remote instance for which the network connection is established.', example='es-cn-09k1rgid9000g****'),
}

model DeleteConnectedClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='Return results:

*   true: remove the interworking instance successfully
*   false: remove the interworking instance failed', example='true'),
}

model DeleteConnectedClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConnectedClusterResponseBody(name='body'),
}

async function deleteConnectedClusterWithOptions(InstanceId: string, request: DeleteConnectedClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConnectedClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectedInstanceId)) {
    query['connectedInstanceId'] = request.connectedInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConnectedCluster',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connected-clusters`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteConnectedCluster(InstanceId: string, request: DeleteConnectedClusterRequest): DeleteConnectedClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConnectedClusterWithOptions(InstanceId, request, headers, runtime);
}

model DeleteDataStreamRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model DeleteDataStreamResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model DeleteDataStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataStreamResponseBody(name='body'),
}

async function deleteDataStreamWithOptions(InstanceId: string, DataStream: string, request: DeleteDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataStreamResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataStream',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams/${OpenApiUtil.getEncodeParam(DataStream)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataStream(InstanceId: string, DataStream: string, request: DeleteDataStreamRequest): DeleteDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime);
}

model DeleteDataTaskRequest {
  clientToken?: string(name='ClientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  taskId?: string(name='taskId', description='The ID of the index migration task.', example='et_cn_0oyg09o96ib40****'),
}

model DeleteDataTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='The returned results.', example='true'),
}

model DeleteDataTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataTaskResponseBody(name='body'),
}

async function deleteDataTaskWithOptions(InstanceId: string, request: DeleteDataTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.taskId)) {
    query['taskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-task`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataTask(InstanceId: string, request: DeleteDataTaskRequest): DeleteDataTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataTaskWithOptions(InstanceId, request, headers, runtime);
}

model DeleteDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: boolean(name='Result', example='true'),
}

model DeleteDeprecatedTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeprecatedTemplateResponseBody(name='body'),
}

async function deleteDeprecatedTemplateWithOptions(InstanceId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDeprecatedTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeprecatedTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/deprecated-templates/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDeprecatedTemplate(InstanceId: string, name: string): DeleteDeprecatedTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDeprecatedTemplateWithOptions(InstanceId, name, headers, runtime);
}

model DeleteILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='694FDC20-0FDD-47C4-B921-BFF902FA****'),
  result?: boolean(name='Result', example='true'),
}

model DeleteILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteILMPolicyResponseBody(name='body'),
}

async function deleteILMPolicyWithOptions(InstanceId: string, PolicyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteILMPolicyResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies/${OpenApiUtil.getEncodeParam(PolicyName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteILMPolicy(InstanceId: string, PolicyName: string): DeleteILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteILMPolicyWithOptions(InstanceId, PolicyName, headers, runtime);
}

model DeleteIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='A0761F7E-0B50-46B9-8CAA-EBB3A420****'),
  result?: boolean(name='Result', example='true'),
}

model DeleteIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIndexTemplateResponseBody(name='body'),
}

async function deleteIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates/${OpenApiUtil.getEncodeParam(IndexTemplate)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIndexTemplate(InstanceId: string, IndexTemplate: string): DeleteIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexTemplateWithOptions(InstanceId, IndexTemplate, headers, runtime);
}

model DeleteInstanceRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  deleteType?: string(name='deleteType', example='protective'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='94B03BBA-A132-42C3-8367-0A0C1C45****'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstanceWithOptions(InstanceId: string, request: DeleteInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deleteType)) {
    query['deleteType'] = request.deleteType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstance(InstanceId: string, request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteInstanceWithOptions(InstanceId, request, headers, runtime);
}

model DeleteLogstashRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  deleteType?: string(name='deleteType', description='The type of the release operation. Valid values:

*   immediate: The cluster is immediately deleted when it is released. After the cluster is deleted, the data stored in the cluster is deleted, and the system removes the cluster from the Logstash cluster list.
*   protective: The cluster is released 24 hours later. During the period of 24 hours, you can still find the cluster in the Logstash cluster list, and [restore the cluster](~~202205~~) or [immediately release the cluster](~~160591~~). After 24 hours elapse, the data stored in the cluster is deleted.', example='protective'),
}

model DeleteLogstashResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='94B03BBA-A132-42C3-8367-0A0C1C45****'),
}

model DeleteLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLogstashResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following information: After the cluster is released, the physical resources used by the cluster are reclaimed. The data stored in the cluster is deleted and cannot be recovered. The disks attached to the nodes in the cluster and the snapshots created for the cluster are released.
  *
  * @param request DeleteLogstashRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteLogstashResponse
 */
async function deleteLogstashWithOptions(InstanceId: string, request: DeleteLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deleteType)) {
    query['deleteType'] = request.deleteType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, take note of the following information: After the cluster is released, the physical resources used by the cluster are reclaimed. The data stored in the cluster is deleted and cannot be recovered. The disks attached to the nodes in the cluster and the snapshots created for the cluster are released.
  *
  * @param request DeleteLogstashRequest
  * @return DeleteLogstashResponse
 */
async function deleteLogstash(InstanceId: string, request: DeleteLogstashRequest): DeleteLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogstashWithOptions(InstanceId, request, headers, runtime);
}

model DeletePipelinesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  pipelineIds?: string(name='pipelineIds', description='The ID of the pipeline.', example='pipeline-test'),
}

model DeletePipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Indicates whether the pipeline is deleted. Valid values:

*   true: The pipeline is deleted.
*   false: The pipeline fails to be deleted.', example='true'),
}

model DeletePipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePipelinesResponseBody(name='body'),
}

async function deletePipelinesWithOptions(InstanceId: string, request: DeletePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.pipelineIds)) {
    query['pipelineIds'] = request.pipelineIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePipelines(InstanceId: string, request: DeletePipelinesRequest): DeletePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePipelinesWithOptions(InstanceId, request, headers, runtime);
}

model DeleteSnapshotRepoRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  repoPath?: string(name='repoPath', description='Reference instance ID.', example='es-cn-n6w1rux8i000w****'),
}

model DeleteSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: reference warehouse deleted successfully
*   false: reference warehouse deleted successfully failed', example='true'),
}

model DeleteSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSnapshotRepoResponseBody(name='body'),
}

async function deleteSnapshotRepoWithOptions(InstanceId: string, request: DeleteSnapshotRepoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSnapshotRepoResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.repoPath)) {
    query['repoPath'] = request.repoPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSnapshotRepo',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-repos`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSnapshotRepo(InstanceId: string, request: DeleteSnapshotRepoRequest): DeleteSnapshotRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSnapshotRepoWithOptions(InstanceId, request, headers, runtime);
}

model DeleteVpcEndpointRequest {
  clientToken?: string(name='ClientToken', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
}

model DeleteVpcEndpointResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: boolean(name='Result', example='true'),
}

model DeleteVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpcEndpointResponseBody(name='body'),
}

async function deleteVpcEndpointWithOptions(InstanceId: string, EndpointId: string, request: DeleteVpcEndpointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVpcEndpointResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcEndpoint',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/vpc-endpoints/${OpenApiUtil.getEncodeParam(EndpointId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVpcEndpoint(InstanceId: string, EndpointId: string, request: DeleteVpcEndpointRequest): DeleteVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVpcEndpointWithOptions(InstanceId, EndpointId, request, headers, runtime);
}

model DescribeAckOperatorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6615EE8D-FD9D-4FD3-997E-6FEA5B8D82ED'),
  result?: {
    status?: string(name='status', description='The installation status of ES-operator. Valid values:

*   deployed: ES-operator is installed.
*   not-deploy: ES-operator is not installed.
*   failed: ES-operator fails to be installed.
*   unknown: The installation status of ES-operator is unknown.', example='deployed'),
    version?: string(name='version', description='The version of ES-operator.', example='1'),
  }(name='Result', description='The returned result.'),
}

model DescribeAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAckOperatorResponseBody(name='body'),
}

/**
  * > Before you install a shipper on an ACK cluster, you can call this operation to query the installation status of ES-operator for the ACK cluster.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeAckOperatorResponse
 */
async function describeAckOperatorWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAckOperatorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeAckOperator',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters/${OpenApiUtil.getEncodeParam(ClusterId)}/operator`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > Before you install a shipper on an ACK cluster, you can call this operation to query the installation status of ES-operator for the ACK cluster.
  *
  * @return DescribeAckOperatorResponse
 */
async function describeAckOperator(ClusterId: string): DescribeAckOperatorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAckOperatorWithOptions(ClusterId, headers, runtime);
}

model DescribeApmResponseBody = {
  requestId?: string(name='RequestId', example='97597D87-8066-5493-B692-5C50DA236D68'),
  result?: {
    apmServerDomain?: string(name='apmServerDomain', example='apm-cn-i7m2fuae****.apm.elasticsearch.aliyuncs.com:8200'),
    createdAt?: string(name='createdAt', example='2021-11-16T07:15:51.967Z'),
    deployedReplica?: long(name='deployedReplica', example='1'),
    description?: string(name='description', example='APMtest'),
    endTime?: long(name='endTime', example='4792752000000'),
    instanceId?: string(name='instanceId', example='apm-cn-i7m2fuae****'),
    nodeAmount?: long(name='nodeAmount', example='1'),
    outputES?: string(name='outputES', example='es-cn-i7m2fsfhc001x****'),
    outputESUserName?: string(name='outputESUserName', example='elastic'),
    ownerId?: string(name='ownerId', example='133071096032****'),
    paymentType?: string(name='paymentType', example='postpaid'),
    region?: string(name='region', example='cn-hangzhou'),
    replica?: int32(name='replica', example='1'),
    resourceSpec?: string(name='resourceSpec', example='C1M2'),
    status?: string(name='status', example='active'),
    version?: string(name='version', example='7.10.2'),
    vpcId?: string(name='vpcId', example='vpc-bp1530vdhqkamm9s0****'),
    vsArea?: string(name='vsArea', example='cn-hangzhou-i'),
    vswitchId?: string(name='vswitchId', example='vsw-bp1j1mql6r9g5vfb4****'),
  }(name='Result'),
}

model DescribeApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApmResponseBody(name='body'),
}

async function describeApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeApm(instanceId: string): DescribeApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApmWithOptions(instanceId, headers, runtime);
}

model DescribeCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content', description='The content of the file.', example='fileBeat.inputs:xxx'),
        fileName?: string(name='fileName', description='The name of the file.', example='filebeat.yml'),
      }
    ](name='configs', description='The information about the configuration file of the shipper.'),
    dryRun?: boolean(name='dryRun', description='Indicates whether a dry run is performed. Valid values:

*   true
*   false', example='false'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType', description='The configuration type. Valid values:

*   collectorTargetInstance
*   collectorDeployMachine
*   collectorElasticsearchForKibana', example='collectorDeployMachine'),
        enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether monitoring is enabled. This parameter is returned if the value of **configType** is **collectorTargetInstance**. Valid values:

*   true
*   false', example='true'),
        groupId?: string(name='groupId', description='The ID of the machine group. This parameter is returned if the value of **configType** is **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
        host?: string(name='host', description='The private endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId', description='The ID of the resource that is associated with the shipper. If the value of **configType** is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType** is **collectorDeployMachines** and the value of **type** is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='es-cn-n6w1o1****'),
        instanceType?: string(name='instanceType', description='The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='elasticsearch'),
        kibanaHost?: string(name='kibanaHost', description='The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values:

*   heartOk: The heartbeat is normal.
*   heartLost: The heartbeat is abnormal.
*   uninstalled: The shipper is not installed.
*   failed: The shipper fails to be installed.', example='heartOk'),
            instanceId?: string(name='instanceId', description='The IDs of the ECS instances.', example='i-bp1gyhphjaj73jsr****'),
          }
        ](name='machines', description='The information about the Elastic Compute Service (ECS) instances on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachines** and the value of **type** is **ECSInstanceId**.'),
        protocol?: string(name='protocol', description='The transmission protocol, which must be the same as the access protocol of the resource specified in the output configuration part of the shipper. Valid values: HTTP and HTTPS. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='HTTP'),
        successPodsCount?: string(name='successPodsCount', description='The number of pods from which data is succcessfully collected in the Container Service for Kubernetes (ACK) cluster.', example='8'),
        totalPodsCount?: string(name='totalPodsCount', description='The total number of pods from which data is collected in the ACK cluster.', example='10'),
        type?: string(name='type', description='The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
        userName?: string(name='userName', description='The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
      }
    ](name='extendConfigs', description='The extended configurations of the shipper.'),
    gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-06-20T07:26:47.000+0000'),
    name?: string(name='name', description='The name of the shipper.', example='ct-cn-4135is2tj194p****'),
    ownerId?: string(name='ownerId', description='The account ID.', example='16852099488*****'),
    resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-rg31ahn82m0qd****'),
    resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.', example='fileBeat'),
    resVersion?: string(name='resVersion', description='The version of the shipper.', example='6.8.5_with_community'),
    status?: string(name='status', description='The status of the shipper. Valid values:

*   activating
*   active', example='active'),
    vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) where the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
  }(name='Result', description='The returned result.'),
}

model DescribeCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCollectorResponseBody(name='body'),
}

async function describeCollectorWithOptions(ResId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeCollectorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCollector(ResId: string): DescribeCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeCollectorWithOptions(ResId, headers, runtime);
}

model DescribeComponentIndexResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: {
    meta?: map[string]any(name='_meta', example='{ "description": "set number of shards to one" }'),
    template?: {
      aliases?: map[string]any(name='aliases', example='{}'),
      mappings?: map[string]any(name='mappings', example='{ "properties": { "@timestamp": { "type": "date" } } }'),
      settings?: map[string]any(name='settings', example='{ "index.number_of_replicas": 0 }'),
    }(name='template'),
  }(name='Result'),
}

model DescribeComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeComponentIndexResponseBody(name='body'),
}

async function describeComponentIndexWithOptions(InstanceId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeComponentIndexResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeComponentIndex(InstanceId: string, name: string): DescribeComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeComponentIndexWithOptions(InstanceId, name, headers, runtime);
}

model DescribeConnectableClustersRequest {
  alreadySetItems?: boolean(name='alreadySetItems', description='The ID of the instance that can communicate with each other.', example='true'),
}

model DescribeConnectableClustersResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      instances?: string(name='instances', example='es-cn-xxx'),
      networkType?: string(name='networkType', example='vpc'),
    }
  ](name='Result'),
}

model DescribeConnectableClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeConnectableClustersResponseBody(name='body'),
}

async function describeConnectableClustersWithOptions(InstanceId: string, request: DescribeConnectableClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeConnectableClustersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.alreadySetItems)) {
    query['alreadySetItems'] = request.alreadySetItems;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConnectableClusters',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connectable-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeConnectableClusters(InstanceId: string, request: DescribeConnectableClustersRequest): DescribeConnectableClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeConnectableClustersWithOptions(InstanceId, request, headers, runtime);
}

model DescribeDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: {
    dataStream?: boolean(name='dataStream', example='false'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate', example='openstore-index-template'),
    order?: long(name='order', example='100'),
    template?: {
      aliases?: string(name='aliases', example='"{}"'),
      mappings?: string(name='mappings', example='"{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}"'),
      settings?: string(name='settings', example='"{\\"index.number_of_shards\\":\\"1\\"}"'),
    }(name='template'),
    version?: string(name='version', example='70000'),
  }(name='Result'),
}

model DescribeDeprecatedTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeprecatedTemplateResponseBody(name='body'),
}

async function describeDeprecatedTemplateWithOptions(InstanceId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDeprecatedTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeprecatedTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/deprecated-templates/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeprecatedTemplate(InstanceId: string, name: string): DescribeDeprecatedTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDeprecatedTemplateWithOptions(InstanceId, name, headers, runtime);
}

model DescribeDiagnoseReportRequest {
  lang?: string(name='lang', example='en'),
}

model DescribeDiagnoseReportResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    createTime?: long(name='createTime', example='1535745731000'),
    diagnoseItems?: [ 
      {
        detail?: {
          desc?: string(name='desc', example='Check whether the number of replica shards is optimal and easy to maintain'),
          name?: string(name='name', example='Number of Replica Shards'),
          result?: string(name='result', example='You may need to adjust the numbers of replica shards of some indices as follows: [geoname08 : 0 -&gt; 1][geoname09 : 0 -&gt; 1][geonametest01 : 0 -&gt; 1]'),
          suggest?: string(name='suggest', example='You can call the following function in the Elasticsearch API....'),
          type?: string(name='type', example='ES_API'),
        }(name='detail'),
        health?: string(name='health', example='YELLOW'),
        item?: string(name='item', example='IndexAliasUseDiagnostic'),
      }
    ](name='diagnoseItems'),
    health?: string(name='health', example='YELLOW'),
    instanceId?: string(name='instanceId', example='es-cn-abc'),
    reportId?: string(name='reportId', example='trigger__2020-08-17T17:09:02'),
    state?: string(name='state', example='SUCCESS'),
    trigger?: string(name='trigger', example='SYSTEM'),
  }(name='Result'),
}

model DescribeDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDiagnoseReportResponseBody(name='body'),
}

async function describeDiagnoseReportWithOptions(InstanceId: string, ReportId: string, request: DescribeDiagnoseReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDiagnoseReportResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiagnoseReport',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/reports/${OpenApiUtil.getEncodeParam(ReportId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDiagnoseReport(InstanceId: string, ReportId: string, request: DescribeDiagnoseReportRequest): DescribeDiagnoseReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDiagnoseReportWithOptions(InstanceId, ReportId, request, headers, runtime);
}

model DescribeDiagnosisSettingsRequest {
  lang?: string(name='lang', description='The language of the returned result. Default value: en.', example='en'),
}

model DescribeDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5E82B8A8-EED7-4557-A6E9-D1AD3E58****'),
  result?: {
    scene?: string(name='scene', description='Scenarios of intelligent maintenance.', example='Business Search'),
    updateTime?: long(name='updateTime', description='The timestamp of the last update for Intelligent Maintenance scenarios.', example='1588994035385'),
  }(name='Result', description='The return results.'),
}

model DescribeDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDiagnosisSettingsResponseBody(name='body'),
}

async function describeDiagnosisSettingsWithOptions(InstanceId: string, request: DescribeDiagnosisSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDiagnosisSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiagnosisSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDiagnosisSettings(InstanceId: string, request: DescribeDiagnosisSettingsRequest): DescribeDiagnosisSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime);
}

model DescribeDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeDynamicSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDynamicSettingsResponseBody(name='body'),
}

async function describeDynamicSettingsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDynamicSettingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDynamicSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dynamic-settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDynamicSettings(InstanceId: string): DescribeDynamicSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDynamicSettingsWithOptions(InstanceId, headers, runtime);
}

model DescribeElasticsearchHealthResponseBody = {
  code?: string(name='Code', description='The response code returned.', example='200'),
  message?: string(name='Message', description='The response message returned.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0731F217-2C8A-4D42-8BCD-5C352866E3B7'),
  result?: string(name='Result', description='The color that indicates the health status of the cluster.', example='GREEN'),
}

model DescribeElasticsearchHealthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeElasticsearchHealthResponseBody(name='body'),
}

/**
  * An Elasticsearch cluster can be in a health state indicated by one of the following colors:
  * *   GREEN: Primary shards and replica shards for the primary shards are normally allocated.
  * *   YELLOW: Primary shards are normally allocated, but replica shards for the primary shards are not normally allocated.
  * *   RED: Primary shards are not normally allocated.
  *
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeElasticsearchHealthResponse
 */
async function describeElasticsearchHealthWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeElasticsearchHealthResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeElasticsearchHealth',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/elasticsearch-health`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * An Elasticsearch cluster can be in a health state indicated by one of the following colors:
  * *   GREEN: Primary shards and replica shards for the primary shards are normally allocated.
  * *   YELLOW: Primary shards are normally allocated, but replica shards for the primary shards are not normally allocated.
  * *   RED: Primary shards are not normally allocated.
  *
  * @return DescribeElasticsearchHealthResponse
 */
async function describeElasticsearchHealth(InstanceId: string): DescribeElasticsearchHealthResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeElasticsearchHealthWithOptions(InstanceId, headers, runtime);
}

model DescribeILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='FF44681E-FD41-4FDE-B8DF-295DCDD6****'),
  result?: {
    name?: string(name='name', example='ilm-history-ilm-policy'),
    phases?: map[string]any(name='phases', example='{"cold":{"minAge":"30d","actions":{"allocate":{"numberOfReplicas":1,"require":{"boxType":"warm"}},"setPriority":{"priority":100}}},"hot":{"minAge":"0s","actions":{"rollover":{"maxAge":"30d","maxDocs":10000,"maxSize":"50gb"},"setPriority":{"priority":1000}}},"delete":{"minAge":"30d","actions":{"delete":{}}}}'),
  }(name='Result'),
}

model DescribeILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeILMPolicyResponseBody(name='body'),
}

async function describeILMPolicyWithOptions(InstanceId: string, PolicyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeILMPolicyResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies/${OpenApiUtil.getEncodeParam(PolicyName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeILMPolicy(InstanceId: string, PolicyName: string): DescribeILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeILMPolicyWithOptions(InstanceId, PolicyName, headers, runtime);
}

model DescribeIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='25DB38F8-82E4-4D16-82BB-FF077C7F****'),
  result?: {
    dataStream?: boolean(name='dataStream', example='true'),
    ilmPolicy?: string(name='ilmPolicy', example='cube_default_ilm_policy'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate', example='data-stream-default'),
    priority?: int32(name='priority', example='0'),
    template?: {
      aliases?: string(name='aliases', example='{\\"mydata\\":{}}'),
      mappings?: string(name='mappings', example='{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}'),
      settings?: string(name='settings', example='{\\"index.refresh_interval\\":\\"1s\\"}'),
    }(name='template'),
  }(name='Result'),
}

model DescribeIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIndexTemplateResponseBody(name='body'),
}

async function describeIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeIndexTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates/${OpenApiUtil.getEncodeParam(IndexTemplate)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIndexTemplate(InstanceId: string, IndexTemplate: string): DescribeIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeIndexTemplateWithOptions(InstanceId, IndexTemplate, headers, runtime);
}

model DescribeInstanceResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    advancedDedicateMaster?: boolean(name='advancedDedicateMaster', example='true'),
    advancedSetting?: {
      gcName?: string(name='gcName', example='CMS'),
    }(name='advancedSetting'),
    aliwsDicts?: [ 
      {
        fileSize?: long(name='fileSize', example='2782602'),
        name?: string(name='name', example='aliws_ext_dict.txt'),
        sourceType?: string(name='sourceType', example='OSS'),
        type?: string(name='type', example='ALI_WS'),
      }
    ](name='aliwsDicts'),
    clientNodeConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='40'),
      diskType?: string(name='diskType', example='cloud_efficiency'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='clientNodeConfiguration'),
    createdAt?: string(name='createdAt', example='2018-07-13T03:58:07.253Z'),
    dedicateMaster?: boolean(name='dedicateMaster', example='false'),
    description?: string(name='description', example='es-cn-abc'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize', example='2782602'),
        name?: string(name='name', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', example='ORIGIN'),
        type?: string(name='type', example='MAIN'),
      }
    ](name='dictList'),
    domain?: string(name='domain', example='es-cn-3h4k3axh33th9****.elasticsearch.aliyuncs.com'),
    elasticDataNodeConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='20'),
      diskEncryption?: boolean(name='diskEncryption', example='true'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      spec?: string(name='spec', example='elasticsearch.sn2ne.large'),
    }(name='elasticDataNodeConfiguration'),
    enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork', example='false'),
    enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork', example='true'),
    enablePublic?: boolean(name='enablePublic', example='true'),
    esConfig?: map[string]any(name='esConfig', example='{"http.cors.allow-credentials":"false"}'),
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
    esIPWhitelist?: [ string ](name='esIPWhitelist'),
    esVersion?: string(name='esVersion', example='6.3.2_with_X-Pack'),
    extendConfigs?: [  map[string]any ](name='extendConfigs'),
    haveClientNode?: boolean(name='haveClientNode', example='true'),
    haveKibana?: boolean(name='haveKibana', example='true'),
    ikHotDicts?: [ 
      {
        fileSize?: int32(name='fileSize', example='6'),
        name?: string(name='name', example='deploy_0.dic'),
        sourceType?: string(name='sourceType', example='OSS'),
        type?: string(name='type', example='MAIN'),
      }
    ](name='ikHotDicts'),
    instanceCategory?: string(name='instanceCategory', example='advanced'),
    instanceId?: string(name='instanceId', example='es-cn-3h4k3axh33th9****'),
    isNewDeployment?: boolean(name='isNewDeployment', example='true'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', example='1'),
      disk?: int32(name='disk', example='20'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain', example='es-cn-3h4k3axh33th9****.kibana.elasticsearch.aliyuncs.com'),
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
    kibanaPort?: int32(name='kibanaPort', example='5601'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
    masterConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='40'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type', example='vpc'),
      vpcId?: string(name='vpcId', example='vpc-abc'),
      vsArea?: string(name='vsArea', example='cn-hangzhou-b'),
      vswitchId?: string(name='vswitchId', example='vsw-abc'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName', example='default'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType', example='PRIVATE_ES'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', example='0'),
      diskEncryption?: boolean(name='diskEncryption', example='true'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      performanceLevel?: string(name='performanceLevel', example='PL1'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType', example='postpaid'),
    port?: int32(name='port', example='9200'),
    postpaidServiceStatus?: string(name='postpaidServiceStatus', example='active'),
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
    protocol?: string(name='protocol', example='HTTP'),
    publicDomain?: string(name='publicDomain', example='es-cn-3h4k3axh33th9****.elasticsearch.aliyuncs.com'),
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
    publicPort?: int32(name='publicPort', example='9200'),
    resourceGroupId?: string(name='resourceGroupId', example='rg-aekzvowej3i****'),
    serviceVpc?: boolean(name='serviceVpc', example='true'),
    status?: string(name='status', example='active'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize', example='2782602'),
        name?: string(name='name', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', example='ORIGIN'),
        type?: string(name='type', example='STOP'),
      }
    ](name='synonymsDicts'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey', example='env'),
        tagValue?: string(name='tagValue', example='dev'),
      }
    ](name='tags'),
    updatedAt?: string(name='updatedAt', example='2018-07-13T03:58:07.253Z'),
    vpcInstanceId?: string(name='vpcInstanceId', example='vpc-bp1uag5jj38c****'),
    warmNode?: boolean(name='warmNode', example='true'),
    warmNodeConfiguration?: {
      amount?: int32(name='amount', example='6'),
      disk?: int32(name='disk', example='500'),
      diskEncryption?: boolean(name='diskEncryption', example='true'),
      diskType?: string(name='diskType', example='cloud_efficiency'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
    }(name='warmNodeConfiguration'),
    zoneCount?: int32(name='zoneCount', example='2'),
    zoneInfos?: [ 
      {
        status?: string(name='status', example='NORMAL'),
        zoneId?: string(name='zoneId', example='cn-hangzhou-b'),
      }
    ](name='zoneInfos'),
  }(name='Result'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstanceWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstance(InstanceId: string): DescribeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInstanceWithOptions(InstanceId, headers, runtime);
}

model DescribeKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6D*****'),
  result?: map[string]any(name='Result', example='{"map.includeElasticMapsService": "false", "server.ssl.cert": "/home/admin/packages/kibana/config/cert/client.crt", "server.ssl.enabled": "true", "server.ssl.key": "/home/admin/packages/kibana/config/cert/client.key", "xpack.reporting.capture.browser.chromium.disableSandbox": "true"}'),
}

model DescribeKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeKibanaSettingsResponseBody(name='body'),
}

async function describeKibanaSettingsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeKibanaSettingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeKibanaSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeKibanaSettings(InstanceId: string): DescribeKibanaSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeKibanaSettingsWithOptions(InstanceId, headers, runtime);
}

model DescribeLogstashResponseBody = {
  requestId?: string(name='RequestId', description='Detailed information about the instance.', example='C9334241-4837-46C2-B24B-9BDC517318DE'),
  result?: {
    extendConfigs?: [  map[string]any ](name='ExtendConfigs', description='The configuration information of the node.'),
    resourceGroupId?: string(name='ResourceGroupId', description='The number of data nodes.', example='rg-aekzvowej3i****'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey', description='The value of the tag.', example='env'),
        tagValue?: string(name='tagValue', description='The information about the zones.', example='dev'),
      }
    ](name='Tags', description='The key of the tag.'),
    zoneInfos?: [ 
      {
        status?: string(name='status', description='The zone ID of the new instance.', example='NORMAL'),
        zoneId?: string(name='zoneId', description='The configuration of cluster extension parameters.', example='cn-hangzhou-b'),
      }
    ](name='ZoneInfos', description='The status of the zone. Valid values:

*   ISOLATION: offline
*   NORMAL'),
    config?: map[string]any(name='config', description='The billing method of the instance. Valid values:

*   prepaid: subscription
*   postpaid: pay-as-you-go', example='{"slowlog.threshold.warn": "2s","slowlog.threshold.info": "1s","slowlog.threshold.debug": "500ms","slowlog.threshold.trace": "100ms" }'),
    createdAt?: string(name='createdAt', description='The state of the instance. Four states are supported:

*   Normal: active
*   Active: activating
*   Freeze: inactive
*   Invalid: invalid', example='2020-02-06T14:12:03.672Z'),
    description?: string(name='description', description='The time when the instance was created.', example='ls-cn-abc'),
    endpointList?: [ 
      {
        host?: string(name='host', description='The tags added to the ALB instance.', example='172.16.**.**'),
        port?: string(name='port', description='The IP address of the node.', example='9600'),
        zoneId?: string(name='zoneId', description='The port number.', example='cn-hangzhou-b'),
      }
    ](name='endpointList', description='The ID of the zone where the node resides.'),
    instanceId?: string(name='instanceId', description='The access information of the node.', example='ls-cn-abc'),
    networkConfig?: {
      type?: string(name='type', description='The ID of the vSwitch to which the instance is connected.', example='vpc'),
      vpcId?: string(name='vpcId', description='The zone where the cluster resides.', example='vpc-bp16k1dvzxtmagcva****'),
      vsArea?: string(name='vsArea', description='The network type of the instance. Valid values: Currently, only Virtual Private Cloud (VPC) are supported.', example='cn-hangzhou-*'),
      vswitchId?: string(name='vswitchId', example='vsw-bp1k4ec6s7sjdbudw****'),
    }(name='networkConfig', description='The ID of the virtual private cloud (VPC).'),
    nodeAmount?: int32(name='nodeAmount', description='The name of the instance.', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='Whether to use disk encryption:

*   true
*   false', example='20'),
      diskEncryption?: boolean(name='diskEncryption', description='The disk type of the node.', example='true'),
      diskType?: string(name='diskType', description='The network configurations.', example='cloud_ssd'),
      spec?: string(name='spec', description='The disk size of the node.', example='elasticsearch.sn1ne.large'),
    }(name='nodeSpec', description='The specifications of the node.'),
    paymentType?: string(name='paymentType', description='The ID of the resource group to which the instance belongs.', example='prepaid'),
    status?: string(name='status', description='The ID of the virtual private cloud (VPC) to which the elastic container instances belong.', example='active'),
    updatedAt?: string(name='updatedAt', description='The edition of the dedicated KMS instance.', example='2020-02-06T14:22:36.850Z'),
    version?: string(name='version', description='The ID of the instance.', example='7.4.0_with_X-Pack'),
    vpcInstanceId?: string(name='vpcInstanceId', description='The time when the instance was last updated.', example='vpc-bp16k1dvzxtmagcva****'),
  }(name='Result', description='The configurations of the instance.'),
}

model DescribeLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogstashResponseBody(name='body'),
}

async function describeLogstashWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeLogstashResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLogstash(InstanceId: string): DescribeLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeLogstashWithOptions(InstanceId, headers, runtime);
}

model DescribePipelineResponseBody = {
  requestId?: string(name='RequestId', description='The time when the pipeline was updated.', example='829F38F6-E2D6-4109-90A6-888160BD1***'),
  result?: {
    batchDelay?: int32(name='batchDelay', description='The time when the pipeline was created.', example='50'),
    batchSize?: int32(name='batchSize', example='125'),
    config?: string(name='config', description='The description of the pipeline.', example='input {  }  filter {  }  output {  }'),
    description?: string(name='description', description='The state of the MPS queue. Valid values:

*   NOT_DEPLOYED: The node is not deployed.
*   RUNNING
*   DELETED: Deleted. The console does not display this status.', example='this is a test'),
    gmtCreatedTime?: string(name='gmtCreatedTime', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The total capacity of the queue in bytes. Unit: MB.', example='2020-06-20T07:26:47.000+0000'),
    pipelineId?: string(name='pipelineId', description='Number of queue checkpoint writes.', example='pipeline_test'),
    pipelineStatus?: string(name='pipelineStatus', example='RUNNING'),
    queueCheckPointWrites?: int32(name='queueCheckPointWrites', description='Pipeline batch delay. Unit: milliseconds.', example='1024'),
    queueMaxBytes?: int32(name='queueMaxBytes', description='The number of pipeline workers.', example='1024'),
    queueType?: string(name='queueType', description='The specific configuration of the pipeline.', example='MEMORY'),
    workers?: int32(name='workers', description='The size of the pipeline batch.', example='2'),
  }(name='Result', description='The type of the queue. Valid values:

*   MEMORY: a traditional memory-based queue.
*   PERSISTED: disk-based ACKed queue (persistent queue).'),
}

model DescribePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePipelineResponseBody(name='body'),
}

async function describePipelineWithOptions(InstanceId: string, PipelineId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePipelineResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePipeline',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines/${OpenApiUtil.getEncodeParam(PipelineId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePipeline(InstanceId: string, PipelineId: string): DescribePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePipelineWithOptions(InstanceId, PipelineId, headers, runtime);
}

model DescribePipelineManagementConfigRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model DescribePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    endpoints?: string(name='endpoints', description='The access addresses of the Elasticsearch cluster. Specify each address in the `http://Endpoint of the Elasticsearch cluster:Port number` format.', example='["http://es-cn-n6w1o1x0w001c****.elasticsearch.aliyuncs.com:9200"]'),
    esInstanceId?: string(name='esInstanceId', description='The ID of the Elasticsearch cluster.', example='es-cn-n6w1o1x0w001c****'),
    pipelineIds?: [ string ](name='pipelineIds'),
    pipelineManagementType?: string(name='pipelineManagementType', description='The pipeline management method. Valid values: Kibana and MULTIPLE_PIPELINE.', example='MULTIPLE_PIPELINE'),
    userName?: string(name='userName', description='The username that is used to access the Elasticsearch cluster.', example='elastic'),
  }(name='Result', description='The returned result.'),
}

model DescribePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePipelineManagementConfigResponseBody(name='body'),
}

async function describePipelineManagementConfigWithOptions(InstanceId: string, request: DescribePipelineManagementConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePipelineManagementConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePipelineManagementConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipeline-management-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePipelineManagementConfig(InstanceId: string, request: DescribePipelineManagementConfigRequest): DescribePipelineManagementConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime);
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId', description='The available status of the region.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1ADFG'),
  result?: [ 
    {
      consoleEndpoint?: string(name='consoleEndpoint', example='https://elasticsearch-cn-hangzhou.console.aliyun.com'),
      localName?: string(name='localName', example='China (Hangzhou)'),
      regionEndpoint?: string(name='regionEndpoint', example='elasticsearch.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='regionId', description='The name of the region.', example='cn-hangzhou'),
      status?: string(name='status', description='The endpoint of the region that is exposed in the console.', example='available'),
    }
  ](name='Result', description='The endpoint of the region.'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

model DescribeSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: {
    enable?: boolean(name='Enable', description='Whether to enable automatic backup.', example='true'),
    quartzRegex?: string(name='QuartzRegex', description='Automatic backup time configuration, using Quartz Cron expression.', example='0 0 01 ? * * *'),
  }(name='Result', description='The return results.'),
}

model DescribeSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSnapshotSettingResponseBody(name='body'),
}

async function describeSnapshotSettingWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSnapshotSettingResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnapshotSetting',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-setting`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSnapshotSetting(InstanceId: string): DescribeSnapshotSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSnapshotSettingWithOptions(InstanceId, headers, runtime);
}

model DescribeTemplatesResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      content?: string(name='content', example='{\\n\\t\\"persistent\\":{\\n\\t\\t\\"search\\":{\\n\\t\\t\\t\\"max_buckets\\":\\"10000\\"\\n\\t\\t}\\n\\t}\\n}'),
      templateName?: string(name='templateName', example='dynamicSettings'),
    }
  ](name='Result'),
}

model DescribeTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTemplatesResponseBody(name='body'),
}

async function describeTemplatesWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTemplatesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTemplates(InstanceId: string): DescribeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTemplatesWithOptions(InstanceId, headers, runtime);
}

model DescribeXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    enable?: boolean(name='enable', description='Indicates whether the X-Pack Monitoring feature is enabled. Valid values:

*   true: enabled
*   false: disabled', example='true'),
    endpoints?: [ string ](name='endpoints'),
    esInstanceId?: string(name='esInstanceId', description='The ID of the associated Elasticsearch cluster.', example='es-cn-n6w1o1x0w001c****'),
    pipelineIds?: [ string ](name='pipelineIds'),
    userName?: string(name='userName', description='The username that is used to access the associated Elasticsearch cluster.', example='elastic'),
  }(name='Result', description='The returned result.'),
}

model DescribeXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeXpackMonitorConfigResponseBody(name='body'),
}

async function describeXpackMonitorConfigWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeXpackMonitorConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeXpackMonitorConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/xpack-monitor-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeXpackMonitorConfig(InstanceId: string): DescribeXpackMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeXpackMonitorConfigWithOptions(InstanceId, headers, runtime);
}

model DiagnoseInstanceRequest {
  clientToken?: string(name='ClientToken', description='The timestamp when the diagnostic report was generated.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  diagnoseItems?: [ string ](name='diagnoseItems'),
  indices?: [ string ](name='indices'),
  type?: string(name='type', example='ALL'),
  lang?: string(name='lang', description='The returned data.', example='en'),
}

model DiagnoseInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the report.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    createTime?: long(name='createTime', description='The ID of the diagnostic instance.', example='1535745731000'),
    instanceId?: string(name='instanceId', example='es-cn-n6w1o1x0w001c****'),
    reportId?: string(name='reportId', example='trigger__2020-08-17T17:09:02'),
    state?: string(name='state', example='RUNNING'),
  }(name='Result', description='The diagnosis status. Valid values: Supported: SUCCESS, FAILED, and RUNNING.'),
}

model DiagnoseInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DiagnoseInstanceResponseBody(name='body'),
}

async function diagnoseInstanceWithOptions(InstanceId: string, request: DiagnoseInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DiagnoseInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.diagnoseItems)) {
    body['diagnoseItems'] = request.diagnoseItems;
  }
  if (!Util.isUnset(request.indices)) {
    body['indices'] = request.indices;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DiagnoseInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/diagnose`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function diagnoseInstance(InstanceId: string, request: DiagnoseInstanceRequest): DiagnoseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return diagnoseInstanceWithOptions(InstanceId, request, headers, runtime);
}

model EstimatedLogstashRestartTimeRequest {
  body?: string(name='body'),
  force?: boolean(name='force', description='Specifies whether to forcibly restart the cluster. Default value: false.', example='false'),
}

model EstimatedLogstashRestartTimeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    unit?: string(name='unit', description='The unit.', example='second'),
    value?: long(name='value', description='The estimated restart time.', example='600'),
  }(name='Result', description='The returned result.'),
}

model EstimatedLogstashRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EstimatedLogstashRestartTimeResponseBody(name='body'),
}

async function estimatedLogstashRestartTimeWithOptions(InstanceId: string, request: EstimatedLogstashRestartTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EstimatedLogstashRestartTimeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'EstimatedLogstashRestartTime',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/estimated-time/restart-time`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function estimatedLogstashRestartTime(InstanceId: string, request: EstimatedLogstashRestartTimeRequest): EstimatedLogstashRestartTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return estimatedLogstashRestartTimeWithOptions(InstanceId, request, headers, runtime);
}

model EstimatedRestartTimeRequest {
  body?: string(name='body'),
  force?: boolean(name='force', description='Specifies whether to forcibly restart the cluster. Default value: false.', example='false'),
}

model EstimatedRestartTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    unit?: string(name='unit', description='The unit.', example='second'),
    value?: long(name='value', description='The estimated restart time.', example='50'),
  }(name='Result', description='The returned result.'),
}

model EstimatedRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EstimatedRestartTimeResponseBody(name='body'),
}

async function estimatedRestartTimeWithOptions(InstanceId: string, request: EstimatedRestartTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EstimatedRestartTimeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'EstimatedRestartTime',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/estimated-time/restart-time`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function estimatedRestartTime(InstanceId: string, request: EstimatedRestartTimeRequest): EstimatedRestartTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return estimatedRestartTimeWithOptions(InstanceId, request, headers, runtime);
}

model GetClusterDataInformationRequest {
  body?: string(name='body'),
}

model GetClusterDataInformationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    connectable?: boolean(name='connectable', description='Whether it is connectable.', example='true'),
    metaInfo?: {
      fields?: [ string ](name='fields', description='The fields in the Mapping for the index.'),
      indices?: [ string ](name='indices', description='The index list of the cluster.'),
      mapping?: string(name='mapping', description='The Mapping configuration of the cluster.', example='{\\"_doc\\":{\\"properties\\":{\\"user\\":{\\"properties\\":{\\"last\\":{\\"type\\":\\"text\\",...}}}}}}'),
      settings?: string(name='settings', description='The Settings of the cluster.', example='{\\n  \\"index\\": {\\n    \\"replication\\": {\\n}.....}}'),
      typeName?: [ string ](name='typeName', description='Specifies the type of the index.'),
    }(name='metaInfo', description='The metadata of the cluster.'),
  }(name='Result', description='The return results.'),
}

model GetClusterDataInformationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterDataInformationResponseBody(name='body'),
}

async function getClusterDataInformationWithOptions(request: GetClusterDataInformationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterDataInformationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetClusterDataInformation',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/cluster/data-information`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getClusterDataInformation(request: GetClusterDataInformationRequest): GetClusterDataInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterDataInformationWithOptions(request, headers, runtime);
}

model GetElastictaskResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression', example='0 0 0 ? * MON'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression', example='4 4 4 ? * WED'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model GetElastictaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetElastictaskResponseBody(name='body'),
}

async function getElastictaskWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetElastictaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetElastictask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/elastic-task`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getElastictask(InstanceId: string): GetElastictaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getElastictaskWithOptions(InstanceId, headers, runtime);
}

model GetEmonGrafanaAlertsRequest {
  body?: string(name='body'),
}

model GetEmonGrafanaAlertsResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='08FA74C7-5654-4309-9729-D555AF587B7F'),
  success?: boolean(name='Success', example='true'),
}

model GetEmonGrafanaAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmonGrafanaAlertsResponseBody(name='body'),
}

async function getEmonGrafanaAlertsWithOptions(ProjectId: string, request: GetEmonGrafanaAlertsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonGrafanaAlertsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetEmonGrafanaAlerts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/grafana/proxy/api/alerts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEmonGrafanaAlerts(ProjectId: string, request: GetEmonGrafanaAlertsRequest): GetEmonGrafanaAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonGrafanaAlertsWithOptions(ProjectId, request, headers, runtime);
}

model GetEmonGrafanaDashboardsRequest {
  body?: string(name='body'),
}

model GetEmonGrafanaDashboardsResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='1E9D9827-2092-4385-9DA1-FC5A8D1DB3F5'),
  success?: boolean(name='Success', example='true'),
}

model GetEmonGrafanaDashboardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmonGrafanaDashboardsResponseBody(name='body'),
}

async function getEmonGrafanaDashboardsWithOptions(ProjectId: string, request: GetEmonGrafanaDashboardsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonGrafanaDashboardsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetEmonGrafanaDashboards',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/grafana/proxy/api/search`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEmonGrafanaDashboards(ProjectId: string, request: GetEmonGrafanaDashboardsRequest): GetEmonGrafanaDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonGrafanaDashboardsWithOptions(ProjectId, request, headers, runtime);
}

model GetEmonMonitorDataRequest {
  body?: string(name='body'),
}

model GetEmonMonitorDataResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='2D184B55-FA51-43F7-A1EF-E68A0545****'),
  result?: [ 
    {
      dps?: map[string]any(name='dps', example='{ "1586249280": 465.1980465119913, "1586249300": 213.45243650423305 }'),
      integrity?: float(name='integrity', example='1.0'),
      messageWatermark?: long(name='messageWatermark', example='1522127381471'),
      metric?: string(name='metric', example='elasticbuild.elasticsearch.source.total_doc_count'),
      summary?: float(name='summary', example='10'),
      tags?: map[string]any(name='tags', example='{"taskName":"et-xxx","userId":"123456"}'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model GetEmonMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmonMonitorDataResponseBody(name='body'),
}

async function getEmonMonitorDataWithOptions(ProjectId: string, request: GetEmonMonitorDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonMonitorDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetEmonMonitorData',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/metrics/query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEmonMonitorData(ProjectId: string, request: GetEmonMonitorDataRequest): GetEmonMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonMonitorDataWithOptions(ProjectId, request, headers, runtime);
}

model GetOpenStoreUsageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1DE2491-804F-4C86-BAB4-548DD70B****'),
  result?: {
    currentUsage?: long(name='currentUsage', description='The current OpenStore storage capacity (estimated value based on actual indexes). Unit: Byte.', example='204800'),
    lastDayUsage?: long(name='lastDayUsage', description='The storage capacity of OpenStore yesterday. Unit: bytes.', example='184320'),
  }(name='Result', description='The current request result.'),
}

model GetOpenStoreUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOpenStoreUsageResponseBody(name='body'),
}

async function getOpenStoreUsageWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOpenStoreUsageResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetOpenStoreUsage',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/openstore/usage`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOpenStoreUsage(InstanceId: string): GetOpenStoreUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOpenStoreUsageWithOptions(InstanceId, headers, runtime);
}

model GetRegionConfigurationRequest {
  zoneId?: string(name='zoneId', example='cn-hangzhou-f'),
}

model GetRegionConfigurationResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6F******'),
  result?: {
    clientNodeAmountRange?: {
      maxAmount?: int32(name='maxAmount', example='25'),
      minAmount?: int32(name='minAmount', example='2'),
    }(name='clientNodeAmountRange'),
    clientNodeDiskList?: [ 
      {
        diskType?: string(name='diskType', example='cloud_efficiency'),
        maxSize?: int32(name='maxSize', example='20'),
        minSize?: int32(name='minSize', example='20'),
        scaleLimit?: int32(name='scaleLimit', example='18'),
      }
    ](name='clientNodeDiskList'),
    clientNodeSpec?: [ string ](name='clientNodeSpec'),
    createUrl?: string(name='createUrl', example='https://common-buy.aliyun.com/?commodityCode=elasticsearch&orderType=BUY#/buy'),
    dataDiskList?: [ 
      {
        diskType?: string(name='diskType', example='cloud_ssd'),
        maxSize?: int32(name='maxSize', example='5120'),
        minSize?: int32(name='minSize', example='20'),
        scaleLimit?: int32(name='scaleLimit', example='2048'),
        valueLimitSet?: [ string ](name='valueLimitSet'),
      }
    ](name='dataDiskList'),
    elasticNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount', example='25'),
        minAmount?: int32(name='minAmount', example='2'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption', example='true'),
          diskType?: string(name='diskType', example='cloud_ssd'),
          maxSize?: int32(name='maxSize', example='5120'),
          minSize?: int32(name='minSize', example='500'),
          scaleLimit?: int32(name='scaleLimit', example='2048'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='elasticNodeProperties'),
    env?: string(name='env', example='production'),
    esVersions?: [ string ](name='esVersions'),
    esVersionsLatestList?: [ 
      {
        key?: string(name='key', example='5.5_with_X-Pack'),
        value?: string(name='value', example='5.5.3_with_X-Pack'),
      }
    ](name='esVersionsLatestList'),
    instanceSupportNodes?: [ string ](name='instanceSupportNodes'),
    jvmConfine?: {
      memory?: int32(name='memory', example='32'),
      supportEsVersions?: [ string ](name='supportEsVersions'),
      supportGcs?: [ string ](name='supportGcs'),
    }(name='jvmConfine'),
    kibanaNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount', example='20'),
        minAmount?: int32(name='minAmount', example='1'),
      }(name='amountRange'),
      spec?: [ string ](name='spec'),
    }(name='kibanaNodeProperties'),
    masterDiskList?: [ 
      {
        diskType?: string(name='diskType', example='cloud_ssd'),
        maxSize?: int32(name='maxSize', example='20'),
        minSize?: int32(name='minSize', example='20'),
        scaleLimit?: int32(name='scaleLimit', example='20'),
      }
    ](name='masterDiskList'),
    masterSpec?: [ string ](name='masterSpec'),
    node?: {
      maxAmount?: int32(name='maxAmount', example='50'),
      minAmount?: int32(name='minAmount', example='2'),
    }(name='node'),
    nodeSpecList?: [ 
      {
        cpuCount?: int32(name='cpuCount', example='16'),
        disk?: int32(name='disk', example='44000'),
        diskType?: string(name='diskType', example='local_efficiency'),
        enable?: boolean(name='enable', example='true'),
        memorySize?: int32(name='memorySize', example='64'),
        spec?: string(name='spec', example='elasticsearch.sn2ne.large'),
        specGroupType?: string(name='specGroupType', example='local_efficiency'),
      }
    ](name='nodeSpecList'),
    regionId?: string(name='regionId', example='cn-hangzhou'),
    supportVersions?: [ 
      {
        instanceCategory?: string(name='instanceCategory', example='x-pack'),
        supportVersionList?: [ 
          {
            key?: string(name='key', example='5.5'),
            value?: string(name='value', example='5.5.3'),
          }
        ](name='supportVersionList'),
      }
    ](name='supportVersions'),
    warmNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount', example='50'),
        minAmount?: int32(name='minAmount', example='2'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption', example='true'),
          diskType?: string(name='diskType', example='cloud_efficiency'),
          maxSize?: int32(name='maxSize', example='5120'),
          minSize?: int32(name='minSize', example='500'),
          scaleLimit?: int32(name='scaleLimit', example='2048'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='warmNodeProperties'),
    zones?: [ string ](name='zones'),
  }(name='Result'),
}

model GetRegionConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegionConfigurationResponseBody(name='body'),
}

async function getRegionConfigurationWithOptions(request: GetRegionConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.zoneId)) {
    query['zoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRegionConfiguration',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/region`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRegionConfiguration(request: GetRegionConfigurationRequest): GetRegionConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionConfigurationWithOptions(request, headers, runtime);
}

model GetSuggestShrinkableNodesRequest {
  count?: int32(name='count', description='The number of nodes that you want to remove.', example='1'),
  ignoreStatus?: boolean(name='ignoreStatus', description='Specifies whether to ignore the instance status. Default value: false.', example='false'),
  nodeType?: string(name='nodeType', description='The type of removing nodes. WORKER indicates hot node and WORKER_WARM indicates warm node.', example='WORKER'),
}

model GetSuggestShrinkableNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      host?: string(name='host', description='The IP address of the node.', example='192.168.**.**'),
      port?: int32(name='port', description='The access port number of the node.', example='9200'),
    }
  ](name='Result', description='The return results.'),
}

model GetSuggestShrinkableNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSuggestShrinkableNodesResponseBody(name='body'),
}

async function getSuggestShrinkableNodesWithOptions(InstanceId: string, request: GetSuggestShrinkableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSuggestShrinkableNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query['ignoreStatus'] = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSuggestShrinkableNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/suggest-shrinkable-nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSuggestShrinkableNodes(InstanceId: string, request: GetSuggestShrinkableNodesRequest): GetSuggestShrinkableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSuggestShrinkableNodesWithOptions(InstanceId, request, headers, runtime);
}

model GetTransferableNodesRequest {
  count?: int32(name='count', description='The number of nodes to be migrated.', example='1'),
  nodeType?: string(name='nodeType', description='The type of nodes.**WORKER**represents a hot node,**WORKER_WARM** represents a warm node.', example='WORKER'),
}

model GetTransferableNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      host?: string(name='host', description='The IP address of the node.', example='192.168.**.**'),
      port?: int32(name='port', description='The access port of the node.', example='9200'),
    }
  ](name='Result', description='The return results.'),
}

model GetTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTransferableNodesResponseBody(name='body'),
}

async function getTransferableNodesWithOptions(InstanceId: string, request: GetTransferableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTransferableNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTransferableNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/transferable-nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTransferableNodes(InstanceId: string, request: GetTransferableNodesRequest): GetTransferableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTransferableNodesWithOptions(InstanceId, request, headers, runtime);
}

model InitializeOperationRoleRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model InitializeOperationRoleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29101430-4797-4D1D-96C3-9FCBCCA8F845'),
  result?: boolean(name='Result', description='Indicates whether the service-linked role is created. Valid values:

*   true: The service-linked role is created.
*   false: The service-linked role fails to be created.', example='true'),
}

model InitializeOperationRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InitializeOperationRoleResponseBody(name='body'),
}

/**
  * > Before you perform auto scaling for a cluster at the China site (aliyun.com) or you use shippers to collect logs, you must create a service-linked role.
  *
  * @param request InitializeOperationRoleRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return InitializeOperationRoleResponse
 */
async function initializeOperationRoleWithOptions(request: InitializeOperationRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InitializeOperationRoleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InitializeOperationRole',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/user/slr`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > Before you perform auto scaling for a cluster at the China site (aliyun.com) or you use shippers to collect logs, you must create a service-linked role.
  *
  * @param request InitializeOperationRoleRequest
  * @return InitializeOperationRoleResponse
 */
async function initializeOperationRole(request: InitializeOperationRoleRequest): InitializeOperationRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initializeOperationRoleWithOptions(request, headers, runtime);
}

model InstallAckOperatorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model InstallAckOperatorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EFA88951-7A6F-4A8E-AB8F-2BB7132BA751'),
  result?: boolean(name='Result', description='Indicates whether ES-operator is installed. Valid values:

*   true
*   false', example='true'),
}

model InstallAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallAckOperatorResponseBody(name='body'),
}

/**
  * > Before you install a shipper for an ACK cluster, you must call this operation to install ES-operator for the cluster.
  *
  * @param request InstallAckOperatorRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return InstallAckOperatorResponse
 */
async function installAckOperatorWithOptions(ClusterId: string, request: InstallAckOperatorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallAckOperatorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallAckOperator',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters/${OpenApiUtil.getEncodeParam(ClusterId)}/operator`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > Before you install a shipper for an ACK cluster, you must call this operation to install ES-operator for the cluster.
  *
  * @param request InstallAckOperatorRequest
  * @return InstallAckOperatorResponse
 */
async function installAckOperator(ClusterId: string, request: InstallAckOperatorRequest): InstallAckOperatorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installAckOperatorWithOptions(ClusterId, request, headers, runtime);
}

model InstallKibanaSystemPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InstallKibanaSystemPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: [ string ](name='Result', description='The list of plug-ins to be installed.'),
}

model InstallKibanaSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallKibanaSystemPluginResponseBody(name='body'),
}

async function installKibanaSystemPluginWithOptions(InstanceId: string, request: InstallKibanaSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallKibanaSystemPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallKibanaSystemPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-plugins/system/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installKibanaSystemPlugin(InstanceId: string, request: InstallKibanaSystemPluginRequest): InstallKibanaSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installKibanaSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

model InstallLogstashSystemPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InstallLogstashSystemPluginResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC4****'),
  result?: [ string ](name='Result'),
}

model InstallLogstashSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallLogstashSystemPluginResponseBody(name='body'),
}

/**
  * ls-cn-oew1qbgl\\*\\*\\*\\*
  *
  * @param request InstallLogstashSystemPluginRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return InstallLogstashSystemPluginResponse
 */
async function installLogstashSystemPluginWithOptions(InstanceId: string, request: InstallLogstashSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallLogstashSystemPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallLogstashSystemPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/system/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ls-cn-oew1qbgl\\*\\*\\*\\*
  *
  * @param request InstallLogstashSystemPluginRequest
  * @return InstallLogstashSystemPluginResponse
 */
async function installLogstashSystemPlugin(InstanceId: string, request: InstallLogstashSystemPluginRequest): InstallLogstashSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installLogstashSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

model InstallSystemPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InstallSystemPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ string ](name='Result', description='The list of plug-ins to be installed.'),
}

model InstallSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallSystemPluginResponseBody(name='body'),
}

async function installSystemPluginWithOptions(InstanceId: string, request: InstallSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallSystemPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallSystemPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/system/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installSystemPlugin(InstanceId: string, request: InstallSystemPluginRequest): InstallSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

model InstallUserPluginsRequest {
  body?: string(name='body'),
}

model InstallUserPluginsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6F*****'),
  result?: [ string ](name='Result'),
}

model InstallUserPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallUserPluginsResponseBody(name='body'),
}

async function installUserPluginsWithOptions(InstanceId: string, request: InstallUserPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallUserPluginsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallUserPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/user/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installUserPlugins(InstanceId: string, request: InstallUserPluginsRequest): InstallUserPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installUserPluginsWithOptions(InstanceId, request, headers, runtime);
}

model InterruptElasticsearchTaskRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InterruptElasticsearchTaskResponseBody = {
  code?: string(name='Code', description='The error code. Only displayed if an exception is returned.', example='InstanceStatusNotSupportCurrentAction'),
  message?: string(name='Message', description='The error message. Only displayed if an exception is returned.', example='The cluster is running tasks or in an error status. Try again later.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: boolean(name='Result', description='Return results:

*   true: interrupted change successfully
*   false: interrupted change failed', example='true'),
}

model InterruptElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InterruptElasticsearchTaskResponseBody(name='body'),
}

async function interruptElasticsearchTaskWithOptions(InstanceId: string, request: InterruptElasticsearchTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InterruptElasticsearchTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InterruptElasticsearchTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/interrupt`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function interruptElasticsearchTask(InstanceId: string, request: InterruptElasticsearchTaskRequest): InterruptElasticsearchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return interruptElasticsearchTaskWithOptions(InstanceId, request, headers, runtime);
}

model InterruptLogstashTaskRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InterruptLogstashTaskResponseBody = {
  code?: string(name='Code', description='The error code returned. If the API operation is successfully called, this parameter is not returned.', example='.'),
  message?: string(name='Message', description='The error message returned. If the API operation is successfully called, this parameter is not returned.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0FA05123-745C-42FD-A69B-AFF48EF9****'),
  result?: boolean(name='Result', description='Indicates whether the task is suspended. Valid values:

*   true
*   false', example='true'),
}

model InterruptLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InterruptLogstashTaskResponseBody(name='body'),
}

async function interruptLogstashTaskWithOptions(InstanceId: string, request: InterruptLogstashTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InterruptLogstashTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InterruptLogstashTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/interrupt`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function interruptLogstashTask(InstanceId: string, request: InterruptLogstashTaskRequest): InterruptLogstashTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return interruptLogstashTaskWithOptions(InstanceId, request, headers, runtime);
}

model ListAckClustersRequest {
  page?: int32(name='page', description='The number of the page to return.', example='3'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='20'),
  vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) to which the ACK clusters belong.', example='vpc-bp12nu14urf0upaf4****'),
}

model ListAckClustersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F93EAA49-284F-4FCE-9E67-FA23FB4BB512'),
  result?: [ 
    {
      clusterId?: string(name='clusterId', description='The ID of cluster.', example='c5ea2c2d9a3cf499481292f60425d****'),
      clusterType?: string(name='clusterType', description='The type of the cluster. The value is fixed as ManagedKubernetes.', example='ManagedKubernetes'),
      name?: string(name='name', description='The name of the cluster.', example='test'),
      vpcId?: string(name='vpcId', description='The ID of the VPC to which the cluster belongs.', example='vpc-bp12nu14urf0upaf4****'),
    }
  ](name='Result', description='The returned result.'),
}

model ListAckClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAckClustersResponseBody(name='body'),
}

async function listAckClustersWithOptions(request: ListAckClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAckClustersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['vpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAckClusters',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAckClusters(request: ListAckClustersRequest): ListAckClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAckClustersWithOptions(request, headers, runtime);
}

model ListAckNamespacesRequest {
  page?: int32(name='page', description='The number of the page to return.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='10'),
}

model ListAckNamespacesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='95789100-A329-473B-9D14-9E0B7DB4BD5A'),
  result?: [ 
    {
      namespace?: string(name='namespace', description='The namespace of the cluster.', example='logging'),
      status?: string(name='status', description='The status of the namespace.', example='Active'),
    }
  ](name='Result', description='The returned result.'),
}

model ListAckNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAckNamespacesResponseBody(name='body'),
}

/**
  * > When you install a shipper on an ACK cluster, you must specify a namespace. You can call this operation to query all namespaces in the ACK cluster, and select a namespace based on your business requirements.
  *
  * @param request ListAckNamespacesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListAckNamespacesResponse
 */
async function listAckNamespacesWithOptions(ClusterId: string, request: ListAckNamespacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAckNamespacesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAckNamespaces',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters/${OpenApiUtil.getEncodeParam(ClusterId)}/namespaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > When you install a shipper on an ACK cluster, you must specify a namespace. You can call this operation to query all namespaces in the ACK cluster, and select a namespace based on your business requirements.
  *
  * @param request ListAckNamespacesRequest
  * @return ListAckNamespacesResponse
 */
async function listAckNamespaces(ClusterId: string, request: ListAckNamespacesRequest): ListAckNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAckNamespacesWithOptions(ClusterId, request, headers, runtime);
}

model ListActionRecordsRequest {
  actionNames?: string(name='actionNames'),
  endTime?: long(name='endTime'),
  filter?: string(name='filter'),
  page?: int32(name='page'),
  requestId?: string(name='requestId'),
  size?: int32(name='size'),
  startTime?: long(name='startTime'),
  userId?: string(name='userId'),
}

model ListActionRecordsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      actionName?: string(name='ActionName'),
      actionParams?: map[string]any(name='ActionParams'),
      actionResultAccessList?: [ string ](name='ActionResultAccessList'),
      endTime?: long(name='EndTime'),
      instanceId?: string(name='InstanceId'),
      metaNow?: string(name='MetaNow'),
      metaOld?: string(name='MetaOld'),
      ownerId?: string(name='OwnerId'),
      process?: string(name='Process'),
      recordDiff?: map[string]any(name='RecordDiff'),
      recordIds?: [ string ](name='RecordIds'),
      requestId?: string(name='RequestId'),
      startTime?: long(name='StartTime'),
      stateType?: string(name='StateType'),
      statusInfo?: [ 
        {
          completeNodeCount?: int32(name='completeNodeCount'),
          endTime?: long(name='endTime'),
          exception?: string(name='exception'),
          latencyMills?: long(name='latencyMills'),
          nodeCount?: int32(name='nodeCount'),
          process?: string(name='process'),
          startTime?: long(name='startTime'),
          stateType?: string(name='stateType'),
          subState?: string(name='subState'),
          subStatusInfo?: [ 
            {
              completeNodeCount?: int32(name='completeNodeCount'),
              endTime?: long(name='endTime'),
              exception?: string(name='exception'),
              latencyMills?: long(name='latencyMills'),
              nodeCount?: int32(name='nodeCount'),
              process?: string(name='process'),
              startTime?: long(name='startTime'),
              stateType?: string(name='stateType'),
              subState?: string(name='subState'),
            }
          ](name='subStatusInfo'),
        }
      ](name='StatusInfo'),
      userId?: string(name='UserId'),
      userInfo?: string(name='UserInfo'),
      userType?: string(name='UserType'),
    }
  ](name='Result'),
}

model ListActionRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListActionRecordsResponseBody(name='body'),
}

async function listActionRecordsWithOptions(InstanceId: string, request: ListActionRecordsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListActionRecordsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.actionNames)) {
    query['actionNames'] = request.actionNames;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filter)) {
    query['filter'] = request.filter;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.requestId)) {
    query['requestId'] = request.requestId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.userId)) {
    query['userId'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListActionRecords',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/action-records`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listActionRecords(InstanceId: string, request: ListActionRecordsRequest): ListActionRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listActionRecordsWithOptions(InstanceId, request, headers, runtime);
}

model ListAllNodeRequest {
  extended?: boolean(name='extended', description='The Java Virtual Machine (JVM) heap memory usage of the node.', example='false'),
}

model ListAllNodeResponseBody = {
  requestId?: string(name='RequestId', description='The zone ID of the node.', example='0D71B597-F3FF-5B56-88D7-74F9D3F7****'),
  result?: [ 
    {
      cpuPercent?: string(name='cpuPercent', description='The disk usage.', example='4.2%'),
      diskUsedPercent?: string(name='diskUsedPercent', description='The health status of the node. Valid values: GREEN, YELLOW, RED, and GRAY.', example='1.0%'),
      health?: string(name='health', example='GREEN'),
      heapPercent?: string(name='heapPercent', description='The IP address of the node.', example='21.6%'),
      host?: string(name='host', description='The port that is used to connect to the node.', example='10.15.XX.XX'),
      loadOneM?: string(name='loadOneM', example='0.12'),
      nodeType?: string(name='nodeType', description='The 1-minute load of the node.', example='WORKER'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', description='The type of the nodes. Valid values:

*   MASTER: dedicated master node
*   WORKER: hot node
*   WORKER_WARM: warm node
*   COORDINATING: client node
*   KIBANA: Kibana node', example='cn-hangzhou-i'),
    }
  ](name='Result', description='The CPU utilization.

>  If the **extended** request parameter is set to **true** and the monitoring information of the nodes in the cluster is being synchronized, the value of the cpuPercent parameter is null. In this case, you need to send a request again after 10 seconds to obtain the value of the cpuPercent parameter.'),
}

model ListAllNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAllNodeResponseBody(name='body'),
}

async function listAllNodeWithOptions(InstanceId: string, request: ListAllNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAllNodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.extended)) {
    query['extended'] = request.extended;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAllNode',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAllNode(InstanceId: string, request: ListAllNodeRequest): ListAllNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAllNodeWithOptions(InstanceId, request, headers, runtime);
}

model ListAlternativeSnapshotReposRequest {
  alreadySetItems?: boolean(name='alreadySetItems', description='Indicates whether to return the OSS reference repository added. The return value. Valid values: true and false.', example='true'),
}

model ListAlternativeSnapshotReposResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      instanceId?: string(name='instanceId', description='The ID of the instance.', example='es-cn-6ja1ro4jt000c****'),
      repoPath?: string(name='repoPath', description='The address of the repository.', example='RepoPath'),
    }
  ](name='Result', description='The return results.'),
}

model ListAlternativeSnapshotReposResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlternativeSnapshotReposResponseBody(name='body'),
}

async function listAlternativeSnapshotReposWithOptions(InstanceId: string, request: ListAlternativeSnapshotReposRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlternativeSnapshotReposResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.alreadySetItems)) {
    query['alreadySetItems'] = request.alreadySetItems;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlternativeSnapshotRepos',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/alternative-snapshot-repos`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlternativeSnapshotRepos(InstanceId: string, request: ListAlternativeSnapshotReposRequest): ListAlternativeSnapshotReposResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlternativeSnapshotReposWithOptions(InstanceId, request, headers, runtime);
}

model ListApmRequest {
  description?: string(name='description', example='APMtest'),
  instanceId?: string(name='instanceId', example='apm-cn-i7m2fuae****'),
  output?: string(name='output', example='es-cn-i7m2fsfhc001x****'),
  page?: long(name='page', example='1'),
  size?: long(name='size', example='10'),
}

model ListApmResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='1'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='080D3399-76CF-519D-A540-2C44BC056EB7'),
  result?: [ 
    {
      createdAt?: string(name='createdAt', example='2021-11-16T07:15:51.967Z'),
      deployedReplica?: long(name='deployedReplica', example='1'),
      description?: string(name='description', example='APMtest'),
      instanceId?: string(name='instanceId', example='apm-cn-i7m2fuae****'),
      nodeAmount?: long(name='nodeAmount', example='1'),
      outputES?: string(name='outputES', example='es-cn-i7m2fsfhc001x****'),
      outputESUserName?: string(name='outputESUserName', example='elastic'),
      ownerId?: string(name='ownerId', example='133071096032****'),
      paymentType?: string(name='paymentType', example='postpaid'),
      region?: string(name='region', example='cn-hangzhou'),
      replica?: long(name='replica', example='1'),
      resourceSpec?: string(name='resourceSpec', example='C1M2'),
      status?: string(name='status', example='active'),
      version?: string(name='version', example='7.10.2'),
      vpcId?: string(name='vpcId', example='vpc-bp1530vdhqkamm9s0****'),
      vsArea?: string(name='vsArea', example='cn-hangzhou-i'),
      vswitchId?: string(name='vswitchId', example='vsw-bp1j1mql6r9g5vfb4****'),
    }
  ](name='Result'),
}

model ListApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApmResponseBody(name='body'),
}

async function listApmWithOptions(request: ListApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListApmResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.output)) {
    query['output'] = request.output;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApm(request: ListApmRequest): ListApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listApmWithOptions(request, headers, runtime);
}

model ListAvailableEsInstanceIdsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      description?: string(name='description', description='The name of the Elasticsearch cluster.', example='instanceName'),
      endpoint?: string(name='endpoint', description='The address that is used to access the Elasticsearch cluster over the Internet.', example='http://es-cn-n6w1o1x0w001c****.elasticsearch.aliyuncs.com:9200'),
      esInstanceId?: string(name='esInstanceId', description='The ID of the Elasticsearch cluster.', example='es-cn-n6w1o1x0w001c****'),
      kibanaEndpoint?: string(name='kibanaEndpoint', description='The address that is used to access the Kibana console of the Elasticsearch cluster over the Internet.', example='https://es-cn-n6w1o1x0w001c****.kibana.elasticsearch.aliyuncs.com:5601'),
    }
  ](name='Result', description='The returned result.'),
}

model ListAvailableEsInstanceIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAvailableEsInstanceIdsResponseBody(name='body'),
}

async function listAvailableEsInstanceIdsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListAvailableEsInstanceIdsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableEsInstanceIds',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/available-elasticsearch-for-centralized-management`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAvailableEsInstanceIds(InstanceId: string): ListAvailableEsInstanceIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAvailableEsInstanceIdsWithOptions(InstanceId, headers, runtime);
}

model ListCollectorsRequest {
  instanceId?: string(name='instanceId', description='The ID of the resource with which the shipper is associated.', example='es-cn-nif1q8auz0003****'),
  name?: string(name='name', description='The name of the shipper.', example='collectorName1'),
  page?: int32(name='page', description='The number of the page to return. Valid values: 1 to 200. Default value: 1.', example='1'),
  resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-77uqof2s7rg5c****'),
  size?: int32(name='size', description='The number of entries to return on each page. Valid values: 1 to 500. Default value: 20.', example='10'),
  sourceType?: string(name='sourceType', description='The type of the machine on which the shipper is deployed. If you leave this parameter empty, shippers deployed on all types of machines are returned. Valid values:

*   ECS
*   ACK', example='ECS'),
}

model ListCollectorsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='5'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      collectorPaths?: [ string ](name='collectorPaths'),
      configs?: [ 
        {
          content?: string(name='content', description='The content of the file.', example='- key: log\\n title: Log file content\\n description: >\\n Contains log file lines.\\n ....'),
          fileName?: string(name='fileName', description='The name of the file.', example='fields.yml'),
        }
      ](name='configs', description='The information about the configuration file of the shipper.'),
      dryRun?: boolean(name='dryRun', description='Indicates whether a dry run is performed. Valid values:

*   true
*   false', example='false'),
      extendConfigs?: [ 
        {
          configType?: string(name='configType', description='The configuration type. Valid values:

*   collectorTargetInstance
*   collectorDeployMachine
*   collectorElasticsearchForKibana', example='collectorDeployMachine'),
          enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether monitoring is enabled. This parameter is returned if the value of **configType** is **collectorTargetInstance** and the value of **instanceType** is **elasticsearch**. Valid values:

*   true
*   false', example='true'),
          groupId?: string(name='groupId', description='The ID of the machine group. This parameter is returned if the value of **configType** is **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
          host?: string(name='host', description='The internal endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
          hosts?: [ string ](name='hosts'),
          instanceId?: string(name='instanceId', description='The ID of the resource with which the shipper is associated. If the value of **configType** is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='es-cn-nif1z89fz003i****'),
          instanceType?: string(name='instanceType', description='The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='elasticsearch'),
          kibanaHost?: string(name='kibanaHost', description='The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601'),
          machines?: [ 
            {
              agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values:

*   heartOk
*   heartLost
*   uninstalled
*   failed', example='heartOk'),
              instanceId?: string(name='instanceId', description='The IDs of the ECS instances.', example='i-bp13y63575oypr9d****'),
            }
          ](name='machines', description='The information about the ECS instances on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ECSInstanceId**.'),
          protocol?: string(name='protocol', description='The transmission protocol, which must be the same as the access protocol of the resource specified in the output configuration part of the shipper. Valid values: HTTP and HTTPS. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='HTTP'),
          successPodsCount?: string(name='successPodsCount', description='The number of pods from which data is successfully collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='8'),
          totalPodsCount?: string(name='totalPodsCount', description='The total number of pods from which data is collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='10'),
          type?: string(name='type', description='The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
          userName?: string(name='userName', description='The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
        }
      ](name='extendConfigs', description='The extended configurations of the shipper.'),
      gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-08-18T02:06:12.000+0000'),
      gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-08-18T09:40:43.000+0000'),
      name?: string(name='name', description='The name of the shipper.', example='FileBeat001'),
      ownerId?: string(name='ownerId', description='The account ID.', example='168520994880****'),
      resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-0v3xj86085dvq****'),
      resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.', example='fileBeat'),
      resVersion?: string(name='resVersion', description='The version of the shipper.', example='6.8.5_with_community'),
      status?: string(name='status', description='The status of the shipper. Valid values:

*   activating
*   active', example='active'),
      vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) where the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
    }
  ](name='Result', description='The returned result.'),
}

model ListCollectorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCollectorsResponseBody(name='body'),
}

async function listCollectorsWithOptions(request: ListCollectorsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCollectorsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.resId)) {
    query['resId'] = request.resId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['sourceType'] = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCollectors',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCollectors(request: ListCollectorsRequest): ListCollectorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCollectorsWithOptions(request, headers, runtime);
}

model ListComponentIndicesRequest {
  name?: string(name='name', example='template'),
  page?: int32(name='page', example='5'),
  size?: int32(name='size', example='10'),
}

model ListComponentIndicesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='10'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      composed?: [ string ](name='composed'),
      content?: {
        meta?: map[string]any(name='_meta', example='{ "description": "set number of shards to one" }'),
        template?: {
          settings?: {
            index?: {
              codec?: string(name='codec', example='best_compression'),
              lifecycle?: {
                name?: string(name='name', example='synthetics'),
              }(name='lifecycle'),
            }(name='index'),
          }(name='settings'),
        }(name='template'),
        version?: long(name='version', example='0'),
      }(name='content'),
      name?: string(name='name', example='synthetics-settings'),
    }
  ](name='Result'),
}

model ListComponentIndicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListComponentIndicesResponseBody(name='body'),
}

async function listComponentIndicesWithOptions(InstanceId: string, request: ListComponentIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentIndicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListComponentIndices',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listComponentIndices(InstanceId: string, request: ListComponentIndicesRequest): ListComponentIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentIndicesWithOptions(InstanceId, request, headers, runtime);
}

model ListConnectedClustersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    result?: [ 
    {
      instances?: string(name='instances', description='The ID of the remote instance that is connected to the network of the current instance.', example='es-cn-09k1rocex0006****'),
      networkType?: string(name='networkType', description='The network type of the instance.', example='vpc'),
    }
  ](name='Result')
  }(name='Result', description='The return results.'),
}

model ListConnectedClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConnectedClustersResponseBody(name='body'),
}

async function listConnectedClustersWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListConnectedClustersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListConnectedClusters',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connected-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConnectedClusters(InstanceId: string): ListConnectedClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConnectedClustersWithOptions(InstanceId, headers, runtime);
}

model ListDataStreamsRequest {
  isManaged?: boolean(name='isManaged', example='false'),
  name?: string(name='name', example='Log1'),
}

model ListDataStreamsResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count', example='100'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize', example='143993923932990'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      health?: string(name='health', example='Green'),
      ilmPolicyName?: string(name='ilmPolicyName', example='rollver1'),
      indexTemplateName?: string(name='indexTemplateName', example='template1'),
      indices?: [ 
        {
          createTime?: string(name='createTime', example='2018-07-13T03:58:07.253Z'),
          health?: string(name='health', example='Green'),
          isManaged?: boolean(name='isManaged', example='false'),
          managedStatus?: string(name='managedStatus', example='following'),
          name?: string(name='name', example='Log1'),
          size?: long(name='size', example='15393899'),
        }
      ](name='indices'),
      managedStorageSize?: long(name='managedStorageSize', example='1788239393298'),
      name?: string(name='name', example='my-index-0001'),
      totalStorageSize?: long(name='totalStorageSize', example='1788239393298'),
    }
  ](name='Result'),
}

model ListDataStreamsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataStreamsResponseBody(name='body'),
}

async function listDataStreamsWithOptions(InstanceId: string, request: ListDataStreamsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataStreamsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.isManaged)) {
    query['isManaged'] = request.isManaged;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataStreams',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataStreams(InstanceId: string, request: ListDataStreamsRequest): ListDataStreamsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataStreamsWithOptions(InstanceId, request, headers, runtime);
}

model ListDataTasksResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The time when the site monitoring task was created.', example='2020-07-30 06:32:18'),
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType', description='The type of the target cluster. Default value: elasticsearch.', example='1'),
        endpoint?: string(name='endpoint', description='The public network access address of the target cluster.', example='http://192.168.xx.xx:4101'),
        index?: string(name='index', description='The target index.', example='product_info'),
        type?: string(name='type', description='The type of the destination index.', example='_doc'),
        vpcId?: string(name='vpcId', description='The ID of the VPC to which the cluster belongs.', example='vpc-2ze55voww95g82gak****'),
        vpcInstanceId?: string(name='vpcInstanceId', description='The instance ID or Server Load Balancer (SLB) ID of the current cluster.', example='es-cn-09k1rnu3g0002****-worker'),
        vpcInstancePort?: string(name='vpcInstancePort', description='The access port number of the cluster.', example='9200'),
      }(name='sinkCluster', description='The information of the target cluster.'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType', description='The type of the source cluster. Default value: elasticsearch.', example='1'),
        index?: string(name='index', description='The index whose data you want to migrate.', example='product_info'),
        mapping?: string(name='mapping', description='The Mapping configuration of the cluster.', example='{\\"_doc\\":{\\"properties\\":{\\"user\\":{\\"properties\\":{\\"last\\":{\\"type\\":\\"text\\",...}}}}}}'),
        routing?: string(name='routing', description='The routing field to index the table. It is set to the primary key by default.', example='_id'),
        settings?: string(name='settings', description='The Settings of the cluster.', example='{\\n  \\"index\\": {\\n    \\"replication\\": {\\n}.....}}'),
        type?: string(name='type', description='The type of the destination index.', example='_doc'),
      }(name='sourceCluster', description='The information about the source cluster.'),
      status?: string(name='status', description='The status of the task.', example='SUCCESS'),
      taskId?: string(name='taskId', description='The ID of the task.', example='et_cn_mfv1233r47272****'),
    }
  ](name='Result', description='The return results.'),
}

model ListDataTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataTasksResponseBody(name='body'),
}

async function listDataTasksWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataTasksResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataTasks',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-task`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataTasks(InstanceId: string): ListDataTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataTasksWithOptions(InstanceId, headers, runtime);
}

model ListDefaultCollectorConfigurationsRequest {
  resType?: string(name='resType', description='The shipper type. Valid values:

*   fileBeat
*   metricBeat
*   heartBeat
*   auditBeat', example='fileBeat'),
  resVersion?: string(name='resVersion', description='The shipper version. The shipper version varies based on the type of the machine on which the shipper is deployed. Valid values:

*   ECS: 6.8.5\\_with_community
*   ACK: 6.8.13\\_with_community', example='6.8.5_with_community'),
  sourceType?: string(name='sourceType', description='The type of the machine on which the shipper is deployed. If you do not configure this parameter, the default configuration files of shippers deployed on all types of machines are returned. Valid values:

*   ECS: ECS instance
*   ACK: ACK cluster', example='ECS'),
}

model ListDefaultCollectorConfigurationsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8BAE3C32-8E4A-47D6-B4B0-95B5DE643BF5'),
  result?: [ 
    {
      content?: string(name='content', description='The content of the configuration file.', example='- key: log\\n  title: Log file content\\n  description: >\\n    Contains log file lines.\\n  fields:\\n ......'),
      fileName?: string(name='fileName', description='The name of the configuration file.', example='fields.yml'),
    }
  ](name='Result', description='The returned result.'),
}

model ListDefaultCollectorConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDefaultCollectorConfigurationsResponseBody(name='body'),
}

async function listDefaultCollectorConfigurationsWithOptions(request: ListDefaultCollectorConfigurationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDefaultCollectorConfigurationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resType)) {
    query['resType'] = request.resType;
  }
  if (!Util.isUnset(request.resVersion)) {
    query['resVersion'] = request.resVersion;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['sourceType'] = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDefaultCollectorConfigurations',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/beats/default-configurations`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDefaultCollectorConfigurations(request: ListDefaultCollectorConfigurationsRequest): ListDefaultCollectorConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDefaultCollectorConfigurationsWithOptions(request, headers, runtime);
}

model ListDeprecatedTemplatesRequest {
  name?: string(name='name', example='component-openstore-index-template'),
  page?: int32(name='page', example='5'),
  size?: int32(name='size', example='10'),
}

model ListDeprecatedTemplatesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='5'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream', example='false'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate', example='openstore-index-template'),
      order?: long(name='order', example='100'),
      template?: {
        aliases?: string(name='aliases', example='"{}"'),
        mappings?: string(name='mappings', example='"{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}"'),
        settings?: string(name='settings', example='"{\\"index.number_of_shards\\":\\"1\\"}"'),
      }(name='template'),
      version?: string(name='version', example='70000'),
    }
  ](name='Result'),
}

model ListDeprecatedTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeprecatedTemplatesResponseBody(name='body'),
}

async function listDeprecatedTemplatesWithOptions(InstanceId: string, request: ListDeprecatedTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeprecatedTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeprecatedTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/deprecated-templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeprecatedTemplates(InstanceId: string, request: ListDeprecatedTemplatesRequest): ListDeprecatedTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeprecatedTemplatesWithOptions(InstanceId, request, headers, runtime);
}

model ListDiagnoseIndicesRequest {
  lang?: string(name='lang', description='The language. Multiple languages are supported.', example='en'),
}

model ListDiagnoseIndicesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F05ED12E-140A-4ACB-B059-3A508A69F2E1'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseIndicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnoseIndicesResponseBody(name='body'),
}

async function listDiagnoseIndicesWithOptions(InstanceId: string, request: ListDiagnoseIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseIndicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnoseIndices',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/indices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDiagnoseIndices(InstanceId: string, request: ListDiagnoseIndicesRequest): ListDiagnoseIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseIndicesWithOptions(InstanceId, request, headers, runtime);
}

model ListDiagnoseReportRequest {
  detail?: boolean(name='detail', description='SYSTEM', example='true'),
  endTime?: long(name='endTime', description='1', example='1595174399999'),
  lang?: string(name='lang', description='1594569600000', example='spanish'),
  page?: int32(name='page', description='20', example='1'),
  size?: int32(name='size', description='true', example='20'),
  startTime?: long(name='startTime', description='1595174399999', example='1594569600000'),
  trigger?: string(name='trigger', description='The ID of the request.', example='SYSTEM'),
}

model ListDiagnoseReportResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The returned results.', example='15'),
  }(name='Headers', description='The total number of entries returned.'),
  requestId?: string(name='RequestId', description='The header of the response.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      createTime?: long(name='createTime', description='The ID of the report.', example='1535745731000'),
      diagnoseItems?: [ 
        {
          detail?: {
            desc?: string(name='desc', description='The diagnosis.', example='Check whether the number of replica shards is optimal and easy to maintain'),
            name?: string(name='name', description='The description of the diagnostic item.', example='Number of Replica Shards'),
            result?: string(name='result', description='The suggestion for the diagnosis.', example='You may need to adjust the numbers of replica shards of some indices as follows:  [geoname08 : 0 -&gt; 1][geoname09 : 0 -&gt; 1][geonametest01 : 0 -&gt; 1]'),
            suggest?: string(name='suggest', example='You can call the following function in the Elasticsearch API....'),
            type?: string(name='type', description='The full name of the diagnostic item.', example='ES_API'),
          }(name='detail', description='The type of the diagnostic result. Valid values:

*   TEXT: text description
*   CONSOLE_API: console-triggered
*   ES_API: API triggered'),
          health?: string(name='health', description='The details of the diagnostic item.', example='YELLOW'),
          item?: string(name='item', description='The health of the diagnostic item. Supported: GREEN, YELLOW, RED, and UNKNOWN.', example='IndexAliasUseDiagnostic'),
        }
      ](name='diagnoseItems', description='The name of the item.'),
      health?: string(name='health', description='Reports the list of diagnostic item information.', example='YELLOW'),
      instanceId?: string(name='instanceId', description='The overall health of the cluster in the report. Supported: GREEN, YELLOW, RED, and UNKNOWN.', example='es-cn-abc'),
      reportId?: string(name='reportId', description='The diagnosis status. Valid values: Supported: SUCCESS, FAILED, and RUNNING.', example='trigger__2020-08-17T17:09:02f'),
      state?: string(name='state', description='The ID of the instance for diagnosis.', example='SUCCESS'),
      trigger?: string(name='trigger', description='The timestamp when the report was created.', example='USER'),
    }
  ](name='Result', description='The trigger mode of health diagnostics. Valid values:

*   SYSTEM: The system is automatically triggered.
*   INNER: internal trigger
*   USER: manually triggered by the user'),
}

model ListDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnoseReportResponseBody(name='body'),
}

async function listDiagnoseReportWithOptions(InstanceId: string, request: ListDiagnoseReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseReportResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.detail)) {
    query['detail'] = request.detail;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnoseReport',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/reports`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDiagnoseReport(InstanceId: string, request: ListDiagnoseReportRequest): ListDiagnoseReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseReportWithOptions(InstanceId, request, headers, runtime);
}

model ListDiagnoseReportIdsRequest {
  endTime?: long(name='endTime', description='The end of the time range to query. The value must be a UNIX timestamp.', example='1595174399999'),
  lang?: string(name='lang', description='The language of the reports.', example='spanish'),
  page?: int32(name='page', description='The number of the page to return. Valid values: 1 to 200. Default value: 1.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page. Valid values: 1 to 500. Default value: 10.', example='15'),
  startTime?: long(name='startTime', description='The beginning of the time range to query. The value must be a UNIX timestamp.', example='1595088000000'),
  trigger?: string(name='trigger', description='The method that is used to trigger health diagnostics. Valid values: SYSTEM, INNER, and USER.', example='SYSTEM'),
}

model ListDiagnoseReportIdsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='1'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseReportIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnoseReportIdsResponseBody(name='body'),
}

async function listDiagnoseReportIdsWithOptions(InstanceId: string, request: ListDiagnoseReportIdsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseReportIdsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnoseReportIds',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/report-ids`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDiagnoseReportIds(InstanceId: string, request: ListDiagnoseReportIdsRequest): ListDiagnoseReportIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseReportIdsWithOptions(InstanceId, request, headers, runtime);
}

model ListDiagnosisItemsRequest {
  lang?: string(name='lang', example='en'),
}

model ListDiagnosisItemsResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ 
    {
      description?: string(name='description', example='BulkReject'),
      key?: string(name='key', example='ClusterBulkRejectDiagnostic'),
      name?: string(name='name', example='BulkReject'),
    }
  ](name='Result'),
}

model ListDiagnosisItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnosisItemsResponseBody(name='body'),
}

async function listDiagnosisItemsWithOptions(request: ListDiagnosisItemsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnosisItemsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnosisItems',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/items`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDiagnosisItems(request: ListDiagnosisItemsRequest): ListDiagnosisItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnosisItemsWithOptions(request, headers, runtime);
}

model ListDictInformationRequest {
  analyzerType?: string(name='analyzerType', example='ALIWS'),
  bucketName?: string(name='bucketName', example='search-cloud-test-cn-****'),
  key?: string(name='key', example='oss/dic_0.dic'),
}

model ListDictInformationResponseBody = {
  requestId?: string(name='RequestId', example='7C4334EA-D22B-48BD-AE28-08EE68******'),
  result?: {
    fileSize?: long(name='fileSize', example='2202301'),
    ossObject?: {
      bucketName?: string(name='bucketName', example='es-osstest*'),
      etag?: string(name='etag', example='2ABAB5E70BBF631145647F6BE533****'),
      key?: string(name='key', example='oss/dict_0*.dic'),
    }(name='ossObject'),
    type?: string(name='type', example='STOP'),
  }(name='Result'),
}

model ListDictInformationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDictInformationResponseBody(name='body'),
}

async function listDictInformationWithOptions(InstanceId: string, request: ListDictInformationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDictInformationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.analyzerType)) {
    query['analyzerType'] = request.analyzerType;
  }
  if (!Util.isUnset(request.bucketName)) {
    query['bucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.key)) {
    query['key'] = request.key;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDictInformation',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dict/_info`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDictInformation(InstanceId: string, request: ListDictInformationRequest): ListDictInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDictInformationWithOptions(InstanceId, request, headers, runtime);
}

model ListDictsRequest {
  analyzerType?: string(name='analyzerType', description='The type of the dictionary. Valid values:

*   IK: IK dictionary after a standard update
*   IK_HOT: IK dictionary after a rolling update
*   SYNONYMS: synonym dictionary
*   ALIWS: Alibaba Cloud dictionary', example='IK'),
  name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
}

model ListDictsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='1'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2937F832-F39E-41EF-89BA-B528342A2A3A'),
  result?: [ 
    {
      downloadUrl?: string(name='downloadUrl', description='The link that is used to download the dictionary over the Internet. The link is valid for 90s.', example='http://test_bucket.oss-cn-hangzhou.aliyuncs.com/AliyunEs/test.dic?Expires=162573****&OSSAccessKeyId=LTAI*****V9&Signature=PNPO********BBGsJDO4V3VfU4sE%3D'),
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: byte.', example='2782602'),
      name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
      sourceType?: string(name='sourceType', description='The source type.', example='ORIGIN'),
      type?: string(name='type', description='The type of the IK dictionary. Valid values:

*   MAIN: main dictionary
*   STOP: stopword list', example='MAIN'),
    }
  ](name='Result', description='The returned result.'),
}

model ListDictsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDictsResponseBody(name='body'),
}

async function listDictsWithOptions(InstanceId: string, request: ListDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDictsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.analyzerType)) {
    query['analyzerType'] = request.analyzerType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDicts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dicts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDicts(InstanceId: string, request: ListDictsRequest): ListDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDictsWithOptions(InstanceId, request, headers, runtime);
}

model ListEcsInstancesRequest {
  ecsInstanceIds?: string(name='ecsInstanceIds', description='test', example='["i-bp13y63575oypr9d****","i-bp1gyhphjaj73jsr****"]'),
  ecsInstanceName?: string(name='ecsInstanceName', description='\\[{ "tagKey":"a","tagValue":"b"}]', example='test'),
  page?: int32(name='page', description='10', example='1'),
  size?: int32(name='size', description='\\["i-bp13y63575oypr9d\\*\\*\\*\\*","i-bp1gyhphjaj73jsr\\*\\*\\*\\*"]', example='10'),
  tags?: string(name='tags', description='vpc-bp16k1dvzxtmagcva\\*\\*\\*\\*', example='[{ "tagKey":"a","tagValue":"b"}]'),
  vpcId?: string(name='vpcId', description='The ID of the request.', example='vpc-bp16k1dvzxtmagcva****'),
}

model ListEcsInstancesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The returned data.', example='11'),
  }(name='Headers', description='The number of returned records.'),
  requestId?: string(name='RequestId', description='The header of the response.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      cloudAssistantStatus?: string(name='cloudAssistantStatus', description='The name of the ECS instance.', example='true'),
      collectors?: [ 
        {
          collectorPaths?: [ string ](name='collectorPaths'),
          configs?: [ 
            {
              content?: string(name='content', description='The name of the file.', example='- key: log\\n title: Log file content\\n description: >\\n Contains log file lines.\\n ....'),
              fileName?: string(name='fileName', description='The information about the extended parameter.', example='fields.yml'),
            }
          ](name='configs', description='The content of the file.'),
          dryRun?: boolean(name='dryRun', description='The ID of the Alibaba Cloud account.', example='false'),
          extendConfigs?: [ 
            {
              configType?: string(name='configType', description='The instance type specified by Collector Output. Supports Elasticsearch and Logstash. Displayed when the **configType** is **collectorTargetInstance**.', example='collectorDeployMachine'),
              enableMonitoring?: boolean(name='enableMonitoring', description='The ID of the host group. Displayed when the **configType** is **collectorDeployMachine**.', example='true'),
              groupId?: string(name='groupId', description='The configuration type. Valid values:

*   collectorTargetInstance: Collector Output
*   collectorDeployMachine: Collector Deployment Machine
*   Collector Elasticsearch ForKibana: Elasticsearch instance information that supports the Kibana dashboard', example='default_ct-cn-5i2l75bz4776****'),
              hosts?: [ string ](name='hosts', description='The path in which Filebeat is collected.'),
              instanceId?: string(name='instanceId', description='The list of ECS instances on which the collector is deployed. Displayed when the **configType** is **collectorDeployMachines** and the **type** is **ECSInstanceId**.', example='es-cn-nif1z89fz003i****'),
              instanceType?: string(name='instanceType', description='The transmission protocol, which must be the same as the access protocol of the instance specified by Output. HTTP and HTTPS. Displayed when the **configType** is **collectorTargetInstance**.', example='elasticsearch'),
              machines?: [ 
                {
                  agentStatus?: string(name='agentStatus', description='The IDs of ECS instances.', example='heartOk'),
                  instanceId?: string(name='instanceId', description='The list of access addresses of the specified instance for the output of the collector. Displayed when the **configType** is **collectorTargetInstance**.', example='i-bp13y63575oypr9d****'),
                }
              ](name='machines', description='The status of each crawl on the ECS instance. Valid values:

*   heartOk: The heartbeat is normal.
*   heartLost: The heartbeat is abnormal.
*   uninstalled
*   failed: The installation failed.'),
              protocol?: string(name='protocol', description='The username that is used to access the instance. The default value is elastic. Displayed when the **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='HTTP'),
              type?: string(name='type', description='The ID of the instance that is associated with the crawker. If the **configType** parameter is set to **collectorTargetInstance**, the value of this parameter is the ID of the output collector. If the **configType** parameter is set to **collectorDeployMachines** and the **type** parameter is set to **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='ECSInstanceId'),
              userName?: string(name='userName', description='The type of the machine on which the Collector is deployed. This parameter is displayed when the **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId:ECS
*   ACKCluster: Container Kubernetes', example='elastic'),
            }
          ](name='extendConfigs', description='Whether Monitoring is enabled. This field is displayed when the **configType** is **collectorTargetInstance** and the **instanceType** is **Elasticsearch**. Valid values:

*   true
*   false'),
          gmtCreatedTime?: string(name='gmtCreatedTime', description='The status of the collector. Valid values:

*   activating: The project is taking effect.
*   active: The instance has taken effect.', example='2020-06-20T07:26:47.000+0000'),
          gmtUpdateTime?: string(name='gmtUpdateTime', description='Specifies whether to verify and create a crawer. Valid values:

*   true: only verifies and does not create a
*   false: verifies and creates a', example='2020-06-20T07:26:47.000+0000'),
          name?: string(name='name', description='The configuration file information of the collector.', example='ct-testAbc'),
          ownerId?: string(name='ownerId', description='The ID of the Virtual Private Cloud to which the collector belongs.', example='16852***488*****'),
          resId?: string(name='resId', description='The time when the collector was updated.', example='ct-cn-0v3xj86085dvq****'),
          resType?: string(name='resType', description='The version of the collector. If the machine type of the collector is ECS, only **6.8.5\\_with_community** is supported.', example='fileBeat'),
          resVersion?: string(name='resVersion', description='The time when the crawl collector was created.', example='6.8.5_with_community'),
          status?: string(name='status', description='The name of the collector.', example='activing'),
          vpcId?: string(name='vpcId', description='The type of the collector. FileBeat, metricBeat, heartBeat, and auditBeat are supported.', example='vpc-bp16k1dvzxtm******'),
        }
      ](name='collectors', description='The ID of the collector instance.'),
      ecsInstanceId?: string(name='ecsInstanceId', description='The tags of the ECS instance.', example='i-bp14ncqge8wy3l3d****'),
      ecsInstanceName?: string(name='ecsInstanceName', description='The ID of the ECS instance.', example='ecsTestName'),
      ipAddress?: [ 
        {
          host?: string(name='host', description='The information about the collectors on the ECS instance.', example='172.16.xx.xx'),
          ipType?: string(name='ipType', description='The IP address of the endpoint.', example='private'),
        }
      ](name='ipAddress', description='The type of the IP address that is used by the instance. Valid values:

*   public: public endpoint
*   private: private network address'),
      osType?: string(name='osType', description='The status of the ECS instance. Valid values:

*   running: The master instance is running
*   starting
*   stopping: The task is being stopped.
*   stopped: The node is stopped.', example='linux'),
      status?: string(name='status', description='The IP address of the ECS instance.', example='running'),
      tags?: string(name='tags', description='The operating system type of the ECS instance. Valid values:

*   windows:Windows operating system
*   linux:Linux operating system', example='[ { "tagKey": "a", "tagValue": "b" } ]'),
    }
  ](name='Result', description='Cloud Assistant the installation status, support:

*   true: The Prometheus agent was installed.
*   false: The Prometheus agent was not installed.'),
}

model ListEcsInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEcsInstancesResponseBody(name='body'),
}

/**
  * **Important** To call this operation, you must create the Aliyun Elasticsearch AccessingOOSRole and the system service role AliyunOOSAccessingECS 4ESRole to Elasticsearch the service account to obtain the ECS access permissions of the primary account. For more information, see [Collect ECS service logs](~~146446~~).
  *
  * @param request ListEcsInstancesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListEcsInstancesResponse
 */
async function listEcsInstancesWithOptions(request: ListEcsInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEcsInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.ecsInstanceIds)) {
    query['ecsInstanceIds'] = request.ecsInstanceIds;
  }
  if (!Util.isUnset(request.ecsInstanceName)) {
    query['ecsInstanceName'] = request.ecsInstanceName;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['vpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEcsInstances',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ecs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **Important** To call this operation, you must create the Aliyun Elasticsearch AccessingOOSRole and the system service role AliyunOOSAccessingECS 4ESRole to Elasticsearch the service account to obtain the ECS access permissions of the primary account. For more information, see [Collect ECS service logs](~~146446~~).
  *
  * @param request ListEcsInstancesRequest
  * @return ListEcsInstancesResponse
 */
async function listEcsInstances(request: ListEcsInstancesRequest): ListEcsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEcsInstancesWithOptions(request, headers, runtime);
}

model ListExtendfilesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      filePath?: string(name='filePath', description='The path of the driver file.', example='/ssd/1/share/ls-cn-oew1qbgl****/logstash/current/config/custom/mysql-connector-java-5.1.35.jar'),
      fileSize?: long(name='fileSize', description='The size of the driver file.', example='968668'),
      name?: string(name='name', description='The name of the driver file.', example='mysql-connector-java-5.1.35.jar'),
      sourceType?: string(name='sourceType', description='The source type.', example='ORIGIN'),
    }
  ](name='Result', description='The returned result.'),
}

model ListExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExtendfilesResponseBody(name='body'),
}

async function listExtendfilesWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListExtendfilesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListExtendfiles',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/extendfiles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExtendfiles(InstanceId: string): ListExtendfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExtendfilesWithOptions(InstanceId, headers, runtime);
}

model ListILMPoliciesRequest {
  policyName?: string(name='policyName', example='policy-1'),
}

model ListILMPoliciesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      name?: string(name='name', example='policy-1'),
      phases?: map[string]any(name='phases', example='{"hot":{"minAge":"0ms","actions":{"rollover":{"maxSize":"50gb","maxAge":"30d"},"setPriority":{"priority":100}}},"delete":{"minAge":"3d","actions":{"delete":{}}}}'),
    }
  ](name='Result'),
}

model ListILMPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListILMPoliciesResponseBody(name='body'),
}

async function listILMPoliciesWithOptions(InstanceId: string, request: ListILMPoliciesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListILMPoliciesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.policyName)) {
    query['policyName'] = request.policyName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListILMPolicies',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listILMPolicies(InstanceId: string, request: ListILMPoliciesRequest): ListILMPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listILMPoliciesWithOptions(InstanceId, request, headers, runtime);
}

model ListIndexTemplatesRequest {
  indexTemplate?: string(name='indexTemplate', example='my-template'),
  page?: int32(name='page', example='5'),
  size?: int32(name='size', example='50'),
}

model ListIndexTemplatesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream', example='true'),
      ilmPolicy?: string(name='ilmPolicy', example='my_ilm_policy'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate', example='my-template'),
      priority?: int32(name='priority', example='100'),
      template?: {
        aliases?: string(name='aliases', example='{\\"index.number_of_shards\\":\\"1\\"}'),
        mappings?: string(name='mappings', example='{\\"properties\\":{\\"created_at\\":{\\"format\\":\\"EEE MMM dd HH:mm:ss Z yyyy\\",\\"type\\":\\"date\\"},\\"host_name\\":{\\"type\\":\\"keyword\\"}}}'),
        settings?: string(name='settings', example='{\\"mydata\\":{}}'),
      }(name='template'),
    }
  ](name='Result'),
}

model ListIndexTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIndexTemplatesResponseBody(name='body'),
}

async function listIndexTemplatesWithOptions(InstanceId: string, request: ListIndexTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIndexTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.indexTemplate)) {
    query['indexTemplate'] = request.indexTemplate;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIndexTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIndexTemplates(InstanceId: string, request: ListIndexTemplatesRequest): ListIndexTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIndexTemplatesWithOptions(InstanceId, request, headers, runtime);
}

model ListInstanceRequest {
  description?: string(name='description', description='cn-hangzhou-i', example='aliyunes_test1'),
  esVersion?: string(name='esVersion', description='advanced', example='6.7_with_X-Pack'),
  instanceCategory?: string(name='instanceCategory', description='The number of data nodes.', example='advanced'),
  instanceId?: string(name='instanceId', description='postpaid', example='es-cn-v641a0ta3000g****'),
  page?: int32(name='page', description='\\[{"tagKey":"key1","tagValue":"value1"}]', example='1'),
  paymentType?: string(name='paymentType', description='Specifies whether to include dedicated master nodes. Valid values:

*   true: The files contain data that is dumped to the IA storage medium.
*   false: The files do not contain data that is dumped to the IA storage medium.', example='postpaid'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the request.', example='rg-aekzvowej3i****'),
  size?: int32(name='size', description='vpc-bp16k1dvzxtmagcva\\*\\*\\*\\*', example='10'),
  tags?: string(name='tags', description='The header of the response.', example='[{"tagKey":"key1","tagValue":"value1"}]'),
  vpcId?: string(name='vpcId', description='The number of entries returned per page.', example='vpc-bp16k1dvzxtmagcva****'),
  zoneId?: string(name='zoneId', description='The returned data.', example='cn-hangzhou-i'),
}

model ListInstanceResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='Specifies whether to include dedicated master nodes (obsolete). Valid values:

*   true: The files contain data that is dumped to the IA storage medium.
*   false: The files do not contain data that is dumped to the IA storage medium.', example='10'),
  }(name='Headers', description='The status of the instance. Valid values:

*   active: normal
*   activating: taking effect
*   inactive: frozen
*   invalid: invalid'),
  requestId?: string(name='RequestId', description='The time when the node is created.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      advancedDedicateMaster?: boolean(name='advancedDedicateMaster', description='The billing method of the instance. Valid values:

*   **prepaid**: subscription
*   **postpaid**: pay-as-you-go', example='false'),
      clientNodeConfiguration?: {
        amount?: int32(name='amount', description='The size of the node storage space. Unit: GB.', example='3'),
        disk?: int32(name='disk', description='Specifies whether to enable disk encryption for the node. Valid values:

*   true: enables instant image cache.
*   false: disables reuse of image cache layers.', example='20'),
        diskType?: string(name='diskType', description='The storage type of the node. Valid values:

*   cloud_ssd: SSD.
*   cloud_essd: ESSD.
*   cloud_efficiency: ultra disk', example='cloud_efficiency'),
        spec?: string(name='spec', description='The number of nodes.', example='elasticsearch.sn2ne.large'),
      }(name='clientNodeConfiguration', description='The instance type of the node. For more information, see [Specifications](~~271718~~).'),
      createdAt?: string(name='createdAt', description='The status of the pay-as-you-go service that is overlaid on a subscription instance. Valid values:

*   **active**: normal
*   **closed**: Close
*   **indebt**: Overdue payments are frozen', example='2018-07-13T03:58:07.253Z'),
      dedicateMaster?: boolean(name='dedicateMaster', description='The edition of the dedicated KMS instance.', example='false'),
      description?: string(name='description', description='The key of the tag.', example='es-cn-abc'),
      elasticDataNodeConfiguration?: {
        amount?: int32(name='amount', description='The number of nodes.', example='3'),
        disk?: int32(name='disk', description='The size of the node storage space. Unit: GB.', example='20'),
        diskEncryption?: boolean(name='diskEncryption', description='The storage type of the node.', example='true'),
        diskType?: string(name='diskType', description='The configuration of dedicated master nodes.', example='cloud_ssd'),
        spec?: string(name='spec', description='The instance type of the node. For more information, see [Specifications](~~271718~~).', example='elasticsearch.sn2ne.large'),
      }(name='elasticDataNodeConfiguration', description='The configuration of Kibana nodes.'),
      esVersion?: string(name='esVersion', description='The value of the tag.', example='6.7_with_X-Pack'),
      extendConfigs?: [  map[string]any ](name='extendConfigs', description='The configurations of elastic data nodes.'),
      instanceId?: string(name='instanceId', description='The instance type of the node. For more information, see [Specifications](~~271718~~).', example='es-cn-v641a0ta3000g****'),
      isNewDeployment?: string(name='isNewDeployment', description='The configuration of cluster extension parameters.', example='true'),
      kibanaConfiguration?: {
        amount?: int32(name='amount', description='The size of the node storage space. Unit: GB.', example='1'),
        disk?: int32(name='disk', description='The storage type of the node. Only cloud_ssd(SSD cloud disk) is supported.', example='20'),
        diskType?: string(name='diskType', description='The network configurations.', example='cloud_ssd'),
        spec?: string(name='spec', description='The number of nodes.', example='elasticsearch.n4.small'),
      }(name='kibanaConfiguration', description='The instance type of the node. For more information, see [Specifications](~~271718~~).'),
      kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
      kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
      masterConfiguration?: {
        amount?: int32(name='amount', description='The network type. Only Virtual Private Cloud (VPC) is supported.', example='3'),
        disk?: int32(name='disk', description='The vSwitch ID of the cluster.', example='20'),
        diskType?: string(name='diskType', description='The configuration of data nodes.', example='cloud_ssd'),
        spec?: string(name='spec', description='The zone where the cluster resides.', example='elasticsearch.sn2ne.large'),
      }(name='masterConfiguration', description='The VPC ID of the cluster.'),
      networkConfig?: {
        type?: string(name='type', description='The storage type of the node. Valid values:

*   cloud_ssd: standard SSD
*   cloud_efficiency: ultra disk', example='vpc'),
        vpcId?: string(name='vpcId', description='The storage space of the node. Unit: GB.', example='vpc-abc'),
        vsArea?: string(name='vsArea', description='Specifies whether to use disk encryption. Valid values:

*   true
*   false', example='cn-hangzhou-e'),
        vswitchId?: string(name='vswitchId', description='The performance level of the ESSD. This parameter is required when the diskType parameter is set to cloud_essd. Valid values: PL1, PL2, and PL3.', example='vsw-def'),
        whiteIpGroupList?: [ 
          {
            groupName?: string(name='groupName', example='default'),
            ips?: [ string ](name='ips'),
            whiteIpType?: string(name='whiteIpType', example='PUBLIC_KIBANA'),
          }
        ](name='whiteIpGroupList'),
      }(name='networkConfig', description='The instance type of the node. For more information, see [Specifications](~~271718~~).'),
      nodeAmount?: int32(name='nodeAmount', description='The ID of the resource group.', example='2'),
      nodeSpec?: {
        disk?: int32(name='disk', example='50'),
        diskEncryption?: boolean(name='diskEncryption', example='false'),
        diskType?: string(name='diskType', example='cloud_ssd'),
        performanceLevel?: string(name='performanceLevel', example='PL1'),
        spec?: string(name='spec', example='elasticsearch.n4.small'),
      }(name='nodeSpec', description='The VPC ID of the cluster.'),
      paymentType?: string(name='paymentType', description='The time when the instance was last updated.', example='postpaid'),
      postpaidServiceStatus?: string(name='postpaidServiceStatus', description='The tags of the instance. Each tag is a key-value pair.', example='active'),
      privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
      publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
      resourceGroupId?: string(name='resourceGroupId', description='The ID of the instance.', example='rg-aekzvowej3i****'),
      serviceVpc?: boolean(name='serviceVpc', description='Specifies whether to deploy the new architecture.', example='true'),
      status?: string(name='status', description='The name of the instance.', example='active'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey', description='The size of the node storage space. Unit: GB.', example='env'),
          tagValue?: string(name='tagValue', description='The storage type of the node. Only ultra disks (cloud_efficiency) are supported.', example='dev'),
        }
      ](name='tags', description='The number of nodes.'),
      updatedAt?: string(name='updatedAt', description='Coordination node configuration.', example='2018-07-18T10:10:04.484Z'),
      vpcInstanceId?: string(name='vpcInstanceId', example='vpc-bp1uag5jj38c****'),
    }
  ](name='Result', description='Indicates whether it is a service VPC.'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstanceWithOptions(request: ListInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.esVersion)) {
    query['esVersion'] = request.esVersion;
  }
  if (!Util.isUnset(request.instanceCategory)) {
    query['instanceCategory'] = request.instanceCategory;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.paymentType)) {
    query['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['vpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['zoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceWithOptions(request, headers, runtime);
}

model ListInstanceHistoryEventsRequest {
  body?: [ 
    {
      desc?: boolean(name='desc', example='true'),
      sortField?: string(name='sortField', example='event_time'),
    }
  ](name='body'),
  eventCreateEndTime?: string(name='eventCreateEndTime', example='1645596516000'),
  eventCreateStartTime?: string(name='eventCreateStartTime', example='1645596516000'),
  eventCycleStatus?: [ string ](name='eventCycleStatus'),
  eventExecuteEndTime?: string(name='eventExecuteEndTime', example='1645596516000'),
  eventExecuteStartTime?: string(name='eventExecuteStartTime', example='1645596516000'),
  eventFinashEndTime?: string(name='eventFinashEndTime', example='1645596516000'),
  eventFinashStartTime?: string(name='eventFinashStartTime', example='1645596516000'),
  eventLevel?: [ string ](name='eventLevel'),
  eventType?: [ string ](name='eventType'),
  instanceId?: string(name='instanceId', example='es-cn-2r42l7a740005****'),
  nodeIP?: string(name='nodeIP', example='10.1.xx.xx'),
  page?: int32(name='page', example='0'),
  size?: int32(name='size', example='10'),
}

model ListInstanceHistoryEventsShrinkRequest {
  body?: [ 
    {
      desc?: boolean(name='desc', example='true'),
      sortField?: string(name='sortField', example='event_time'),
    }
  ](name='body'),
  eventCreateEndTime?: string(name='eventCreateEndTime', example='1645596516000'),
  eventCreateStartTime?: string(name='eventCreateStartTime', example='1645596516000'),
  eventCycleStatusShrink?: string(name='eventCycleStatus'),
  eventExecuteEndTime?: string(name='eventExecuteEndTime', example='1645596516000'),
  eventExecuteStartTime?: string(name='eventExecuteStartTime', example='1645596516000'),
  eventFinashEndTime?: string(name='eventFinashEndTime', example='1645596516000'),
  eventFinashStartTime?: string(name='eventFinashStartTime', example='1645596516000'),
  eventLevelShrink?: string(name='eventLevel'),
  eventTypeShrink?: string(name='eventType'),
  instanceId?: string(name='instanceId', example='es-cn-2r42l7a740005****'),
  nodeIP?: string(name='nodeIP', example='10.1.xx.xx'),
  page?: int32(name='page', example='0'),
  size?: int32(name='size', example='10'),
}

model ListInstanceHistoryEventsResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='15'),
    xTotalFailed?: long(name='X-Total-Failed', example='2'),
    xTotalSuccess?: long(name='X-Total-Success', example='13'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='D1A6830A-F59B-4E05-BFAC-9496C21DBBA7'),
  result?: [ 
    {
      ecsId?: string(name='ecsId', example='i-2ze8s9cjdf2cv969****'),
      eventCreateTime?: string(name='eventCreateTime', example='2017-12-07T00:00:00Z'),
      eventCycleStatus?: string(name='eventCycleStatus', example='EXECUTED'),
      eventExecuteTime?: string(name='eventExecuteTime', example='2017-12-07T00:00:00Z'),
      eventFinashTime?: string(name='eventFinashTime', example='2017-12-07T00:00:00Z'),
      eventLevel?: string(name='eventLevel', example='INFO'),
      eventType?: string(name='eventType', example='ECS:AUTO_RESTART'),
      instanceId?: string(name='instanceId', example='es-cn-2r42l7a740005****'),
      nodeIP?: string(name='nodeIP', example='10.1.xx.xx'),
      regionId?: string(name='regionId', example='cn-hangzhou'),
    }
  ](name='Result'),
}

model ListInstanceHistoryEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceHistoryEventsResponseBody(name='body'),
}

async function listInstanceHistoryEventsWithOptions(tmpReq: ListInstanceHistoryEventsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceHistoryEventsResponse {
  Util.validateModel(tmpReq);
  var request = new ListInstanceHistoryEventsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.eventCycleStatus)) {
    request.eventCycleStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventCycleStatus, 'eventCycleStatus', 'simple');
  }
  if (!Util.isUnset(tmpReq.eventLevel)) {
    request.eventLevelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventLevel, 'eventLevel', 'simple');
  }
  if (!Util.isUnset(tmpReq.eventType)) {
    request.eventTypeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventType, 'eventType', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.eventCreateEndTime)) {
    query['eventCreateEndTime'] = request.eventCreateEndTime;
  }
  if (!Util.isUnset(request.eventCreateStartTime)) {
    query['eventCreateStartTime'] = request.eventCreateStartTime;
  }
  if (!Util.isUnset(request.eventCycleStatusShrink)) {
    query['eventCycleStatus'] = request.eventCycleStatusShrink;
  }
  if (!Util.isUnset(request.eventExecuteEndTime)) {
    query['eventExecuteEndTime'] = request.eventExecuteEndTime;
  }
  if (!Util.isUnset(request.eventExecuteStartTime)) {
    query['eventExecuteStartTime'] = request.eventExecuteStartTime;
  }
  if (!Util.isUnset(request.eventFinashEndTime)) {
    query['eventFinashEndTime'] = request.eventFinashEndTime;
  }
  if (!Util.isUnset(request.eventFinashStartTime)) {
    query['eventFinashStartTime'] = request.eventFinashStartTime;
  }
  if (!Util.isUnset(request.eventLevelShrink)) {
    query['eventLevel'] = request.eventLevelShrink;
  }
  if (!Util.isUnset(request.eventTypeShrink)) {
    query['eventType'] = request.eventTypeShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeIP)) {
    query['nodeIP'] = request.nodeIP;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceHistoryEvents',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/events`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceHistoryEvents(request: ListInstanceHistoryEventsRequest): ListInstanceHistoryEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceHistoryEventsWithOptions(request, headers, runtime);
}

model ListInstanceIndicesRequest {
  all?: boolean(name='all', description='false', example='false'),
  isManaged?: boolean(name='isManaged', description='15', example='false'),
  isOpenstore?: boolean(name='isOpenstore', description='The ID of the request.', example='false'),
  name?: string(name='name', description='1', example='log-0001'),
  page?: int32(name='page', description='The header of the response.', example='1'),
  size?: int32(name='size', description='The total size of the index in Cloud Hosting. Unit: bytes.', example='15'),
}

model ListInstanceIndicesResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count', description='The details of the index list.', example='15'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize', description='The total number of indexes in the OpenStore cold phase.', example='18093942932'),
    xOSSCount?: int32(name='X-OSS-Count', description='The time when the index list was queried.', example='5'),
    xOSSStorageSize?: long(name='X-OSS-StorageSize', description='This parameter is deprecated.', example='9093942932'),
  }(name='Headers', description='The total size of the OpenStore cold stage index for this instance. Unit: bytes.'),
  requestId?: string(name='RequestId', description='The total number of indexes in Cloud Hosting.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The name of the Elasticsearch index.', example='2021-01-11T05:49:41.114Z'),
      health?: string(name='health', example='green'),
      ilmExplain?: string(name='ilmExplain', example='{    "indices": {         ".ds-console-2021.08.18-000002": {             "index": ".ds-console-2021.08.18-000002",             "managed": true,             "policy": "console",             "lifecycle_date_millis": 1629277498775,             "age": "2.64h",             "phase": "hot",             "phase_time_millis": 1629277450334,             "action": "complete",             "action_time_millis": 1629278605586,             "step": "complete",             "step_time_millis": 1629278605586,             "phase_execution": {                 "policy": "console",                 "phase_definition": {                     "min_age": "0s",                     "actions": {                         "rollover": {                             "max_size": "1gb",                             "max_age": "1d",                             "max_docs": 10000                         },                         "set_priority": {                             "priority": 1000                         }                     }                 },                 "version": 1,                 "modified_date_in_millis": 1629277370953             }         }     } }'),
      isManaged?: string(name='isManaged', description='The managed status of the index. The following three statuses are supported:

*   following: Hosting.
*   closing: The instance is being unhosted.
*   closed: unmanaged.', example='false'),
      managedStatus?: string(name='managedStatus', description='The current storage lifecycle. Value meaning:

*   warm: warm.
*   cold: the cold phase.
*   hot: hot phase.
*   delete: deletes a stage.

>  If this parameter is empty, the current index is not managed by the lifecycle.', example='closing'),
      name?: string(name='name', description='The full lifecycle status of the current index.', example='.kibana_task_manager_1'),
      phase?: string(name='phase', example='warm'),
      size?: long(name='size', description='The running status of the index. The following three statuses are supported:

*   green: healthy.
*   yellow: alerts.
*   red: an exception.', example='49298589'),
    }
  ](name='Result', description='The total storage space occupied by the current index. Unit: bytes.'),
}

model ListInstanceIndicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceIndicesResponseBody(name='body'),
}

async function listInstanceIndicesWithOptions(InstanceId: string, request: ListInstanceIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceIndicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.isManaged)) {
    query['isManaged'] = request.isManaged;
  }
  if (!Util.isUnset(request.isOpenstore)) {
    query['isOpenstore'] = request.isOpenstore;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceIndices',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/indices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceIndices(InstanceId: string, request: ListInstanceIndicesRequest): ListInstanceIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceIndicesWithOptions(InstanceId, request, headers, runtime);
}

model ListKibanaPluginsRequest {
  page?: string(name='page', description='The number of the page to return. Default value: 1.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='10'),
}

model ListKibanaPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='3'),
  }(name='Headers', description='The request header.'),
  requestId?: string(name='RequestId', description='The request ID.', example='11234B4A-34CE-473B-8E61-AD95702E****'),
  result?: [ 
    {
      description?: string(name='description', description='The description of the plug-in.', example='Customize DSL statements to query data.'),
      name?: string(name='name', description='The name of the plug-in.', example='bsearch_querybuilder'),
      source?: string(name='source', description='The source of the plug-in.', example='SYSTEM'),
      specificationUrl?: string(name='specificationUrl', description='The URL of the introduction to the plug-in. The value null is supported.', example='https://xxxx'),
      state?: string(name='state', description='The installation status of the plug-in.', example='INSTALLED'),
    }
  ](name='Result', description='The information about the plug-ins.'),
}

model ListKibanaPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListKibanaPluginsResponseBody(name='body'),
}

async function listKibanaPluginsWithOptions(InstanceId: string, request: ListKibanaPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListKibanaPluginsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListKibanaPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listKibanaPlugins(InstanceId: string, request: ListKibanaPluginsRequest): ListKibanaPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listKibanaPluginsWithOptions(InstanceId, request, headers, runtime);
}

model ListLogstashRequest {
  description?: string(name='description', description='rg-acfm2h5vbzd\\*\\*\\*\\*', example='ls-cn-abc'),
  instanceId?: string(name='instanceId', description='\\[{"tagKey":"key1","tagValue":"value1"}]', example='ls-cn-n6w1o5jq****'),
  page?: int32(name='page', description='ls-cn-n6w1o5jq\\*\\*\\*\\*', example='1'),
  resourceGroupId?: string(name='resourceGroupId', description='Details of the request header.', example='rg-acfm2h5vbzd****'),
  size?: int32(name='size', description='5.5.3\\_with_X-Pack', example='10'),
  tags?: string(name='tags', description='The number of entries returned per page.', example='[{"tagKey":"key1","tagValue":"value1"}]'),
  version?: string(name='version', description='The ID of the request.', example='5.5.3_with_X-Pack'),
}

model ListLogstashResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The number of data nodes.', example='10'),
  }(name='Headers', description='The billing method of the instance. Supported: prepaid (subscription) and postpaid (pay-as-you-go).'),
  requestId?: string(name='RequestId', description='Detailed information about the matching instances.', example='AC442F2F-5068-4434-AA21-E78947A9****'),
  result?: [ 
    {
      tags?: [ 
        {
          tagKey?: string(name='TagKey', description='The disk size of the node.', example='env'),
          tagValue?: string(name='TagValue', description='The instance type of the ECS instance.', example='dev'),
        }
      ](name='Tags', description='The configuration information of the data node.'),
      createdAt?: string(name='createdAt', description='The ID of the instance.', example='2018-07-13T03:58:07.253Z'),
      description?: string(name='description', description='The time when the instance was last updated.', example='ls-cn-abc'),
      instanceId?: string(name='instanceId', description='The tag value of the cloud disk.', example='ls-cn-n6w1o5jq****'),
      networkConfig?: {
        type?: string(name='type', example='vpc'),
        vpcId?: string(name='vpcId', description='The ID of the vSwitch.', example='vpc-abc'),
        vsArea?: string(name='vsArea', example='cn-hangzhou-*'),
        vswitchId?: string(name='vswitchId', example='vsw-def'),
      }(name='networkConfig', description='The network type. Currently, only Virtual Private Cloud (VPC) is supported.'),
      nodeAmount?: int32(name='nodeAmount', description='The state of the instance. Valid values: Normal, Active, Inactive, and Invalid.', example='2'),
      nodeSpec?: {
        disk?: int32(name='disk', description='The network configurations.', example='50'),
        diskEncryption?: boolean(name='diskEncryption', description='The ID of the VPC.', example='false'),
        diskType?: string(name='diskType', description='The zone where the cluster resides.', example='cloud_ssd'),
        spec?: string(name='spec', description='The type of the disk.', example='logstash.n4.small'),
      }(name='nodeSpec', description='Specifies whether to use disk encryption. Valid values:

*   true: Enables the concurrent query feature for queries other than aggregate queries.
*   false: Disables the concurrent query feature for queries other than aggregate queries.'),
      paymentType?: string(name='paymentType', description='The time when the instance was created.', example='postpaid'),
      resourceGroupId?: string(name='resourceGroupId'),
      status?: string(name='status', description='The version of the instance. Currently, only 6.7.0\\_with_X-Pack and 7.4.0\\_with_X-Pack are supported.', example='active'),
      updatedAt?: string(name='updatedAt', description='The tag of the instance. Valid values:', example='2018-07-18T10:10:04.484Z'),
      version?: string(name='version', description='The tag key of the cloud disk.', example='6.7.0_with_X-Pack'),
    }
  ](name='Result', description='The name of the VPC.'),
}

model ListLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogstashResponseBody(name='body'),
}

async function listLogstashWithOptions(request: ListLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLogstash(request: ListLogstashRequest): ListLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashWithOptions(request, headers, runtime);
}

model ListLogstashLogRequest {
  beginTime?: long(name='beginTime', description='20', example='1531910852074'),
  endTime?: long(name='endTime', description='The ID of the request.', example='1531910852074'),
  page?: int32(name='page', description='The returned data.', example='1'),
  query?: string(name='query', description='1', example='host:10.7.xx.xx AND level:info AND content:opening'),
  size?: int32(name='size', description='The severity level of the log entry. Including trace, debug, info, warn, error, etc. (GC logs have no level).', example='20'),
  type?: string(name='type', description='1531910852074', example='LOGSTASH_INSTANCE_LOG'),
}

model ListLogstashLogResponseBody = {
  requestId?: string(name='RequestId', description='The details of the log.', example='7F40EAA1-6F1D-4DD9-8DB8-C5F00C4E****'),
  result?: [ 
    {
      content?: string(name='content', description='The IP address of the node that generates the log.', example='[logstash.outputs.fileextend] Opening file {:path=>\\"/ssd/1/ls-cn-v0h1kzca****/logstash/logs/debug/test\\"}'),
      host?: string(name='host', example='192.168.xx.xx'),
      instanceId?: string(name='instanceId', example='ls-cn-v0h1kzca****'),
      level?: string(name='level', description='The ID of the instance.', example='info'),
      timestamp?: long(name='timestamp', example='1531985112420'),
    }
  ](name='Result', description='The timestamp of log generation. Unit: ms.'),
}

model ListLogstashLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogstashLogResponseBody(name='body'),
}

async function listLogstashLogWithOptions(InstanceId: string, request: ListLogstashLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashLogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    query['beginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogstashLog',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/search-log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLogstashLog(InstanceId: string, request: ListLogstashLogRequest): ListLogstashLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashLogWithOptions(InstanceId, request, headers, runtime);
}

model ListLogstashPluginsRequest {
  name?: string(name='name', description='USER', example='logstash-filter-clone'),
  page?: int32(name='page', description='The ID of the request.', example='10'),
  size?: int32(name='size', description='The returned results.', example='3'),
  source?: string(name='source', description='The description of the plug-in.', example='USER'),
}

model ListLogstashPluginsResponseBody = {
  requestId?: string(name='RequestId', description='The address of the documentation for the plug-in.', example='99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      description?: string(name='description', description='The source of the plug-in.', example='The clone filter is for duplicating events.'),
      name?: string(name='name', example='logstash-filter-clone'),
      source?: string(name='source', example='SYSTEM'),
      specificationUrl?: string(name='specificationUrl', description='The name of the plug-in.', example='https://xxx.html'),
      state?: string(name='state', example='INSTALLED'),
    }
  ](name='Result', description='The status of the plug-in. Valid values:

*   INSTALLED: Installed
*   UNINSTALLED: Not installed
*   INSTALLING: The instance is being installed.
*   UNINSTALLING: The instance is being uninstalled.
*   UPGRADING: The backup gateway is being upgraded.
*   FAILED: Installation failed
*   UNKNOWN: The cluster is lost and cannot be created.'),
}

model ListLogstashPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogstashPluginsResponseBody(name='body'),
}

async function listLogstashPluginsWithOptions(InstanceId: string, request: ListLogstashPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashPluginsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogstashPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLogstashPlugins(InstanceId: string, request: ListLogstashPluginsRequest): ListLogstashPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashPluginsWithOptions(InstanceId, request, headers, runtime);
}

model ListNodesRequest {
  ecsInstanceIds?: string(name='ecsInstanceIds', description='The IDs of the ECS instances.', example='i-bp1ei8ysh7orb6eq****'),
  ecsInstanceName?: string(name='ecsInstanceName', description='The name of the ECS instance.', example='test'),
  page?: int32(name='page', description='The number of the page to return.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='10'),
  tags?: string(name='tags', description='The tags of the ECS instance. You must configure tagKey and tagValue.', example='[{"tagKey":"abc","tagValue":"xyz"}]'),
}

model ListNodesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The number of entries returned.', example='10'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1FD7642-7C40-4FF2-9C0F-21F1A1746F70'),
  result?: [ 
    {
      agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values:

*   heartOk: The heartbeat is normal.
*   heartLost: The heartbeat is abnormal.
*   uninstalled: The shipper is not installed.
*   failed: The shipper fails to be installed.', example='heartOk'),
      cloudAssistantStatus?: string(name='cloudAssistantStatus', description='Indicates whether the Cloud Assistant client is installed. Valid values:

*   true: installed
*   false: not installed', example='true'),
      ecsInstanceId?: string(name='ecsInstanceId', description='The ID of the ECS instance.', example='i-bp13y63575oypr****'),
      ecsInstanceName?: string(name='ecsInstanceName', description='The name of the ECS instance.', example='ECS_beat'),
      ipAddress?: [ 
        {
          host?: string(name='host', description='The IP address.', example='192.168.xx.xx'),
          ipType?: string(name='ipType', description='The type of the IP address. Valid values:

*   public: public IP address
*   private: private IP address', example='public'),
        }
      ](name='ipAddress', description='The IP addresses of the ECS instance.'),
      osType?: string(name='osType', description='The operating system type of the ECS instance. Valid values:

*   windows: Windows Server
*   linux: Linux', example='linux'),
      status?: string(name='status', description='The status of the ECS instance. Valid values:

*   running: The instance is running.
*   starting: The instance is being started.
*   stopping: The instance is being stopped.
*   stopped: The instance is stopped.', example='running'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey', description='The key of the tag.', example='abc'),
          tagValue?: string(name='tagValue', description='The value of the tag.', example='xyz'),
        }
      ](name='tags', description='The tags of the ECS instance.'),
    }
  ](name='Result', description='The returned result.'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodesWithOptions(ResId: string, request: ListNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.ecsInstanceIds)) {
    query['ecsInstanceIds'] = request.ecsInstanceIds;
  }
  if (!Util.isUnset(request.ecsInstanceName)) {
    query['ecsInstanceName'] = request.ecsInstanceName;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNodes(ResId: string, request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodesWithOptions(ResId, request, headers, runtime);
}

model ListPipelineRequest {
  page?: int32(name='page', description='The header of the response.', example='1'),
  pipelineId?: string(name='pipelineId', description='The ID of the request.', example='pipeline_test'),
  size?: int32(name='size', description='The total number of returned entries.', example='15'),
}

model ListPipelineResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The time when the pipeline was updated.', example='2'),
  }(name='Headers', description='The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job.'),
  requestId?: string(name='RequestId', description='The response.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      gmtCreatedTime?: string(name='gmtCreatedTime', example='2020-08-05T03:10:38.188Z'),
      gmtUpdateTime?: string(name='gmtUpdateTime', example='2020-08-05T08:43:31.757Z'),
      pipelineId?: string(name='pipelineId', description='The status of the pipeline. Supported:

*   NOT_DEPLOYED: The node is not deployed.
*   RUNNING
*   DELETED: Deleted. The console does not display this status.', example='pipeline_test'),
      pipelineStatus?: string(name='pipelineStatus', example='NOT_DEPLOYED'),
    }
  ](name='Result', description='The time when the pipeline was created.'),
}

model ListPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineResponseBody(name='body'),
}

async function listPipelineWithOptions(InstanceId: string, request: ListPipelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['pipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipeline',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPipeline(InstanceId: string, request: ListPipelineRequest): ListPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineWithOptions(InstanceId, request, headers, runtime);
}

model ListPipelineIdsRequest {
  body?: string(name='body', example='{     "userName":"elastic",     "password":"xxxxxx" }'),
}

model ListPipelineIdsResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      available?: boolean(name='available', example='true'),
      code?: string(name='code', example='OK'),
      message?: string(name='message', example='OK'),
      pipelineId?: string(name='pipelineId', example='testKibanaManagement'),
    }
  ](name='Result'),
}

model ListPipelineIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineIdsResponseBody(name='body'),
}

async function listPipelineIdsWithOptions(InstanceId: string, request: ListPipelineIdsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineIdsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListPipelineIds',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/pipeline-ids`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPipelineIds(InstanceId: string, request: ListPipelineIdsRequest): ListPipelineIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineIdsWithOptions(InstanceId, request, headers, runtime);
}

model ListPluginsRequest {
  name?: string(name='name', description='SYSTEM', example='analysis-ik'),
  page?: string(name='page', description='The ID of the request.', example='1'),
  size?: int32(name='size', description='The header of the response.', example='10'),
  source?: string(name='source', description='The total number of entries returned.', example='SYSTEM'),
}

model ListPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The address of the plug-in description document.', example='2'),
  }(name='Headers', description='The description of the plug-in.'),
  requestId?: string(name='RequestId', description='The return results.', example='5A5D8E74-565C-43DC-B031-29289FA9****'),
  result?: [ 
    {
      description?: string(name='description', description='The source type of the plug-in.', example='IK analysis plug-in for Elasticsearch.'),
      name?: string(name='name', example='analysis-ik'),
      source?: string(name='source', example='SYSTEM'),
      specificationUrl?: string(name='specificationUrl', description='The name of the plug-in.', example='https://xxxx.html'),
      state?: string(name='state', example='INSTALLED'),
    }
  ](name='Result', description='The status of the plug-in.'),
}

model ListPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPluginsResponseBody(name='body'),
}

async function listPluginsWithOptions(InstanceId: string, request: ListPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPluginsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPlugins(InstanceId: string, request: ListPluginsRequest): ListPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPluginsWithOptions(InstanceId, request, headers, runtime);
}

model ListSearchLogRequest {
  beginTime?: long(name='beginTime', description='20', example='1531910852074'),
  endTime?: long(name='endTime', description='The ID of the request.', example='1531910852074'),
  page?: int32(name='page', description='The header of the response.', example='1'),
  query?: string(name='query', description='1', example='host:172.16.**.** AND content:netty'),
  size?: int32(name='size', description='The number of entries returned per page.', example='20'),
  type?: string(name='type', description='1531910852074', example='INSTANCELOG'),
}

model ListSearchLogResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The IP address of the node that generates the log.', example='1000'),
  }(name='Headers', description='The level of the log. Valid values:

*   warn: warning log
*   info: information log
*   error: error log
*   trace: trace logs
*   debug: debug logs

The level information has been migrated to the contentCollection field.'),
  requestId?: string(name='RequestId', description='The list of logs returned by the request.', example='7F40EAA1-6F1D-4DD9-8DB8-C5F00C4E****'),
  result?: [ 
    {
      content?: string(name='content', description='The ID of the instance.', example='[GC (Allocation Failure) 2018-07-19T17:24:20.682+0800: 7516.513: [ParNew: 6604768K->81121K(7341504K), 0.0760606 secs] 7226662K->703015K(31813056K), 0.0762507 secs] [Times: user=0.52 sys=0.00, real=0.07 secs]'),
      contentCollection?: map[string]any(name='contentCollection', example='{"level": "info", "host": "192.168.**.**", "time": "2019-03-18T08:16:12.741Z","content": "[o.e.c.r.a.AllocationService] [MnNASM_] Cluster health status changed from [YELLOW] to [GREEN] (reason: [shards started [[my_index][3]] ...])."}'),
      host?: string(name='host', description='Details of the log entry. Different content fields are returned for different log types.', example='192.168.**.**'),
      instanceId?: string(name='instanceId', example='es-cn-n6w1o1x0w001c****'),
      level?: string(name='level', description='The timestamp when the log is generated. Unit: ms.', example='info'),
      timestamp?: long(name='timestamp', example='1531985112420'),
    }
  ](name='Result', description='The content of the log entry. Migrated to the contentCollection field.'),
}

model ListSearchLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSearchLogResponseBody(name='body'),
}

async function listSearchLogWithOptions(InstanceId: string, request: ListSearchLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSearchLogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    query['beginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSearchLog',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/search-log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSearchLog(InstanceId: string, request: ListSearchLogRequest): ListSearchLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSearchLogWithOptions(InstanceId, request, headers, runtime);
}

model ListShardRecoveriesRequest {
  activeOnly?: boolean(name='activeOnly', description='Specifies whether to return information about data restoration of shards. Valid values:

*   true: returns information about data restoration of shards that are being restored.
*   false: returns information about data restoration of all shards.', example='true'),
}

model ListShardRecoveriesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      bytesPercent?: string(name='bytesPercent', description='The data restoration progress.', example='80%'),
      bytesTotal?: long(name='bytesTotal', description='The total amount of data that is restored.', example='12086'),
      filesPercent?: string(name='filesPercent', description='The file execution progress.', example='80.0%'),
      filesTotal?: long(name='filesTotal', description='The total number of files.', example='79'),
      index?: string(name='index', description='The name of the index.', example='my-index-000001'),
      sourceHost?: string(name='sourceHost', description='The IP address of the source node.', example='192.168.XX.XX'),
      sourceNode?: string(name='sourceNode', description='The name of the source node.', example='2Kni3dJ'),
      stage?: string(name='stage', description='The data restoration status. Valid values:

*   done: Data restoration is complete.
*   finalize: Data is being cleared.
*   index: Index metadata is being read, and bytes are being copied from source to destination.
*   init: Data restoration is not started.
*   start: Data restoration is started.
*   translog: Translogs are being redone.', example='done'),
      targetHost?: string(name='targetHost', description='The IP address of the destination node.', example='192.168.XX.XX'),
      targetNode?: string(name='targetNode', description='The name of the destination node.', example='YVVKLmW'),
      translogOps?: long(name='translogOps', description='The number of translog operations to be restored.', example='12086'),
      translogOpsPercent?: string(name='translogOpsPercent', description='The restoration progress of translog operations.', example='80%'),
    }
  ](name='Result', description='The returned result.'),
}

model ListShardRecoveriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListShardRecoveriesResponseBody(name='body'),
}

/**
  * > The restoration of a shard is a process of synchronizing data from a primary shard to a replica shard. After the restoration is complete, the replica shard is available for data searches.
  *
  * @param request ListShardRecoveriesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListShardRecoveriesResponse
 */
async function listShardRecoveriesWithOptions(InstanceId: string, request: ListShardRecoveriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListShardRecoveriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.activeOnly)) {
    query['activeOnly'] = request.activeOnly;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListShardRecoveries',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/cat-recovery`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > The restoration of a shard is a process of synchronizing data from a primary shard to a replica shard. After the restoration is complete, the replica shard is available for data searches.
  *
  * @param request ListShardRecoveriesRequest
  * @return ListShardRecoveriesResponse
 */
async function listShardRecoveries(InstanceId: string, request: ListShardRecoveriesRequest): ListShardRecoveriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShardRecoveriesWithOptions(InstanceId, request, headers, runtime);
}

model ListSnapshotReposByInstanceIdResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ 
    {
      instanceId?: string(name='instanceId', description='Reference instance ID.', example='es-cn-6ja1ro4jt000c****'),
      repoPath?: string(name='repoPath', description='The address of the repository.', example='es-cn-6ja1ro4jt000c****'),
      snapWarehouse?: string(name='snapWarehouse', description='Reference warehouse name.', example='aliyun_snapshot_from_es-cn-6ja1ro4jt000c****'),
      status?: string(name='status', description='Reference warehouse status. available indicates that it is valid. unavailable indicates that it is invalid.', example='available'),
    }
  ](name='Result', description='The return results.'),
}

model ListSnapshotReposByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSnapshotReposByInstanceIdResponseBody(name='body'),
}

async function listSnapshotReposByInstanceIdWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSnapshotReposByInstanceIdResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSnapshotReposByInstanceId',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-repos`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSnapshotReposByInstanceId(InstanceId: string): ListSnapshotReposByInstanceIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSnapshotReposByInstanceIdWithOptions(InstanceId, headers, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The number of the returned page.', example='1d2db86sca4384811e0b5e8707e******'),
  page?: int32(name='Page', description='1d2db86sca4384811e0b5e8707e\\*\\*\\*\\*\\*\\*', example='1', deprecated='true'),
  resourceIds?: string(name='ResourceIds', description='The ID of the request.', example='["es-cn-aaa","es-cn-bbb"]'),
  resourceType?: string(name='ResourceType', description='\\[{"key":"env","value","dev"},{"key":"dev", "value":"IT"}]', example='INSTANCE'),
  size?: int32(name='Size', description='\\["es-cn-aaa","es-cn-bbb"]', example='10', deprecated='true'),
  tags?: string(name='Tags', description='The header of the response. This parameter is empty and is for reference only. You cannot force this parameter to be relied on in the program.

>  The return examples does not contain this parameter.', example='[{"key":"env","value","dev"},{"key":"dev",  "value":"IT"}]'),
}

model ListTagResourcesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The value of the tag.', example='10'),
  }(name='Headers', description='The labels of the resource.'),
  pageSize?: int32(name='PageSize', description='The number of resources to query.', example='1'),
  requestId?: string(name='RequestId', description='A list of resources that have tags.', example='F99407AB-2FA9-489E-A259-40CF6D******'),
  tagResources?: {
    tagResource?: [ 
      {
        resourceId?: string(name='ResourceId', example='es-cn-oew1q8bev0002****'),
        resourceType?: string(name='ResourceType', example='ALIYUN::ELASTICSEARCH::INSTANCE'),
        tagKey?: string(name='TagKey', example='env'),
        tagValue?: string(name='TagValue', description='The tag key.', example='dev'),
      }
    ](name='TagResource', description='Indicates the ID of a resource.'),
  }(name='TagResources', description='The type of the resource. Fixed to `ALIYUN::ELASTICSEARCH::INSTANCE`.'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

model ListTagsRequest {
  pageSize?: int32(name='pageSize', description='The return results.', example='20'),
  resourceType?: string(name='resourceType', description='The tag value of the ENI.', example='INSTANCE'),
}

model ListTagsResponseBody = {
  requestId?: string(name='RequestId', description='The key of the tag.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      tagKey?: string(name='TagKey', example='env'),
      tagValue?: string(name='TagValue', example='dev'),
    }
  ](name='Result'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagsResponseBody(name='body'),
}

async function listTagsWithOptions(request: ListTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTags',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags/all-tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagsWithOptions(request, headers, runtime);
}

model ListVpcEndpointsRequest {
  page?: int32(name='page', description='The number of the page to return.

Pages start from page 1. Default value: 1.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page. Default value: 20.', example='10'),
}

model ListVpcEndpointsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      connectionStatus?: string(name='connectionStatus', description='The status of the endpoint connection. Valid values:

*   Pending
*   Connecting
*   Connected
*   Disconnecting
*   Disconnected
*   Deleting
*   ServiceDeleted', example='Disconnected'),
      createTime?: string(name='createTime', description='The time when the endpoint was created.', example='2021-07-22T01:19:24Z'),
      endpointBusinessStatus?: string(name='endpointBusinessStatus', description='The business status of the endpoint. Valid values:

*   Normal
*   FinancialLocked', example='Normal'),
      endpointDomain?: string(name='endpointDomain', description='The domain name of the endpoint. The domain name is used for connection configuration.', example='ep-bp18s6wy9420wdi4****.epsrv-bp1bz3efowa4kc0****.cn-hangzhou.privatelink.aliyuncs.com'),
      endpointId?: string(name='endpointId', description='The ID of the endpoint.', example='ep-bp1tah7zbrwmkjef****'),
      endpointName?: string(name='endpointName', description='The name of the endpoint.', example='test'),
      endpointStatus?: string(name='endpointStatus', description='The status of the endpoint. Valid values:

*   Creating
*   Active
*   Pending
*   Deleting', example='Active'),
      serviceId?: string(name='serviceId', description='The ID of the endpoint service with which the endpoint is associated.', example='epsrv-bp1w0p3jdirbfmt6****'),
      serviceName?: string(name='serviceName', description='The name of the endpoint service with which the endpoint is associated.', example='com.aliyuncs.privatelink.cn-hangzhou.epsrv-bp1w0p3jdirbfmt6****'),
    }
  ](name='Result', description='The details of the endpoints.'),
}

model ListVpcEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcEndpointsResponseBody(name='body'),
}

async function listVpcEndpointsWithOptions(InstanceId: string, request: ListVpcEndpointsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcEndpointsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVpcEndpoints',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/vpc-endpoints`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVpcEndpoints(InstanceId: string, request: ListVpcEndpointsRequest): ListVpcEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcEndpointsWithOptions(InstanceId, request, headers, runtime);
}

model MigrateToOtherZoneRequest {
  body?: string(name='body'),
  dryRun?: boolean(name='dryRun', description='Verify whether the zone node can be migrated. true indicates that the data is only verified and the migration task is not executed. false indicates that the migration task is executed after the verification is successful.', example='false'),
}

model MigrateToOtherZoneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: migration succeeded
*   false: The migration fails', example='true'),
}

model MigrateToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateToOtherZoneResponseBody(name='body'),
}

/**
  * If the specifications in your zone are insufficient, you can upgrade your instance to nodes in another zone. Before calling this interface, you must ensure that:
  * *   The error message returned because the current account is in a zone that has sufficient resources.
  *     After migrating nodes with current specifications to another zone, you need to manually [upgrade cluster](~~96650~~) because the cluster will not be upgraded during the migration process. Therefore, select a zone with sufficient resources to avoid cluster upgrade failure. We recommend that you choose new zones that are in lower alphabetical order. For example, for cn-hangzhou-e and cn-hangzhou-h zones, choose cn-hangzhou-h first.
  * *   The cluster is in the healthy state.
  *     Can be passed`  GET _cat/health?v  `command to view the health status of the cluster.
  *
  * @param request MigrateToOtherZoneRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return MigrateToOtherZoneResponse
 */
async function migrateToOtherZoneWithOptions(InstanceId: string, request: MigrateToOtherZoneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateToOtherZoneResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'MigrateToOtherZone',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/migrate-zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If the specifications in your zone are insufficient, you can upgrade your instance to nodes in another zone. Before calling this interface, you must ensure that:
  * *   The error message returned because the current account is in a zone that has sufficient resources.
  *     After migrating nodes with current specifications to another zone, you need to manually [upgrade cluster](~~96650~~) because the cluster will not be upgraded during the migration process. Therefore, select a zone with sufficient resources to avoid cluster upgrade failure. We recommend that you choose new zones that are in lower alphabetical order. For example, for cn-hangzhou-e and cn-hangzhou-h zones, choose cn-hangzhou-h first.
  * *   The cluster is in the healthy state.
  *     Can be passed`  GET _cat/health?v  `command to view the health status of the cluster.
  *
  * @param request MigrateToOtherZoneRequest
  * @return MigrateToOtherZoneResponse
 */
async function migrateToOtherZone(InstanceId: string, request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateToOtherZoneWithOptions(InstanceId, request, headers, runtime);
}

model ModifyDeployMachineRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model ModifyDeployMachineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C37CE536-6C0F-4778-9B59-6D94C7F7EB63'),
  result?: boolean(name='Result', description='Indicates whether the ECS instances are changed. Valid values:

*   true
*   false', example='true'),
}

model ModifyDeployMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDeployMachineResponseBody(name='body'),
}

async function modifyDeployMachineWithOptions(ResId: string, request: ModifyDeployMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyDeployMachineResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyDeployMachine',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/modify-deploy-machines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDeployMachine(ResId: string, request: ModifyDeployMachineRequest): ModifyDeployMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyDeployMachineWithOptions(ResId, request, headers, runtime);
}

model ModifyElastictaskRequest {
  body?: string(name='body'),
}

model ModifyElastictaskResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression', example='0 0 0 ? * MON'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression', example='4 4 4 ? * WED'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model ModifyElastictaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyElastictaskResponseBody(name='body'),
}

async function modifyElastictaskWithOptions(InstanceId: string, request: ModifyElastictaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyElastictaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyElastictask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/elastic-task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyElastictask(InstanceId: string, request: ModifyElastictaskRequest): ModifyElastictaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyElastictaskWithOptions(InstanceId, request, headers, runtime);
}

model ModifyInstanceMaintainTimeRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body', example='{     "openMaintainTime": true,     "maintainStartTime": "03:00Z",     "maintainEndTime": "04:00Z" }'),
}

model ModifyInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model ModifyInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceMaintainTimeResponseBody(name='body'),
}

/**
  * es-cn-n6w1o1x0w001c\\*\\*\\*\\*
  *
  * @param request ModifyInstanceMaintainTimeRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyInstanceMaintainTimeResponse
 */
async function modifyInstanceMaintainTimeWithOptions(InstanceId: string, request: ModifyInstanceMaintainTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyInstanceMaintainTimeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceMaintainTime',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/modify-maintaintime`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * es-cn-n6w1o1x0w001c\\*\\*\\*\\*
  *
  * @param request ModifyInstanceMaintainTimeRequest
  * @return ModifyInstanceMaintainTimeResponse
 */
async function modifyInstanceMaintainTime(InstanceId: string, request: ModifyInstanceMaintainTimeRequest): ModifyInstanceMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyInstanceMaintainTimeWithOptions(InstanceId, request, headers, runtime);
}

model ModifyWhiteIpsRequest {
  modifyMode?: string(name='modifyMode', description='The information about the IP address whitelist that you want to update. You can specify only one whitelist.

> You cannot configure both the whiteIpList and whiteIpGroup parameters.', example='Cover'),
  networkType?: string(name='networkType', description='The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.

> You cannot configure both the whiteIpList and whiteIpGroup parameters.', example='PUBLIC'),
  nodeType?: string(name='nodeType', description='The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.', example='WORKER'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='The type of the IP address whitelist. Valid values:

*   PRIVATE_KIBANA
*   PRIVATE_ES
*   PUBLIC_ES
*   PUBLIC_KIBANA', example='test_group'),
    ips?: [ string ](name='ips', description='The returned result.'),
    whiteIpType?: string(name='whiteIpType', description='The request ID.', example='PRIVATE_ES'),
  }(name='whiteIpGroup', description='The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  whiteIpList?: [ string ](name='whiteIpList', description='The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  clientToken?: string(name='clientToken', description='The network type. This parameter is required if you configure the whiteIpList parameter. Valid values:

*   PRIVATE
*   PUBLIC', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model ModifyWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1DERFG'),
  result?: boolean(name='Result', example='true'),
}

model ModifyWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWhiteIpsResponseBody(name='body'),
}

/**
  * The ID of the cluster.
  *
  * @param request ModifyWhiteIpsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyWhiteIpsResponse
 */
async function modifyWhiteIpsWithOptions(InstanceId: string, request: ModifyWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.modifyMode)) {
    body['modifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.networkType)) {
    body['networkType'] = request.networkType;
  }
  if (!Util.isUnset(request.nodeType)) {
    body['nodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body['whiteIpGroup'] = request.whiteIpGroup;
  }
  if (!Util.isUnset(request.whiteIpList)) {
    body['whiteIpList'] = request.whiteIpList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/modify-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the cluster.
  *
  * @param request ModifyWhiteIpsRequest
  * @return ModifyWhiteIpsResponse
 */
async function modifyWhiteIps(InstanceId: string, request: ModifyWhiteIpsRequest): ModifyWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model MoveResourceGroupRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    createdAt?: string(name='createdAt', description='The time when the cluster was created.', example='2020-07-06T10:18:48.662Z'),
    description?: string(name='description', description='The name of the cluster.', example='es-cn-abc'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The type of the source of the dictionary file. Valid values:

*   OSS: Object Storage Service (OSS). You must make sure that the access control list (ACL) of the related OSS bucket is public read.
*   ORIGIN: previously uploaded dictionary.', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: stopword list
*   MAIN: main dictionary
*   SYNONYMS: synonym dictionary
*   ALI_WS: Alibaba Cloud dictionary', example='MAIN'),
      }
    ](name='dictList', description='The configurations of IK dictionaries.'),
    domain?: string(name='domain', description='The internal endpoint of the cluster.', example='es-cn-nif1q8auz0003****.elasticsearch.aliyuncs.com'),
    esVersion?: string(name='esVersion', description='The version of the cluster.', example='6.7.0_with_X-Pack'),
    instanceId?: string(name='instanceId', description='The ID of the cluster.', example='es-cn-n6w1o1x0w001c****'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', description='The number of nodes.', example='1'),
      disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification category.', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration', description='The configurations of Kibana nodes.'),
    kibanaDomain?: string(name='kibanaDomain', description='The public endpoint of the Kibana console of the cluster.', example='es-cn-nif1q8auz0003****.kibana.elasticsearch.aliyuncs.com'),
    kibanaPort?: int32(name='kibanaPort', description='The port number that is used to access the Kibana console of the cluster over the Internet.', example='5601'),
    masterConfiguration?: {
      amount?: int32(name='amount', description='The number of nodes.', example='3'),
      disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification category.', example='elasticsearch.sn2ne.large'),
    }(name='masterConfiguration', description='The configurations of dedicated master nodes.'),
    networkConfig?: {
      type?: string(name='type', description='The network type. Only the VPC is supported.', example='vpc'),
      vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp16k1dvzxtmagcva****'),
      vsArea?: string(name='vsArea', description='The zone where the cluster resides.', example='cn-hangzhou-i'),
      vswitchId?: string(name='vswitchId', description='The ID of the vSwitch.', example='vsw-bp1k4ec6s7sjdbudw****'),
    }(name='networkConfig', description='The network configurations.'),
    nodeAmount?: int32(name='nodeAmount', description='The number of data nodes in the cluster.', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='50'),
      diskType?: string(name='diskType', description='The storage type.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification category.', example='elasticsearch.n4.small'),
    }(name='nodeSpec', description='The configurations of data nodes.'),
    paymentType?: string(name='paymentType', description='The billing method of the cluster. Valid values:

*   prepaid: subscription
*   postpaid: pay-as-you-go', example='postpaid'),
    publicDomain?: string(name='publicDomain', description='The public endpoint of the cluster.', example='es-cn-n6w1o1x0w001c****.public.elasticsearch.aliyuncs.com'),
    publicPort?: int32(name='publicPort', description='The port number that is used to access the cluster over the Internet.', example='9200'),
    status?: string(name='status', description='The status of the cluster. Valid values:

*   active: The cluster is normal.
*   activating: The cluster is being activated.
*   Inactive: The cluster is frozen.
*   invalid: The cluster is valid.', example='active'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The type of the source of the dictionary file. Valid values:

*   OSS: Object Storage Service (OSS). You must make sure that the ACL of the related OSS bucket is public read.
*   ORIGIN: previously uploaded dictionary.', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: stopword list
*   MAIN: main dictionary
*   SYNONYMS: synonym dictionary
*   ALI_WS: Alibaba Cloud dictionary', example='STOP'),
      }
    ](name='synonymsDicts', description='The configurations of synonym dictionaries.'),
    updatedAt?: string(name='updatedAt', description='The time when the cluster was last updated.', example='2018-07-18T10:10:04.484Z'),
  }(name='Result', description='The returned result.'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroupWithOptions(InstanceId: string, request: MoveResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'MoveResourceGroup',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/resourcegroup`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveResourceGroup(InstanceId: string, request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return moveResourceGroupWithOptions(InstanceId, request, headers, runtime);
}

model OpenDiagnosisRequest {
  clientToken?: string(name='ClientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  lang?: string(name='lang', example='en'),
}

model OpenDiagnosisResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model OpenDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenDiagnosisResponseBody(name='body'),
}

async function openDiagnosisWithOptions(InstanceId: string, request: OpenDiagnosisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenDiagnosisResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenDiagnosis',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/open-diagnosis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openDiagnosis(InstanceId: string, request: OpenDiagnosisRequest): OpenDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openDiagnosisWithOptions(InstanceId, request, headers, runtime);
}

model OpenHttpsRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model OpenHttpsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: open the HTTPS protocol successfully
*   false: open the HTTPS protocol failed', example='true'),
}

model OpenHttpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenHttpsResponseBody(name='body'),
}

/**
  * >  To ensure data security, we recommend that you enable HTTPS.
  *
  * @param request OpenHttpsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return OpenHttpsResponse
 */
async function openHttpsWithOptions(InstanceId: string, request: OpenHttpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenHttpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenHttps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/open-https`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  To ensure data security, we recommend that you enable HTTPS.
  *
  * @param request OpenHttpsRequest
  * @return OpenHttpsResponse
 */
async function openHttps(InstanceId: string, request: OpenHttpsRequest): OpenHttpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openHttpsWithOptions(InstanceId, request, headers, runtime);
}

model PostEmonTryAlarmRuleRequest {
  body?: string(name='body'),
}

model PostEmonTryAlarmRuleResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='3EC5731F-0944-4E4F-9DD5-1F976B3FCC3D'),
  success?: boolean(name='Success', example='true'),
}

model PostEmonTryAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PostEmonTryAlarmRuleResponseBody(name='body'),
}

async function postEmonTryAlarmRuleWithOptions(ProjectId: string, AlarmGroupId: string, request: PostEmonTryAlarmRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PostEmonTryAlarmRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'PostEmonTryAlarmRule',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/alarm-groups/${OpenApiUtil.getEncodeParam(AlarmGroupId)}/alarm-rules/_test`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function postEmonTryAlarmRule(ProjectId: string, AlarmGroupId: string, request: PostEmonTryAlarmRuleRequest): PostEmonTryAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return postEmonTryAlarmRuleWithOptions(ProjectId, AlarmGroupId, request, headers, runtime);
}

model RecommendTemplatesRequest {
  usageScenario?: string(name='usageScenario', description='*
*
*
*
*

**

****', example='general'),
}

model RecommendTemplatesResponseBody = {
  requestId?: string(name='RequestId', example='66B060CF-7381-49C7-9B89-7757927FDA16'),
  result?: [ 
    {
      content?: string(name='content', example='{\\n\\t\\"persistent\\": {\\n\\t\\t\\"search\\": {\\n\\t\\t\\t\\"max_buckets\\": \\"10000\\"\\n\\t\\t}\\n\\t}\\n}'),
      templateName?: string(name='templateName', description='*
*
*
*

**

****', example='dynamicSettings'),
    }
  ](name='Result'),
}

model RecommendTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecommendTemplatesResponseBody(name='body'),
}

async function recommendTemplatesWithOptions(InstanceId: string, request: RecommendTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RecommendTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.usageScenario)) {
    query['usageScenario'] = request.usageScenario;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecommendTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/recommended-templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recommendTemplates(InstanceId: string, request: RecommendTemplatesRequest): RecommendTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return recommendTemplatesWithOptions(InstanceId, request, headers, runtime);
}

model ReinstallCollectorRequest {
  clientToken?: string(name='ClientToken', description='The request body parameters. For more information, see the Request body section in this topic.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body', description='Indicates whether the shipper is installed. Valid values:

*   true: The shipper is installed.
*   false: The shipper fails to be installed.', example='{
  "restartType": "nodeEcsId",
  "nodes":["i-bp1gyhphjaj73jsr****","i-bp10piq1mkfnyw9t****"]
}'),
}

model ReinstallCollectorResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The ID of the request.', example='true'),
}

model ReinstallCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReinstallCollectorResponseBody(name='body'),
}

async function reinstallCollectorWithOptions(ResId: string, request: ReinstallCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReinstallCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ReinstallCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/reinstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reinstallCollector(ResId: string, request: ReinstallCollectorRequest): ReinstallCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return reinstallCollectorWithOptions(ResId, request, headers, runtime);
}

model RemoveApmResponseBody = {
  requestId?: string(name='RequestId', example='29A879FB-86BF-54CA-9426-B769A099E1A1'),
  result?: boolean(name='Result', example='true'),
}

model RemoveApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveApmResponseBody(name='body'),
}

async function removeApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveApmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeApm(instanceId: string): RemoveApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeApmWithOptions(instanceId, headers, runtime);
}

model RenewInstanceRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='This parameter is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B350****'),
}

model RenewInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: renewal successfully
*   false: renewal failed', example='true'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstanceWithOptions(InstanceId: string, request: RenewInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/renew`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewInstance(InstanceId: string, request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewInstanceWithOptions(InstanceId, request, headers, runtime);
}

model RenewLogstashRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model RenewLogstashResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: boolean(name='Result', description='The returned result. Valid values:

*   true: The cluster is renewed.
*   false: The cluster fails to be renewed.', example='true'),
}

model RenewLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewLogstashResponseBody(name='body'),
}

async function renewLogstashWithOptions(InstanceId: string, request: RenewLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RenewLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/renew`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewLogstash(InstanceId: string, request: RenewLogstashRequest): RenewLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewLogstashWithOptions(InstanceId, request, headers, runtime);
}

model RestartCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model RestartCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='84B4038A-AF38-4BF4-9FAD-EA92A4FFF00A'),
  result?: boolean(name='Result', description='Indicates whether the shipper is restarted. Valid values:

*   true: The shipper is restarted.
*   false: The shipper fails to be restarted.', example='true'),
}

model RestartCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartCollectorResponseBody(name='body'),
}

async function restartCollectorWithOptions(ResId: string, request: RestartCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartCollector(ResId: string, request: RestartCollectorRequest): RestartCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartCollectorWithOptions(ResId, request, headers, runtime);
}

model RestartInstanceRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. The maximum length of the token is 64 ASCII characters.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  force?: boolean(name='force', description='Specifies whether to ignore the status of the instance and forcibly restart the instance.', example='false'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: {
    createdAt?: string(name='createdAt', description='The time when the instance was created.', example='2020-07-06T10:18:48.662Z'),
    description?: string(name='description', description='The name of the instance.', example='es-cn-abc'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the Dictionary File. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The source type. Valid values:

*   OSS: OSS open storage (need to ensure that OSS storage space is public readable.)
*   ORIGIN: Open source Elasticsearch
*   UPLOAD: Uploaded files', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: The STOP word.
*   MAIN: MAIN Dictionary
*   SYNONYMS: SYNONYMS
*   ALI_WS: an Alibaba Dictionary.', example='MAIN'),
      }
    ](name='dictList', description='The configuration of the IK dictionaries.'),
    domain?: string(name='domain', description='The intranet access address of the instance.', example='es-cn-nif1q8auz0003****.elasticsearch.aliyuncs.com'),
    esVersion?: string(name='esVersion', description='The version of the instance.', example='6.7.0_with_X-Pack'),
    instanceId?: string(name='instanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', description='The number of performance metrics.', example='1'),
      disk?: int32(name='disk', description='The size of the node storage space. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type of the node.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification of data nodes.', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration', description='The configuration of Kibana nodes.'),
    kibanaDomain?: string(name='kibanaDomain', description='The public network access address of Kibana.', example='es-cn-nif1q8auz0003****.kibana.elasticsearch.aliyuncs.com'),
    kibanaPort?: int32(name='kibanaPort', description='The public port of the Kibana network.', example='5601'),
    masterConfiguration?: {
      amount?: int32(name='amount', description='The number of nodes in the cluster.', example='3'),
      disk?: int32(name='disk', description='The size of the node storage space. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type of the node. This tool only supports cloud_ssd (cloud SSD) disks.', example='cloud_ssd'),
      spec?: string(name='spec', description='The node specifications of the cluster.', example='elasticsearch.sn2ne.large'),
    }(name='masterConfiguration', description='The configuration of dedicated master nodes.'),
    networkConfig?: {
      type?: string(name='type', description='The network type. Only Virtual Private Cloud (VPC) is supported.', example='vpc'),
      vpcId?: string(name='vpcId', description='The ID of the VPC.', example='vpc-bp16k1dvzxtmagcva****'),
      vsArea?: string(name='vsArea', description='The zone where the instance is deployed.', example='cn-hangzhou-i'),
      vswitchId?: string(name='vswitchId', description='The ID of the vSwitch associated with the specified VPC.', example='vsw-bp1k4ec6s7sjdbudw****'),
    }(name='networkConfig', description='The network configuration.'),
    nodeAmount?: int32(name='nodeAmount', description='The number of data nodes.', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='The storage space size per data node. Unit: GB.', example='50'),
      diskType?: string(name='diskType', description='The storage type of the node. Valid values: cloud_ssd and cloud_efficiency.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification of data nodes.', example='elasticsearch.n4.small'),
    }(name='nodeSpec', description='The configuration of data nodes.'),
    paymentType?: string(name='paymentType', description='The billing method of the created ECS instance.

Valid values: prepaid and postpaid.', example='postpaid'),
    publicDomain?: string(name='publicDomain', description='The public network access address.', example='es-cn-n6w1o1x0w001c****.public.elasticsearch.aliyuncs.com'),
    publicPort?: int32(name='publicPort', description='The public network port.', example='9200'),
    status?: string(name='status', description='The state of the cluster.

Supported: active (normal), activating (initializing), inactive (blocked), and invalid (expired).', example='active'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the Dictionary File. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The source type. Valid values:

*   OSS:OSS open storage (the OSS storage space must be publicly readable.)
*   ORIGIN: open-source Elasticsearch
*   UPLOAD', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: The STOP word.
*   MAIN: MAIN Dictionary
*   SYNONYMS: SYNONYMS
*   ALI_WS: an Alibaba Dictionary.', example='STOP'),
      }
    ](name='synonymsDicts', description='The configuration of the synonym dictionaries.'),
    updatedAt?: string(name='updatedAt', description='The time when the instance was last updated.', example='2018-07-18T10:10:04.484Z'),
  }(name='Result', description='The return results.'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartInstanceResponseBody(name='body'),
}

/**
  * >  After the instance is restarted, the instance enters the activating state. After the instance is restarted, its status changes to active. Alibaba Cloud Elasticsearch supports restarting a single node. Restarting a node can be divided into normal restart and blue-green restart.
  *
  * @param request RestartInstanceRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return RestartInstanceResponse
 */
async function restartInstanceWithOptions(InstanceId: string, request: RestartInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RestartInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  After the instance is restarted, the instance enters the activating state. After the instance is restarted, its status changes to active. Alibaba Cloud Elasticsearch supports restarting a single node. Restarting a node can be divided into normal restart and blue-green restart.
  *
  * @param request RestartInstanceRequest
  * @return RestartInstanceResponse
 */
async function restartInstance(InstanceId: string, request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartInstanceWithOptions(InstanceId, request, headers, runtime);
}

model RestartLogstashRequest {
  batchCount?: double(name='batchCount', example='20%'),
  blueGreenDep?: boolean(name='blueGreenDep', example='false'),
  nodeTypes?: [ string ](name='nodeTypes'),
  nodes?: [ string ](name='nodes'),
  restartType?: string(name='restartType', example='instance'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  force?: boolean(name='force', example='true'),
}

model RestartLogstashResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: Logstash(name='Result'),
}

model RestartLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartLogstashResponseBody(name='body'),
}

async function restartLogstashWithOptions(InstanceId: string, request: RestartLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.batchCount)) {
    body['batchCount'] = request.batchCount;
  }
  if (!Util.isUnset(request.blueGreenDep)) {
    body['blueGreenDep'] = request.blueGreenDep;
  }
  if (!Util.isUnset(request.nodeTypes)) {
    body['nodeTypes'] = request.nodeTypes;
  }
  if (!Util.isUnset(request.nodes)) {
    body['nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.restartType)) {
    body['restartType'] = request.restartType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestartLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartLogstash(InstanceId: string, request: RestartLogstashRequest): RestartLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartLogstashWithOptions(InstanceId, request, headers, runtime);
}

model ResumeElasticsearchTaskRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model ResumeElasticsearchTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: resume the interrupted change successfully
*   false: resume the interrupted change successfully failed', example='true'),
}

model ResumeElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeElasticsearchTaskResponseBody(name='body'),
}

async function resumeElasticsearchTaskWithOptions(InstanceId: string, request: ResumeElasticsearchTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeElasticsearchTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumeElasticsearchTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeElasticsearchTask(InstanceId: string, request: ResumeElasticsearchTaskRequest): ResumeElasticsearchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeElasticsearchTaskWithOptions(InstanceId, request, headers, runtime);
}

model ResumeLogstashTaskRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model ResumeLogstashTaskResponseBody = {
  code?: string(name='Code', description='The error code returned. If the API operation is successfully called, this parameter is not returned.', example='InstanceNotFound'),
  message?: string(name='Message', description='The error message returned. If the API operation is successfully called, this parameter is not returned.', example='The specified cluster does not exist. Check the cluster status and try again.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0FA05123-745C-42FD-A69B-AFF48EF9****'),
  result?: boolean(name='Result', description='Indicates whether the change task is resumed. Valid values:

*   true: The change task is resumed.
*   false: The change task fails to be resumed.', example='true'),
}

model ResumeLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeLogstashTaskResponseBody(name='body'),
}

async function resumeLogstashTaskWithOptions(InstanceId: string, request: ResumeLogstashTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeLogstashTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumeLogstashTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeLogstashTask(InstanceId: string, request: ResumeLogstashTaskRequest): ResumeLogstashTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeLogstashTaskWithOptions(InstanceId, request, headers, runtime);
}

model RolloverDataStreamRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model RolloverDataStreamResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model RolloverDataStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RolloverDataStreamResponseBody(name='body'),
}

async function rolloverDataStreamWithOptions(InstanceId: string, DataStream: string, request: RolloverDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RolloverDataStreamResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RolloverDataStream',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams/${OpenApiUtil.getEncodeParam(DataStream)}/rollover`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rolloverDataStream(InstanceId: string, DataStream: string, request: RolloverDataStreamRequest): RolloverDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rolloverDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime);
}

model RunPipelinesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model RunPipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result. Valid values:

*   true: successful
*   false: failed', example='true'),
}

model RunPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunPipelinesResponseBody(name='body'),
}

async function runPipelinesWithOptions(InstanceId: string, request: RunPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RunPipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RunPipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines/action/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runPipelines(InstanceId: string, request: RunPipelinesRequest): RunPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runPipelinesWithOptions(InstanceId, request, headers, runtime);
}

model ShrinkNodeRequest {
  body?: [ 
    {
      host?: string(name='host', example='192.168.xx.xx'),
      hostName?: string(name='hostName', example='es-cn-pl32xxxxxxx-data-f-1'),
      nodeType?: string(name='nodeType', example='WORKER'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  count?: int32(name='count', example='2'),
  ignoreStatus?: boolean(name='ignoreStatus', example='false'),
  nodeType?: string(name='nodeType', example='WORKER'),
}

model ShrinkNodeResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model ShrinkNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ShrinkNodeResponseBody(name='body'),
}

async function shrinkNodeWithOptions(InstanceId: string, request: ShrinkNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ShrinkNodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query['ignoreStatus'] = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ShrinkNode',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/shrink`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function shrinkNode(InstanceId: string, request: ShrinkNodeRequest): ShrinkNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return shrinkNodeWithOptions(InstanceId, request, headers, runtime);
}

model StartApmResponseBody = {
  requestId?: string(name='RequestId', example='526F30AB-4A43-55BA-910F-ACD275FD5F14'),
  result?: boolean(name='Result', example='true'),
}

model StartApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartApmResponseBody(name='body'),
}

async function startApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartApmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}/actions/start`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startApm(instanceId: string): StartApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startApmWithOptions(instanceId, headers, runtime);
}

model StartCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model StartCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result.', example='true'),
}

model StartCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartCollectorResponseBody(name='body'),
}

async function startCollectorWithOptions(ResId: string, request: StartCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/start`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startCollector(ResId: string, request: StartCollectorRequest): StartCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startCollectorWithOptions(ResId, request, headers, runtime);
}

model StopApmResponseBody = {
  requestId?: string(name='RequestId', example='FEC32FE6-4697-5110-9668-C6016EAEB5DE'),
  result?: boolean(name='Result', example='true'),
}

model StopApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopApmResponseBody(name='body'),
}

async function stopApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopApmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}/actions/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopApm(instanceId: string): StopApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopApmWithOptions(instanceId, headers, runtime);
}

model StopCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model StopCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result.', example='true'),
}

model StopCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopCollectorResponseBody(name='body'),
}

async function stopCollectorWithOptions(ResId: string, request: StopCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopCollector(ResId: string, request: StopCollectorRequest): StopCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopCollectorWithOptions(ResId, request, headers, runtime);
}

model StopPipelinesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model StopPipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result. Valid values:

*   true: The pipelines are stopped.
*   false: The pipelines fail to be stopped.', example='true'),
}

model StopPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopPipelinesResponseBody(name='body'),
}

async function stopPipelinesWithOptions(InstanceId: string, request: StopPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopPipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'StopPipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines/action/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopPipelines(InstanceId: string, request: StopPipelinesRequest): StopPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopPipelinesWithOptions(InstanceId, request, headers, runtime);
}

model TagResourcesRequest {
  resourceIds?: [ string ](name='ResourceIds', description='A tag.'),
  resourceType?: string(name='ResourceType', description='The request ID.', example='INSTANCE'),
  tags?: [ 
    {
      key?: string(name='key', description='The returned object.', example='env'),
      value?: string(name='value', description='Indicates whether tags are added to the clusters. Valid values:

*   true
*   false', example='IT'),
    }
  ](name='Tags', description='The value of the tag.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', example='3D8795D9-8FF5-46B2-86E6-E3B407*******'),
  result?: boolean(name='Result', example='true'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceIds)) {
    body['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

model TransferNodeRequest {
  body?: [ 
    {
      host?: string(name='host', example='192.168.xx.xx'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  nodeType?: string(name='nodeType', example='WORKER'),
}

model TransferNodeResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model TransferNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferNodeResponseBody(name='body'),
}

async function transferNodeWithOptions(InstanceId: string, request: TransferNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TransferNodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TransferNode',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/transfer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferNode(InstanceId: string, request: TransferNodeRequest): TransferNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return transferNodeWithOptions(InstanceId, request, headers, runtime);
}

model TriggerNetworkRequest {
  actionType?: string(name='actionType', example='OPEN'),
  networkType?: string(name='networkType', example='PUBLIC'),
  nodeType?: string(name='nodeType', example='KIBANA'),
  clientToken?: string(name='clientToken', example='407d02b74c49beb5bfdac7ec8bde2488'),
}

model TriggerNetworkResponseBody = {
  requestId?: string(name='RequestId', example='5A5D8E74-565C-43DC-B031-29289FA****'),
  result?: boolean(name='Result', example='true'),
}

model TriggerNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TriggerNetworkResponseBody(name='body'),
}

async function triggerNetworkWithOptions(InstanceId: string, request: TriggerNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TriggerNetworkResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.actionType)) {
    body['actionType'] = request.actionType;
  }
  if (!Util.isUnset(request.networkType)) {
    body['networkType'] = request.networkType;
  }
  if (!Util.isUnset(request.nodeType)) {
    body['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TriggerNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/network-trigger`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function triggerNetwork(InstanceId: string, request: TriggerNetworkRequest): TriggerNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return triggerNetworkWithOptions(InstanceId, request, headers, runtime);
}

model UninstallKibanaPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UninstallKibanaPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ string ](name='Result', description='The returned result shows a list of uninstalled plug-ins.'),
}

model UninstallKibanaPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallKibanaPluginResponseBody(name='body'),
}

async function uninstallKibanaPluginWithOptions(InstanceId: string, request: UninstallKibanaPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallKibanaPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UninstallKibanaPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-plugins/actions/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallKibanaPlugin(InstanceId: string, request: UninstallKibanaPluginRequest): UninstallKibanaPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallKibanaPluginWithOptions(InstanceId, request, headers, runtime);
}

model UninstallLogstashPluginRequest {
  body?: [ string ](name='body', example='["logstash-input-datahub", "logstash-input-maxcompute" ]'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UninstallLogstashPluginResponseBody = {
  headers?: map[string]any(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ string ](name='Result'),
}

model UninstallLogstashPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallLogstashPluginResponseBody(name='body'),
}

async function uninstallLogstashPluginWithOptions(InstanceId: string, request: UninstallLogstashPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallLogstashPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UninstallLogstashPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/actions/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallLogstashPlugin(InstanceId: string, request: UninstallLogstashPluginRequest): UninstallLogstashPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallLogstashPluginWithOptions(InstanceId, request, headers, runtime);
}

model UninstallPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  force?: boolean(name='force'),
}

model UninstallPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ string ](name='Result', description='The list of plug-ins to be unloaded. If the unloading fails, an exception is returned.'),
}

model UninstallPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallPluginResponseBody(name='body'),
}

async function uninstallPluginWithOptions(InstanceId: string, request: UninstallPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UninstallPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/actions/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallPlugin(InstanceId: string, request: UninstallPluginRequest): UninstallPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallPluginWithOptions(InstanceId, request, headers, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to delete all parts. Default value: **false** . This parameter is valid only when **TagKeys** is not specified.', example='false'),
  resourceIds?: string(name='ResourceIds', description='The resource list that you want to delete.', example='["es-cn-09k1rocex0006****","es-cn-oew1rgiev0009****"]'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Fixed to **INSTANCE** .', example='INSTANCE'),
  tagKeys?: string(name='TagKeys', description='The list of tags that you want to delete. The list can contain up to 20 subitems.', example='["tagKey1","tagKey2"]'),
  body?: string(name='body'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6D******'),
  result?: boolean(name='Result', description='Return results:

*   true: deleted
*   false: Failed', example='true'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * *   You can only delete user tags.
  * > User labels are manually added to instances by users. A system Tag is a tag that Alibaba Cloud services add to instances. System labels are divided into visible labels and invisible labels.
  * *   If you delete a resource tag relationship that is not associated with any resources, you must delete the tags.
  *
  * @param request UntagResourcesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['TagKeys'] = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items:
  * *   You can only delete user tags.
  * > User labels are manually added to instances by users. A system Tag is a tag that Alibaba Cloud services add to instances. System labels are divided into visible labels and invisible labels.
  * *   If you delete a resource tag relationship that is not associated with any resources, you must delete the tags.
  *
  * @param request UntagResourcesRequest
  * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

model UpdateAdminPasswordRequest {
  esAdminPassword?: string(name='esAdminPassword', example='es_password'),
  clientToken?: string(name='clientToken', description='Indicates whether the password was updated. Valid values:

*   true: The call was successful.
*   false: The call failed.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateAdminPasswordResponseBody = {
  requestId?: string(name='RequestId', example='0FA05123-745C-42FD-A69B-AFF48EF9****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateAdminPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAdminPasswordResponseBody(name='body'),
}

/**
  * 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
  *
  * @param request UpdateAdminPasswordRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateAdminPasswordResponse
 */
async function updateAdminPasswordWithOptions(InstanceId: string, request: UpdateAdminPasswordRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAdminPasswordResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.esAdminPassword)) {
    body['esAdminPassword'] = request.esAdminPassword;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAdminPassword',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/admin-pwd`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
  *
  * @param request UpdateAdminPasswordRequest
  * @return UpdateAdminPasswordResponse
 */
async function updateAdminPassword(InstanceId: string, request: UpdateAdminPasswordRequest): UpdateAdminPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAdminPasswordWithOptions(InstanceId, request, headers, runtime);
}

model UpdateAdvancedSettingRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateAdvancedSettingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: boolean(name='Result', description='Return results:

*   true: garbage collector configuration changed successfully
*   false: garbage collector configuration changed successfully failed', example='true'),
}

model UpdateAdvancedSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAdvancedSettingResponseBody(name='body'),
}

async function updateAdvancedSettingWithOptions(InstanceId: string, request: UpdateAdvancedSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAdvancedSettingResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateAdvancedSetting',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-advanced-setting`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAdvancedSetting(InstanceId: string, request: UpdateAdvancedSettingRequest): UpdateAdvancedSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAdvancedSettingWithOptions(InstanceId, request, headers, runtime);
}

model UpdateAliwsDictRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateAliwsDictResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='6226'),
      name?: string(name='name', description='The name of the uploaded dictionary file.', example='aliws_ext_dict.txt'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='OSS'),
      type?: string(name='type', description='The dictionary type. The value is fixed as ALI_WS.', example='ALI_WS'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateAliwsDictResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAliwsDictResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following items:
  * *   Elasticsearch V5.X clusters do not support the analysis-aliws plug-in.
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
  * @param request UpdateAliwsDictRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateAliwsDictResponse
 */
async function updateAliwsDictWithOptions(InstanceId: string, request: UpdateAliwsDictRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAliwsDictResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateAliwsDict',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/aliws-dict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, take note of the following items:
  * *   Elasticsearch V5.X clusters do not support the analysis-aliws plug-in.
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
  * @param request UpdateAliwsDictRequest
  * @return UpdateAliwsDictResponse
 */
async function updateAliwsDict(InstanceId: string, request: UpdateAliwsDictRequest): UpdateAliwsDictResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAliwsDictWithOptions(InstanceId, request, headers, runtime);
}

model UpdateApmRequest {
  description?: string(name='description', example='APMtest'),
  outputES?: string(name='outputES', example='es-cn-i7m2fsfhc001x****'),
  outputESPassword?: string(name='outputESPassword', example='ESPassword****'),
  outputESUserName?: string(name='outputESUserName', example='elastic'),
  token?: string(name='token', example='AMPPassword****'),
}

model UpdateApmResponseBody = {
  requestId?: string(name='RequestId', example='18061926-CC50-5F9B-9600-034C29F1D5B0'),
  result?: boolean(name='Result', example='true'),
}

model UpdateApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApmResponseBody(name='body'),
}

async function updateApmWithOptions(instanceId: string, request: UpdateApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApmResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.outputES)) {
    body['outputES'] = request.outputES;
  }
  if (!Util.isUnset(request.outputESPassword)) {
    body['outputESPassword'] = request.outputESPassword;
  }
  if (!Util.isUnset(request.outputESUserName)) {
    body['outputESUserName'] = request.outputESUserName;
  }
  if (!Util.isUnset(request.token)) {
    body['token'] = request.token;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApm(instanceId: string, request: UpdateApmRequest): UpdateApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApmWithOptions(instanceId, request, headers, runtime);
}

model UpdateBlackIpsRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateBlackIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
  }(name='Result'),
}

model UpdateBlackIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBlackIpsResponseBody(name='body'),
}

/**
  * @deprecated
  *
  * @param request UpdateBlackIpsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateBlackIpsResponse
 */
// Deprecated
async function updateBlackIpsWithOptions(InstanceId: string, request: UpdateBlackIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateBlackIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBlackIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/black-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * @deprecated
  *
  * @param request UpdateBlackIpsRequest
  * @return UpdateBlackIpsResponse
 */
// Deprecated
async function updateBlackIps(InstanceId: string, request: UpdateBlackIpsRequest): UpdateBlackIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateBlackIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content', description='The content of the configuration file.', example='filebeat.inputs:xxx'),
        fileName?: string(name='fileName', description='The name of the configuration file.', example='filebeat.yml'),
      }
    ](name='configs', description='The information about the configuration file for the shipper.'),
    dryRun?: boolean(name='dryRun', description='Indicates whether the shipper is checked and updated. Valid values:

*   true: The shipper is only checked.
*   false: The shipper is checked and updated.', example='false'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType', description='The type of the configuration items. Valid values:

*   collectorTargetInstance: indicates the information about the output of the shipper.
*   collectorDeployMachine: indicates the information about the machine on which the shipper is installed.
*   collectorElasticsearchForKibana: indicates the information about the Elasticsearch cluster for which Kibana Dashboard is enabled.', example='collectorDeployMachine'),
        enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether Kibana Monitoring is enabled. This parameter is returned only when **configType** is set to **collectorTargetInstance** and **instanceType** is set to **elasticsearch**. Valid values: true and false.', example='true'),
        groupId?: string(name='groupId', description='The machine group ID. This parameter is returned only when **configType** is set to **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
        host?: string(name='host', description='The address that is used to access Kibana over an internal network after you enable Kibana Dashboard. This parameter is returned only when **configType** is set to **collectorElasticsearchForKibana**.', example='es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId', description='The ID of the object that is associated with the shipper. If **configType** is set to **collectorTargetInstance**, the value of this parameter is the ID of the output of the shipper. If **configType** is set to **collectorDeployMachines** and **type** is set to **ACKCluster**, the value of this parameter is the ID of an ACK cluster.', example='es-cn-nif1z89fz003i****'),
        instanceType?: string(name='instanceType', description='The type of the output of the shipper. Valid values: elasticsearch and logstash. This parameter is returned only when **configType** is set to **collectorTargetInstance**.', example='elasticsearch'),
        kibanaHost?: string(name='kibanaHost', description='The address that is used to access Kibana over the Internet after you enable Kibana Dashboard. This parameter is returned only when **configType** is set to **collectorElasticsearchForKibana**.', example='https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus', description='The installation status of the shipper on an ECS instance. Valid values:

*   heartOk
*   heartLost
*   uninstalled
*   failed', example='heartOk'),
            instanceId?: string(name='instanceId', description='The ID of the ECS instance on which the shipper is installed.', example='i-bp13y63575oypr9d****'),
          }
        ](name='machines', description='This parameter is returned only when configType is set to collectorDeployMachine.

This parameter indicates the information about the ECS instances or ACK clusters on which the shipper is installed.'),
        protocol?: string(name='protocol', description='The transfer protocol that is used. It is the same as the protocol over which you can access the output of the shipper. Valid values: HTTP and HTTPS. This parameter is returned only when **configType** is set to **collectorTargetInstance**.', example='HTTP'),
        successPodsCount?: string(name='successPodsCount', description='The number of pods from which logs are successfully collected in the ACK cluster. This parameter is returned only when **configType** is set to **collectorDeployMachines** and **type** is set to **ACKCluster**.', example='8'),
        totalPodsCount?: string(name='totalPodsCount', description='The number of pods from which logs needed to be collected in the ACK cluster. This parameter is returned only when **configType** is set to **collectorDeployMachines** and **type** is set to **ACKCluster**.', example='10'),
        type?: string(name='type', description='The type of the machine on which the shipper is installed. This parameter is returned only when **configType** is set to **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
        userName?: string(name='userName', description='The username that is used to access the output of the shipper. Default value: elastic. This parameter is returned only when **configType** is set to **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
      }
    ](name='extendConfigs', description='The extended parameters that are configured for the shipper.'),
    gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-06-20T07:26:47.000+0000'),
    name?: string(name='name', description='The name of the shipper.', example='ct-test'),
    ownerId?: string(name='ownerId', description='The account ID.', example='16852099488*****'),
    resId?: string(name='resId', description='The shipper ID.', example='ct-cn-0v3xj86085dvq****'),
    resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.', example='fileBeat'),
    resVersion?: string(name='resVersion', description='The version of the shipper.', example='6.8.5_with_community'),
    status?: string(name='status', description='The status of the shipper. Valid values:

*   activing: The shipper is being initialized.
*   active: The shipper is in effect.', example='active'),
    vpcId?: string(name='vpcId', description='The ID of the VPC in which the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
  }(name='Result', description='The returned result.'),
}

model UpdateCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCollectorResponseBody(name='body'),
}

async function updateCollectorWithOptions(ResId: string, request: UpdateCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCollector(ResId: string, request: UpdateCollectorRequest): UpdateCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCollectorWithOptions(ResId, request, headers, runtime);
}

model UpdateCollectorNameRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateCollectorNameResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content', description='The content of the file.', example='- key: log\\n title: Log file content\\n description: >\\n Contains log file lines.\\n ....'),
        fileName?: string(name='fileName', description='The name of the file.', example='fields.yml'),
      }
    ](name='configs', description='The information about the configuration file of the shipper.'),
    dryRun?: boolean(name='dryRun', description='Indicates whether a dry run is performed. Valid values:

*   true
*   false', example='false'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType', description='The configuration type. Valid values:

*   collectorTargetInstance
*   collectorDeployMachine
*   collectorElasticsearchForKibana', example='collectorDeployMachine'),
        enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether monitoring is enabled. This parameter is returned if the value of **configType** is **collectorTargetInstance** and the value of **instanceType** is **elasticsearch**. Valid values:

*   true
*   false', example='true'),
        groupId?: string(name='groupId', description='The ID of the machine group. This parameter is returned if the value of **configType** is **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
        host?: string(name='host', description='The private endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='es-cn-4591jumei000u****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId', description='The ID of the resource that is associated with the shipper. If the value of **configType** is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='es-cn-n6w1o1****'),
        instanceType?: string(name='instanceType', description='The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='elasticsearch'),
        kibanaHost?: string(name='kibanaHost', description='The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='https://es-cn-4591jumei000u****.kibana.elasticsearch.aliyuncs.com:5601'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values: **heartOk**, **heartLost**, **uninstalled**, and **failed**.', example='heartOk'),
            instanceId?: string(name='instanceId', description='The IDs of the ECS instances.', example='c1b9fde5172b84f82b9928e825a7b8988'),
          }
        ](name='machines', description='The information about the ECS instances on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ECSInstanceId**.'),
        protocol?: string(name='protocol', description='The transmission protocol. Valid values: **HTTP** and **HTTPS**.', example='HTTP'),
        successPodsCount?: string(name='successPodsCount', description='The number of pods from which data is successfully collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='8'),
        totalPodsCount?: string(name='totalPodsCount', description='The total number of pods from which data is collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='10'),
        type?: string(name='type', description='The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
        userName?: string(name='userName', description='The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
      }
    ](name='extendConfigs', description='The extended configurations of the shipper.'),
    gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-06-20T07:26:47.000+0000'),
    name?: string(name='name', description='The name of the shipper.', example='ct-test'),
    ownerId?: string(name='ownerId', description='The account ID.', example='16852099488*****'),
    resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-77uqof2s7rg5c****'),
    resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and audiBeat.', example='fileBeat'),
    resVersion?: string(name='resVersion', description='The version of the shipper. The version of a shipper depends on the type of the machine on which the shipper is deployed.

*   Elastic Compute Service (ECS) instance: 6.8.5\\_with_community
*   Container Service for Kubernetes (ACK) cluster: 6.8.13\\_with_community', example='6.8.5_with_community'),
    status?: string(name='status', description='The status of the shipper. Valid values: activating and active.', example='active'),
    vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) where the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
  }(name='Result', description='The returned result.'),
}

model UpdateCollectorNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCollectorNameResponseBody(name='body'),
}

async function updateCollectorNameWithOptions(ResId: string, request: UpdateCollectorNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCollectorNameResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateCollectorName',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/rename`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCollectorName(ResId: string, request: UpdateCollectorNameRequest): UpdateCollectorNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCollectorNameWithOptions(ResId, request, headers, runtime);
}

model UpdateComponentIndexRequest {
  meta?: map[string]any(name='_meta', example='{ "description": "set number of shards to one" }'),
  template?: {
    aliases?: map[string]any(name='aliases', example='{}'),
    mappings?: map[string]any(name='mappings', example='{ "properties": { "@timestamp": { "type": "date" } } }'),
    settings?: map[string]any(name='settings', example='{ "index.number_of_replicas": 0 }'),
  }(name='template'),
}

model UpdateComponentIndexResponseBody = {
  requestId?: string(name='requestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
}

model UpdateComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateComponentIndexResponseBody(name='body'),
}

async function updateComponentIndexWithOptions(InstanceId: string, name: string, request: UpdateComponentIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateComponentIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meta)) {
    body['_meta'] = request.meta;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateComponentIndex(InstanceId: string, name: string, request: UpdateComponentIndexRequest): UpdateComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateComponentIndexWithOptions(InstanceId, name, request, headers, runtime);
}

model UpdateDescriptionRequest {
  description?: string(name='description', example='aliyunes_name_test'),
  clientToken?: string(name='clientToken', description='The new name of the instance.', example='5A2CFF0E-5718-45B5-9D4D-70B350****'),
}

model UpdateDescriptionResponseBody = {
  requestId?: string(name='RequestId', example='FDF34727-1664-44C1-A8DA-3EB72D60****'),
  result?: {
    description?: string(name='description', example='aliyunes_test_name'),
  }(name='Result'),
}

model UpdateDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDescriptionResponseBody(name='body'),
}

async function updateDescriptionWithOptions(InstanceId: string, request: UpdateDescriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDescriptionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDescription',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/description`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDescription(InstanceId: string, request: UpdateDescriptionRequest): UpdateDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDescriptionWithOptions(InstanceId, request, headers, runtime);
}

model UpdateDiagnosisSettingsRequest {
  clientToken?: string(name='ClientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
  lang?: string(name='lang', description='The language of the response. Default value: en.', example='en'),
}

model UpdateDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: update successfully
*   false: update failed', example='true'),
}

model UpdateDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDiagnosisSettingsResponseBody(name='body'),
}

async function updateDiagnosisSettingsWithOptions(InstanceId: string, request: UpdateDiagnosisSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDiagnosisSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateDiagnosisSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/settings`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDiagnosisSettings(InstanceId: string, request: UpdateDiagnosisSettingsRequest): UpdateDiagnosisSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateDictRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateDictResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='2782602'),
      name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='ORIGIN'),
      type?: string(name='type', description='The dictionary type. Valid values:

*   MAIN: IK main dicrionary
*   STOP: IK stopword list', example='MAIN'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateDictResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDictResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following items:
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
  * @param request UpdateDictRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateDictResponse
 */
async function updateDictWithOptions(InstanceId: string, request: UpdateDictRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDictResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateDict',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, take note of the following items:
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
  * @param request UpdateDictRequest
  * @return UpdateDictResponse
 */
async function updateDict(InstanceId: string, request: UpdateDictRequest): UpdateDictResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDictWithOptions(InstanceId, request, headers, runtime);
}

model UpdateDynamicSettingsRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  body?: string(name='body'),
  mode?: string(name='mode'),
}

model UpdateDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateDynamicSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDynamicSettingsResponseBody(name='body'),
}

async function updateDynamicSettingsWithOptions(InstanceId: string, request: UpdateDynamicSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDynamicSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.mode)) {
    query['mode'] = request.mode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateDynamicSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dynamic-settings`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDynamicSettings(InstanceId: string, request: UpdateDynamicSettingsRequest): UpdateDynamicSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDynamicSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateExtendConfigRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateExtendConfigResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', example='true'),
}

model UpdateExtendConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExtendConfigResponseBody(name='body'),
}

async function updateExtendConfigWithOptions(InstanceId: string, request: UpdateExtendConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExtendConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateExtendConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/extend-configs/actions/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateExtendConfig(InstanceId: string, request: UpdateExtendConfigRequest): UpdateExtendConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExtendConfigWithOptions(InstanceId, request, headers, runtime);
}

model UpdateExtendfilesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateExtendfilesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the driver file. Unit: byte.', example='1853083'),
      name?: string(name='name', description='The name of the driver file.', example='mysql-connector-java-6.0.2.jar'),
      sourceType?: string(name='sourceType', description='The source of the driver file. This parameter is fixed as ORIGIN, which indicates that the driver file is retained.', example='ORIGIN'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExtendfilesResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items: You can call this operation only to delete the driver files that are uploaded to a Logstash cluster in the Alibaba Cloud Management Console. You can add or modify driver files only in the Alibaba Cloud Management Console.
  *
  * @param request UpdateExtendfilesRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateExtendfilesResponse
 */
async function updateExtendfilesWithOptions(InstanceId: string, request: UpdateExtendfilesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExtendfilesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateExtendfiles',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/extendfiles`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items: You can call this operation only to delete the driver files that are uploaded to a Logstash cluster in the Alibaba Cloud Management Console. You can add or modify driver files only in the Alibaba Cloud Management Console.
  *
  * @param request UpdateExtendfilesRequest
  * @return UpdateExtendfilesResponse
 */
async function updateExtendfiles(InstanceId: string, request: UpdateExtendfilesRequest): UpdateExtendfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExtendfilesWithOptions(InstanceId, request, headers, runtime);
}

model UpdateHotIkDictsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateHotIkDictsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='6'),
      name?: string(name='name', description='The name of the dictionary file.', example='deploy_0.dic'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='OSS'),
      type?: string(name='type', description='The type of the dictionaries. Valid values:

*   MAIN: IK main dictionary
*   STOP: IK stopword list', example='MAIN'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateHotIkDictsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHotIkDictsResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following items:
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
  * @param request UpdateHotIkDictsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateHotIkDictsResponse
 */
async function updateHotIkDictsWithOptions(InstanceId: string, request: UpdateHotIkDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateHotIkDictsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateHotIkDicts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ik-hot-dict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, take note of the following items:
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
  * @param request UpdateHotIkDictsRequest
  * @return UpdateHotIkDictsResponse
 */
async function updateHotIkDicts(InstanceId: string, request: UpdateHotIkDictsRequest): UpdateHotIkDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHotIkDictsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateILMPolicyRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='my-policy'),
}

model UpdateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateILMPolicyResponseBody(name='body'),
}

async function updateILMPolicyWithOptions(InstanceId: string, PolicyName: string, request: UpdateILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateILMPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies/${OpenApiUtil.getEncodeParam(PolicyName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateILMPolicy(InstanceId: string, PolicyName: string, request: UpdateILMPolicyRequest): UpdateILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateILMPolicyWithOptions(InstanceId, PolicyName, request, headers, runtime);
}

model UpdateIndexTemplateRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='my-template'),
}

model UpdateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIndexTemplateResponseBody(name='body'),
}

async function updateIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, request: UpdateIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIndexTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates/${OpenApiUtil.getEncodeParam(IndexTemplate)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIndexTemplate(InstanceId: string, IndexTemplate: string, request: UpdateIndexTemplateRequest): UpdateIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIndexTemplateWithOptions(InstanceId, IndexTemplate, request, headers, runtime);
}

model UpdateInstanceRequest {
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  instanceCategory?: string(name='instanceCategory', example='advanced'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  nodeAmount?: int32(name='nodeAmount', example='3'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  clientToken?: string(name='clientToken', description='The result of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  force?: boolean(name='force', example='false'),
  orderActionType?: string(name='orderActionType', description='The number of data nodes.', example='upgrade'),
}

model UpdateInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='The time when the instance was created.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    createdAt?: string(name='createdAt', description='The private domain name of the instance.', example='2018-07-13T03:58:07.253Z'),
    description?: string(name='description', description='The configuration of data nodes.', example='test'),
    domain?: string(name='domain', description='The ID of the instance.', example='es-cn-abc.elasticsearch.aliyuncs.com'),
    esVersion?: string(name='esVersion', description='The node specifications.', example='5.5.3_with_X-Pack'),
    instanceId?: string(name='instanceId', description='The storage space of the node. Unit: GB.', example='es-cn-abc'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', description='The configuration of dedicated master nodes.', example='1'),
      disk?: int32(name='disk', description='The node specifications.', example='20'),
      diskType?: string(name='diskType', description='The number of nodes.', example='cloud_ssd'),
      spec?: string(name='spec', description='The storage type of the node. This parameter can be ignored.', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration', description='The size of the node storage space.'),
    masterConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='20'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      spec?: string(name='spec', description='The storage type of the node. Only cloud_ssd(SSD cloud disk) is supported.', example='elasticsearch.sn2ne.large'),
    }(name='masterConfiguration', description='The storage space of the node. Unit: GB.'),
    nodeAmount?: int32(name='nodeAmount', description='The billing method of the instance. Valid values:

*   prepaid: subscription
*   postpaid: pay-as-you-go', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='The node specifications.', example='40'),
      diskType?: string(name='diskType', description='The number of nodes.', example='cloud_ssd'),
      spec?: string(name='spec', description='The configuration of Kibana nodes.', example='elasticsearch.sn2ne.xlarge'),
    }(name='nodeSpec', description='The storage type of the node. Valid values:

*   cloud_ssd: standard SSD
*   cloud_efficiency: ultra disk'),
    paymentType?: string(name='paymentType', description='The edition of the dedicated KMS instance.', example='postpaid'),
    status?: string(name='status', description='The name of the instance.', example='active'),
  }(name='Result', description='The state of the instance. Valid values:

*   active: normal
*   activating: taking effect
*   inactive: frozen
*   invalid: invalid'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceResponseBody(name='body'),
}

/**
  * es-cn-n6w1ptcb30009\\*\\*\\*\\*
  *
  * @param request UpdateInstanceRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateInstanceResponse
 */
async function updateInstanceWithOptions(InstanceId: string, request: UpdateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }
  if (!Util.isUnset(request.orderActionType)) {
    query['orderActionType'] = request.orderActionType;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.clientNodeConfiguration)) {
    body['clientNodeConfiguration'] = request.clientNodeConfiguration;
  }
  if (!Util.isUnset(request.elasticDataNodeConfiguration)) {
    body['elasticDataNodeConfiguration'] = request.elasticDataNodeConfiguration;
  }
  if (!Util.isUnset(request.instanceCategory)) {
    body['instanceCategory'] = request.instanceCategory;
  }
  if (!Util.isUnset(request.kibanaConfiguration)) {
    body['kibanaConfiguration'] = request.kibanaConfiguration;
  }
  if (!Util.isUnset(request.masterConfiguration)) {
    body['masterConfiguration'] = request.masterConfiguration;
  }
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }
  if (!Util.isUnset(request.warmNodeConfiguration)) {
    body['warmNodeConfiguration'] = request.warmNodeConfiguration;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * es-cn-n6w1ptcb30009\\*\\*\\*\\*
  *
  * @param request UpdateInstanceRequest
  * @return UpdateInstanceResponse
 */
async function updateInstance(InstanceId: string, request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceWithOptions(InstanceId, request, headers, runtime);
}

model UpdateInstanceChargeTypeRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateInstanceChargeTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: boolean(name='Result', description='Return results:

*   true: conversion successful
*   false: conversion failed', example='true'),
}

model UpdateInstanceChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceChargeTypeResponseBody(name='body'),
}

async function updateInstanceChargeTypeWithOptions(InstanceId: string, request: UpdateInstanceChargeTypeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceChargeTypeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceChargeType',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/convert-pay-type`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInstanceChargeType(InstanceId: string, request: UpdateInstanceChargeTypeRequest): UpdateInstanceChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceChargeTypeWithOptions(InstanceId, request, headers, runtime);
}

model UpdateInstanceSettingsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateInstanceSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BB1C321A-211C-4FD7-BD8B-7F2FABE2****'),
}

model UpdateInstanceSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceSettingsResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * When the instance is in the activating, invalid, or inactive state, you cannot update the configuration.
  *
  * @param request UpdateInstanceSettingsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateInstanceSettingsResponse
 */
async function updateInstanceSettingsWithOptions(InstanceId: string, request: UpdateInstanceSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/instance-settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items:
  * When the instance is in the activating, invalid, or inactive state, you cannot update the configuration.
  *
  * @param request UpdateInstanceSettingsRequest
  * @return UpdateInstanceSettingsResponse
 */
async function updateInstanceSettings(InstanceId: string, request: UpdateInstanceSettingsRequest): UpdateInstanceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateKibanaSettingsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='This parameter is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B350****'),
}

model UpdateKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC*****'),
  result?: boolean(name='Result', description='Return results:

*   true: The Kibana language modified successfully
*   false: The Kibana language modified failed', example='true'),
}

model UpdateKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateKibanaSettingsResponseBody(name='body'),
}

async function updateKibanaSettingsWithOptions(InstanceId: string, request: UpdateKibanaSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateKibanaSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateKibanaSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-kibana-settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateKibanaSettings(InstanceId: string, request: UpdateKibanaSettingsRequest): UpdateKibanaSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateKibanaSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateKibanaWhiteIpsRequest {
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist', description='The IP address whitelists. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.

You cannot configure both the kibanaIPWhitelist and whiteIpGroup parameters.'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='The type of the whitelist. Set the value to PUBLIC_KIBANA. This value indicates a public IP address whitelist.', example='test_group_name'),
    ips?: [ string ](name='ips', description='The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
    whiteIpType?: string(name='whiteIpType', description='The IP addresses in the whitelist.', example='PUBLIC_KIBANA'),
  }(name='whiteIpGroup', description='The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  clientToken?: string(name='clientToken', description='The update mode. Valid values:

*   Cover: overwrites the IP addresses in the specified IP address whitelist with the IP addresses specified by using the ips parameter. This is the default value.
*   Append: adds the IP addresses specified by using the ips parameter to the specified IP address whitelist.
*   Delete: deletes the IP addresses specified by using the ips parameter from the specified IP address whitelist. At least one IP address must be retained for the whitelist.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  modifyMode?: string(name='modifyMode', description='The body of the request.', example='Cover'),
}

model UpdateKibanaWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', description='The details of the Elasticsearch cluster.', example='E5EF11F1-DBAE-4020-AC24-DFA6C4345CAE'),
  result?: {
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist', description='The public IP address whitelists for access to the Kibana console of the cluster.'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist', description='The private IP address whitelists for access to the Kibana console of the cluster.'),
    networkConfig?: {
      type?: string(name='type', description='The IP address whitelists.', example='vpc'),
      vpcId?: string(name='vpcId', description='The ID of the vSwitch.', example='vpc-bp1jy348ibzulk6hn****'),
      vsArea?: string(name='vsArea', description='The network type.', example='cn-hangzhou-h'),
      vswitchId?: string(name='vswitchId', description='The region ID.', example='vsw-bp1a0mifpletdd1da****'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName', description='The IP addresses in the whitelist.', example='test_group_name'),
          ips?: [ string ](name='ips', description='The IP addresses in the whitelist.'),
          whiteIpType?: string(name='whiteIpType', example='PUBLIC_KIBANA'),
        }
      ](name='whiteIpGroupList', description='The IP address whitelists.'),
    }(name='networkConfig', description='The ID of the virtual private cloud (VPC).'),
  }(name='Result', description='The private IP address whitelists for access to the Kibana console of the cluster.'),
}

model UpdateKibanaWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateKibanaWhiteIpsResponseBody(name='body'),
}

/**
  * *   Before you call this operation, you must make sure that the cluster is not in the activating, invalid, or inactive state.
  * *   You can update an IP address whitelist by using the following parameters:
  *     *   kibanaIPWhitelist
  *     *   modifyMode and whiteIpGroup
  * *   You cannot specify private IP addresses for public IP address whitelists and cannot specify public IP addresses for private IP address whitelists.
  *
  * @param request UpdateKibanaWhiteIpsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateKibanaWhiteIpsResponse
 */
async function updateKibanaWhiteIpsWithOptions(InstanceId: string, request: UpdateKibanaWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateKibanaWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.kibanaIPWhitelist)) {
    body['kibanaIPWhitelist'] = request.kibanaIPWhitelist;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body['whiteIpGroup'] = request.whiteIpGroup;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateKibanaWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Before you call this operation, you must make sure that the cluster is not in the activating, invalid, or inactive state.
  * *   You can update an IP address whitelist by using the following parameters:
  *     *   kibanaIPWhitelist
  *     *   modifyMode and whiteIpGroup
  * *   You cannot specify private IP addresses for public IP address whitelists and cannot specify public IP addresses for private IP address whitelists.
  *
  * @param request UpdateKibanaWhiteIpsRequest
  * @return UpdateKibanaWhiteIpsResponse
 */
async function updateKibanaWhiteIps(InstanceId: string, request: UpdateKibanaWhiteIpsRequest): UpdateKibanaWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateKibanaWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateLogstashRequest {
  nodeAmount?: int32(name='nodeAmount', example='3'),
  nodeSpec?: {
    disk?: int32(name='disk', example='20'),
    diskType?: string(name='diskType', example='cloud_efficiency'),
    spec?: string(name='spec', example='elasticsearch.sn1ne.large'),
  }(name='nodeSpec'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateLogstashResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashResponseBody(name='body'),
}

async function updateLogstashWithOptions(InstanceId: string, request: UpdateLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLogstash(InstanceId: string, request: UpdateLogstashRequest): UpdateLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashWithOptions(InstanceId, request, headers, runtime);
}

model UpdateLogstashChargeTypeRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateLogstashChargeTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Indicates whether the billing method of the cluster is switched. Valid values:

*   true: The billing method is switched.
*   false: The billing method fails to be switched.', example='true'),
}

model UpdateLogstashChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashChargeTypeResponseBody(name='body'),
}

async function updateLogstashChargeTypeWithOptions(InstanceId: string, request: UpdateLogstashChargeTypeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashChargeTypeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstashChargeType',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/convert-pay-type`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLogstashChargeType(InstanceId: string, request: UpdateLogstashChargeTypeRequest): UpdateLogstashChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashChargeTypeWithOptions(InstanceId, request, headers, runtime);
}

model UpdateLogstashDescriptionRequest {
  description?: string(name='description'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateLogstashDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    description?: string(name='description', description='The name of the cluster.', example='logstash_name'),
  }(name='Result', description='The result returned.'),
}

model UpdateLogstashDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashDescriptionResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items: You cannot change the name of a cluster that is in the activating, invalid, or inactive state.
  *
  * @param request UpdateLogstashDescriptionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLogstashDescriptionResponse
 */
async function updateLogstashDescriptionWithOptions(InstanceId: string, request: UpdateLogstashDescriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashDescriptionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstashDescription',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/description`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items: You cannot change the name of a cluster that is in the activating, invalid, or inactive state.
  *
  * @param request UpdateLogstashDescriptionRequest
  * @return UpdateLogstashDescriptionResponse
 */
async function updateLogstashDescription(InstanceId: string, request: UpdateLogstashDescriptionRequest): UpdateLogstashDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashDescriptionWithOptions(InstanceId, request, headers, runtime);
}

model UpdateLogstashSettingsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateLogstashSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='71D0D1DA-B22F-58CB-AF5B-D1657A6A****'),
}

model UpdateLogstashSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashSettingsResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * If the instance is in the Active (activating), Invalid (invalid), and Inactive (inactive) state, the information cannot be updated.
  *
  * @param request UpdateLogstashSettingsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLogstashSettingsResponse
 */
async function updateLogstashSettingsWithOptions(InstanceId: string, request: UpdateLogstashSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstashSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/instance-settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items:
  * If the instance is in the Active (activating), Invalid (invalid), and Inactive (inactive) state, the information cannot be updated.
  *
  * @param request UpdateLogstashSettingsRequest
  * @return UpdateLogstashSettingsResponse
 */
async function updateLogstashSettings(InstanceId: string, request: UpdateLogstashSettingsRequest): UpdateLogstashSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePipelineManagementConfigRequest {
  endpoints?: [ string ](name='endpoints'),
  password?: string(name='password', example='******'),
  pipelineIds?: [ string ](name='pipelineIds'),
  pipelineManagementType?: string(name='pipelineManagementType', example='ES'),
  userName?: string(name='userName', example='elastic'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdatePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdatePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelineManagementConfigResponseBody(name='body'),
}

async function updatePipelineManagementConfigWithOptions(InstanceId: string, request: UpdatePipelineManagementConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePipelineManagementConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.endpoints)) {
    body['endpoints'] = request.endpoints;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.pipelineIds)) {
    body['pipelineIds'] = request.pipelineIds;
  }
  if (!Util.isUnset(request.pipelineManagementType)) {
    body['pipelineManagementType'] = request.pipelineManagementType;
  }
  if (!Util.isUnset(request.userName)) {
    body['userName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipelineManagementConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipeline-management-config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePipelineManagementConfig(InstanceId: string, request: UpdatePipelineManagementConfigRequest): UpdatePipelineManagementConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePipelinesRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  trigger?: boolean(name='trigger', description='Specifies whether to deploy the pipeline immediately.', example='false'),
}

model UpdatePipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Indicates whether the pipeline is updated. Valid values:

*   true: The pipeline is updated.
*   false: The pipeline fails to be updated.', example='true'),
}

model UpdatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelinesResponseBody(name='body'),
}

async function updatePipelinesWithOptions(InstanceId: string, request: UpdatePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePipelines(InstanceId: string, request: UpdatePipelinesRequest): UpdatePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePipelinesWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePrivateNetworkWhiteIpsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  modifyMode?: string(name='modifyMode', description='The results that are returned.', example='Cover'),
}

model UpdatePrivateNetworkWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', example='6DEBE5EE-0368-4757-8F82-EF9C3972****'),
  result?: {
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  }(name='Result'),
}

model UpdatePrivateNetworkWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePrivateNetworkWhiteIpsResponseBody(name='body'),
}

/**
  * >  In the following returned example, only the parameters in the returned data list are guaranteed to be included, and the parameters not mentioned are for reference only. For more information about the parameters, see [ListInstance](~~142230~~). You cannot force a dependency in a program to get these parameters.
  *
  * @param request UpdatePrivateNetworkWhiteIpsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdatePrivateNetworkWhiteIpsResponse
 */
async function updatePrivateNetworkWhiteIpsWithOptions(InstanceId: string, request: UpdatePrivateNetworkWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePrivateNetworkWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePrivateNetworkWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/private-network-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  In the following returned example, only the parameters in the returned data list are guaranteed to be included, and the parameters not mentioned are for reference only. For more information about the parameters, see [ListInstance](~~142230~~). You cannot force a dependency in a program to get these parameters.
  *
  * @param request UpdatePrivateNetworkWhiteIpsRequest
  * @return UpdatePrivateNetworkWhiteIpsResponse
 */
async function updatePrivateNetworkWhiteIps(InstanceId: string, request: UpdatePrivateNetworkWhiteIpsRequest): UpdatePrivateNetworkWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePrivateNetworkWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePublicNetworkRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdatePublicNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2A88ECA1-D827-4581-AD39-05149586****'),
  result?: {
    enablePublic?: boolean(name='enablePublic', description='The status of the public network access switch.', example='false'),
  }(name='Result', description='The return results.'),
}

model UpdatePublicNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicNetworkResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following items:
  * When the instance is in the activating, invalid, or inactive state, its configuration cannot be updated.
  *
  * @param request UpdatePublicNetworkRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdatePublicNetworkResponse
 */
async function updatePublicNetworkWithOptions(InstanceId: string, request: UpdatePublicNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePublicNetworkResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/public-network`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following items:
  * When the instance is in the activating, invalid, or inactive state, its configuration cannot be updated.
  *
  * @param request UpdatePublicNetworkRequest
  * @return UpdatePublicNetworkResponse
 */
async function updatePublicNetwork(InstanceId: string, request: UpdatePublicNetworkRequest): UpdatePublicNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePublicNetworkWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePublicWhiteIpsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  modifyMode?: string(name='modifyMode', description='The results that are returned.', example='Cover'),
}

model UpdatePublicWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', example='C82758DD-282F-4D48-934F-92170A33****'),
  result?: {
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  }(name='Result'),
}

model UpdatePublicWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicWhiteIpsResponseBody(name='body'),
}

/**
  * >  In the following example, only the parameters in the returned data list are guaranteed to be included. The parameters that are not mentioned are for reference only. For more information about the parameters, see [ListInstance](~~142230~~). You cannot force a dependency in a program to get these parameters.
  *
  * @param request UpdatePublicWhiteIpsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdatePublicWhiteIpsResponse
 */
async function updatePublicWhiteIpsWithOptions(InstanceId: string, request: UpdatePublicWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePublicWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/public-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  In the following example, only the parameters in the returned data list are guaranteed to be included. The parameters that are not mentioned are for reference only. For more information about the parameters, see [ListInstance](~~142230~~). You cannot force a dependency in a program to get these parameters.
  *
  * @param request UpdatePublicWhiteIpsRequest
  * @return UpdatePublicWhiteIpsResponse
 */
async function updatePublicWhiteIps(InstanceId: string, request: UpdatePublicWhiteIpsRequest): UpdatePublicWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePublicWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateReadWritePolicyRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateReadWritePolicyResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateReadWritePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateReadWritePolicyResponseBody(name='body'),
}

async function updateReadWritePolicyWithOptions(InstanceId: string, request: UpdateReadWritePolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateReadWritePolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateReadWritePolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-read-write-policy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateReadWritePolicy(InstanceId: string, request: UpdateReadWritePolicyRequest): UpdateReadWritePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateReadWritePolicyWithOptions(InstanceId, request, headers, runtime);
}

model UpdateSnapshotSettingRequest {
  body?: string(name='body'),
}

model UpdateSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: {
    enable?: boolean(name='enable', description='Specifies whether to enable automatic backup.', example='true'),
    quartzRegex?: string(name='quartzRegex', description='The start time of automatic backup.', example='0 0 01 ? * * *'),
  }(name='Result', description='The return results.'),
}

model UpdateSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSnapshotSettingResponseBody(name='body'),
}

async function updateSnapshotSettingWithOptions(InstanceId: string, request: UpdateSnapshotSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSnapshotSettingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateSnapshotSetting',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-setting`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSnapshotSetting(InstanceId: string, request: UpdateSnapshotSettingRequest): UpdateSnapshotSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSnapshotSettingWithOptions(InstanceId, request, headers, runtime);
}

model UpdateSynonymsDictsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateSynonymsDictsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7C5622CC-B312-426F-85AA-B0271*******'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='220'),
      name?: string(name='name', description='The name of the dictionary file.', example='deploy_0.txt'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='OSS'),
      type?: string(name='type', description='The dictionary type. The value is fixed as SYNONYMS.', example='SYNONYMS'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateSynonymsDictsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSynonymsDictsResponseBody(name='body'),
}

/**
  * Before you call this operation, take note of the following items:
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
  * @param request UpdateSynonymsDictsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateSynonymsDictsResponse
 */
async function updateSynonymsDictsWithOptions(InstanceId: string, request: UpdateSynonymsDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSynonymsDictsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateSynonymsDicts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/synonymsDict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, take note of the following items:
  * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
  * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
  *
  * @param request UpdateSynonymsDictsRequest
  * @return UpdateSynonymsDictsResponse
 */
async function updateSynonymsDicts(InstanceId: string, request: UpdateSynonymsDictsRequest): UpdateSynonymsDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSynonymsDictsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateTemplateRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body', example='{     "content": "{\\n\\t\\"persistent\\":{\\n\\t\\t\\"search\\":{\\n\\t\\t\\t\\"max_buckets\\":\\"10000\\"\\n\\t\\t}\\n\\t}\\n}" }'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplateWithOptions(InstanceId: string, TemplateName: string, request: UpdateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/templates/${OpenApiUtil.getEncodeParam(TemplateName)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTemplate(InstanceId: string, TemplateName: string, request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTemplateWithOptions(InstanceId, TemplateName, request, headers, runtime);
}

model UpdateWhiteIpsRequest {
  esIPWhitelist?: [ string ](name='esIPWhitelist', description='The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='The type of the whitelist. Set the value to **PRIVATE_ES**. This value indicates a private IP address whitelist.', example='test_group'),
    ips?: [ string ](name='ips', description='The returned result.'),
    whiteIpType?: string(name='whiteIpType', description='The returned result.', example='PRIVATE_ES'),
  }(name='whiteIpGroup', description='The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  clientToken?: string(name='clientToken', description='The IP addresses in the whitelist.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  modifyMode?: string(name='modifyMode', description='The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.

>  You cannot configure both the esIPWhitelist and whiteIpGroup parameters.', example='Cover'),
}

model UpdateWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', description='The updated whitelist.', example='8D58B014-BBD7-4D80-B219-00B9D5C6860C'),
  result?: {
    esIPWhitelist?: [ string ](name='esIPWhitelist', description='The list of whitelists.'),
    networkConfig?: {
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName', description='The type of the whitelist. The value of this parameter is fixed as PRIVATE_ES, which indicates a private IP address whitelist.', example='test_group'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType', example='PRIVATE_ES'),
        }
      ](name='whiteIpGroupList', description='The IP addresses in the whitelist.'),
    }(name='networkConfig', description='The name of the whitelist. By default, the default whitelist is included.'),
  }(name='Result', description='The network configurations.'),
}

model UpdateWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWhiteIpsResponseBody(name='body'),
}

/**
  * > For more information about the parameters displayed in the following sample code but not provided in the preceding tables, see [ListInstance](~~142230~~). You cannot force your program to obtain these parameters.
  *
  * @param request UpdateWhiteIpsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateWhiteIpsResponse
 */
async function updateWhiteIpsWithOptions(InstanceId: string, request: UpdateWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.esIPWhitelist)) {
    body['esIPWhitelist'] = request.esIPWhitelist;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body['whiteIpGroup'] = request.whiteIpGroup;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > For more information about the parameters displayed in the following sample code but not provided in the preceding tables, see [ListInstance](~~142230~~). You cannot force your program to obtain these parameters.
  *
  * @param request UpdateWhiteIpsRequest
  * @return UpdateWhiteIpsResponse
 */
async function updateWhiteIps(InstanceId: string, request: UpdateWhiteIpsRequest): UpdateWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateXpackMonitorConfigRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  enable?: boolean(name='enable', example='true'),
  endpoints?: [ string ](name='endpoints'),
  password?: string(name='password', example='******'),
  userName?: string(name='userName', example='elastic'),
}

model UpdateXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', example='true'),
}

model UpdateXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateXpackMonitorConfigResponseBody(name='body'),
}

async function updateXpackMonitorConfigWithOptions(InstanceId: string, request: UpdateXpackMonitorConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateXpackMonitorConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!Util.isUnset(request.endpoints)) {
    body['endpoints'] = request.endpoints;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    body['userName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateXpackMonitorConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/xpack-monitor-config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateXpackMonitorConfig(InstanceId: string, request: UpdateXpackMonitorConfigRequest): UpdateXpackMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateXpackMonitorConfigWithOptions(InstanceId, request, headers, runtime);
}

model UpgradeEngineVersionRequest {
  type?: string(name='type', example='engineVersion'),
  version?: string(name='version', example='6.7'),
  clientToken?: string(name='clientToken', description='The moderation results.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  dryRun?: boolean(name='dryRun', description='The monitoring type. Valid values:

*   checkClusterHealth: Cluster Health Status
*   checkConfigCompatible: Configuration Compatibility Status
*   checkClusterResource: resource space status
*   checkClusterSnapshot: Whether a snapshot exists', example='false'),
}

model UpgradeEngineVersionResponseBody = {
  requestId?: string(name='RequestId', description='The verification information.', example='F99407AB-2FA9-489E-A259-40CF6DC*****'),
  result?: [ 
    {
      status?: string(name='status', example='success'),
      validateResult?: [ 
        {
          errorCode?: string(name='errorCode', example='ClusterStatusNotHealth'),
          errorMsg?: string(name='errorMsg', example='The cluster status is not health'),
          errorType?: string(name='errorType', description='The verification is passed. Valid values:

*   success: through
*   failed: failed', example='clusterStatus'),
        }
      ](name='validateResult', description='The error message returned.'),
      validateType?: string(name='validateType', description='The error code returned if the request failed.', example='checkClusterHealth'),
    }
  ](name='Result', description='The type of the error. Valid values:

*   clusterStatus: the health status of the cluster.
*   clusterConfigYml: Cluster YML File
*   clusterConfigPlugins: Cluster Configuration File
*   clusterResource: cluster resources
*   clusterSnapshot: cluster snapshot'),
}

model UpgradeEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeEngineVersionResponseBody(name='body'),
}

/**
  * 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
  *
  * @param request UpgradeEngineVersionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpgradeEngineVersionResponse
 */
async function upgradeEngineVersionWithOptions(InstanceId: string, request: UpgradeEngineVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpgradeEngineVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeEngineVersion',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/upgrade-version`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
  *
  * @param request UpgradeEngineVersionRequest
  * @return UpgradeEngineVersionResponse
 */
async function upgradeEngineVersion(InstanceId: string, request: UpgradeEngineVersionRequest): UpgradeEngineVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeEngineVersionWithOptions(InstanceId, request, headers, runtime);
}

model ValidateConnectionRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model ValidateConnectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='Indicates whether the connectivity is normal. Valid values:

*   true
*   false', example='true'),
}

model ValidateConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateConnectionResponseBody(name='body'),
}

/**
  * > Before you enable the X-Pack Monitoring feature for a Logstash cluster, you must associate the Logstash cluster with an Elasticsearch cluster. This way, you can view the monitoring data of the Logstash cluster in the Kibana console of the Elasticsearch cluster.
  *
  * @param request ValidateConnectionRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ValidateConnectionResponse
 */
async function validateConnectionWithOptions(InstanceId: string, request: ValidateConnectionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateConnectionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ValidateConnection',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/validate-connection`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > Before you enable the X-Pack Monitoring feature for a Logstash cluster, you must associate the Logstash cluster with an Elasticsearch cluster. This way, you can view the monitoring data of the Logstash cluster in the Kibana console of the Elasticsearch cluster.
  *
  * @param request ValidateConnectionRequest
  * @return ValidateConnectionResponse
 */
async function validateConnection(InstanceId: string, request: ValidateConnectionRequest): ValidateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateConnectionWithOptions(InstanceId, request, headers, runtime);
}

model ValidateShrinkNodesRequest {
  body?: [ 
    {
      host?: string(name='host', example='192.168.xx.xx'),
      hostName?: string(name='hostName', example='es-cn-pl32xxxxxxx-data-f-1'),
      nodeType?: string(name='nodeType', example='WORKER'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body'),
  count?: int32(name='count', example='2'),
  ignoreStatus?: boolean(name='ignoreStatus', description='The ID of the request.', example='false'),
  nodeType?: string(name='nodeType', description='Returned results:

*   true: can be scaled in
*   false: cannot be scaled in.', example='WORKER'),
}

model ValidateShrinkNodesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model ValidateShrinkNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateShrinkNodesResponseBody(name='body'),
}

async function validateShrinkNodesWithOptions(InstanceId: string, request: ValidateShrinkNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateShrinkNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query['ignoreStatus'] = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateShrinkNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/validate-shrink-nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validateShrinkNodes(InstanceId: string, request: ValidateShrinkNodesRequest): ValidateShrinkNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateShrinkNodesWithOptions(InstanceId, request, headers, runtime);
}

model ValidateSlrPermissionRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  rolename?: string(name='rolename', example='AliyunServiceRoleForElasticsearchCollector'),
}

model ValidateSlrPermissionResponseBody = {
  requestId?: string(name='RequestId', example='BC4ED7DD-8C84-49B5-8A95-456F82E44D13'),
  result?: boolean(name='Result', example='true'),
}

model ValidateSlrPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateSlrPermissionResponseBody(name='body'),
}

async function validateSlrPermissionWithOptions(request: ValidateSlrPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateSlrPermissionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.rolename)) {
    query['rolename'] = request.rolename;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidateSlrPermission',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/user/servicerolepermission`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validateSlrPermission(request: ValidateSlrPermissionRequest): ValidateSlrPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateSlrPermissionWithOptions(request, headers, runtime);
}

model ValidateTransferableNodesRequest {
  body?: [ 
    {
      host?: string(name='host', example='172.16.xx.xx'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body'),
  nodeType?: string(name='nodeType', example='WORKER'),
}

model ValidateTransferableNodesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model ValidateTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateTransferableNodesResponseBody(name='body'),
}

async function validateTransferableNodesWithOptions(InstanceId: string, request: ValidateTransferableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateTransferableNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateTransferableNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/validate-transfer-nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function validateTransferableNodes(InstanceId: string, request: ValidateTransferableNodesRequest): ValidateTransferableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateTransferableNodesWithOptions(InstanceId, request, headers, runtime);
}

model CreateInstanceRequest {
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration'),
  description?: string(name='description', example='es'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  esAdminPassword?: string(name='esAdminPassword', example='es_password'),
  esVersion?: string(name='esVersion', example='5.5.3_with_X-Pack'),
  instanceCategory?: string(name='instanceCategory', example='advanced'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  networkConfig?: NetworkConfig(name='networkConfig'),
  nodeAmount?: int32(name='nodeAmount', example='3'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  paymentInfo?: PaymentInfo(name='paymentInfo'),
  paymentType?: string(name='paymentType', example='postpaid'),
  resourceGroupId?: string(name='resourceGroupId', example='rg-aekzu7tsu4nem4q'),
  tags?: [ 
    {
      tagKey?: string(name='tagKey'),
      tagValue?: string(name='tagValue'),
    }
  ](name='tags'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  zoneCount?: int32(name='zoneCount', example='2'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * The configurations of warm nodes.
  *
  * @param request CreateInstanceRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateInstanceResponse
 */
async function createInstanceWithOptions(request: CreateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.clientNodeConfiguration)) {
    body['clientNodeConfiguration'] = request.clientNodeConfiguration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.elasticDataNodeConfiguration)) {
    body['elasticDataNodeConfiguration'] = request.elasticDataNodeConfiguration;
  }
  if (!Util.isUnset(request.esAdminPassword)) {
    body['esAdminPassword'] = request.esAdminPassword;
  }
  if (!Util.isUnset(request.esVersion)) {
    body['esVersion'] = request.esVersion;
  }
  if (!Util.isUnset(request.instanceCategory)) {
    body['instanceCategory'] = request.instanceCategory;
  }
  if (!Util.isUnset(request.kibanaConfiguration)) {
    body['kibanaConfiguration'] = request.kibanaConfiguration;
  }
  if (!Util.isUnset(request.masterConfiguration)) {
    body['masterConfiguration'] = request.masterConfiguration;
  }
  if (!Util.isUnset(request.networkConfig)) {
    body['networkConfig'] = request.networkConfig;
  }
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }
  if (!Util.isUnset(request.paymentInfo)) {
    body['paymentInfo'] = request.paymentInfo;
  }
  if (!Util.isUnset(request.paymentType)) {
    body['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.warmNodeConfiguration)) {
    body['warmNodeConfiguration'] = request.warmNodeConfiguration;
  }
  if (!Util.isUnset(request.zoneCount)) {
    body['zoneCount'] = request.zoneCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'createInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
  * The configurations of warm nodes.
  *
  * @param request CreateInstanceRequest
  * @return CreateInstanceResponse
 */
async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createInstanceWithOptions(request, headers, runtime);
}

