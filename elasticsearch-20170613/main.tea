/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('elasticsearch', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ClientNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskType?: string(name='diskType'),
  spec?: string(name='spec'),
}

model DictInfo {
  fileSize?: long(name='fileSize'),
  name?: string(name='name'),
  sourceType?: string(name='sourceType'),
  type?: string(name='type'),
}

model ElasticDataNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec?: string(name='spec'),
}

model Elasticsearch {
  advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
  advancedSetting?: {
    gcName?: string(name='gcName'),
  }(name='advancedSetting'),
  aliwsDicts?: [
    DictInfo
  ](name='aliwsDicts'),
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration'),
  createdAt?: string(name='createdAt'),
  dataNode?: boolean(name='dataNode'),
  dedicateMaster?: boolean(name='dedicateMaster'),
  description?: string(name='description'),
  dictList?: [
    DictInfo
  ](name='dictList'),
  domain?: string(name='domain'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork'),
  enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork'),
  enablePublic?: boolean(name='enablePublic'),
  endTime?: long(name='endTime'),
  esConfig?: map[string]string(name='esConfig'),
  esIPWhitelist?: [ string ](name='esIPWhitelist'),
  esVersion?: string(name='esVersion'),
  extendConfigs?: [  map[string]any ](name='extendConfigs'),
  haveClientNode?: boolean(name='haveClientNode'),
  haveElasticDataNode?: boolean(name='haveElasticDataNode'),
  haveKibana?: boolean(name='haveKibana'),
  ikHotDicts?: [
    DictInfo
  ](name='ikHotDicts'),
  instanceId?: string(name='instanceId'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  kibanaDomain?: string(name='kibanaDomain'),
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
  kibanaPort?: long(name='kibanaPort'),
  kibanaPrivateDomain?: string(name='kibanaPrivateDomain'),
  kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
  kibanaPrivatePort?: long(name='kibanaPrivatePort'),
  kibanaProtocol?: string(name='kibanaProtocol'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  networkConfig?: NetworkConfig(name='networkConfig'),
  nodeAmount?: long(name='nodeAmount'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  paymentType?: string(name='paymentType'),
  port?: long(name='port'),
  privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  productType?: string(name='productType'),
  protocol?: string(name='protocol'),
  publicDomain?: string(name='publicDomain'),
  publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  publicPort?: long(name='publicPort'),
  readWritePolicy?: ReadWritePolicy(name='readWritePolicy'),
  resourceGroupId?: string(name='resourceGroupId'),
  serviceVpc?: boolean(name='serviceVpc'),
  status?: string(name='status'),
  synonymsDicts?: [
    DictInfo
  ](name='synonymsDicts'),
  tags?: [
    Tag
  ](name='tags'),
  updatedAt?: string(name='updatedAt'),
  warmNode?: boolean(name='warmNode'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  zoneCount?: long(name='zoneCount'),
  zoneInfos?: [
    ZoneInfo
  ](name='zoneInfos'),
}

model KibanaNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  spec?: string(name='spec'),
}

model Logstash {
  config?: map[string]string(name='config'),
  createdAt?: string(name='createdAt'),
  dataNode?: boolean(name='dataNode'),
  description?: string(name='description'),
  endTime?: long(name='endTime'),
  endpointList?: [ 
    {
      host?: string(name='host'),
      port?: long(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='endpointList'),
  instanceId?: string(name='instanceId'),
  networkConfig?: {
    type?: string(name='type'),
    vpcId?: string(name='vpcId'),
    vsArea?: string(name='vsArea'),
    vswitchId?: string(name='vswitchId'),
  }(name='networkConfig'),
  nodeAmount?: long(name='nodeAmount'),
  nodeSpec?: {
    disk?: long(name='disk'),
    diskType?: string(name='diskType'),
    spec?: string(name='spec'),
  }(name='nodeSpec'),
  paymentType?: string(name='paymentType'),
  protocol?: string(name='protocol'),
  resourceGroupId?: string(name='resourceGroupId'),
  status?: string(name='status'),
  tags?: [ 
    {
      tagKey?: string(name='tagKey'),
      tagValue?: string(name='tagValue'),
    }
  ](name='tags'),
  updatedAt?: string(name='updatedAt'),
  version?: string(name='version'),
  zoneCount?: long(name='zoneCount'),
  zoneInfos?: [ 
    {
      status?: string(name='status'),
      zoneId?: string(name='zoneId'),
    }
  ](name='zoneInfos'),
}

model MasterNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskType?: string(name='diskType'),
  spec?: string(name='spec'),
}

model NetworkConfig {
  type?: string(name='type'),
  vpcId?: string(name='vpcId'),
  vsArea?: string(name='vsArea'),
  vswitchId?: string(name='vswitchId'),
  whiteIpGroupList?: [
    WhiteIpGroup
  ](name='whiteIpGroupList'),
}

model NodeInfo {
  host?: string(name='host'),
  hostName?: string(name='hostName'),
  port?: long(name='port'),
  zoneId?: string(name='zoneId'),
}

model NodeSpec {
  disk?: int32(name='disk'),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec?: string(name='spec'),
}

model PaymentInfo {
  autoRenewDuration?: long(name='autoRenewDuration'),
  duration?: long(name='duration'),
  isAutoRenew?: boolean(name='isAutoRenew'),
  pricingCycle?: string(name='pricingCycle'),
}

model ReadWritePolicy {
  autoGeneratePk?: boolean(name='autoGeneratePk'),
  writeHa?: boolean(name='writeHa'),
  writePolicy?: string(name='writePolicy'),
}

model Tag {
  tagKey?: string(name='tagKey'),
  tagValue?: string(name='tagValue'),
}

model WarmNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec?: string(name='spec'),
}

model WhiteIpGroup {
  whiteIpType?: string(name='WhiteIpType'),
  groupName?: string(name='groupName'),
  ips?: [ string ](name='ips'),
}

model ZoneInfo {
  status?: string(name='status'),
  zoneId?: string(name='zoneId'),
}

model ActivateZonesRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model ActivateZonesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ActivateZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActivateZonesResponseBody(name='body'),
}

async function activateZones(InstanceId: string, request: ActivateZonesRequest): ActivateZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return activateZonesWithOptions(InstanceId, request, headers, runtime);
}

async function activateZonesWithOptions(InstanceId: string, request: ActivateZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ActivateZonesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ActivateZones',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/recover-zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddConnectableClusterRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model AddConnectableClusterResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model AddConnectableClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddConnectableClusterResponseBody(name='body'),
}

async function addConnectableCluster(InstanceId: string, request: AddConnectableClusterRequest): AddConnectableClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addConnectableClusterWithOptions(InstanceId, request, headers, runtime);
}

async function addConnectableClusterWithOptions(InstanceId: string, request: AddConnectableClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddConnectableClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'AddConnectableCluster',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connected-clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AddSnapshotRepoRequest {
  body?: string(name='body'),
}

model AddSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model AddSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSnapshotRepoResponseBody(name='body'),
}

async function addSnapshotRepo(InstanceId: string, request: AddSnapshotRepoRequest): AddSnapshotRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addSnapshotRepoWithOptions(InstanceId, request, headers, runtime);
}

async function addSnapshotRepoWithOptions(InstanceId: string, request: AddSnapshotRepoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddSnapshotRepoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'AddSnapshotRepo',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-repos`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CancelDeletionRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model CancelDeletionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelDeletionResponseBody(name='body'),
}

async function cancelDeletion(InstanceId: string, request: CancelDeletionRequest): CancelDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelDeletionWithOptions(InstanceId, request, headers, runtime);
}

async function cancelDeletionWithOptions(InstanceId: string, request: CancelDeletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelDeletionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CancelDeletion',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/cancel-deletion`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CancelLogstashDeletionRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model CancelLogstashDeletionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelLogstashDeletionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelLogstashDeletionResponseBody(name='body'),
}

async function cancelLogstashDeletion(InstanceId: string, request: CancelLogstashDeletionRequest): CancelLogstashDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelLogstashDeletionWithOptions(InstanceId, request, headers, runtime);
}

async function cancelLogstashDeletionWithOptions(InstanceId: string, request: CancelLogstashDeletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelLogstashDeletionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CancelLogstashDeletion',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/cancel-deletion`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CancelTaskRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  taskType?: string(name='taskType'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTask(InstanceId: string, request: CancelTaskRequest): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelTaskWithOptions(InstanceId, request, headers, runtime);
}

async function cancelTaskWithOptions(InstanceId: string, request: CancelTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.taskType)) {
    query['taskType'] = request.taskType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CancelTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/cancel-task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CapacityPlanRequest {
  complexQueryAvailable?: boolean(name='complexQueryAvailable'),
  dataInfo?: [ 
    {
      code?: string(name='code'),
      size?: long(name='size'),
      totalCount?: int32(name='totalCount'),
      type?: string(name='type'),
      unit?: string(name='unit'),
    }
  ](name='dataInfo'),
  metric?: [ 
    {
      averageQps?: int32(name='averageQps'),
      code?: string(name='code'),
      concurrent?: long(name='concurrent'),
      peakQps?: int32(name='peakQps'),
      responseTime?: int32(name='responseTime'),
      throughput?: long(name='throughput'),
      type?: string(name='type'),
    }
  ](name='metric'),
  usageScenario?: string(name='usageScenario'),
}

model CapacityPlanResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    extendConfigs?: [ 
      {
        configType?: string(name='ConfigType'),
        disk?: long(name='Disk'),
        diskType?: string(name='DiskType'),
      }
    ](name='ExtendConfigs'),
    instanceCategory?: string(name='InstanceCategory'),
    nodeConfigurations?: [ 
      {
        amount?: long(name='Amount'),
        cpu?: long(name='Cpu'),
        disk?: long(name='Disk'),
        diskType?: string(name='DiskType'),
        memory?: long(name='Memory'),
        nodeType?: string(name='NodeType'),
      }
    ](name='NodeConfigurations'),
    oversizedCluster?: boolean(name='OversizedCluster'),
  }(name='Result'),
}

model CapacityPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CapacityPlanResponseBody(name='body'),
}

async function capacityPlan(request: CapacityPlanRequest): CapacityPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return capacityPlanWithOptions(request, headers, runtime);
}

async function capacityPlanWithOptions(request: CapacityPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CapacityPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.complexQueryAvailable)) {
    body['complexQueryAvailable'] = request.complexQueryAvailable;
  }
  if (!Util.isUnset(request.dataInfo)) {
    body['dataInfo'] = request.dataInfo;
  }
  if (!Util.isUnset(request.metric)) {
    body['metric'] = request.metric;
  }
  if (!Util.isUnset(request.usageScenario)) {
    body['usageScenario'] = request.usageScenario;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CapacityPlan',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/assist/actions/capacity-plan`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CloseDiagnosisRequest {
  clientToken?: string(name='ClientToken'),
  lang?: string(name='lang'),
}

model CloseDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CloseDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseDiagnosisResponseBody(name='body'),
}

async function closeDiagnosis(InstanceId: string, request: CloseDiagnosisRequest): CloseDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeDiagnosisWithOptions(InstanceId, request, headers, runtime);
}

async function closeDiagnosisWithOptions(InstanceId: string, request: CloseDiagnosisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseDiagnosisResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseDiagnosis',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/close-diagnosis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CloseHttpsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model CloseHttpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CloseHttpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseHttpsResponseBody(name='body'),
}

async function closeHttps(InstanceId: string, request: CloseHttpsRequest): CloseHttpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeHttpsWithOptions(InstanceId, request, headers, runtime);
}

async function closeHttpsWithOptions(InstanceId: string, request: CloseHttpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseHttpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CloseHttps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/close-https`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CloseManagedIndexRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model CloseManagedIndexResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CloseManagedIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseManagedIndexResponseBody(name='body'),
}

async function closeManagedIndex(InstanceId: string, Index: string, request: CloseManagedIndexRequest): CloseManagedIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeManagedIndexWithOptions(InstanceId, Index, request, headers, runtime);
}

async function closeManagedIndexWithOptions(InstanceId: string, Index: string, request: CloseManagedIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseManagedIndexResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CloseManagedIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/indices/${OpenApiUtil.getEncodeParam(Index)}/close-managed`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateCollectorRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model CreateCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    resId?: string(name='resId'),
  }(name='Result'),
}

model CreateCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCollectorResponseBody(name='body'),
}

async function createCollector(request: CreateCollectorRequest): CreateCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCollectorWithOptions(request, headers, runtime);
}

async function createCollectorWithOptions(request: CreateCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateComponentIndexRequest {
  meta?: map[string]any(name='_meta'),
  template?: {
    aliases?: map[string]any(name='aliases'),
    mappings?: map[string]any(name='mappings'),
    settings?: map[string]any(name='settings'),
  }(name='template'),
}

model CreateComponentIndexResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CreateComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateComponentIndexResponseBody(name='body'),
}

async function createComponentIndex(InstanceId: string, name: string, request: CreateComponentIndexRequest): CreateComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createComponentIndexWithOptions(InstanceId, name, request, headers, runtime);
}

async function createComponentIndexWithOptions(InstanceId: string, name: string, request: CreateComponentIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateComponentIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meta)) {
    body['_meta'] = request.meta;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDataStreamRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model CreateDataStreamResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    name?: string(name='name'),
  }(name='Result'),
}

model CreateDataStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataStreamResponseBody(name='body'),
}

async function createDataStream(InstanceId: string, request: CreateDataStreamRequest): CreateDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDataStreamWithOptions(InstanceId, request, headers, runtime);
}

async function createDataStreamWithOptions(InstanceId: string, request: CreateDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDataStreamResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateDataStream',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDataTasksRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model CreateDataTasksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        index?: string(name='index'),
        mapping?: string(name='mapping'),
        password?: string(name='password'),
        routing?: string(name='routing'),
        settings?: string(name='settings'),
        type?: string(name='type'),
        username?: string(name='username'),
        vpcId?: string(name='vpcId'),
        vpcInstanceId?: string(name='vpcInstanceId'),
        vpcInstancePort?: string(name='vpcInstancePort'),
      }(name='sinkCluster'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        endpoint?: string(name='endpoint'),
        index?: string(name='index'),
        password?: string(name='password'),
        type?: string(name='type'),
        username?: string(name='username'),
        vpcId?: string(name='vpcId'),
        vpcInstanceId?: string(name='vpcInstanceId'),
        vpcInstancePort?: int32(name='vpcInstancePort'),
      }(name='sourceCluster'),
    }
  ](name='Result'),
}

model CreateDataTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataTasksResponseBody(name='body'),
}

async function createDataTasks(InstanceId: string, request: CreateDataTasksRequest): CreateDataTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDataTasksWithOptions(InstanceId, request, headers, runtime);
}

async function createDataTasksWithOptions(InstanceId: string, request: CreateDataTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDataTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateDataTasks',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateILMPolicyRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model CreateILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateILMPolicyResponseBody(name='body'),
}

async function createILMPolicy(InstanceId: string, request: CreateILMPolicyRequest): CreateILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createILMPolicyWithOptions(InstanceId, request, headers, runtime);
}

async function createILMPolicyWithOptions(InstanceId: string, request: CreateILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateILMPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateIndexTemplateRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model CreateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIndexTemplateResponseBody(name='body'),
}

async function createIndexTemplate(InstanceId: string, request: CreateIndexTemplateRequest): CreateIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexTemplateWithOptions(InstanceId, request, headers, runtime);
}

async function createIndexTemplateWithOptions(InstanceId: string, request: CreateIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateLogstashRequest {
  description?: string(name='description'),
  networkConfig?: {
    type?: string(name='type'),
    vpcId?: string(name='vpcId'),
    vsArea?: string(name='vsArea'),
    vswitchId?: string(name='vswitchId'),
  }(name='networkConfig'),
  nodeAmount?: int32(name='nodeAmount'),
  nodeSpec?: {
    disk?: long(name='disk'),
    diskType?: string(name='diskType'),
    spec?: string(name='spec'),
  }(name='nodeSpec'),
  paymentInfo?: {
    autoRenewDuration?: long(name='autoRenewDuration'),
    duration?: long(name='duration'),
    isAutoRenew?: boolean(name='isAutoRenew'),
    pricingCycle?: string(name='pricingCycle'),
  }(name='paymentInfo'),
  paymentType?: string(name='paymentType'),
  version?: string(name='version'),
  clientToken?: string(name='clientToken'),
}

model CreateLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: Logstash(name='Result'),
}

model CreateLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLogstashResponseBody(name='body'),
}

async function createLogstash(request: CreateLogstashRequest): CreateLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogstashWithOptions(request, headers, runtime);
}

async function createLogstashWithOptions(request: CreateLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.networkConfig)) {
    body['networkConfig'] = request.networkConfig;
  }
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }
  if (!Util.isUnset(request.paymentInfo)) {
    body['paymentInfo'] = request.paymentInfo;
  }
  if (!Util.isUnset(request.paymentType)) {
    body['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePipelinesRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
  trigger?: boolean(name='trigger'),
}

model CreatePipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CreatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePipelinesResponseBody(name='body'),
}

async function createPipelines(InstanceId: string, request: CreatePipelinesRequest): CreatePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function createPipelinesWithOptions(InstanceId: string, request: CreatePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreatePipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSnapshotRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshot(InstanceId: string, request: CreateSnapshotRequest): CreateSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSnapshotWithOptions(InstanceId, request, headers, runtime);
}

async function createSnapshotWithOptions(InstanceId: string, request: CreateSnapshotRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSnapshotResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateSnapshot',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshots`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateVpcEndpointRequest {
  clientToken?: string(name='ClientToken'),
  serviceId?: string(name='serviceId'),
  zoneId?: string(name='zoneId'),
  dryRun?: boolean(name='dryRun'),
}

model CreateVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    endpointDomain?: string(name='endpointDomain'),
    endpointId?: string(name='endpointId'),
    endpointName?: string(name='endpointName'),
    serviceId?: string(name='serviceId'),
  }(name='Result'),
}

model CreateVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVpcEndpointResponseBody(name='body'),
}

async function createVpcEndpoint(InstanceId: string, request: CreateVpcEndpointRequest): CreateVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVpcEndpointWithOptions(InstanceId, request, headers, runtime);
}

async function createVpcEndpointWithOptions(InstanceId: string, request: CreateVpcEndpointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVpcEndpointResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceId)) {
    body['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.zoneId)) {
    body['zoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcEndpoint',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/vpc-endpoints`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeactivateZonesRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model DeactivateZonesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeactivateZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeactivateZonesResponseBody(name='body'),
}

async function deactivateZones(InstanceId: string, request: DeactivateZonesRequest): DeactivateZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deactivateZonesWithOptions(InstanceId, request, headers, runtime);
}

async function deactivateZonesWithOptions(InstanceId: string, request: DeactivateZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeactivateZonesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeactivateZones',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/down-zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteCollectorRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model DeleteCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCollectorResponseBody(name='body'),
}

async function deleteCollector(ResId: string, request: DeleteCollectorRequest): DeleteCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCollectorWithOptions(ResId, request, headers, runtime);
}

async function deleteCollectorWithOptions(ResId: string, request: DeleteCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteComponentIndexRequest {
  body?: string(name='body'),
}

model DeleteComponentIndexResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteComponentIndexResponseBody(name='body'),
}

async function deleteComponentIndex(InstanceId: string, name: string, request: DeleteComponentIndexRequest): DeleteComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteComponentIndexWithOptions(InstanceId, name, request, headers, runtime);
}

async function deleteComponentIndexWithOptions(InstanceId: string, name: string, request: DeleteComponentIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteComponentIndexResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteConnectedClusterRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  connectedInstanceId?: string(name='connectedInstanceId'),
}

model DeleteConnectedClusterResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteConnectedClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConnectedClusterResponseBody(name='body'),
}

async function deleteConnectedCluster(InstanceId: string, request: DeleteConnectedClusterRequest): DeleteConnectedClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConnectedClusterWithOptions(InstanceId, request, headers, runtime);
}

async function deleteConnectedClusterWithOptions(InstanceId: string, request: DeleteConnectedClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConnectedClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectedInstanceId)) {
    query['connectedInstanceId'] = request.connectedInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteConnectedCluster',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connected-clusters`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDataStreamRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model DeleteDataStreamResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteDataStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataStreamResponseBody(name='body'),
}

async function deleteDataStream(InstanceId: string, DataStream: string, request: DeleteDataStreamRequest): DeleteDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime);
}

async function deleteDataStreamWithOptions(InstanceId: string, DataStream: string, request: DeleteDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataStreamResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataStream',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams/${OpenApiUtil.getEncodeParam(DataStream)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDataTaskRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
  taskId?: string(name='taskId'),
}

model DeleteDataTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteDataTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataTaskResponseBody(name='body'),
}

async function deleteDataTask(InstanceId: string, request: DeleteDataTaskRequest): DeleteDataTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataTaskWithOptions(InstanceId, request, headers, runtime);
}

async function deleteDataTaskWithOptions(InstanceId: string, request: DeleteDataTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.taskId)) {
    query['taskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-task`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDeprecatedTemplateRequest {
  body?: string(name='body'),
}

model DeleteDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteDeprecatedTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeprecatedTemplateResponseBody(name='body'),
}

async function deleteDeprecatedTemplate(InstanceId: string, name: string, request: DeleteDeprecatedTemplateRequest): DeleteDeprecatedTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDeprecatedTemplateWithOptions(InstanceId, name, request, headers, runtime);
}

async function deleteDeprecatedTemplateWithOptions(InstanceId: string, name: string, request: DeleteDeprecatedTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDeprecatedTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeprecatedTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/deprecated-templates/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteILMPolicyRequest {
  body?: string(name='body'),
}

model DeleteILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteILMPolicyResponseBody(name='body'),
}

async function deleteILMPolicy(InstanceId: string, PolicyName: string, request: DeleteILMPolicyRequest): DeleteILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteILMPolicyWithOptions(InstanceId, PolicyName, request, headers, runtime);
}

async function deleteILMPolicyWithOptions(InstanceId: string, PolicyName: string, request: DeleteILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteILMPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies/${OpenApiUtil.getEncodeParam(PolicyName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteIndexTemplateRequest {
  body?: string(name='body'),
}

model DeleteIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIndexTemplateResponseBody(name='body'),
}

async function deleteIndexTemplate(InstanceId: string, IndexTemplate: string, request: DeleteIndexTemplateRequest): DeleteIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexTemplateWithOptions(InstanceId, IndexTemplate, request, headers, runtime);
}

async function deleteIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, request: DeleteIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates/${OpenApiUtil.getEncodeParam(IndexTemplate)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteInstanceRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  deleteType?: string(name='deleteType'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(InstanceId: string, request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function deleteInstanceWithOptions(InstanceId: string, request: DeleteInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deleteType)) {
    query['deleteType'] = request.deleteType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteLogstashRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  deleteType?: string(name='deleteType'),
}

model DeleteLogstashResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLogstashResponseBody(name='body'),
}

async function deleteLogstash(InstanceId: string, request: DeleteLogstashRequest): DeleteLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogstashWithOptions(InstanceId, request, headers, runtime);
}

async function deleteLogstashWithOptions(InstanceId: string, request: DeleteLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deleteType)) {
    query['deleteType'] = request.deleteType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePipelinesRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
  pipelineIds?: string(name='pipelineIds'),
}

model DeletePipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeletePipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePipelinesResponseBody(name='body'),
}

async function deletePipelines(InstanceId: string, request: DeletePipelinesRequest): DeletePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function deletePipelinesWithOptions(InstanceId: string, request: DeletePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.pipelineIds)) {
    query['pipelineIds'] = request.pipelineIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeletePipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteSnapshotRepoRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  repoPath?: string(name='repoPath'),
}

model DeleteSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSnapshotRepoResponseBody(name='body'),
}

async function deleteSnapshotRepo(InstanceId: string, request: DeleteSnapshotRepoRequest): DeleteSnapshotRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSnapshotRepoWithOptions(InstanceId, request, headers, runtime);
}

async function deleteSnapshotRepoWithOptions(InstanceId: string, request: DeleteSnapshotRepoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSnapshotRepoResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.repoPath)) {
    query['repoPath'] = request.repoPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSnapshotRepo',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-repos`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteVpcEndpointRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model DeleteVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVpcEndpointResponseBody(name='body'),
}

async function deleteVpcEndpoint(InstanceId: string, EndpointId: string, request: DeleteVpcEndpointRequest): DeleteVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVpcEndpointWithOptions(InstanceId, EndpointId, request, headers, runtime);
}

async function deleteVpcEndpointWithOptions(InstanceId: string, EndpointId: string, request: DeleteVpcEndpointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVpcEndpointResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcEndpoint',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/vpc-endpoints/${OpenApiUtil.getEncodeParam(EndpointId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeAckOperatorRequest {
  body?: string(name='body'),
}

model DescribeAckOperatorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    status?: string(name='status'),
    version?: string(name='version'),
  }(name='Result'),
}

model DescribeAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAckOperatorResponseBody(name='body'),
}

async function describeAckOperator(ClusterId: string, request: DescribeAckOperatorRequest): DescribeAckOperatorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAckOperatorWithOptions(ClusterId, request, headers, runtime);
}

async function describeAckOperatorWithOptions(ClusterId: string, request: DescribeAckOperatorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAckOperatorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeAckOperator',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters/${OpenApiUtil.getEncodeParam(ClusterId)}/operator`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApmRequest {
  body?: string(name='body'),
}

model DescribeApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    apmServerDomain?: string(name='apmServerDomain'),
    createdAt?: string(name='createdAt'),
    deployedReplica?: long(name='deployedReplica'),
    description?: string(name='description'),
    endTime?: long(name='endTime'),
    instanceId?: string(name='instanceId'),
    nodeAmount?: long(name='nodeAmount'),
    outputES?: string(name='outputES'),
    outputESUserName?: string(name='outputESUserName'),
    ownerId?: string(name='ownerId'),
    paymentType?: string(name='paymentType'),
    region?: string(name='region'),
    replica?: int32(name='replica'),
    resourceSpec?: string(name='resourceSpec'),
    status?: string(name='status'),
    version?: string(name='version'),
    vpcId?: string(name='vpcId'),
    vsArea?: string(name='vsArea'),
    vswitchId?: string(name='vswitchId'),
  }(name='Result'),
}

model DescribeApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApmResponseBody(name='body'),
}

async function describeApm(instanceId: string, request: DescribeApmRequest): DescribeApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApmWithOptions(instanceId, request, headers, runtime);
}

async function describeApmWithOptions(instanceId: string, request: DescribeApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApmResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeCollectorRequest {
  body?: string(name='body'),
}

model DescribeCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content'),
        fileName?: string(name='fileName'),
      }
    ](name='configs'),
    dryRun?: boolean(name='dryRun'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType'),
        enableMonitoring?: boolean(name='enableMonitoring'),
        groupId?: string(name='groupId'),
        host?: string(name='host'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId'),
        instanceType?: string(name='instanceType'),
        kibanaHost?: string(name='kibanaHost'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus'),
            instanceId?: string(name='instanceId'),
          }
        ](name='machines'),
        protocol?: string(name='protocol'),
        successPodsCount?: string(name='successPodsCount'),
        totalPodsCount?: string(name='totalPodsCount'),
        type?: string(name='type'),
        userName?: string(name='userName'),
      }
    ](name='extendConfigs'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    name?: string(name='name'),
    ownerId?: string(name='ownerId'),
    resId?: string(name='resId'),
    resType?: string(name='resType'),
    resVersion?: string(name='resVersion'),
    status?: string(name='status'),
    vpcId?: string(name='vpcId'),
  }(name='Result'),
}

model DescribeCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCollectorResponseBody(name='body'),
}

async function describeCollector(ResId: string, request: DescribeCollectorRequest): DescribeCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeCollectorWithOptions(ResId, request, headers, runtime);
}

async function describeCollectorWithOptions(ResId: string, request: DescribeCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeCollectorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeComponentIndexRequest {
  body?: string(name='body'),
}

model DescribeComponentIndexResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    meta?: map[string]any(name='_meta'),
    template?: {
      aliases?: map[string]any(name='aliases'),
      mappings?: map[string]any(name='mappings'),
      settings?: map[string]any(name='settings'),
    }(name='template'),
  }(name='Result'),
}

model DescribeComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeComponentIndexResponseBody(name='body'),
}

async function describeComponentIndex(InstanceId: string, name: string, request: DescribeComponentIndexRequest): DescribeComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeComponentIndexWithOptions(InstanceId, name, request, headers, runtime);
}

async function describeComponentIndexWithOptions(InstanceId: string, name: string, request: DescribeComponentIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeComponentIndexResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeConnectableClustersRequest {
  alreadySetItems?: boolean(name='alreadySetItems'),
  body?: string(name='body'),
}

model DescribeConnectableClustersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      instances?: string(name='instances'),
      networkType?: string(name='networkType'),
    }
  ](name='Result'),
}

model DescribeConnectableClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeConnectableClustersResponseBody(name='body'),
}

async function describeConnectableClusters(InstanceId: string, request: DescribeConnectableClustersRequest): DescribeConnectableClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeConnectableClustersWithOptions(InstanceId, request, headers, runtime);
}

async function describeConnectableClustersWithOptions(InstanceId: string, request: DescribeConnectableClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeConnectableClustersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.alreadySetItems)) {
    query['alreadySetItems'] = request.alreadySetItems;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeConnectableClusters',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connectable-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeDeprecatedTemplateRequest {
  body?: string(name='body'),
}

model DescribeDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    dataStream?: boolean(name='dataStream'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate'),
    order?: long(name='order'),
    template?: {
      aliases?: string(name='aliases'),
      mappings?: string(name='mappings'),
      settings?: string(name='settings'),
    }(name='template'),
    version?: string(name='version'),
  }(name='Result'),
}

model DescribeDeprecatedTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDeprecatedTemplateResponseBody(name='body'),
}

async function describeDeprecatedTemplate(InstanceId: string, name: string, request: DescribeDeprecatedTemplateRequest): DescribeDeprecatedTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDeprecatedTemplateWithOptions(InstanceId, name, request, headers, runtime);
}

async function describeDeprecatedTemplateWithOptions(InstanceId: string, name: string, request: DescribeDeprecatedTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDeprecatedTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeprecatedTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/deprecated-templates/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeDiagnoseReportRequest {
  body?: string(name='body'),
  lang?: string(name='lang'),
}

model DescribeDiagnoseReportResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createTime?: long(name='createTime'),
    diagnoseItems?: [ 
      {
        detail?: {
          desc?: string(name='desc'),
          name?: string(name='name'),
          result?: string(name='result'),
          suggest?: string(name='suggest'),
          type?: string(name='type'),
        }(name='detail'),
        health?: string(name='health'),
        item?: string(name='item'),
      }
    ](name='diagnoseItems'),
    health?: string(name='health'),
    instanceId?: string(name='instanceId'),
    reportId?: string(name='reportId'),
    state?: string(name='state'),
    trigger?: string(name='trigger'),
  }(name='Result'),
}

model DescribeDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDiagnoseReportResponseBody(name='body'),
}

async function describeDiagnoseReport(InstanceId: string, ReportId: string, request: DescribeDiagnoseReportRequest): DescribeDiagnoseReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDiagnoseReportWithOptions(InstanceId, ReportId, request, headers, runtime);
}

async function describeDiagnoseReportWithOptions(InstanceId: string, ReportId: string, request: DescribeDiagnoseReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDiagnoseReportResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiagnoseReport',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/reports/${OpenApiUtil.getEncodeParam(ReportId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeDiagnosisSettingsRequest {
  body?: string(name='body'),
  lang?: string(name='lang'),
}

model DescribeDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    scene?: string(name='scene'),
    updateTime?: long(name='updateTime'),
  }(name='Result'),
}

model DescribeDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDiagnosisSettingsResponseBody(name='body'),
}

async function describeDiagnosisSettings(InstanceId: string, request: DescribeDiagnosisSettingsRequest): DescribeDiagnosisSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function describeDiagnosisSettingsWithOptions(InstanceId: string, request: DescribeDiagnosisSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDiagnosisSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiagnosisSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeDynamicSettingsRequest {
  body?: string(name='body'),
}

model DescribeDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeDynamicSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDynamicSettingsResponseBody(name='body'),
}

async function describeDynamicSettings(InstanceId: string, request: DescribeDynamicSettingsRequest): DescribeDynamicSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDynamicSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function describeDynamicSettingsWithOptions(InstanceId: string, request: DescribeDynamicSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDynamicSettingsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDynamicSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dynamic-settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeElasticsearchHealthRequest {
  body?: string(name='body'),
}

model DescribeElasticsearchHealthResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeElasticsearchHealthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeElasticsearchHealthResponseBody(name='body'),
}

async function describeElasticsearchHealth(InstanceId: string, request: DescribeElasticsearchHealthRequest): DescribeElasticsearchHealthResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeElasticsearchHealthWithOptions(InstanceId, request, headers, runtime);
}

async function describeElasticsearchHealthWithOptions(InstanceId: string, request: DescribeElasticsearchHealthRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeElasticsearchHealthResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeElasticsearchHealth',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/elasticsearch-health`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeILMPolicyRequest {
  body?: string(name='body'),
}

model DescribeILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    name?: string(name='name'),
    phases?: map[string]any(name='phases'),
  }(name='Result'),
}

model DescribeILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeILMPolicyResponseBody(name='body'),
}

async function describeILMPolicy(InstanceId: string, PolicyName: string, request: DescribeILMPolicyRequest): DescribeILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeILMPolicyWithOptions(InstanceId, PolicyName, request, headers, runtime);
}

async function describeILMPolicyWithOptions(InstanceId: string, PolicyName: string, request: DescribeILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeILMPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies/${OpenApiUtil.getEncodeParam(PolicyName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeIndexTemplateRequest {
  body?: string(name='body'),
}

model DescribeIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    dataStream?: boolean(name='dataStream'),
    ilmPolicy?: string(name='ilmPolicy'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate'),
    priority?: int32(name='priority'),
    template?: {
      aliases?: string(name='aliases'),
      mappings?: string(name='mappings'),
      settings?: string(name='settings'),
    }(name='template'),
  }(name='Result'),
}

model DescribeIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIndexTemplateResponseBody(name='body'),
}

async function describeIndexTemplate(InstanceId: string, IndexTemplate: string, request: DescribeIndexTemplateRequest): DescribeIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeIndexTemplateWithOptions(InstanceId, IndexTemplate, request, headers, runtime);
}

async function describeIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, request: DescribeIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeIndexTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates/${OpenApiUtil.getEncodeParam(IndexTemplate)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeInstanceRequest {
  body?: string(name='body'),
}

model DescribeInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
    advancedSetting?: {
      gcName?: string(name='gcName'),
    }(name='advancedSetting'),
    aliwsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='aliwsDicts'),
    clientNodeConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='clientNodeConfiguration'),
    createdAt?: string(name='createdAt'),
    dedicateMaster?: boolean(name='dedicateMaster'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    elasticDataNodeConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='elasticDataNodeConfiguration'),
    enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork'),
    enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork'),
    enablePublic?: boolean(name='enablePublic'),
    esConfig?: map[string]any(name='esConfig'),
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
    esIPWhitelist?: [ string ](name='esIPWhitelist'),
    esVersion?: string(name='esVersion'),
    extendConfigs?: [  map[string]any ](name='extendConfigs'),
    haveClientNode?: boolean(name='haveClientNode'),
    haveKibana?: boolean(name='haveKibana'),
    instanceId?: string(name='instanceId'),
    isNewDeployment?: boolean(name='isNewDeployment'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
    kibanaPort?: int32(name='kibanaPort'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    port?: int32(name='port'),
    postpaidServiceStatus?: string(name='postpaidServiceStatus'),
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
    protocol?: string(name='protocol'),
    publicDomain?: string(name='publicDomain'),
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
    publicPort?: int32(name='publicPort'),
    resourceGroupId?: string(name='resourceGroupId'),
    serviceVpc?: boolean(name='serviceVpc'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey'),
        tagValue?: string(name='tagValue'),
      }
    ](name='tags'),
    updatedAt?: string(name='updatedAt'),
    vpcInstanceId?: string(name='vpcInstanceId'),
    warmNode?: boolean(name='warmNode'),
    warmNodeConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='warmNodeConfiguration'),
    zoneCount?: int32(name='zoneCount'),
    zoneInfos?: [ 
      {
        status?: string(name='status'),
        zoneId?: string(name='zoneId'),
      }
    ](name='zoneInfos'),
  }(name='Result'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstance(InstanceId: string, request: DescribeInstanceRequest): DescribeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function describeInstanceWithOptions(InstanceId: string, request: DescribeInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
}

model DescribeKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeKibanaSettingsResponseBody(name='body'),
}

async function describeKibanaSettings(InstanceId: string): DescribeKibanaSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeKibanaSettingsWithOptions(InstanceId, headers, runtime);
}

async function describeKibanaSettingsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeKibanaSettingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeKibanaSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    extendConfigs?: [  map[string]any ](name='ExtendConfigs'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey'),
        tagValue?: string(name='tagValue'),
      }
    ](name='Tags'),
    zoneInfos?: [ 
      {
        status?: string(name='status'),
        zoneId?: string(name='zoneId'),
      }
    ](name='ZoneInfos'),
    config?: map[string]any(name='config'),
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    endpointList?: [ 
      {
        host?: string(name='host'),
        port?: string(name='port'),
        zoneId?: string(name='zoneId'),
      }
    ](name='endpointList'),
    instanceId?: string(name='instanceId'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    status?: string(name='status'),
    updatedAt?: string(name='updatedAt'),
    version?: string(name='version'),
    vpcInstanceId?: string(name='vpcInstanceId'),
  }(name='Result'),
}

model DescribeLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogstashResponseBody(name='body'),
}

async function describeLogstash(InstanceId: string): DescribeLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeLogstashWithOptions(InstanceId, headers, runtime);
}

async function describeLogstashWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeLogstashResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePipelineRequest {
  body?: string(name='body'),
}

model DescribePipelineResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    batchDelay?: int32(name='batchDelay'),
    batchSize?: int32(name='batchSize'),
    config?: string(name='config'),
    description?: string(name='description'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    pipelineId?: string(name='pipelineId'),
    pipelineStatus?: string(name='pipelineStatus'),
    queueCheckPointWrites?: int32(name='queueCheckPointWrites'),
    queueMaxBytes?: int32(name='queueMaxBytes'),
    queueType?: string(name='queueType'),
    workers?: int32(name='workers'),
  }(name='Result'),
}

model DescribePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePipelineResponseBody(name='body'),
}

async function describePipeline(InstanceId: string, PipelineId: string, request: DescribePipelineRequest): DescribePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePipelineWithOptions(InstanceId, PipelineId, request, headers, runtime);
}

async function describePipelineWithOptions(InstanceId: string, PipelineId: string, request: DescribePipelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribePipeline',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines/${OpenApiUtil.getEncodeParam(PipelineId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePipelineManagementConfigRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model DescribePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    endpoints?: string(name='endpoints'),
    esInstanceId?: string(name='esInstanceId'),
    pipelineIds?: [ string ](name='pipelineIds'),
    pipelineManagementType?: string(name='pipelineManagementType'),
    userName?: string(name='userName'),
  }(name='Result'),
}

model DescribePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePipelineManagementConfigResponseBody(name='body'),
}

async function describePipelineManagementConfig(InstanceId: string, request: DescribePipelineManagementConfigRequest): DescribePipelineManagementConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime);
}

async function describePipelineManagementConfigWithOptions(InstanceId: string, request: DescribePipelineManagementConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePipelineManagementConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribePipelineManagementConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipeline-management-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      consoleEndpoint?: string(name='consoleEndpoint'),
      localName?: string(name='localName'),
      regionEndpoint?: string(name='regionEndpoint'),
      regionId?: string(name='regionId'),
      status?: string(name='status'),
    }
  ](name='Result'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeSnapshotSettingRequest {
  body?: string(name='body'),
}

model DescribeSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='Enable'),
    quartzRegex?: string(name='QuartzRegex'),
  }(name='Result'),
}

model DescribeSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSnapshotSettingResponseBody(name='body'),
}

async function describeSnapshotSetting(InstanceId: string, request: DescribeSnapshotSettingRequest): DescribeSnapshotSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSnapshotSettingWithOptions(InstanceId, request, headers, runtime);
}

async function describeSnapshotSettingWithOptions(InstanceId: string, request: DescribeSnapshotSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSnapshotSettingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnapshotSetting',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-setting`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeTemplatesRequest {
  body?: string(name='body'),
}

model DescribeTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      templateName?: string(name='templateName'),
    }
  ](name='Result'),
}

model DescribeTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTemplatesResponseBody(name='body'),
}

async function describeTemplates(InstanceId: string, request: DescribeTemplatesRequest): DescribeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTemplatesWithOptions(InstanceId, request, headers, runtime);
}

async function describeTemplatesWithOptions(InstanceId: string, request: DescribeTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTemplatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeXpackMonitorConfigRequest {
  body?: string(name='body'),
}

model DescribeXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='enable'),
    endpoints?: [ string ](name='endpoints'),
    esInstanceId?: string(name='esInstanceId'),
    pipelineIds?: [ string ](name='pipelineIds'),
    userName?: string(name='userName'),
  }(name='Result'),
}

model DescribeXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeXpackMonitorConfigResponseBody(name='body'),
}

async function describeXpackMonitorConfig(InstanceId: string, request: DescribeXpackMonitorConfigRequest): DescribeXpackMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeXpackMonitorConfigWithOptions(InstanceId, request, headers, runtime);
}

async function describeXpackMonitorConfigWithOptions(InstanceId: string, request: DescribeXpackMonitorConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeXpackMonitorConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DescribeXpackMonitorConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/xpack-monitor-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DiagnoseInstanceRequest {
  clientToken?: string(name='ClientToken'),
  diagnoseItems?: [ string ](name='diagnoseItems'),
  indices?: [ string ](name='indices'),
  type?: string(name='type'),
  lang?: string(name='lang'),
}

model DiagnoseInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createTime?: long(name='createTime'),
    instanceId?: string(name='instanceId'),
    reportId?: string(name='reportId'),
    state?: string(name='state'),
  }(name='Result'),
}

model DiagnoseInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DiagnoseInstanceResponseBody(name='body'),
}

async function diagnoseInstance(InstanceId: string, request: DiagnoseInstanceRequest): DiagnoseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return diagnoseInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function diagnoseInstanceWithOptions(InstanceId: string, request: DiagnoseInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DiagnoseInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.diagnoseItems)) {
    body['diagnoseItems'] = request.diagnoseItems;
  }
  if (!Util.isUnset(request.indices)) {
    body['indices'] = request.indices;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DiagnoseInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/diagnose`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EstimatedLogstashRestartTimeRequest {
  body?: string(name='body'),
  force?: boolean(name='force'),
}

model EstimatedLogstashRestartTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    unit?: string(name='unit'),
    value?: long(name='value'),
  }(name='Result'),
}

model EstimatedLogstashRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EstimatedLogstashRestartTimeResponseBody(name='body'),
}

async function estimatedLogstashRestartTime(InstanceId: string, request: EstimatedLogstashRestartTimeRequest): EstimatedLogstashRestartTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return estimatedLogstashRestartTimeWithOptions(InstanceId, request, headers, runtime);
}

async function estimatedLogstashRestartTimeWithOptions(InstanceId: string, request: EstimatedLogstashRestartTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EstimatedLogstashRestartTimeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'EstimatedLogstashRestartTime',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/estimated-time/restart-time`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EstimatedRestartTimeRequest {
  body?: string(name='body'),
  force?: boolean(name='force'),
}

model EstimatedRestartTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    unit?: string(name='unit'),
    value?: long(name='value'),
  }(name='Result'),
}

model EstimatedRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EstimatedRestartTimeResponseBody(name='body'),
}

async function estimatedRestartTime(InstanceId: string, request: EstimatedRestartTimeRequest): EstimatedRestartTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return estimatedRestartTimeWithOptions(InstanceId, request, headers, runtime);
}

async function estimatedRestartTimeWithOptions(InstanceId: string, request: EstimatedRestartTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EstimatedRestartTimeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'EstimatedRestartTime',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/estimated-time/restart-time`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetClusterDataInformationRequest {
  body?: string(name='body'),
}

model GetClusterDataInformationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    connectable?: boolean(name='connectable'),
    metaInfo?: {
      fields?: [ string ](name='fields'),
      indices?: [ string ](name='indices'),
      mapping?: string(name='mapping'),
      settings?: string(name='settings'),
      typeName?: [ string ](name='typeName'),
    }(name='metaInfo'),
  }(name='Result'),
}

model GetClusterDataInformationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetClusterDataInformationResponseBody(name='body'),
}

async function getClusterDataInformation(request: GetClusterDataInformationRequest): GetClusterDataInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterDataInformationWithOptions(request, headers, runtime);
}

async function getClusterDataInformationWithOptions(request: GetClusterDataInformationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterDataInformationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetClusterDataInformation',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/cluster/data-information`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetElastictaskRequest {
  body?: string(name='body'),
}

model GetElastictaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model GetElastictaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetElastictaskResponseBody(name='body'),
}

async function getElastictask(InstanceId: string, request: GetElastictaskRequest): GetElastictaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getElastictaskWithOptions(InstanceId, request, headers, runtime);
}

async function getElastictaskWithOptions(InstanceId: string, request: GetElastictaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetElastictaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetElastictask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/elastic-task`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEmonGrafanaAlertsRequest {
  body?: string(name='body'),
}

model GetEmonGrafanaAlertsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEmonGrafanaAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmonGrafanaAlertsResponseBody(name='body'),
}

async function getEmonGrafanaAlerts(ProjectId: string, request: GetEmonGrafanaAlertsRequest): GetEmonGrafanaAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonGrafanaAlertsWithOptions(ProjectId, request, headers, runtime);
}

async function getEmonGrafanaAlertsWithOptions(ProjectId: string, request: GetEmonGrafanaAlertsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonGrafanaAlertsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetEmonGrafanaAlerts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/grafana/proxy/api/alerts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEmonGrafanaDashboardsRequest {
  body?: string(name='body'),
}

model GetEmonGrafanaDashboardsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEmonGrafanaDashboardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmonGrafanaDashboardsResponseBody(name='body'),
}

async function getEmonGrafanaDashboards(ProjectId: string, request: GetEmonGrafanaDashboardsRequest): GetEmonGrafanaDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonGrafanaDashboardsWithOptions(ProjectId, request, headers, runtime);
}

async function getEmonGrafanaDashboardsWithOptions(ProjectId: string, request: GetEmonGrafanaDashboardsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonGrafanaDashboardsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetEmonGrafanaDashboards',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/grafana/proxy/api/search`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEmonMonitorDataRequest {
  body?: string(name='body'),
}

model GetEmonMonitorDataResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      dps?: map[string]any(name='dps'),
      integrity?: float(name='integrity'),
      messageWatermark?: long(name='messageWatermark'),
      metric?: string(name='metric'),
      summary?: float(name='summary'),
      tags?: map[string]any(name='tags'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model GetEmonMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEmonMonitorDataResponseBody(name='body'),
}

async function getEmonMonitorData(ProjectId: string, request: GetEmonMonitorDataRequest): GetEmonMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonMonitorDataWithOptions(ProjectId, request, headers, runtime);
}

async function getEmonMonitorDataWithOptions(ProjectId: string, request: GetEmonMonitorDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonMonitorDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetEmonMonitorData',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/metrics/query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetOpenStoreUsageRequest {
  body?: string(name='body'),
}

model GetOpenStoreUsageResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    currentUsage?: long(name='currentUsage'),
    lastDayUsage?: long(name='lastDayUsage'),
  }(name='Result'),
}

model GetOpenStoreUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOpenStoreUsageResponseBody(name='body'),
}

async function getOpenStoreUsage(InstanceId: string, request: GetOpenStoreUsageRequest): GetOpenStoreUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOpenStoreUsageWithOptions(InstanceId, request, headers, runtime);
}

async function getOpenStoreUsageWithOptions(InstanceId: string, request: GetOpenStoreUsageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetOpenStoreUsageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetOpenStoreUsage',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/openstore/usage`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRegionConfigurationRequest {
  body?: string(name='body'),
  zoneId?: string(name='zoneId'),
}

model GetRegionConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    clientNodeAmountRange?: {
      maxAmount?: int32(name='maxAmount'),
      minAmount?: int32(name='minAmount'),
    }(name='clientNodeAmountRange'),
    clientNodeDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
      }
    ](name='clientNodeDiskList'),
    clientNodeSpec?: [ string ](name='clientNodeSpec'),
    createUrl?: string(name='createUrl'),
    dataDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
        valueLimitSet?: [ string ](name='valueLimitSet'),
      }
    ](name='dataDiskList'),
    elasticNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount'),
        minAmount?: int32(name='minAmount'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption'),
          diskType?: string(name='diskType'),
          maxSize?: int32(name='maxSize'),
          minSize?: int32(name='minSize'),
          scaleLimit?: int32(name='scaleLimit'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='elasticNodeProperties'),
    env?: string(name='env'),
    esVersions?: [ string ](name='esVersions'),
    esVersionsLatestList?: [ 
      {
        key?: string(name='key'),
        value?: string(name='value'),
      }
    ](name='esVersionsLatestList'),
    instanceSupportNodes?: [ string ](name='instanceSupportNodes'),
    jvmConfine?: {
      memory?: int32(name='memory'),
      supportEsVersions?: [ string ](name='supportEsVersions'),
      supportGcs?: [ string ](name='supportGcs'),
    }(name='jvmConfine'),
    kibanaNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount'),
        minAmount?: int32(name='minAmount'),
      }(name='amountRange'),
      spec?: [ string ](name='spec'),
    }(name='kibanaNodeProperties'),
    masterDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
      }
    ](name='masterDiskList'),
    masterSpec?: [ string ](name='masterSpec'),
    node?: {
      maxAmount?: int32(name='maxAmount'),
      minAmount?: int32(name='minAmount'),
    }(name='node'),
    nodeSpecList?: [ 
      {
        cpuCount?: int32(name='cpuCount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        enable?: boolean(name='enable'),
        memorySize?: int32(name='memorySize'),
        spec?: string(name='spec'),
        specGroupType?: string(name='specGroupType'),
      }
    ](name='nodeSpecList'),
    regionId?: string(name='regionId'),
    supportVersions?: [ 
      {
        instanceCategory?: string(name='instanceCategory'),
        supportVersionList?: [ 
          {
            key?: string(name='key'),
            value?: string(name='value'),
          }
        ](name='supportVersionList'),
      }
    ](name='supportVersions'),
    warmNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount'),
        minAmount?: int32(name='minAmount'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption'),
          diskType?: string(name='diskType'),
          maxSize?: int32(name='maxSize'),
          minSize?: int32(name='minSize'),
          scaleLimit?: int32(name='scaleLimit'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='warmNodeProperties'),
    zones?: [ string ](name='zones'),
  }(name='Result'),
}

model GetRegionConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRegionConfigurationResponseBody(name='body'),
}

async function getRegionConfiguration(request: GetRegionConfigurationRequest): GetRegionConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionConfigurationWithOptions(request, headers, runtime);
}

async function getRegionConfigurationWithOptions(request: GetRegionConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.zoneId)) {
    query['zoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetRegionConfiguration',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/region`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetSuggestShrinkableNodesRequest {
  body?: string(name='body'),
  count?: int32(name='count'),
  ignoreStatus?: boolean(name='ignoreStatus'),
  nodeType?: string(name='nodeType'),
}

model GetSuggestShrinkableNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
    }
  ](name='Result'),
}

model GetSuggestShrinkableNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSuggestShrinkableNodesResponseBody(name='body'),
}

async function getSuggestShrinkableNodes(InstanceId: string, request: GetSuggestShrinkableNodesRequest): GetSuggestShrinkableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSuggestShrinkableNodesWithOptions(InstanceId, request, headers, runtime);
}

async function getSuggestShrinkableNodesWithOptions(InstanceId: string, request: GetSuggestShrinkableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSuggestShrinkableNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query['ignoreStatus'] = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetSuggestShrinkableNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/suggest-shrinkable-nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTransferableNodesRequest {
  body?: string(name='body'),
  count?: int32(name='count'),
  nodeType?: string(name='nodeType'),
}

model GetTransferableNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
    }
  ](name='Result'),
}

model GetTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTransferableNodesResponseBody(name='body'),
}

async function getTransferableNodes(InstanceId: string, request: GetTransferableNodesRequest): GetTransferableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTransferableNodesWithOptions(InstanceId, request, headers, runtime);
}

async function getTransferableNodesWithOptions(InstanceId: string, request: GetTransferableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTransferableNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetTransferableNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/transferable-nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InitializeOperationRoleRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model InitializeOperationRoleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InitializeOperationRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InitializeOperationRoleResponseBody(name='body'),
}

async function initializeOperationRole(request: InitializeOperationRoleRequest): InitializeOperationRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initializeOperationRoleWithOptions(request, headers, runtime);
}

async function initializeOperationRoleWithOptions(request: InitializeOperationRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InitializeOperationRoleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InitializeOperationRole',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/user/slr`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InstallAckOperatorRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model InstallAckOperatorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InstallAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallAckOperatorResponseBody(name='body'),
}

async function installAckOperator(ClusterId: string, request: InstallAckOperatorRequest): InstallAckOperatorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installAckOperatorWithOptions(ClusterId, request, headers, runtime);
}

async function installAckOperatorWithOptions(ClusterId: string, request: InstallAckOperatorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallAckOperatorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallAckOperator',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters/${OpenApiUtil.getEncodeParam(ClusterId)}/operator`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InstallKibanaSystemPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model InstallKibanaSystemPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallKibanaSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallKibanaSystemPluginResponseBody(name='body'),
}

async function installKibanaSystemPlugin(InstanceId: string, request: InstallKibanaSystemPluginRequest): InstallKibanaSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installKibanaSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

async function installKibanaSystemPluginWithOptions(InstanceId: string, request: InstallKibanaSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallKibanaSystemPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallKibanaSystemPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-plugins/system/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InstallLogstashSystemPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model InstallLogstashSystemPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallLogstashSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallLogstashSystemPluginResponseBody(name='body'),
}

async function installLogstashSystemPlugin(InstanceId: string, request: InstallLogstashSystemPluginRequest): InstallLogstashSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installLogstashSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

async function installLogstashSystemPluginWithOptions(InstanceId: string, request: InstallLogstashSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallLogstashSystemPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallLogstashSystemPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/system/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InstallSystemPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model InstallSystemPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallSystemPluginResponseBody(name='body'),
}

async function installSystemPlugin(InstanceId: string, request: InstallSystemPluginRequest): InstallSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

async function installSystemPluginWithOptions(InstanceId: string, request: InstallSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallSystemPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallSystemPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/system/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InstallUserPluginsRequest {
  body?: string(name='body'),
}

model InstallUserPluginsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallUserPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallUserPluginsResponseBody(name='body'),
}

async function installUserPlugins(InstanceId: string, request: InstallUserPluginsRequest): InstallUserPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installUserPluginsWithOptions(InstanceId, request, headers, runtime);
}

async function installUserPluginsWithOptions(InstanceId: string, request: InstallUserPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallUserPluginsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallUserPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/user/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InterruptElasticsearchTaskRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model InterruptElasticsearchTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InterruptElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InterruptElasticsearchTaskResponseBody(name='body'),
}

async function interruptElasticsearchTask(InstanceId: string, request: InterruptElasticsearchTaskRequest): InterruptElasticsearchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return interruptElasticsearchTaskWithOptions(InstanceId, request, headers, runtime);
}

async function interruptElasticsearchTaskWithOptions(InstanceId: string, request: InterruptElasticsearchTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InterruptElasticsearchTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InterruptElasticsearchTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/interrupt`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InterruptLogstashTaskRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model InterruptLogstashTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InterruptLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InterruptLogstashTaskResponseBody(name='body'),
}

async function interruptLogstashTask(InstanceId: string, request: InterruptLogstashTaskRequest): InterruptLogstashTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return interruptLogstashTaskWithOptions(InstanceId, request, headers, runtime);
}

async function interruptLogstashTaskWithOptions(InstanceId: string, request: InterruptLogstashTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InterruptLogstashTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InterruptLogstashTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/interrupt`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAckClustersRequest {
  body?: string(name='body'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  vpcId?: string(name='vpcId'),
}

model ListAckClustersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      clusterId?: string(name='clusterId'),
      clusterType?: string(name='clusterType'),
      name?: string(name='name'),
      vpcId?: string(name='vpcId'),
    }
  ](name='Result'),
}

model ListAckClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAckClustersResponseBody(name='body'),
}

async function listAckClusters(request: ListAckClustersRequest): ListAckClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAckClustersWithOptions(request, headers, runtime);
}

async function listAckClustersWithOptions(request: ListAckClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAckClustersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['vpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListAckClusters',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAckNamespacesRequest {
  body?: string(name='body'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListAckNamespacesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      namespace?: string(name='namespace'),
      status?: string(name='status'),
    }
  ](name='Result'),
}

model ListAckNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAckNamespacesResponseBody(name='body'),
}

async function listAckNamespaces(ClusterId: string, request: ListAckNamespacesRequest): ListAckNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAckNamespacesWithOptions(ClusterId, request, headers, runtime);
}

async function listAckNamespacesWithOptions(ClusterId: string, request: ListAckNamespacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAckNamespacesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListAckNamespaces',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters/${OpenApiUtil.getEncodeParam(ClusterId)}/namespaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListActionRecordsRequest {
  actionNames?: string(name='actionNames'),
  body?: string(name='body'),
  endTime?: long(name='endTime'),
  filter?: string(name='filter'),
  page?: int32(name='page'),
  requestId?: string(name='requestId'),
  size?: int32(name='size'),
  startTime?: long(name='startTime'),
  userId?: string(name='userId'),
}

model ListActionRecordsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      actionName?: string(name='ActionName'),
      actionParams?: map[string]any(name='ActionParams'),
      actionResultAccessList?: [ string ](name='ActionResultAccessList'),
      endTime?: long(name='EndTime'),
      instanceId?: string(name='InstanceId'),
      metaNow?: string(name='MetaNow'),
      metaOld?: string(name='MetaOld'),
      ownerId?: string(name='OwnerId'),
      process?: string(name='Process'),
      recordDiff?: map[string]any(name='RecordDiff'),
      recordIds?: [ string ](name='RecordIds'),
      requestId?: string(name='RequestId'),
      startTime?: long(name='StartTime'),
      stateType?: string(name='StateType'),
      statusInfo?: [ 
        {
          completeNodeCount?: int32(name='completeNodeCount'),
          endTime?: long(name='endTime'),
          exception?: string(name='exception'),
          latencyMills?: long(name='latencyMills'),
          nodeCount?: int32(name='nodeCount'),
          process?: string(name='process'),
          startTime?: long(name='startTime'),
          stateType?: string(name='stateType'),
          subState?: string(name='subState'),
          subStatusInfo?: [ 
            {
              completeNodeCount?: int32(name='completeNodeCount'),
              endTime?: long(name='endTime'),
              exception?: string(name='exception'),
              latencyMills?: long(name='latencyMills'),
              nodeCount?: int32(name='nodeCount'),
              process?: string(name='process'),
              startTime?: long(name='startTime'),
              stateType?: string(name='stateType'),
              subState?: string(name='subState'),
            }
          ](name='subStatusInfo'),
        }
      ](name='StatusInfo'),
      userId?: string(name='UserId'),
      userInfo?: string(name='UserInfo'),
      userType?: string(name='UserType'),
    }
  ](name='Result'),
}

model ListActionRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListActionRecordsResponseBody(name='body'),
}

async function listActionRecords(InstanceId: string, request: ListActionRecordsRequest): ListActionRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listActionRecordsWithOptions(InstanceId, request, headers, runtime);
}

async function listActionRecordsWithOptions(InstanceId: string, request: ListActionRecordsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListActionRecordsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.actionNames)) {
    query['actionNames'] = request.actionNames;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filter)) {
    query['filter'] = request.filter;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.requestId)) {
    query['requestId'] = request.requestId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.userId)) {
    query['userId'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListActionRecords',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/action-records`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAllNodeRequest {
  body?: string(name='body'),
  extended?: boolean(name='extended'),
}

model ListAllNodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      cpuPercent?: string(name='cpuPercent'),
      diskUsedPercent?: string(name='diskUsedPercent'),
      health?: string(name='health'),
      heapPercent?: string(name='heapPercent'),
      host?: string(name='host'),
      loadOneM?: string(name='loadOneM'),
      nodeType?: string(name='nodeType'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='Result'),
}

model ListAllNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAllNodeResponseBody(name='body'),
}

async function listAllNode(InstanceId: string, request: ListAllNodeRequest): ListAllNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAllNodeWithOptions(InstanceId, request, headers, runtime);
}

async function listAllNodeWithOptions(InstanceId: string, request: ListAllNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAllNodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.extended)) {
    query['extended'] = request.extended;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListAllNode',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAlternativeSnapshotReposRequest {
  alreadySetItems?: boolean(name='alreadySetItems'),
  body?: string(name='body'),
}

model ListAlternativeSnapshotReposResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      instanceId?: string(name='instanceId'),
      repoPath?: string(name='repoPath'),
    }
  ](name='Result'),
}

model ListAlternativeSnapshotReposResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlternativeSnapshotReposResponseBody(name='body'),
}

async function listAlternativeSnapshotRepos(InstanceId: string, request: ListAlternativeSnapshotReposRequest): ListAlternativeSnapshotReposResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlternativeSnapshotReposWithOptions(InstanceId, request, headers, runtime);
}

async function listAlternativeSnapshotReposWithOptions(InstanceId: string, request: ListAlternativeSnapshotReposRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlternativeSnapshotReposResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.alreadySetItems)) {
    query['alreadySetItems'] = request.alreadySetItems;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListAlternativeSnapshotRepos',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/alternative-snapshot-repos`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListApmRequest {
  body?: string(name='body'),
  description?: string(name='description'),
  instanceId?: string(name='instanceId'),
  output?: string(name='output'),
  page?: long(name='page'),
  size?: long(name='size'),
}

model ListApmResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createdAt?: string(name='createdAt'),
      deployedReplica?: long(name='deployedReplica'),
      description?: string(name='description'),
      instanceId?: string(name='instanceId'),
      nodeAmount?: long(name='nodeAmount'),
      outputES?: string(name='outputES'),
      outputESUserName?: string(name='outputESUserName'),
      ownerId?: string(name='ownerId'),
      paymentType?: string(name='paymentType'),
      region?: string(name='region'),
      replica?: long(name='replica'),
      resourceSpec?: string(name='resourceSpec'),
      status?: string(name='status'),
      version?: string(name='version'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }
  ](name='Result'),
}

model ListApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApmResponseBody(name='body'),
}

async function listApm(request: ListApmRequest): ListApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listApmWithOptions(request, headers, runtime);
}

async function listApmWithOptions(request: ListApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListApmResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.output)) {
    query['output'] = request.output;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAvailableEsInstanceIdsRequest {
  body?: string(name='body'),
}

model ListAvailableEsInstanceIdsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      endpoint?: string(name='endpoint'),
      esInstanceId?: string(name='esInstanceId'),
      kibanaEndpoint?: string(name='kibanaEndpoint'),
    }
  ](name='Result'),
}

model ListAvailableEsInstanceIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAvailableEsInstanceIdsResponseBody(name='body'),
}

async function listAvailableEsInstanceIds(InstanceId: string, request: ListAvailableEsInstanceIdsRequest): ListAvailableEsInstanceIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAvailableEsInstanceIdsWithOptions(InstanceId, request, headers, runtime);
}

async function listAvailableEsInstanceIdsWithOptions(InstanceId: string, request: ListAvailableEsInstanceIdsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAvailableEsInstanceIdsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableEsInstanceIds',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/available-elasticsearch-for-centralized-management`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListCollectorsRequest {
  body?: string(name='body'),
  instanceId?: string(name='instanceId'),
  name?: string(name='name'),
  page?: int32(name='page'),
  resId?: string(name='resId'),
  size?: int32(name='size'),
  sourceType?: string(name='sourceType'),
}

model ListCollectorsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      collectorPaths?: [ string ](name='collectorPaths'),
      configs?: [ 
        {
          content?: string(name='content'),
          fileName?: string(name='fileName'),
        }
      ](name='configs'),
      dryRun?: boolean(name='dryRun'),
      extendConfigs?: [ 
        {
          configType?: string(name='configType'),
          enableMonitoring?: boolean(name='enableMonitoring'),
          groupId?: string(name='groupId'),
          host?: string(name='host'),
          hosts?: [ string ](name='hosts'),
          instanceId?: string(name='instanceId'),
          instanceType?: string(name='instanceType'),
          kibanaHost?: string(name='kibanaHost'),
          machines?: [ 
            {
              agentStatus?: string(name='agentStatus'),
              instanceId?: string(name='instanceId'),
            }
          ](name='machines'),
          protocol?: string(name='protocol'),
          successPodsCount?: string(name='successPodsCount'),
          totalPodsCount?: string(name='totalPodsCount'),
          type?: string(name='type'),
          userName?: string(name='userName'),
        }
      ](name='extendConfigs'),
      gmtCreatedTime?: string(name='gmtCreatedTime'),
      gmtUpdateTime?: string(name='gmtUpdateTime'),
      name?: string(name='name'),
      ownerId?: string(name='ownerId'),
      resId?: string(name='resId'),
      resType?: string(name='resType'),
      resVersion?: string(name='resVersion'),
      status?: string(name='status'),
      vpcId?: string(name='vpcId'),
    }
  ](name='Result'),
}

model ListCollectorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCollectorsResponseBody(name='body'),
}

async function listCollectors(request: ListCollectorsRequest): ListCollectorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCollectorsWithOptions(request, headers, runtime);
}

async function listCollectorsWithOptions(request: ListCollectorsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCollectorsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.resId)) {
    query['resId'] = request.resId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['sourceType'] = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListCollectors',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListComponentIndicesRequest {
  name?: string(name='name'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListComponentIndicesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      composed?: [ string ](name='composed'),
      content?: {
        meta?: map[string]any(name='_meta'),
        template?: {
          settings?: {
            index?: {
              codec?: string(name='codec'),
              lifecycle?: {
                name?: string(name='name'),
              }(name='lifecycle'),
            }(name='index'),
          }(name='settings'),
        }(name='template'),
        version?: long(name='version'),
      }(name='content'),
      name?: string(name='name'),
    }
  ](name='Result'),
}

model ListComponentIndicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListComponentIndicesResponseBody(name='body'),
}

async function listComponentIndices(InstanceId: string, request: ListComponentIndicesRequest): ListComponentIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentIndicesWithOptions(InstanceId, request, headers, runtime);
}

async function listComponentIndicesWithOptions(InstanceId: string, request: ListComponentIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentIndicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListComponentIndices',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListConnectedClustersRequest {
  body?: string(name='body'),
}

model ListConnectedClustersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    result?: [ 
    {
      instances?: string(name='instances'),
      networkType?: string(name='networkType'),
    }
  ](name='Result')
  }(name='Result'),
}

model ListConnectedClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConnectedClustersResponseBody(name='body'),
}

async function listConnectedClusters(InstanceId: string, request: ListConnectedClustersRequest): ListConnectedClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConnectedClustersWithOptions(InstanceId, request, headers, runtime);
}

async function listConnectedClustersWithOptions(InstanceId: string, request: ListConnectedClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConnectedClustersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListConnectedClusters',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connected-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataStreamsRequest {
  body?: string(name='body'),
  isManaged?: boolean(name='isManaged'),
  name?: string(name='name'),
}

model ListDataStreamsResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      health?: string(name='health'),
      ilmPolicyName?: string(name='ilmPolicyName'),
      indexTemplateName?: string(name='indexTemplateName'),
      indices?: [ 
        {
          createTime?: string(name='createTime'),
          health?: string(name='health'),
          isManaged?: boolean(name='isManaged'),
          managedStatus?: string(name='managedStatus'),
          name?: string(name='name'),
          size?: long(name='size'),
        }
      ](name='indices'),
      managedStorageSize?: long(name='managedStorageSize'),
      name?: string(name='name'),
      totalStorageSize?: long(name='totalStorageSize'),
    }
  ](name='Result'),
}

model ListDataStreamsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataStreamsResponseBody(name='body'),
}

async function listDataStreams(InstanceId: string, request: ListDataStreamsRequest): ListDataStreamsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataStreamsWithOptions(InstanceId, request, headers, runtime);
}

async function listDataStreamsWithOptions(InstanceId: string, request: ListDataStreamsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataStreamsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.isManaged)) {
    query['isManaged'] = request.isManaged;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListDataStreams',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataTasksRequest {
  body?: string(name='body'),
}

model ListDataTasksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='createTime'),
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        endpoint?: string(name='endpoint'),
        index?: string(name='index'),
        type?: string(name='type'),
        vpcId?: string(name='vpcId'),
        vpcInstanceId?: string(name='vpcInstanceId'),
        vpcInstancePort?: string(name='vpcInstancePort'),
      }(name='sinkCluster'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        index?: string(name='index'),
        mapping?: string(name='mapping'),
        routing?: string(name='routing'),
        settings?: string(name='settings'),
        type?: string(name='type'),
      }(name='sourceCluster'),
      status?: string(name='status'),
      taskId?: string(name='taskId'),
    }
  ](name='Result'),
}

model ListDataTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataTasksResponseBody(name='body'),
}

async function listDataTasks(InstanceId: string, request: ListDataTasksRequest): ListDataTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataTasksWithOptions(InstanceId, request, headers, runtime);
}

async function listDataTasksWithOptions(InstanceId: string, request: ListDataTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataTasksResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListDataTasks',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-task`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDefaultCollectorConfigurationsRequest {
  body?: string(name='body'),
  resType?: string(name='resType'),
  resVersion?: string(name='resVersion'),
  sourceType?: string(name='sourceType'),
}

model ListDefaultCollectorConfigurationsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      fileName?: string(name='fileName'),
    }
  ](name='Result'),
}

model ListDefaultCollectorConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDefaultCollectorConfigurationsResponseBody(name='body'),
}

async function listDefaultCollectorConfigurations(request: ListDefaultCollectorConfigurationsRequest): ListDefaultCollectorConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDefaultCollectorConfigurationsWithOptions(request, headers, runtime);
}

async function listDefaultCollectorConfigurationsWithOptions(request: ListDefaultCollectorConfigurationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDefaultCollectorConfigurationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resType)) {
    query['resType'] = request.resType;
  }
  if (!Util.isUnset(request.resVersion)) {
    query['resVersion'] = request.resVersion;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['sourceType'] = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListDefaultCollectorConfigurations',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/beats/default-configurations`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeprecatedTemplatesRequest {
  body?: string(name='body'),
  name?: string(name='name'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListDeprecatedTemplatesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate'),
      order?: long(name='order'),
      template?: {
        aliases?: string(name='aliases'),
        mappings?: string(name='mappings'),
        settings?: string(name='settings'),
      }(name='template'),
      version?: string(name='version'),
    }
  ](name='Result'),
}

model ListDeprecatedTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeprecatedTemplatesResponseBody(name='body'),
}

async function listDeprecatedTemplates(InstanceId: string, request: ListDeprecatedTemplatesRequest): ListDeprecatedTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeprecatedTemplatesWithOptions(InstanceId, request, headers, runtime);
}

async function listDeprecatedTemplatesWithOptions(InstanceId: string, request: ListDeprecatedTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeprecatedTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListDeprecatedTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/deprecated-templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDiagnoseIndicesRequest {
  body?: string(name='body'),
  lang?: string(name='lang'),
}

model ListDiagnoseIndicesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseIndicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnoseIndicesResponseBody(name='body'),
}

async function listDiagnoseIndices(InstanceId: string, request: ListDiagnoseIndicesRequest): ListDiagnoseIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseIndicesWithOptions(InstanceId, request, headers, runtime);
}

async function listDiagnoseIndicesWithOptions(InstanceId: string, request: ListDiagnoseIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseIndicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnoseIndices',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/indices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDiagnoseReportRequest {
  detail?: boolean(name='detail'),
  endTime?: long(name='endTime'),
  lang?: string(name='lang'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  startTime?: long(name='startTime'),
  trigger?: string(name='trigger'),
}

model ListDiagnoseReportResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: long(name='createTime'),
      diagnoseItems?: [ 
        {
          detail?: {
            desc?: string(name='desc'),
            name?: string(name='name'),
            result?: string(name='result'),
            suggest?: string(name='suggest'),
            type?: string(name='type'),
          }(name='detail'),
          health?: string(name='health'),
          item?: string(name='item'),
        }
      ](name='diagnoseItems'),
      health?: string(name='health'),
      instanceId?: string(name='instanceId'),
      reportId?: string(name='reportId'),
      state?: string(name='state'),
      trigger?: string(name='trigger'),
    }
  ](name='Result'),
}

model ListDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnoseReportResponseBody(name='body'),
}

async function listDiagnoseReport(InstanceId: string, request: ListDiagnoseReportRequest): ListDiagnoseReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseReportWithOptions(InstanceId, request, headers, runtime);
}

async function listDiagnoseReportWithOptions(InstanceId: string, request: ListDiagnoseReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseReportResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.detail)) {
    query['detail'] = request.detail;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnoseReport',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/reports`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDiagnoseReportIdsRequest {
  body?: string(name='body'),
  endTime?: long(name='endTime'),
  lang?: string(name='lang'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  startTime?: long(name='startTime'),
  trigger?: string(name='trigger'),
}

model ListDiagnoseReportIdsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseReportIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDiagnoseReportIdsResponseBody(name='body'),
}

async function listDiagnoseReportIds(InstanceId: string, request: ListDiagnoseReportIdsRequest): ListDiagnoseReportIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseReportIdsWithOptions(InstanceId, request, headers, runtime);
}

async function listDiagnoseReportIdsWithOptions(InstanceId: string, request: ListDiagnoseReportIdsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseReportIdsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnoseReportIds',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/report-ids`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDictInformationRequest {
  analyzerType?: string(name='analyzerType'),
  body?: string(name='body'),
  bucketName?: string(name='bucketName'),
  key?: string(name='key'),
}

model ListDictInformationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    fileSize?: long(name='fileSize'),
    ossObject?: {
      bucketName?: string(name='bucketName'),
      etag?: string(name='etag'),
      key?: string(name='key'),
    }(name='ossObject'),
    type?: string(name='type'),
  }(name='Result'),
}

model ListDictInformationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDictInformationResponseBody(name='body'),
}

async function listDictInformation(InstanceId: string, request: ListDictInformationRequest): ListDictInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDictInformationWithOptions(InstanceId, request, headers, runtime);
}

async function listDictInformationWithOptions(InstanceId: string, request: ListDictInformationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDictInformationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.analyzerType)) {
    query['analyzerType'] = request.analyzerType;
  }
  if (!Util.isUnset(request.bucketName)) {
    query['bucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.key)) {
    query['key'] = request.key;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListDictInformation',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dict/_info`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDictsRequest {
  analyzerType?: string(name='analyzerType'),
  body?: string(name='body'),
  name?: string(name='name'),
}

model ListDictsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      downloadUrl?: string(name='downloadUrl'),
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model ListDictsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDictsResponseBody(name='body'),
}

async function listDicts(InstanceId: string, request: ListDictsRequest): ListDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDictsWithOptions(InstanceId, request, headers, runtime);
}

async function listDictsWithOptions(InstanceId: string, request: ListDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDictsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.analyzerType)) {
    query['analyzerType'] = request.analyzerType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListDicts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dicts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEcsInstancesRequest {
  body?: string(name='body'),
  ecsInstanceIds?: string(name='ecsInstanceIds'),
  ecsInstanceName?: string(name='ecsInstanceName'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  tags?: string(name='tags'),
  vpcId?: string(name='vpcId'),
}

model ListEcsInstancesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      cloudAssistantStatus?: string(name='cloudAssistantStatus'),
      collectors?: [ 
        {
          collectorPaths?: [ string ](name='collectorPaths'),
          configs?: [ 
            {
              content?: string(name='content'),
              fileName?: string(name='fileName'),
            }
          ](name='configs'),
          dryRun?: boolean(name='dryRun'),
          extendConfigs?: [ 
            {
              configType?: string(name='configType'),
              enableMonitoring?: boolean(name='enableMonitoring'),
              groupId?: string(name='groupId'),
              hosts?: [ string ](name='hosts'),
              instanceId?: string(name='instanceId'),
              instanceType?: string(name='instanceType'),
              machines?: [ 
                {
                  agentStatus?: string(name='agentStatus'),
                  instanceId?: string(name='instanceId'),
                }
              ](name='machines'),
              protocol?: string(name='protocol'),
              type?: string(name='type'),
              userName?: string(name='userName'),
            }
          ](name='extendConfigs'),
          gmtCreatedTime?: string(name='gmtCreatedTime'),
          gmtUpdateTime?: string(name='gmtUpdateTime'),
          name?: string(name='name'),
          ownerId?: string(name='ownerId'),
          resId?: string(name='resId'),
          resType?: string(name='resType'),
          resVersion?: string(name='resVersion'),
          status?: string(name='status'),
          vpcId?: string(name='vpcId'),
        }
      ](name='collectors'),
      ecsInstanceId?: string(name='ecsInstanceId'),
      ecsInstanceName?: string(name='ecsInstanceName'),
      ipAddress?: [ 
        {
          host?: string(name='host'),
          ipType?: string(name='ipType'),
        }
      ](name='ipAddress'),
      osType?: string(name='osType'),
      status?: string(name='status'),
      tags?: string(name='tags'),
    }
  ](name='Result'),
}

model ListEcsInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEcsInstancesResponseBody(name='body'),
}

async function listEcsInstances(request: ListEcsInstancesRequest): ListEcsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEcsInstancesWithOptions(request, headers, runtime);
}

async function listEcsInstancesWithOptions(request: ListEcsInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEcsInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.ecsInstanceIds)) {
    query['ecsInstanceIds'] = request.ecsInstanceIds;
  }
  if (!Util.isUnset(request.ecsInstanceName)) {
    query['ecsInstanceName'] = request.ecsInstanceName;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['vpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListEcsInstances',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ecs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListExtendfilesRequest {
  body?: string(name='body'),
}

model ListExtendfilesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      filePath?: string(name='filePath'),
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
    }
  ](name='Result'),
}

model ListExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExtendfilesResponseBody(name='body'),
}

async function listExtendfiles(InstanceId: string, request: ListExtendfilesRequest): ListExtendfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExtendfilesWithOptions(InstanceId, request, headers, runtime);
}

async function listExtendfilesWithOptions(InstanceId: string, request: ListExtendfilesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListExtendfilesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListExtendfiles',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/extendfiles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListILMPoliciesRequest {
  body?: string(name='body'),
  policyName?: string(name='policyName'),
}

model ListILMPoliciesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      name?: string(name='name'),
      phases?: map[string]any(name='phases'),
    }
  ](name='Result'),
}

model ListILMPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListILMPoliciesResponseBody(name='body'),
}

async function listILMPolicies(InstanceId: string, request: ListILMPoliciesRequest): ListILMPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listILMPoliciesWithOptions(InstanceId, request, headers, runtime);
}

async function listILMPoliciesWithOptions(InstanceId: string, request: ListILMPoliciesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListILMPoliciesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.policyName)) {
    query['policyName'] = request.policyName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListILMPolicies',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIndexTemplatesRequest {
  body?: string(name='body'),
  indexTemplate?: string(name='indexTemplate'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListIndexTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream'),
      ilmPolicy?: string(name='ilmPolicy'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate'),
      priority?: int32(name='priority'),
      template?: {
        aliases?: string(name='aliases'),
        mappings?: string(name='mappings'),
        settings?: string(name='settings'),
      }(name='template'),
    }
  ](name='Result'),
}

model ListIndexTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIndexTemplatesResponseBody(name='body'),
}

async function listIndexTemplates(InstanceId: string, request: ListIndexTemplatesRequest): ListIndexTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIndexTemplatesWithOptions(InstanceId, request, headers, runtime);
}

async function listIndexTemplatesWithOptions(InstanceId: string, request: ListIndexTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIndexTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.indexTemplate)) {
    query['indexTemplate'] = request.indexTemplate;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListIndexTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstanceRequest {
  description?: string(name='description'),
  esVersion?: string(name='esVersion'),
  instanceCategory?: string(name='instanceCategory'),
  instanceId?: string(name='instanceId'),
  page?: int32(name='page'),
  paymentType?: string(name='paymentType'),
  resourceGroupId?: string(name='resourceGroupId'),
  size?: int32(name='size'),
  tags?: string(name='tags'),
  vpcId?: string(name='vpcId'),
  zoneId?: string(name='zoneId'),
}

model ListInstanceResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
      clientNodeConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='clientNodeConfiguration'),
      createdAt?: string(name='createdAt'),
      dedicateMaster?: boolean(name='dedicateMaster'),
      description?: string(name='description'),
      elasticDataNodeConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskEncryption?: boolean(name='diskEncryption'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='elasticDataNodeConfiguration'),
      esVersion?: string(name='esVersion'),
      extendConfigs?: [  map[string]any ](name='extendConfigs'),
      instanceId?: string(name='instanceId'),
      isNewDeployment?: string(name='isNewDeployment'),
      kibanaConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='kibanaConfiguration'),
      masterConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='masterConfiguration'),
      networkConfig?: {
        type?: string(name='type'),
        vpcId?: string(name='vpcId'),
        vsArea?: string(name='vsArea'),
        vswitchId?: string(name='vswitchId'),
      }(name='networkConfig'),
      nodeAmount?: int32(name='nodeAmount'),
      nodeSpec?: {
        disk?: int32(name='disk'),
        diskEncryption?: boolean(name='diskEncryption'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='nodeSpec'),
      paymentType?: string(name='paymentType'),
      postpaidServiceStatus?: string(name='postpaidServiceStatus'),
      resourceGroupId?: string(name='resourceGroupId'),
      serviceVpc?: boolean(name='serviceVpc'),
      status?: string(name='status'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey'),
          tagValue?: string(name='tagValue'),
        }
      ](name='tags'),
      updatedAt?: string(name='updatedAt'),
    }
  ](name='Result'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceWithOptions(request, headers, runtime);
}

async function listInstanceWithOptions(request: ListInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.esVersion)) {
    query['esVersion'] = request.esVersion;
  }
  if (!Util.isUnset(request.instanceCategory)) {
    query['instanceCategory'] = request.instanceCategory;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.paymentType)) {
    query['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['vpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['zoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstanceHistoryEventsRequest {
  body?: [ 
    {
      desc?: boolean(name='desc'),
      sortField?: string(name='sortField'),
    }
  ](name='body'),
  eventCreateEndTime?: string(name='eventCreateEndTime'),
  eventCreateStartTime?: string(name='eventCreateStartTime'),
  eventCycleStatus?: [ string ](name='eventCycleStatus'),
  eventExecuteEndTime?: string(name='eventExecuteEndTime'),
  eventExecuteStartTime?: string(name='eventExecuteStartTime'),
  eventFinashEndTime?: string(name='eventFinashEndTime'),
  eventFinashStartTime?: string(name='eventFinashStartTime'),
  eventLevel?: [ string ](name='eventLevel'),
  eventType?: [ string ](name='eventType'),
  instanceId?: string(name='instanceId'),
  nodeIP?: string(name='nodeIP'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListInstanceHistoryEventsShrinkRequest {
  body?: [ 
    {
      desc?: boolean(name='desc'),
      sortField?: string(name='sortField'),
    }
  ](name='body'),
  eventCreateEndTime?: string(name='eventCreateEndTime'),
  eventCreateStartTime?: string(name='eventCreateStartTime'),
  eventCycleStatusShrink?: string(name='eventCycleStatus'),
  eventExecuteEndTime?: string(name='eventExecuteEndTime'),
  eventExecuteStartTime?: string(name='eventExecuteStartTime'),
  eventFinashEndTime?: string(name='eventFinashEndTime'),
  eventFinashStartTime?: string(name='eventFinashStartTime'),
  eventLevelShrink?: string(name='eventLevel'),
  eventTypeShrink?: string(name='eventType'),
  instanceId?: string(name='instanceId'),
  nodeIP?: string(name='nodeIP'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListInstanceHistoryEventsResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count'),
    xTotalFailed?: long(name='X-Total-Failed'),
    xTotalSuccess?: long(name='X-Total-Success'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      ecsId?: string(name='ecsId'),
      eventCreateTime?: string(name='eventCreateTime'),
      eventCycleStatus?: string(name='eventCycleStatus'),
      eventExecuteTime?: string(name='eventExecuteTime'),
      eventFinashTime?: string(name='eventFinashTime'),
      eventLevel?: string(name='eventLevel'),
      eventType?: string(name='eventType'),
      instanceId?: string(name='instanceId'),
      nodeIP?: string(name='nodeIP'),
      regionId?: string(name='regionId'),
    }
  ](name='Result'),
}

model ListInstanceHistoryEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceHistoryEventsResponseBody(name='body'),
}

async function listInstanceHistoryEvents(request: ListInstanceHistoryEventsRequest): ListInstanceHistoryEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceHistoryEventsWithOptions(request, headers, runtime);
}

async function listInstanceHistoryEventsWithOptions(tmpReq: ListInstanceHistoryEventsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceHistoryEventsResponse {
  Util.validateModel(tmpReq);
  var request = new ListInstanceHistoryEventsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.eventCycleStatus)) {
    request.eventCycleStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventCycleStatus, 'eventCycleStatus', 'simple');
  }
  if (!Util.isUnset(tmpReq.eventLevel)) {
    request.eventLevelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventLevel, 'eventLevel', 'simple');
  }
  if (!Util.isUnset(tmpReq.eventType)) {
    request.eventTypeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventType, 'eventType', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.eventCreateEndTime)) {
    query['eventCreateEndTime'] = request.eventCreateEndTime;
  }
  if (!Util.isUnset(request.eventCreateStartTime)) {
    query['eventCreateStartTime'] = request.eventCreateStartTime;
  }
  if (!Util.isUnset(request.eventCycleStatusShrink)) {
    query['eventCycleStatus'] = request.eventCycleStatusShrink;
  }
  if (!Util.isUnset(request.eventExecuteEndTime)) {
    query['eventExecuteEndTime'] = request.eventExecuteEndTime;
  }
  if (!Util.isUnset(request.eventExecuteStartTime)) {
    query['eventExecuteStartTime'] = request.eventExecuteStartTime;
  }
  if (!Util.isUnset(request.eventFinashEndTime)) {
    query['eventFinashEndTime'] = request.eventFinashEndTime;
  }
  if (!Util.isUnset(request.eventFinashStartTime)) {
    query['eventFinashStartTime'] = request.eventFinashStartTime;
  }
  if (!Util.isUnset(request.eventLevelShrink)) {
    query['eventLevel'] = request.eventLevelShrink;
  }
  if (!Util.isUnset(request.eventTypeShrink)) {
    query['eventType'] = request.eventTypeShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeIP)) {
    query['nodeIP'] = request.nodeIP;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceHistoryEvents',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/events`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstanceIndicesRequest {
  all?: boolean(name='all'),
  isManaged?: boolean(name='isManaged'),
  isOpenstore?: boolean(name='isOpenstore'),
  name?: string(name='name'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListInstanceIndicesResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize'),
    xOSSCount?: int32(name='X-OSS-Count'),
    xOSSStorageSize?: long(name='X-OSS-StorageSize'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='createTime'),
      health?: string(name='health'),
      ilmExplain?: string(name='ilmExplain'),
      isManaged?: string(name='isManaged'),
      managedStatus?: string(name='managedStatus'),
      name?: string(name='name'),
      phase?: string(name='phase'),
      size?: long(name='size'),
    }
  ](name='Result'),
}

model ListInstanceIndicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceIndicesResponseBody(name='body'),
}

async function listInstanceIndices(InstanceId: string, request: ListInstanceIndicesRequest): ListInstanceIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceIndicesWithOptions(InstanceId, request, headers, runtime);
}

async function listInstanceIndicesWithOptions(InstanceId: string, request: ListInstanceIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceIndicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.isManaged)) {
    query['isManaged'] = request.isManaged;
  }
  if (!Util.isUnset(request.isOpenstore)) {
    query['isOpenstore'] = request.isOpenstore;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceIndices',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/indices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListKibanaPluginsRequest {
  body?: string(name='body'),
  page?: string(name='page'),
  size?: int32(name='size'),
}

model ListKibanaPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      source?: string(name='source'),
      specificationUrl?: string(name='specificationUrl'),
      state?: string(name='state'),
    }
  ](name='Result'),
}

model ListKibanaPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListKibanaPluginsResponseBody(name='body'),
}

async function listKibanaPlugins(InstanceId: string, request: ListKibanaPluginsRequest): ListKibanaPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listKibanaPluginsWithOptions(InstanceId, request, headers, runtime);
}

async function listKibanaPluginsWithOptions(InstanceId: string, request: ListKibanaPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListKibanaPluginsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListKibanaPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLogstashRequest {
  body?: string(name='body'),
  description?: string(name='description'),
  instanceId?: string(name='instanceId'),
  ownerId?: string(name='ownerId'),
  page?: int32(name='page'),
  resourceGroupId?: string(name='resourceGroupId'),
  size?: int32(name='size'),
  tags?: string(name='tags'),
  version?: string(name='version'),
}

model ListLogstashResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tags?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tags'),
      createdAt?: string(name='createdAt'),
      description?: string(name='description'),
      instanceId?: string(name='instanceId'),
      networkConfig?: {
        type?: string(name='type'),
        vpcId?: string(name='vpcId'),
        vsArea?: string(name='vsArea'),
        vswitchId?: string(name='vswitchId'),
      }(name='networkConfig'),
      nodeAmount?: int32(name='nodeAmount'),
      nodeSpec?: {
        disk?: int32(name='disk'),
        diskEncryption?: boolean(name='diskEncryption'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='nodeSpec'),
      paymentType?: string(name='paymentType'),
      status?: string(name='status'),
      updatedAt?: string(name='updatedAt'),
      version?: string(name='version'),
    }
  ](name='Result'),
}

model ListLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogstashResponseBody(name='body'),
}

async function listLogstash(request: ListLogstashRequest): ListLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashWithOptions(request, headers, runtime);
}

async function listLogstashWithOptions(request: ListLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['ownerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLogstashLogRequest {
  beginTime?: long(name='beginTime'),
  body?: string(name='body'),
  endTime?: long(name='endTime'),
  page?: int32(name='page'),
  query?: string(name='query'),
  size?: int32(name='size'),
  type?: string(name='type'),
}

model ListLogstashLogResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      host?: string(name='host'),
      instanceId?: string(name='instanceId'),
      level?: string(name='level'),
      timestamp?: long(name='timestamp'),
    }
  ](name='Result'),
}

model ListLogstashLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogstashLogResponseBody(name='body'),
}

async function listLogstashLog(InstanceId: string, request: ListLogstashLogRequest): ListLogstashLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashLogWithOptions(InstanceId, request, headers, runtime);
}

async function listLogstashLogWithOptions(InstanceId: string, request: ListLogstashLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashLogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    query['beginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListLogstashLog',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/search-log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLogstashPluginsRequest {
  name?: string(name='name'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  source?: string(name='source'),
}

model ListLogstashPluginsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      source?: string(name='source'),
      specificationUrl?: string(name='specificationUrl'),
      state?: string(name='state'),
    }
  ](name='Result'),
}

model ListLogstashPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogstashPluginsResponseBody(name='body'),
}

async function listLogstashPlugins(InstanceId: string, request: ListLogstashPluginsRequest): ListLogstashPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashPluginsWithOptions(InstanceId, request, headers, runtime);
}

async function listLogstashPluginsWithOptions(InstanceId: string, request: ListLogstashPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashPluginsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogstashPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListNodesRequest {
  body?: string(name='body'),
  ecsInstanceIds?: string(name='ecsInstanceIds'),
  ecsInstanceName?: string(name='ecsInstanceName'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  tags?: string(name='tags'),
}

model ListNodesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      agentStatus?: string(name='agentStatus'),
      cloudAssistantStatus?: string(name='cloudAssistantStatus'),
      ecsInstanceId?: string(name='ecsInstanceId'),
      ecsInstanceName?: string(name='ecsInstanceName'),
      ipAddress?: [ 
        {
          host?: string(name='host'),
          ipType?: string(name='ipType'),
        }
      ](name='ipAddress'),
      osType?: string(name='osType'),
      status?: string(name='status'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey'),
          tagValue?: string(name='tagValue'),
        }
      ](name='tags'),
    }
  ](name='Result'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodes(ResId: string, request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodesWithOptions(ResId, request, headers, runtime);
}

async function listNodesWithOptions(ResId: string, request: ListNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.ecsInstanceIds)) {
    query['ecsInstanceIds'] = request.ecsInstanceIds;
  }
  if (!Util.isUnset(request.ecsInstanceName)) {
    query['ecsInstanceName'] = request.ecsInstanceName;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPipelineRequest {
  body?: string(name='body'),
  page?: int32(name='page'),
  pipelineId?: string(name='pipelineId'),
  size?: int32(name='size'),
}

model ListPipelineResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      gmtCreatedTime?: string(name='gmtCreatedTime'),
      gmtUpdateTime?: string(name='gmtUpdateTime'),
      pipelineId?: string(name='pipelineId'),
      pipelineStatus?: string(name='pipelineStatus'),
    }
  ](name='Result'),
}

model ListPipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineResponseBody(name='body'),
}

async function listPipeline(InstanceId: string, request: ListPipelineRequest): ListPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineWithOptions(InstanceId, request, headers, runtime);
}

async function listPipelineWithOptions(InstanceId: string, request: ListPipelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['pipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListPipeline',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPipelineIdsRequest {
  body?: string(name='body'),
}

model ListPipelineIdsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      available?: boolean(name='available'),
      code?: string(name='code'),
      message?: string(name='message'),
      pipelineId?: string(name='pipelineId'),
    }
  ](name='Result'),
}

model ListPipelineIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPipelineIdsResponseBody(name='body'),
}

async function listPipelineIds(InstanceId: string, request: ListPipelineIdsRequest): ListPipelineIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineIdsWithOptions(InstanceId, request, headers, runtime);
}

async function listPipelineIdsWithOptions(InstanceId: string, request: ListPipelineIdsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineIdsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListPipelineIds',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/pipeline-ids`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPluginsRequest {
  name?: string(name='name'),
  page?: string(name='page'),
  size?: int32(name='size'),
  source?: string(name='source'),
}

model ListPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      source?: string(name='source'),
      specificationUrl?: string(name='specificationUrl'),
      state?: string(name='state'),
    }
  ](name='Result'),
}

model ListPluginsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPluginsResponseBody(name='body'),
}

async function listPlugins(InstanceId: string, request: ListPluginsRequest): ListPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPluginsWithOptions(InstanceId, request, headers, runtime);
}

async function listPluginsWithOptions(InstanceId: string, request: ListPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPluginsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSearchLogRequest {
  beginTime?: long(name='beginTime'),
  endTime?: long(name='endTime'),
  page?: int32(name='page'),
  query?: string(name='query'),
  size?: int32(name='size'),
  type?: string(name='type'),
}

model ListSearchLogResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      contentCollection?: map[string]any(name='contentCollection'),
      host?: string(name='host'),
      instanceId?: string(name='instanceId'),
      level?: string(name='level'),
      timestamp?: long(name='timestamp'),
    }
  ](name='Result'),
}

model ListSearchLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSearchLogResponseBody(name='body'),
}

async function listSearchLog(InstanceId: string, request: ListSearchLogRequest): ListSearchLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSearchLogWithOptions(InstanceId, request, headers, runtime);
}

async function listSearchLogWithOptions(InstanceId: string, request: ListSearchLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSearchLogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    query['beginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSearchLog',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/search-log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListShardRecoveriesRequest {
  activeOnly?: boolean(name='activeOnly'),
  body?: string(name='body'),
}

model ListShardRecoveriesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      bytesPercent?: string(name='bytesPercent'),
      bytesTotal?: long(name='bytesTotal'),
      filesPercent?: string(name='filesPercent'),
      filesTotal?: long(name='filesTotal'),
      index?: string(name='index'),
      sourceHost?: string(name='sourceHost'),
      sourceNode?: string(name='sourceNode'),
      stage?: string(name='stage'),
      targetHost?: string(name='targetHost'),
      targetNode?: string(name='targetNode'),
      translogOps?: long(name='translogOps'),
      translogOpsPercent?: string(name='translogOpsPercent'),
    }
  ](name='Result'),
}

model ListShardRecoveriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListShardRecoveriesResponseBody(name='body'),
}

async function listShardRecoveries(InstanceId: string, request: ListShardRecoveriesRequest): ListShardRecoveriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShardRecoveriesWithOptions(InstanceId, request, headers, runtime);
}

async function listShardRecoveriesWithOptions(InstanceId: string, request: ListShardRecoveriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListShardRecoveriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.activeOnly)) {
    query['activeOnly'] = request.activeOnly;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListShardRecoveries',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/cat-recovery`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSnapshotReposByInstanceIdRequest {
  body?: string(name='body'),
}

model ListSnapshotReposByInstanceIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      instanceId?: string(name='instanceId'),
      repoPath?: string(name='repoPath'),
      snapWarehouse?: string(name='snapWarehouse'),
      status?: string(name='status'),
    }
  ](name='Result'),
}

model ListSnapshotReposByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSnapshotReposByInstanceIdResponseBody(name='body'),
}

async function listSnapshotReposByInstanceId(InstanceId: string, request: ListSnapshotReposByInstanceIdRequest): ListSnapshotReposByInstanceIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSnapshotReposByInstanceIdWithOptions(InstanceId, request, headers, runtime);
}

async function listSnapshotReposByInstanceIdWithOptions(InstanceId: string, request: ListSnapshotReposByInstanceIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSnapshotReposByInstanceIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListSnapshotReposByInstanceId',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-repos`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  page?: int32(name='Page'),
  resourceIds?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  size?: int32(name='Size'),
  tags?: string(name='Tags'),
}

model ListTagResourcesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        tagKey?: string(name='TagKey'),
        tagValue?: string(name='TagValue'),
      }
    ](name='TagResource'),
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTagsRequest {
  pageSize?: int32(name='pageSize'),
  resourceType?: string(name='resourceType'),
}

model ListTagsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Result'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagsResponseBody(name='body'),
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagsWithOptions(request, headers, runtime);
}

async function listTagsWithOptions(request: ListTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTags',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags/all-tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListVpcEndpointsRequest {
  body?: string(name='body'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListVpcEndpointsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      connectionStatus?: string(name='connectionStatus'),
      createTime?: string(name='createTime'),
      endpointBusinessStatus?: string(name='endpointBusinessStatus'),
      endpointDomain?: string(name='endpointDomain'),
      endpointId?: string(name='endpointId'),
      endpointName?: string(name='endpointName'),
      endpointStatus?: string(name='endpointStatus'),
      serviceId?: string(name='serviceId'),
      serviceName?: string(name='serviceName'),
    }
  ](name='Result'),
}

model ListVpcEndpointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcEndpointsResponseBody(name='body'),
}

async function listVpcEndpoints(InstanceId: string, request: ListVpcEndpointsRequest): ListVpcEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcEndpointsWithOptions(InstanceId, request, headers, runtime);
}

async function listVpcEndpointsWithOptions(InstanceId: string, request: ListVpcEndpointsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcEndpointsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListVpcEndpoints',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/vpc-endpoints`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model MigrateToOtherZoneRequest {
  body?: string(name='body'),
  dryRun?: boolean(name='dryRun'),
}

model MigrateToOtherZoneResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model MigrateToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateToOtherZoneResponseBody(name='body'),
}

async function migrateToOtherZone(InstanceId: string, request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateToOtherZoneWithOptions(InstanceId, request, headers, runtime);
}

async function migrateToOtherZoneWithOptions(InstanceId: string, request: MigrateToOtherZoneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateToOtherZoneResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'MigrateToOtherZone',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/migrate-zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyDeployMachineRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model ModifyDeployMachineResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyDeployMachineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDeployMachineResponseBody(name='body'),
}

async function modifyDeployMachine(ResId: string, request: ModifyDeployMachineRequest): ModifyDeployMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyDeployMachineWithOptions(ResId, request, headers, runtime);
}

async function modifyDeployMachineWithOptions(ResId: string, request: ModifyDeployMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyDeployMachineResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyDeployMachine',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/modify-deploy-machines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyElastictaskRequest {
  body?: string(name='body'),
}

model ModifyElastictaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model ModifyElastictaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyElastictaskResponseBody(name='body'),
}

async function modifyElastictask(InstanceId: string, request: ModifyElastictaskRequest): ModifyElastictaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyElastictaskWithOptions(InstanceId, request, headers, runtime);
}

async function modifyElastictaskWithOptions(InstanceId: string, request: ModifyElastictaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyElastictaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyElastictask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/elastic-task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyInstanceMaintainTimeRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model ModifyInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyInstanceMaintainTime(InstanceId: string, request: ModifyInstanceMaintainTimeRequest): ModifyInstanceMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyInstanceMaintainTimeWithOptions(InstanceId, request, headers, runtime);
}

async function modifyInstanceMaintainTimeWithOptions(InstanceId: string, request: ModifyInstanceMaintainTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyInstanceMaintainTimeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceMaintainTime',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/modify-maintaintime`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyWhiteIpsRequest {
  modifyMode?: string(name='modifyMode'),
  networkType?: string(name='networkType'),
  nodeType?: string(name='nodeType'),
  whiteIpGroup?: {
    groupName?: string(name='groupName'),
    ips?: [ string ](name='ips'),
    whiteIpType?: string(name='whiteIpType'),
  }(name='whiteIpGroup'),
  whiteIpList?: [ string ](name='whiteIpList'),
  clientToken?: string(name='clientToken'),
}

model ModifyWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWhiteIpsResponseBody(name='body'),
}

async function modifyWhiteIps(InstanceId: string, request: ModifyWhiteIpsRequest): ModifyWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function modifyWhiteIpsWithOptions(InstanceId: string, request: ModifyWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.modifyMode)) {
    body['modifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.networkType)) {
    body['networkType'] = request.networkType;
  }
  if (!Util.isUnset(request.nodeType)) {
    body['nodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body['whiteIpGroup'] = request.whiteIpGroup;
  }
  if (!Util.isUnset(request.whiteIpList)) {
    body['whiteIpList'] = request.whiteIpList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/modify-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model MoveResourceGroupRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    esVersion?: string(name='esVersion'),
    instanceId?: string(name='instanceId'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaPort?: int32(name='kibanaPort'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    publicDomain?: string(name='publicDomain'),
    publicPort?: int32(name='publicPort'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    updatedAt?: string(name='updatedAt'),
  }(name='Result'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroup(InstanceId: string, request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return moveResourceGroupWithOptions(InstanceId, request, headers, runtime);
}

async function moveResourceGroupWithOptions(InstanceId: string, request: MoveResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'MoveResourceGroup',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/resourcegroup`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model OpenDiagnosisRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
  lang?: string(name='lang'),
}

model OpenDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model OpenDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenDiagnosisResponseBody(name='body'),
}

async function openDiagnosis(InstanceId: string, request: OpenDiagnosisRequest): OpenDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openDiagnosisWithOptions(InstanceId, request, headers, runtime);
}

async function openDiagnosisWithOptions(InstanceId: string, request: OpenDiagnosisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenDiagnosisResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'OpenDiagnosis',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/open-diagnosis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model OpenHttpsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model OpenHttpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model OpenHttpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenHttpsResponseBody(name='body'),
}

async function openHttps(InstanceId: string, request: OpenHttpsRequest): OpenHttpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openHttpsWithOptions(InstanceId, request, headers, runtime);
}

async function openHttpsWithOptions(InstanceId: string, request: OpenHttpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenHttpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'OpenHttps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/open-https`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PostEmonTryAlarmRuleRequest {
  body?: string(name='body'),
}

model PostEmonTryAlarmRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PostEmonTryAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PostEmonTryAlarmRuleResponseBody(name='body'),
}

async function postEmonTryAlarmRule(ProjectId: string, AlarmGroupId: string, request: PostEmonTryAlarmRuleRequest): PostEmonTryAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return postEmonTryAlarmRuleWithOptions(ProjectId, AlarmGroupId, request, headers, runtime);
}

async function postEmonTryAlarmRuleWithOptions(ProjectId: string, AlarmGroupId: string, request: PostEmonTryAlarmRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PostEmonTryAlarmRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'PostEmonTryAlarmRule',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/alarm-groups/${OpenApiUtil.getEncodeParam(AlarmGroupId)}/alarm-rules/_test`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RecommendTemplatesRequest {
  body?: string(name='body'),
  usageScenario?: string(name='usageScenario'),
}

model RecommendTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      templateName?: string(name='templateName'),
    }
  ](name='Result'),
}

model RecommendTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecommendTemplatesResponseBody(name='body'),
}

async function recommendTemplates(InstanceId: string, request: RecommendTemplatesRequest): RecommendTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return recommendTemplatesWithOptions(InstanceId, request, headers, runtime);
}

async function recommendTemplatesWithOptions(InstanceId: string, request: RecommendTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RecommendTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.usageScenario)) {
    query['usageScenario'] = request.usageScenario;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RecommendTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/recommended-templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ReinstallCollectorRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model ReinstallCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ReinstallCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReinstallCollectorResponseBody(name='body'),
}

async function reinstallCollector(ResId: string, request: ReinstallCollectorRequest): ReinstallCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return reinstallCollectorWithOptions(ResId, request, headers, runtime);
}

async function reinstallCollectorWithOptions(ResId: string, request: ReinstallCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReinstallCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ReinstallCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/reinstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveApmRequest {
  body?: string(name='body'),
}

model RemoveApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RemoveApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveApmResponseBody(name='body'),
}

async function removeApm(instanceId: string, request: RemoveApmRequest): RemoveApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeApmWithOptions(instanceId, request, headers, runtime);
}

async function removeApmWithOptions(instanceId: string, request: RemoveApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveApmResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RemoveApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RenewInstanceRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model RenewInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(InstanceId: string, request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function renewInstanceWithOptions(InstanceId: string, request: RenewInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/renew`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RenewLogstashRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model RenewLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RenewLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewLogstashResponseBody(name='body'),
}

async function renewLogstash(InstanceId: string, request: RenewLogstashRequest): RenewLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewLogstashWithOptions(InstanceId, request, headers, runtime);
}

async function renewLogstashWithOptions(InstanceId: string, request: RenewLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RenewLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/renew`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RestartCollectorRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model RestartCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RestartCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartCollectorResponseBody(name='body'),
}

async function restartCollector(ResId: string, request: RestartCollectorRequest): RestartCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartCollectorWithOptions(ResId, request, headers, runtime);
}

async function restartCollectorWithOptions(ResId: string, request: RestartCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RestartCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RestartInstanceRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  force?: boolean(name='force'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    esVersion?: string(name='esVersion'),
    instanceId?: string(name='instanceId'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaPort?: int32(name='kibanaPort'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    publicDomain?: string(name='publicDomain'),
    publicPort?: int32(name='publicPort'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    updatedAt?: string(name='updatedAt'),
  }(name='Result'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartInstanceResponseBody(name='body'),
}

async function restartInstance(InstanceId: string, request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function restartInstanceWithOptions(InstanceId: string, request: RestartInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RestartInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RestartLogstashRequest {
  batchCount?: double(name='batchCount'),
  blueGreenDep?: boolean(name='blueGreenDep'),
  nodeTypes?: [ string ](name='nodeTypes'),
  nodes?: [ string ](name='nodes'),
  restartType?: string(name='restartType'),
  clientToken?: string(name='clientToken'),
  force?: boolean(name='force'),
}

model RestartLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: Logstash(name='Result'),
}

model RestartLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartLogstashResponseBody(name='body'),
}

async function restartLogstash(InstanceId: string, request: RestartLogstashRequest): RestartLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartLogstashWithOptions(InstanceId, request, headers, runtime);
}

async function restartLogstashWithOptions(InstanceId: string, request: RestartLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.batchCount)) {
    body['batchCount'] = request.batchCount;
  }
  if (!Util.isUnset(request.blueGreenDep)) {
    body['blueGreenDep'] = request.blueGreenDep;
  }
  if (!Util.isUnset(request.nodeTypes)) {
    body['nodeTypes'] = request.nodeTypes;
  }
  if (!Util.isUnset(request.nodes)) {
    body['nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.restartType)) {
    body['restartType'] = request.restartType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestartLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ResumeElasticsearchTaskRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model ResumeElasticsearchTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ResumeElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeElasticsearchTaskResponseBody(name='body'),
}

async function resumeElasticsearchTask(InstanceId: string, request: ResumeElasticsearchTaskRequest): ResumeElasticsearchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeElasticsearchTaskWithOptions(InstanceId, request, headers, runtime);
}

async function resumeElasticsearchTaskWithOptions(InstanceId: string, request: ResumeElasticsearchTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeElasticsearchTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ResumeElasticsearchTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ResumeLogstashTaskRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model ResumeLogstashTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ResumeLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeLogstashTaskResponseBody(name='body'),
}

async function resumeLogstashTask(InstanceId: string, request: ResumeLogstashTaskRequest): ResumeLogstashTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeLogstashTaskWithOptions(InstanceId, request, headers, runtime);
}

async function resumeLogstashTaskWithOptions(InstanceId: string, request: ResumeLogstashTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeLogstashTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ResumeLogstashTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RolloverDataStreamRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model RolloverDataStreamResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RolloverDataStreamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RolloverDataStreamResponseBody(name='body'),
}

async function rolloverDataStream(InstanceId: string, DataStream: string, request: RolloverDataStreamRequest): RolloverDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rolloverDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime);
}

async function rolloverDataStreamWithOptions(InstanceId: string, DataStream: string, request: RolloverDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RolloverDataStreamResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RolloverDataStream',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams/${OpenApiUtil.getEncodeParam(DataStream)}/rollover`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RunPipelinesRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model RunPipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RunPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunPipelinesResponseBody(name='body'),
}

async function runPipelines(InstanceId: string, request: RunPipelinesRequest): RunPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runPipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function runPipelinesWithOptions(InstanceId: string, request: RunPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RunPipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RunPipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines/action/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ShrinkNodeRequest {
  body?: [ 
    {
      host?: string(name='host'),
      hostName?: string(name='hostName'),
      nodeType?: string(name='nodeType'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='body'),
  clientToken?: string(name='clientToken'),
  count?: int32(name='count'),
  ignoreStatus?: boolean(name='ignoreStatus'),
  nodeType?: string(name='nodeType'),
}

model ShrinkNodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ShrinkNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ShrinkNodeResponseBody(name='body'),
}

async function shrinkNode(InstanceId: string, request: ShrinkNodeRequest): ShrinkNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return shrinkNodeWithOptions(InstanceId, request, headers, runtime);
}

async function shrinkNodeWithOptions(InstanceId: string, request: ShrinkNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ShrinkNodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query['ignoreStatus'] = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ShrinkNode',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/shrink`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartApmRequest {
  body?: string(name='body'),
}

model StartApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StartApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartApmResponseBody(name='body'),
}

async function startApm(instanceId: string, request: StartApmRequest): StartApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startApmWithOptions(instanceId, request, headers, runtime);
}

async function startApmWithOptions(instanceId: string, request: StartApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartApmResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'StartApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}/actions/start`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartCollectorRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model StartCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StartCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartCollectorResponseBody(name='body'),
}

async function startCollector(ResId: string, request: StartCollectorRequest): StartCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startCollectorWithOptions(ResId, request, headers, runtime);
}

async function startCollectorWithOptions(ResId: string, request: StartCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'StartCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/start`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StopApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopApmResponseBody(name='body'),
}

async function stopApm(instanceId: string): StopApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopApmWithOptions(instanceId, headers, runtime);
}

async function stopApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopApmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}/actions/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopCollectorRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model StopCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StopCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopCollectorResponseBody(name='body'),
}

async function stopCollector(ResId: string, request: StopCollectorRequest): StopCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopCollectorWithOptions(ResId, request, headers, runtime);
}

async function stopCollectorWithOptions(ResId: string, request: StopCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'StopCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopPipelinesRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model StopPipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StopPipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopPipelinesResponseBody(name='body'),
}

async function stopPipelines(InstanceId: string, request: StopPipelinesRequest): StopPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopPipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function stopPipelinesWithOptions(InstanceId: string, request: StopPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopPipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'StopPipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines/action/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TagResourcesRequest {
  resourceIds?: [ string ](name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: [ 
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='Tags'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceIds)) {
    body['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TransferNodeRequest {
  body?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='body'),
  clientToken?: string(name='clientToken'),
  nodeType?: string(name='nodeType'),
}

model TransferNodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model TransferNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferNodeResponseBody(name='body'),
}

async function transferNode(InstanceId: string, request: TransferNodeRequest): TransferNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return transferNodeWithOptions(InstanceId, request, headers, runtime);
}

async function transferNodeWithOptions(InstanceId: string, request: TransferNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TransferNodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TransferNode',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/transfer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TriggerNetworkRequest {
  actionType?: string(name='actionType'),
  networkType?: string(name='networkType'),
  nodeType?: string(name='nodeType'),
  clientToken?: string(name='clientToken'),
}

model TriggerNetworkResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model TriggerNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TriggerNetworkResponseBody(name='body'),
}

async function triggerNetwork(InstanceId: string, request: TriggerNetworkRequest): TriggerNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return triggerNetworkWithOptions(InstanceId, request, headers, runtime);
}

async function triggerNetworkWithOptions(InstanceId: string, request: TriggerNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TriggerNetworkResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.actionType)) {
    body['actionType'] = request.actionType;
  }
  if (!Util.isUnset(request.networkType)) {
    body['networkType'] = request.networkType;
  }
  if (!Util.isUnset(request.nodeType)) {
    body['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TriggerNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/network-trigger`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UninstallKibanaPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UninstallKibanaPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model UninstallKibanaPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallKibanaPluginResponseBody(name='body'),
}

async function uninstallKibanaPlugin(InstanceId: string, request: UninstallKibanaPluginRequest): UninstallKibanaPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallKibanaPluginWithOptions(InstanceId, request, headers, runtime);
}

async function uninstallKibanaPluginWithOptions(InstanceId: string, request: UninstallKibanaPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallKibanaPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UninstallKibanaPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-plugins/actions/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UninstallLogstashPluginRequest {
  body?: [ string ](name='body'),
  clientToken?: string(name='clientToken'),
}

model UninstallLogstashPluginResponseBody = {
  headers?: map[string]any(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model UninstallLogstashPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallLogstashPluginResponseBody(name='body'),
}

async function uninstallLogstashPlugin(InstanceId: string, request: UninstallLogstashPluginRequest): UninstallLogstashPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallLogstashPluginWithOptions(InstanceId, request, headers, runtime);
}

async function uninstallLogstashPluginWithOptions(InstanceId: string, request: UninstallLogstashPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallLogstashPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UninstallLogstashPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/actions/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UninstallPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UninstallPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model UninstallPluginResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallPluginResponseBody(name='body'),
}

async function uninstallPlugin(InstanceId: string, request: UninstallPluginRequest): UninstallPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallPluginWithOptions(InstanceId, request, headers, runtime);
}

async function uninstallPluginWithOptions(InstanceId: string, request: UninstallPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UninstallPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/actions/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  resourceIds?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKeys?: string(name='TagKeys'),
  body?: string(name='body'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['TagKeys'] = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateAdminPasswordRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateAdminPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAdminPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAdminPasswordResponseBody(name='body'),
}

async function updateAdminPassword(InstanceId: string, request: UpdateAdminPasswordRequest): UpdateAdminPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAdminPasswordWithOptions(InstanceId, request, headers, runtime);
}

async function updateAdminPasswordWithOptions(InstanceId: string, request: UpdateAdminPasswordRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAdminPasswordResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateAdminPassword',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/admin-pwd`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateAdvancedSettingRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateAdvancedSettingResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateAdvancedSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAdvancedSettingResponseBody(name='body'),
}

async function updateAdvancedSetting(InstanceId: string, request: UpdateAdvancedSettingRequest): UpdateAdvancedSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAdvancedSettingWithOptions(InstanceId, request, headers, runtime);
}

async function updateAdvancedSettingWithOptions(InstanceId: string, request: UpdateAdvancedSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAdvancedSettingResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateAdvancedSetting',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-advanced-setting`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateAliwsDictRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateAliwsDictResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateAliwsDictResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAliwsDictResponseBody(name='body'),
}

async function updateAliwsDict(InstanceId: string, request: UpdateAliwsDictRequest): UpdateAliwsDictResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAliwsDictWithOptions(InstanceId, request, headers, runtime);
}

async function updateAliwsDictWithOptions(InstanceId: string, request: UpdateAliwsDictRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAliwsDictResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateAliwsDict',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/aliws-dict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateApmRequest {
  description?: string(name='description'),
  outputES?: string(name='outputES'),
  outputESPassword?: string(name='outputESPassword'),
  outputESUserName?: string(name='outputESUserName'),
  token?: string(name='token'),
}

model UpdateApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateApmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApmResponseBody(name='body'),
}

async function updateApm(instanceId: string, request: UpdateApmRequest): UpdateApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApmWithOptions(instanceId, request, headers, runtime);
}

async function updateApmWithOptions(instanceId: string, request: UpdateApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApmResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.outputES)) {
    body['outputES'] = request.outputES;
  }
  if (!Util.isUnset(request.outputESPassword)) {
    body['outputESPassword'] = request.outputESPassword;
  }
  if (!Util.isUnset(request.outputESUserName)) {
    body['outputESUserName'] = request.outputESUserName;
  }
  if (!Util.isUnset(request.token)) {
    body['token'] = request.token;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateBlackIpsRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateBlackIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
  }(name='Result'),
}

model UpdateBlackIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBlackIpsResponseBody(name='body'),
}

async function updateBlackIps(InstanceId: string, request: UpdateBlackIpsRequest): UpdateBlackIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateBlackIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updateBlackIpsWithOptions(InstanceId: string, request: UpdateBlackIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateBlackIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBlackIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/black-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateCollectorRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model UpdateCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content'),
        fileName?: string(name='fileName'),
      }
    ](name='configs'),
    dryRun?: boolean(name='dryRun'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType'),
        enableMonitoring?: boolean(name='enableMonitoring'),
        groupId?: string(name='groupId'),
        host?: string(name='host'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId'),
        instanceType?: string(name='instanceType'),
        kibanaHost?: string(name='kibanaHost'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus'),
            instanceId?: string(name='instanceId'),
          }
        ](name='machines'),
        protocol?: string(name='protocol'),
        successPodsCount?: string(name='successPodsCount'),
        totalPodsCount?: string(name='totalPodsCount'),
        type?: string(name='type'),
        userName?: string(name='userName'),
      }
    ](name='extendConfigs'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    name?: string(name='name'),
    ownerId?: string(name='ownerId'),
    resId?: string(name='resId'),
    resType?: string(name='resType'),
    resVersion?: string(name='resVersion'),
    status?: string(name='status'),
    vpcId?: string(name='vpcId'),
  }(name='Result'),
}

model UpdateCollectorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCollectorResponseBody(name='body'),
}

async function updateCollector(ResId: string, request: UpdateCollectorRequest): UpdateCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCollectorWithOptions(ResId, request, headers, runtime);
}

async function updateCollectorWithOptions(ResId: string, request: UpdateCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateCollectorNameRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model UpdateCollectorNameResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content'),
        fileName?: string(name='fileName'),
      }
    ](name='configs'),
    dryRun?: boolean(name='dryRun'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType'),
        enableMonitoring?: boolean(name='enableMonitoring'),
        groupId?: string(name='groupId'),
        host?: string(name='host'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId'),
        instanceType?: string(name='instanceType'),
        kibanaHost?: string(name='kibanaHost'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus'),
            instanceId?: string(name='instanceId'),
          }
        ](name='machines'),
        protocol?: string(name='protocol'),
        successPodsCount?: string(name='successPodsCount'),
        totalPodsCount?: string(name='totalPodsCount'),
        type?: string(name='type'),
        userName?: string(name='userName'),
      }
    ](name='extendConfigs'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    name?: string(name='name'),
    ownerId?: string(name='ownerId'),
    resId?: string(name='resId'),
    resType?: string(name='resType'),
    resVersion?: string(name='resVersion'),
    status?: string(name='status'),
    vpcId?: string(name='vpcId'),
  }(name='Result'),
}

model UpdateCollectorNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCollectorNameResponseBody(name='body'),
}

async function updateCollectorName(ResId: string, request: UpdateCollectorNameRequest): UpdateCollectorNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCollectorNameWithOptions(ResId, request, headers, runtime);
}

async function updateCollectorNameWithOptions(ResId: string, request: UpdateCollectorNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCollectorNameResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateCollectorName',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/rename`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateComponentIndexRequest {
  meta?: map[string]any(name='_meta'),
  template?: {
    aliases?: map[string]any(name='aliases'),
    mappings?: map[string]any(name='mappings'),
    settings?: map[string]any(name='settings'),
  }(name='template'),
}

model UpdateComponentIndexResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateComponentIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateComponentIndexResponseBody(name='body'),
}

async function updateComponentIndex(InstanceId: string, name: string, request: UpdateComponentIndexRequest): UpdateComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateComponentIndexWithOptions(InstanceId, name, request, headers, runtime);
}

async function updateComponentIndexWithOptions(InstanceId: string, name: string, request: UpdateComponentIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateComponentIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meta)) {
    body['_meta'] = request.meta;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDescriptionRequest {
  description?: string(name='description'),
  clientToken?: string(name='clientToken'),
}

model UpdateDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    description?: string(name='description'),
  }(name='Result'),
}

model UpdateDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDescriptionResponseBody(name='body'),
}

async function updateDescription(InstanceId: string, request: UpdateDescriptionRequest): UpdateDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDescriptionWithOptions(InstanceId, request, headers, runtime);
}

async function updateDescriptionWithOptions(InstanceId: string, request: UpdateDescriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDescriptionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDescription',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/description`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDiagnosisSettingsRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
  lang?: string(name='lang'),
}

model UpdateDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDiagnosisSettingsResponseBody(name='body'),
}

async function updateDiagnosisSettings(InstanceId: string, request: UpdateDiagnosisSettingsRequest): UpdateDiagnosisSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function updateDiagnosisSettingsWithOptions(InstanceId: string, request: UpdateDiagnosisSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDiagnosisSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateDiagnosisSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/settings`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDictRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateDictResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateDictResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDictResponseBody(name='body'),
}

async function updateDict(InstanceId: string, request: UpdateDictRequest): UpdateDictResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDictWithOptions(InstanceId, request, headers, runtime);
}

async function updateDictWithOptions(InstanceId: string, request: UpdateDictRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDictResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateDict',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDynamicSettingsRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  body?: string(name='body'),
  mode?: string(name='mode'),
}

model UpdateDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateDynamicSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDynamicSettingsResponseBody(name='body'),
}

async function updateDynamicSettings(InstanceId: string, request: UpdateDynamicSettingsRequest): UpdateDynamicSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDynamicSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function updateDynamicSettingsWithOptions(InstanceId: string, request: UpdateDynamicSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDynamicSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.mode)) {
    query['mode'] = request.mode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateDynamicSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dynamic-settings`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateExtendConfigRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model UpdateExtendConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateExtendConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExtendConfigResponseBody(name='body'),
}

async function updateExtendConfig(InstanceId: string, request: UpdateExtendConfigRequest): UpdateExtendConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExtendConfigWithOptions(InstanceId, request, headers, runtime);
}

async function updateExtendConfigWithOptions(InstanceId: string, request: UpdateExtendConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExtendConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateExtendConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/extend-configs/actions/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateExtendfilesRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model UpdateExtendfilesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
    }
  ](name='Result'),
}

model UpdateExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateExtendfilesResponseBody(name='body'),
}

async function updateExtendfiles(InstanceId: string, request: UpdateExtendfilesRequest): UpdateExtendfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExtendfilesWithOptions(InstanceId, request, headers, runtime);
}

async function updateExtendfilesWithOptions(InstanceId: string, request: UpdateExtendfilesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExtendfilesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateExtendfiles',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/extendfiles`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateHotIkDictsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateHotIkDictsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateHotIkDictsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHotIkDictsResponseBody(name='body'),
}

async function updateHotIkDicts(InstanceId: string, request: UpdateHotIkDictsRequest): UpdateHotIkDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHotIkDictsWithOptions(InstanceId, request, headers, runtime);
}

async function updateHotIkDictsWithOptions(InstanceId: string, request: UpdateHotIkDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateHotIkDictsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateHotIkDicts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ik-hot-dict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateILMPolicyRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model UpdateILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateILMPolicyResponseBody(name='body'),
}

async function updateILMPolicy(InstanceId: string, PolicyName: string, request: UpdateILMPolicyRequest): UpdateILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateILMPolicyWithOptions(InstanceId, PolicyName, request, headers, runtime);
}

async function updateILMPolicyWithOptions(InstanceId: string, PolicyName: string, request: UpdateILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateILMPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies/${OpenApiUtil.getEncodeParam(PolicyName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateIndexTemplateRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model UpdateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIndexTemplateResponseBody(name='body'),
}

async function updateIndexTemplate(InstanceId: string, IndexTemplate: string, request: UpdateIndexTemplateRequest): UpdateIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIndexTemplateWithOptions(InstanceId, IndexTemplate, request, headers, runtime);
}

async function updateIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, request: UpdateIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIndexTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates/${OpenApiUtil.getEncodeParam(IndexTemplate)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateInstanceRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  orderActionType?: string(name='orderActionType'),
}

model UpdateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    domain?: string(name='domain'),
    esVersion?: string(name='esVersion'),
    instanceId?: string(name='instanceId'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    status?: string(name='status'),
  }(name='Result'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstance(InstanceId: string, request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function updateInstanceWithOptions(InstanceId: string, request: UpdateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.orderActionType)) {
    query['orderActionType'] = request.orderActionType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateInstanceChargeTypeRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateInstanceChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateInstanceChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceChargeTypeResponseBody(name='body'),
}

async function updateInstanceChargeType(InstanceId: string, request: UpdateInstanceChargeTypeRequest): UpdateInstanceChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceChargeTypeWithOptions(InstanceId, request, headers, runtime);
}

async function updateInstanceChargeTypeWithOptions(InstanceId: string, request: UpdateInstanceChargeTypeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceChargeTypeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceChargeType',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/convert-pay-type`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateInstanceSettingsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateInstanceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceSettingsResponseBody(name='body'),
}

async function updateInstanceSettings(InstanceId: string, request: UpdateInstanceSettingsRequest): UpdateInstanceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function updateInstanceSettingsWithOptions(InstanceId: string, request: UpdateInstanceSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/instance-settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateKibanaSettingsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateKibanaSettingsResponseBody(name='body'),
}

async function updateKibanaSettings(InstanceId: string, request: UpdateKibanaSettingsRequest): UpdateKibanaSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateKibanaSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function updateKibanaSettingsWithOptions(InstanceId: string, request: UpdateKibanaSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateKibanaSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateKibanaSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-kibana-settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateKibanaWhiteIpsRequest {
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
  whiteIpGroup?: {
    groupName?: string(name='groupName'),
    ips?: [ string ](name='ips'),
    whiteIpType?: string(name='whiteIpType'),
  }(name='whiteIpGroup'),
  clientToken?: string(name='clientToken'),
  modifyMode?: string(name='modifyMode'),
}

model UpdateKibanaWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
  }(name='Result'),
}

model UpdateKibanaWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateKibanaWhiteIpsResponseBody(name='body'),
}

async function updateKibanaWhiteIps(InstanceId: string, request: UpdateKibanaWhiteIpsRequest): UpdateKibanaWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateKibanaWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updateKibanaWhiteIpsWithOptions(InstanceId: string, request: UpdateKibanaWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateKibanaWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.kibanaIPWhitelist)) {
    body['kibanaIPWhitelist'] = request.kibanaIPWhitelist;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body['whiteIpGroup'] = request.whiteIpGroup;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateKibanaWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateLogstashRequest {
  nodeAmount?: int32(name='nodeAmount'),
  nodeSpec?: {
    disk?: int32(name='disk'),
    diskType?: string(name='diskType'),
    spec?: string(name='spec'),
  }(name='nodeSpec'),
  clientToken?: string(name='clientToken'),
}

model UpdateLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateLogstashResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashResponseBody(name='body'),
}

async function updateLogstash(InstanceId: string, request: UpdateLogstashRequest): UpdateLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashWithOptions(InstanceId, request, headers, runtime);
}

async function updateLogstashWithOptions(InstanceId: string, request: UpdateLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateLogstashChargeTypeRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateLogstashChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateLogstashChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashChargeTypeResponseBody(name='body'),
}

async function updateLogstashChargeType(InstanceId: string, request: UpdateLogstashChargeTypeRequest): UpdateLogstashChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashChargeTypeWithOptions(InstanceId, request, headers, runtime);
}

async function updateLogstashChargeTypeWithOptions(InstanceId: string, request: UpdateLogstashChargeTypeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashChargeTypeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstashChargeType',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/convert-pay-type`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateLogstashDescriptionRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateLogstashDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    description?: string(name='description'),
  }(name='Result'),
}

model UpdateLogstashDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashDescriptionResponseBody(name='body'),
}

async function updateLogstashDescription(InstanceId: string, request: UpdateLogstashDescriptionRequest): UpdateLogstashDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashDescriptionWithOptions(InstanceId, request, headers, runtime);
}

async function updateLogstashDescriptionWithOptions(InstanceId: string, request: UpdateLogstashDescriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashDescriptionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstashDescription',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/description`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateLogstashSettingsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateLogstashSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLogstashSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLogstashSettingsResponseBody(name='body'),
}

async function updateLogstashSettings(InstanceId: string, request: UpdateLogstashSettingsRequest): UpdateLogstashSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function updateLogstashSettingsWithOptions(InstanceId: string, request: UpdateLogstashSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstashSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/instance-settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePipelineManagementConfigRequest {
  endpoints?: [ string ](name='endpoints'),
  password?: string(name='password'),
  pipelineIds?: [ string ](name='pipelineIds'),
  pipelineManagementType?: string(name='pipelineManagementType'),
  userName?: string(name='userName'),
  clientToken?: string(name='clientToken'),
}

model UpdatePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdatePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelineManagementConfigResponseBody(name='body'),
}

async function updatePipelineManagementConfig(InstanceId: string, request: UpdatePipelineManagementConfigRequest): UpdatePipelineManagementConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime);
}

async function updatePipelineManagementConfigWithOptions(InstanceId: string, request: UpdatePipelineManagementConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePipelineManagementConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.endpoints)) {
    body['endpoints'] = request.endpoints;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.pipelineIds)) {
    body['pipelineIds'] = request.pipelineIds;
  }
  if (!Util.isUnset(request.pipelineManagementType)) {
    body['pipelineManagementType'] = request.pipelineManagementType;
  }
  if (!Util.isUnset(request.userName)) {
    body['userName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipelineManagementConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipeline-management-config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePipelinesRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  trigger?: boolean(name='trigger'),
}

model UpdatePipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePipelinesResponseBody(name='body'),
}

async function updatePipelines(InstanceId: string, request: UpdatePipelinesRequest): UpdatePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function updatePipelinesWithOptions(InstanceId: string, request: UpdatePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePrivateNetworkWhiteIpsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  modifyMode?: string(name='modifyMode'),
}

model UpdatePrivateNetworkWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  }(name='Result'),
}

model UpdatePrivateNetworkWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePrivateNetworkWhiteIpsResponseBody(name='body'),
}

async function updatePrivateNetworkWhiteIps(InstanceId: string, request: UpdatePrivateNetworkWhiteIpsRequest): UpdatePrivateNetworkWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePrivateNetworkWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updatePrivateNetworkWhiteIpsWithOptions(InstanceId: string, request: UpdatePrivateNetworkWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePrivateNetworkWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePrivateNetworkWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/private-network-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePublicNetworkRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdatePublicNetworkResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enablePublic?: boolean(name='enablePublic'),
  }(name='Result'),
}

model UpdatePublicNetworkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicNetworkResponseBody(name='body'),
}

async function updatePublicNetwork(InstanceId: string, request: UpdatePublicNetworkRequest): UpdatePublicNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePublicNetworkWithOptions(InstanceId, request, headers, runtime);
}

async function updatePublicNetworkWithOptions(InstanceId: string, request: UpdatePublicNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePublicNetworkResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/public-network`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePublicWhiteIpsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
  modifyMode?: string(name='modifyMode'),
}

model UpdatePublicWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  }(name='Result'),
}

model UpdatePublicWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePublicWhiteIpsResponseBody(name='body'),
}

async function updatePublicWhiteIps(InstanceId: string, request: UpdatePublicWhiteIpsRequest): UpdatePublicWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePublicWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updatePublicWhiteIpsWithOptions(InstanceId: string, request: UpdatePublicWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePublicWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/public-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateReadWritePolicyRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model UpdateReadWritePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateReadWritePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateReadWritePolicyResponseBody(name='body'),
}

async function updateReadWritePolicy(InstanceId: string, request: UpdateReadWritePolicyRequest): UpdateReadWritePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateReadWritePolicyWithOptions(InstanceId, request, headers, runtime);
}

async function updateReadWritePolicyWithOptions(InstanceId: string, request: UpdateReadWritePolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateReadWritePolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateReadWritePolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-read-write-policy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateSnapshotSettingRequest {
  body?: string(name='body'),
}

model UpdateSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='enable'),
    quartzRegex?: string(name='quartzRegex'),
  }(name='Result'),
}

model UpdateSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSnapshotSettingResponseBody(name='body'),
}

async function updateSnapshotSetting(InstanceId: string, request: UpdateSnapshotSettingRequest): UpdateSnapshotSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSnapshotSettingWithOptions(InstanceId, request, headers, runtime);
}

async function updateSnapshotSettingWithOptions(InstanceId: string, request: UpdateSnapshotSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSnapshotSettingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateSnapshotSetting',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-setting`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateSynonymsDictsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken'),
}

model UpdateSynonymsDictsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateSynonymsDictsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSynonymsDictsResponseBody(name='body'),
}

async function updateSynonymsDicts(InstanceId: string, request: UpdateSynonymsDictsRequest): UpdateSynonymsDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSynonymsDictsWithOptions(InstanceId, request, headers, runtime);
}

async function updateSynonymsDictsWithOptions(InstanceId: string, request: UpdateSynonymsDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSynonymsDictsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateSynonymsDicts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/synonymsDict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTemplateRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplate(InstanceId: string, TemplateName: string, request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTemplateWithOptions(InstanceId, TemplateName, request, headers, runtime);
}

async function updateTemplateWithOptions(InstanceId: string, TemplateName: string, request: UpdateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/templates/${OpenApiUtil.getEncodeParam(TemplateName)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateWhiteIpsRequest {
  esIPWhitelist?: [ string ](name='esIPWhitelist'),
  whiteIpGroup?: {
    groupName?: string(name='groupName'),
    ips?: [ string ](name='ips'),
    whiteIpType?: string(name='whiteIpType'),
  }(name='whiteIpGroup'),
  clientToken?: string(name='clientToken'),
  modifyMode?: string(name='modifyMode'),
}

model UpdateWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    esIPWhitelist?: [ string ](name='esIPWhitelist'),
    networkConfig?: {
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
  }(name='Result'),
}

model UpdateWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWhiteIpsResponseBody(name='body'),
}

async function updateWhiteIps(InstanceId: string, request: UpdateWhiteIpsRequest): UpdateWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updateWhiteIpsWithOptions(InstanceId: string, request: UpdateWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.esIPWhitelist)) {
    body['esIPWhitelist'] = request.esIPWhitelist;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body['whiteIpGroup'] = request.whiteIpGroup;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateXpackMonitorConfigRequest {
  clientToken?: string(name='ClientToken'),
  enable?: boolean(name='enable'),
  endpoints?: [ string ](name='endpoints'),
  password?: string(name='password'),
  userName?: string(name='userName'),
}

model UpdateXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateXpackMonitorConfigResponseBody(name='body'),
}

async function updateXpackMonitorConfig(InstanceId: string, request: UpdateXpackMonitorConfigRequest): UpdateXpackMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateXpackMonitorConfigWithOptions(InstanceId, request, headers, runtime);
}

async function updateXpackMonitorConfigWithOptions(InstanceId: string, request: UpdateXpackMonitorConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateXpackMonitorConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!Util.isUnset(request.endpoints)) {
    body['endpoints'] = request.endpoints;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    body['userName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateXpackMonitorConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/xpack-monitor-config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpgradeEngineVersionRequest {
  type?: string(name='type'),
  version?: string(name='version'),
  clientToken?: string(name='clientToken'),
  dryRun?: boolean(name='dryRun'),
}

model UpgradeEngineVersionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      status?: string(name='status'),
      validateResult?: [ 
        {
          errorCode?: string(name='errorCode'),
          errorMsg?: string(name='errorMsg'),
          errorType?: string(name='errorType'),
        }
      ](name='validateResult'),
      validateType?: string(name='validateType'),
    }
  ](name='Result'),
}

model UpgradeEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeEngineVersionResponseBody(name='body'),
}

async function upgradeEngineVersion(InstanceId: string, request: UpgradeEngineVersionRequest): UpgradeEngineVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeEngineVersionWithOptions(InstanceId, request, headers, runtime);
}

async function upgradeEngineVersionWithOptions(InstanceId: string, request: UpgradeEngineVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpgradeEngineVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeEngineVersion',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/upgrade-version`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ValidateConnectionRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
}

model ValidateConnectionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateConnectionResponseBody(name='body'),
}

async function validateConnection(InstanceId: string, request: ValidateConnectionRequest): ValidateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateConnectionWithOptions(InstanceId, request, headers, runtime);
}

async function validateConnectionWithOptions(InstanceId: string, request: ValidateConnectionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateConnectionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ValidateConnection',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/validate-connection`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ValidateShrinkNodesRequest {
  body?: [ 
    {
      host?: string(name='host'),
      hostName?: string(name='hostName'),
      nodeType?: string(name='nodeType'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='body'),
  count?: int32(name='count'),
  ignoreStatus?: boolean(name='ignoreStatus'),
  nodeType?: string(name='nodeType'),
}

model ValidateShrinkNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateShrinkNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateShrinkNodesResponseBody(name='body'),
}

async function validateShrinkNodes(InstanceId: string, request: ValidateShrinkNodesRequest): ValidateShrinkNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateShrinkNodesWithOptions(InstanceId, request, headers, runtime);
}

async function validateShrinkNodesWithOptions(InstanceId: string, request: ValidateShrinkNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateShrinkNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query['ignoreStatus'] = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateShrinkNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/validate-shrink-nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ValidateSlrPermissionRequest {
  clientToken?: string(name='ClientToken'),
  body?: string(name='body'),
  rolename?: string(name='rolename'),
}

model ValidateSlrPermissionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateSlrPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateSlrPermissionResponseBody(name='body'),
}

async function validateSlrPermission(request: ValidateSlrPermissionRequest): ValidateSlrPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateSlrPermissionWithOptions(request, headers, runtime);
}

async function validateSlrPermissionWithOptions(request: ValidateSlrPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateSlrPermissionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.rolename)) {
    query['rolename'] = request.rolename;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ValidateSlrPermission',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/user/servicerolepermission`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ValidateTransferableNodesRequest {
  body?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='body'),
  nodeType?: string(name='nodeType'),
}

model ValidateTransferableNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ValidateTransferableNodesResponseBody(name='body'),
}

async function validateTransferableNodes(InstanceId: string, request: ValidateTransferableNodesRequest): ValidateTransferableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateTransferableNodesWithOptions(InstanceId, request, headers, runtime);
}

async function validateTransferableNodesWithOptions(InstanceId: string, request: ValidateTransferableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateTransferableNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateTransferableNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/validate-transfer-nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateInstanceRequest {
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  esAdminPassword?: string(name='esAdminPassword'),
  esVersion?: string(name='esVersion'),
  instanceCategory?: string(name='instanceCategory'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  networkConfig?: NetworkConfig(name='networkConfig'),
  nodeAmount?: int32(name='nodeAmount'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  paymentInfo?: PaymentInfo(name='paymentInfo'),
  paymentType?: string(name='paymentType'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  zoneCount?: int32(name='zoneCount'),
  clientToken?: string(name='clientToken'),
}

model CreateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    instanceId?: string(name='instanceId'),
  }(name='Result'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createInstanceWithOptions(request, headers, runtime);
}

async function createInstanceWithOptions(request: CreateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.clientNodeConfiguration)) {
    body['clientNodeConfiguration'] = request.clientNodeConfiguration;
  }
  if (!Util.isUnset(request.elasticDataNodeConfiguration)) {
    body['elasticDataNodeConfiguration'] = request.elasticDataNodeConfiguration;
  }
  if (!Util.isUnset(request.esAdminPassword)) {
    body['esAdminPassword'] = request.esAdminPassword;
  }
  if (!Util.isUnset(request.esVersion)) {
    body['esVersion'] = request.esVersion;
  }
  if (!Util.isUnset(request.instanceCategory)) {
    body['instanceCategory'] = request.instanceCategory;
  }
  if (!Util.isUnset(request.kibanaConfiguration)) {
    body['kibanaConfiguration'] = request.kibanaConfiguration;
  }
  if (!Util.isUnset(request.masterConfiguration)) {
    body['masterConfiguration'] = request.masterConfiguration;
  }
  if (!Util.isUnset(request.networkConfig)) {
    body['networkConfig'] = request.networkConfig;
  }
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }
  if (!Util.isUnset(request.paymentInfo)) {
    body['paymentInfo'] = request.paymentInfo;
  }
  if (!Util.isUnset(request.paymentType)) {
    body['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.warmNodeConfiguration)) {
    body['warmNodeConfiguration'] = request.warmNodeConfiguration;
  }
  if (!Util.isUnset(request.zoneCount)) {
    body['zoneCount'] = request.zoneCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'createInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

