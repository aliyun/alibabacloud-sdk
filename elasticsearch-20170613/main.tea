/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('elasticsearch', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ClientNodeConfiguration {
  amount?: long(name='amount', description='This parameter is required.'),
  disk?: long(name='disk', description='This parameter is required.'),
  diskType?: string(name='diskType', description='This parameter is required.'),
  spec?: string(name='spec', description='This parameter is required.'),
}

model CollectorDeployMachine {
  configType?: string(name='configType', description='This parameter is required.', example='collectorDeployMachine'),
  groupId?: string(name='groupId', example='default_ct-cn-f3t0dq5p97199ru3z'),
  instanceId?: string(name='instanceId', example='ce93d7566df2141f490f0f60f646252c3'),
  machines?: [ 
    {
      agentStatus?: string(name='agentStatus', example='UNINSTALLED'),
      instanceId?: string(name='instanceId', example='i-xs34****'),
    }
  ](name='machines'),
  successPodsCount?: string(name='successPodsCount', example='1'),
  totalPodsCount?: string(name='totalPodsCount', example='2'),
  type?: string(name='type', description='This parameter is required.', example='ACKCluster'),
}

model CollectorKibanaInstance {
  configType?: string(name='configType', description='This parameter is required.', example='collectorElasticsearchForKibana'),
  host?: string(name='host', description='This parameter is required.', example='es-cn-*****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
  instanceId?: string(name='instanceId', description='This parameter is required.', example='es-cn-45dfy****'),
  kibanaHost?: string(name='kibanaHost', description='This parameter is required.', example='https://es-cn-****.kibana.elasticsearch.aliyuncs.com:5601'),
  password?: string(name='password', description='This parameter is required.', example='password'),
  protocol?: string(name='protocol', description='This parameter is required.', example='HTTP'),
  userName?: string(name='userName', description='This parameter is required.', example='username'),
}

model CollectorTargetInstance {
  configType?: string(name='configType', description='This parameter is required.', example='collectorTargetInstance'),
  enableMonitoring?: boolean(name='enableMonitoring', description='This parameter is required.', example='false'),
  hosts?: [ string ](name='hosts'),
  instanceId?: string(name='instanceId', description='This parameter is required.', example='es-cn-ks8x****'),
  instanceType?: string(name='instanceType', description='This parameter is required.', example='elasticsearch'),
  password?: string(name='password', description='This parameter is required.', example='password'),
  protocol?: string(name='protocol', description='This parameter is required.', example='HTTP'),
  userName?: string(name='userName', description='This parameter is required.', example='username'),
}

model DictInfo {
  fileSize?: long(name='fileSize'),
  name?: string(name='name'),
  sourceType?: string(name='sourceType'),
  type?: string(name='type'),
}

model ElasticDataNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec?: string(name='spec', description='This parameter is required.'),
}

model Elasticsearch {
  advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
  advancedSetting?: {
    gcName?: string(name='gcName'),
  }(name='advancedSetting'),
  aliwsDicts?: [
    DictInfo
  ](name='aliwsDicts'),
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration'),
  createdAt?: string(name='createdAt'),
  dataNode?: boolean(name='dataNode'),
  dedicateMaster?: boolean(name='dedicateMaster'),
  description?: string(name='description'),
  dictList?: [
    DictInfo
  ](name='dictList'),
  domain?: string(name='domain'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork'),
  enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork'),
  enablePublic?: boolean(name='enablePublic'),
  endTime?: long(name='endTime'),
  esConfig?: map[string]string(name='esConfig'),
  esIPWhitelist?: [ string ](name='esIPWhitelist'),
  esVersion?: string(name='esVersion'),
  extendConfigs?: [  map[string]any ](name='extendConfigs'),
  haveClientNode?: boolean(name='haveClientNode'),
  haveElasticDataNode?: boolean(name='haveElasticDataNode'),
  haveKibana?: boolean(name='haveKibana'),
  ikHotDicts?: [
    DictInfo
  ](name='ikHotDicts'),
  instanceId?: string(name='instanceId'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  kibanaDomain?: string(name='kibanaDomain'),
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
  kibanaPort?: long(name='kibanaPort'),
  kibanaPrivateDomain?: string(name='kibanaPrivateDomain'),
  kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
  kibanaPrivatePort?: long(name='kibanaPrivatePort'),
  kibanaProtocol?: string(name='kibanaProtocol'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  networkConfig?: NetworkConfig(name='networkConfig'),
  nodeAmount?: long(name='nodeAmount'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  paymentType?: string(name='paymentType'),
  port?: long(name='port'),
  privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  productType?: string(name='productType'),
  protocol?: string(name='protocol'),
  publicDomain?: string(name='publicDomain'),
  publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  publicPort?: long(name='publicPort'),
  readWritePolicy?: ReadWritePolicy(name='readWritePolicy'),
  resourceGroupId?: string(name='resourceGroupId'),
  serviceVpc?: boolean(name='serviceVpc'),
  status?: string(name='status'),
  synonymsDicts?: [
    DictInfo
  ](name='synonymsDicts'),
  tags?: [
    Tag
  ](name='tags'),
  updatedAt?: string(name='updatedAt'),
  warmNode?: boolean(name='warmNode'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  zoneCount?: long(name='zoneCount'),
  zoneInfos?: [
    ZoneInfo
  ](name='zoneInfos'),
}

model KibanaNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  spec?: string(name='spec', description='This parameter is required.'),
}

model Logstash {
  config?: map[string]string(name='config'),
  createdAt?: string(name='createdAt'),
  dataNode?: boolean(name='dataNode'),
  description?: string(name='description'),
  endTime?: long(name='endTime'),
  endpointList?: [ 
    {
      host?: string(name='host'),
      port?: long(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='endpointList'),
  instanceId?: string(name='instanceId'),
  networkConfig?: {
    type?: string(name='type'),
    vpcId?: string(name='vpcId'),
    vsArea?: string(name='vsArea'),
    vswitchId?: string(name='vswitchId'),
  }(name='networkConfig'),
  nodeAmount?: long(name='nodeAmount'),
  nodeSpec?: {
    disk?: long(name='disk'),
    diskType?: string(name='diskType'),
    spec?: string(name='spec'),
  }(name='nodeSpec'),
  paymentType?: string(name='paymentType'),
  protocol?: string(name='protocol'),
  resourceGroupId?: string(name='resourceGroupId'),
  status?: string(name='status'),
  tags?: [ 
    {
      tagKey?: string(name='tagKey'),
      tagValue?: string(name='tagValue'),
    }
  ](name='tags'),
  updatedAt?: string(name='updatedAt'),
  version?: string(name='version'),
  zoneCount?: long(name='zoneCount'),
  zoneInfos?: [ 
    {
      status?: string(name='status'),
      zoneId?: string(name='zoneId'),
    }
  ](name='zoneInfos'),
}

model MasterNodeConfiguration {
  amount?: long(name='amount', description='This parameter is required.'),
  disk?: long(name='disk', description='This parameter is required.'),
  diskType?: string(name='diskType', description='This parameter is required.'),
  spec?: string(name='spec', description='This parameter is required.'),
}

model MigrationJob {
  currentState?: string(name='currentState'),
  disableSourceClusterAuth?: boolean(name='disableSourceClusterAuth'),
  disableTargetClusterAuth?: boolean(name='disableTargetClusterAuth'),
  endTime?: long(name='endTime'),
  migrationJobId?: string(name='migrationJobId'),
  phase?: string(name='phase'),
  sourceCluster?: {
    instanceId?: string(name='instanceId'),
    type?: string(name='type'),
  }(name='sourceCluster'),
  startTime?: long(name='startTime'),
  statusResult?: [ 
    {
      code?: string(name='code'),
      success?: boolean(name='success'),
    }
  ](name='statusResult'),
  targetCluster?: {
    instanceId?: string(name='instanceId'),
    type?: string(name='type'),
  }(name='targetCluster'),
  updateTime?: long(name='updateTime'),
}

model NetworkConfig {
  type?: string(name='type'),
  vpcId?: string(name='vpcId'),
  vsArea?: string(name='vsArea'),
  vswitchId?: string(name='vswitchId'),
  whiteIpGroupList?: [
    WhiteIpGroup
  ](name='whiteIpGroupList'),
}

model NodeInfo {
  host?: string(name='host'),
  hostName?: string(name='hostName'),
  port?: long(name='port'),
  zoneId?: string(name='zoneId'),
}

model NodeSpec {
  disk?: int32(name='disk'),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec?: string(name='spec', description='This parameter is required.'),
}

model PaymentInfo {
  autoRenewDuration?: long(name='autoRenewDuration'),
  duration?: long(name='duration'),
  isAutoRenew?: boolean(name='isAutoRenew'),
  pricingCycle?: string(name='pricingCycle'),
}

model ReadWritePolicy {
  autoGeneratePk?: boolean(name='autoGeneratePk'),
  writeHa?: boolean(name='writeHa'),
  writePolicy?: string(name='writePolicy'),
}

model Tag {
  tagKey?: string(name='tagKey'),
  tagValue?: string(name='tagValue'),
}

model WarmNodeConfiguration {
  amount?: long(name='amount'),
  disk?: long(name='disk'),
  diskEncryption?: boolean(name='diskEncryption'),
  diskType?: string(name='diskType'),
  performanceLevel?: string(name='performanceLevel'),
  spec?: string(name='spec', description='This parameter is required.'),
}

model WhiteIpGroup {
  whiteIpType?: string(name='WhiteIpType'),
  groupName?: string(name='groupName'),
  ips?: [ string ](name='ips'),
}

model ZoneInfo {
  status?: string(name='status'),
  zoneId?: string(name='zoneId'),
}

model ResultSpecInfoMapValue = {
  cpuCount?: string(name='cpuCount'),
  memorySize?: string(name='memorySize'),
  enable?: string(name='enable'),
  spec?: string(name='spec'),
  specGroupType?: string(name='specGroupType'),
  disk?: string(name='disk'),
  diskType?: string(name='diskType'),
}

model ActivateZonesRequest {
  body?: string(name='body', description='请求体参数。', example='["cn-hangzhou-i","cn-hangzhou-h"]'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model ActivateZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5A5D8E74-565C-43DC-B031-29289FA****'),
  result?: boolean(name='Result', description='Indicates whether the nodes in disabled zones are restored. Valid values:

*   true
*   false', example='true'),
}

model ActivateZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ActivateZonesResponseBody(name='body'),
}

/**
 * @summary Restores nodes in disabled zones. This operation is available only for multi-zone Elasticsearch clusters.
 *
 * @param request ActivateZonesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActivateZonesResponse
 */
async function activateZonesWithOptions(InstanceId: string, request: ActivateZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ActivateZonesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ActivateZones',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/recover-zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restores nodes in disabled zones. This operation is available only for multi-zone Elasticsearch clusters.
 *
 * @param request ActivateZonesRequest
 * @return ActivateZonesResponse
 */
async function activateZones(InstanceId: string, request: ActivateZonesRequest): ActivateZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return activateZonesWithOptions(InstanceId, request, headers, runtime);
}

model AddConnectableClusterRequest {
  body?: string(name='body', example='{     "instanceId":"es-cn-09k1rgid9000g****" }'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model AddConnectableClusterResponseBody = {
  requestId?: string(name='RequestId', example='5A5D8E74-565C-43DC-B031-29289FA****'),
  result?: boolean(name='Result', example='true'),
}

model AddConnectableClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddConnectableClusterResponseBody(name='body'),
}

/**
 * @param request AddConnectableClusterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddConnectableClusterResponse
 */
async function addConnectableClusterWithOptions(InstanceId: string, request: AddConnectableClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddConnectableClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'AddConnectableCluster',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connected-clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddConnectableClusterRequest
 * @return AddConnectableClusterResponse
 */
async function addConnectableCluster(InstanceId: string, request: AddConnectableClusterRequest): AddConnectableClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addConnectableClusterWithOptions(InstanceId, request, headers, runtime);
}

model AddSnapshotRepoRequest {
  body?: string(name='body'),
}

model AddSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: Reference warehouse created successfully
*   false: Reference warehouse created failed', example='true'),
}

model AddSnapshotRepoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddSnapshotRepoResponseBody(name='body'),
}

/**
 * @summary Call the AddSnapshotRepo to create a reference repository when configuring a cross-cluster OSS repository.
 *
 * @param request AddSnapshotRepoRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSnapshotRepoResponse
 */
async function addSnapshotRepoWithOptions(InstanceId: string, request: AddSnapshotRepoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddSnapshotRepoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'AddSnapshotRepo',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-repos`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call the AddSnapshotRepo to create a reference repository when configuring a cross-cluster OSS repository.
 *
 * @param request AddSnapshotRepoRequest
 * @return AddSnapshotRepoResponse
 */
async function addSnapshotRepo(InstanceId: string, request: AddSnapshotRepoRequest): AddSnapshotRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addSnapshotRepoWithOptions(InstanceId, request, headers, runtime);
}

model CancelDeletionRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CancelDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D682B6B3-B425-46DA-A5FC-5F5C60553622'),
  result?: boolean(name='Result', description='Indicates whether the cluster is restored. Valid values:

*   true: The cluster is restored.
*   false: The cluster fails to be restored.', example='true'),
}

model CancelDeletionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelDeletionResponseBody(name='body'),
}

/**
 * @summary Restores an Elasticsearch cluster that is frozen after it is released.
 *
 * @param request CancelDeletionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelDeletionResponse
 */
async function cancelDeletionWithOptions(InstanceId: string, request: CancelDeletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelDeletionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelDeletion',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/cancel-deletion`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restores an Elasticsearch cluster that is frozen after it is released.
 *
 * @param request CancelDeletionRequest
 * @return CancelDeletionResponse
 */
async function cancelDeletion(InstanceId: string, request: CancelDeletionRequest): CancelDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelDeletionWithOptions(InstanceId, request, headers, runtime);
}

model CancelLogstashDeletionRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CancelLogstashDeletionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='23EBF56B-2DC0-4507-8BE5-B87395DB0FEB'),
  result?: boolean(name='Result', description='Indicates whether the cluster is restored. Valid values:

*   true: The cluster is restored.
*   false: The cluster is not restored.', example='true'),
}

model CancelLogstashDeletionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelLogstashDeletionResponseBody(name='body'),
}

/**
 * @summary Restores a Logstash cluster that is frozen after it is released.
 *
 * @param request CancelLogstashDeletionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelLogstashDeletionResponse
 */
async function cancelLogstashDeletionWithOptions(InstanceId: string, request: CancelLogstashDeletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelLogstashDeletionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelLogstashDeletion',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/cancel-deletion`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restores a Logstash cluster that is frozen after it is released.
 *
 * @param request CancelLogstashDeletionRequest
 * @return CancelLogstashDeletionResponse
 */
async function cancelLogstashDeletion(InstanceId: string, request: CancelLogstashDeletionRequest): CancelLogstashDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelLogstashDeletionWithOptions(InstanceId, request, headers, runtime);
}

model CancelTaskRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  taskType?: string(name='taskType', description='The type of the data migration task. Set the value to MigrateData.

This parameter is required.', example='MigrateData'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: the task was cancelled successfully
*   false: the task was cancelled successfully failed', example='true'),
}

model CancelTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelTaskResponseBody(name='body'),
}

/**
 * @param request CancelTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelTaskResponse
 */
async function cancelTaskWithOptions(InstanceId: string, request: CancelTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.taskType)) {
    query['taskType'] = request.taskType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/cancel-task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CancelTaskRequest
 * @return CancelTaskResponse
 */
async function cancelTask(InstanceId: string, request: CancelTaskRequest): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelTaskWithOptions(InstanceId, request, headers, runtime);
}

model CapacityPlanRequest {
  complexQueryAvailable?: boolean(name='complexQueryAvailable', description='Indicates whether there is a need for complex aggregation queries. Options:

- true: Yes
- false (default): No', example='true'),
  dataInfo?: [ 
    {
      code?: string(name='code', description='Disk data metric code. Options:

- totalRawData: Raw data information
- document: Data document information, estimated document count
- dailyIncrement: Daily data growth
- dailyIncrementDoc: Daily incremental document count
- retentionTime: Data retention period
- replica: Replica settings', example='totalRawData'),
      size?: long(name='size', description='Disk usage metric value.', example='100'),
      totalCount?: int32(name='totalCount', description='Total number of data entries.', example='10000'),
      type?: string(name='type', description='Disk data type. Options:

- hot: Hot data
- warm: Cold data', example='hot'),
      unit?: string(name='unit', description='Data or time unit. Options:

- Data units: MiB, GiB, TB, PB
- Time units: DAYS, WEEKS, MONTHS, YEARS', example='MiB'),
    }
  ](name='dataInfo', description='Disk usage status.'),
  metric?: [ 
    {
      averageQps?: int32(name='averageQps', description='Average QPS.', example='30'),
      code?: string(name='code', description='Search or write metric code. Options:

- write: Write
- search: Search', example='write'),
      concurrent?: long(name='concurrent', description='Concurrent number.', example='2'),
      peakQps?: int32(name='peakQps', description='Peak QPS.', example='30'),
      responseTime?: int32(name='responseTime', description='Expected average response time, unit: milliseconds.', example='100'),
      throughput?: long(name='throughput', description='Throughput, unit: MB/S.', example='100'),
      type?: string(name='type', description='Search/write peak type. Options:

- common: Regular
- peak: Peak', example='common'),
    }
  ](name='metric', description='Metrics information including disk usage, search and write operations, aggregation requests, etc.'),
  usageScenario?: string(name='usageScenario', description='Usage scenarios, options:

- general: General scenario
- analysisVisualization: Data analysis scenario
- dbAcceleration: Database acceleration scenario
- search: Search scenario
- log: Log scenario', example='general'),
}

model CapacityPlanResponseBody = {
  requestId?: string(name='RequestId', description='ID of the current request.', example='E91B7129-A669-4D9D-A743-F90A0FF1F5EF'),
  result?: {
    extendConfigs?: [ 
      {
        configType?: string(name='ConfigType', description='Configuration type, with a single value: sharedDisk.

> This extendConfigs attribute may appear when the planned instance type is Advanced.', example='sharedDisk'),
        disk?: long(name='Disk', description='Disk size, in GiB.', example='2048'),
        diskType?: string(name='DiskType', description='Disk type, with a single value: CPFS_PREMIUM.

> This extendConfigs attribute may appear when the planned instance type is Advanced.', example='CPFS_PREMIUM'),
      }
    ](name='ExtendConfigs', description='Extended configuration information.'),
    instanceCategory?: string(name='InstanceCategory', description='Edition type, with values meaning as follows:

- advanced: Enhanced Edition

- x-pack: Commercial Edition

- community: Community Edition', example='advanced'),
    nodeConfigurations?: [ 
      {
        amount?: long(name='Amount', description='Number of nodes.', example='10'),
        cpu?: long(name='Cpu', description='Number of CPUs.', example='1'),
        disk?: long(name='Disk', description='Disk size, in GiB.', example='20'),
        diskType?: string(name='DiskType', description='Disk type, with meanings as follows:

- cloud_essd: ESSD Cloud Disk

- cloud_ssd: SSD Cloud Disk

- cloud_efficiency: Efficient Cloud Disk

- local_ssd: Local SSD Disk

- local_efficiency: Local Efficient Disk', example='cloud_ssd'),
        memory?: long(name='Memory', description='Specified memory size for the current node role.', example='2'),
        nodeType?: string(name='NodeType', description='Node type, with supported types as follows:

- WORKER: Data Node

- WORKER_WARM: Cold Data Node

- MASTER: Dedicated Master Node

- KIBANA: Kibana Node

- COORDINATING: Coordinator Node

- ELASTIC_WORKER: Elastic Node', example='WORKER'),
      }
    ](name='NodeConfigurations', description='Node information.'),
    oversizedCluster?: boolean(name='OversizedCluster', description='Based on the capacity planning calculation, there is no default value. The meanings of the values are as follows:

- true: Represents an oversized cluster, indicating that the number of data nodes calculated by the capacity planning exceeds the threshold of 50.

- false: The number of data nodes calculated by the capacity planning is within 50.', example='true'),
  }(name='Result', description='Returned result of the request.'),
}

model CapacityPlanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CapacityPlanResponseBody(name='body'),
}

/**
 * @summary Capacity Planning
 *
 * @param request CapacityPlanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CapacityPlanResponse
 */
async function capacityPlanWithOptions(request: CapacityPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CapacityPlanResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.complexQueryAvailable)) {
    body['complexQueryAvailable'] = request.complexQueryAvailable;
  }
  if (!Util.isUnset(request.dataInfo)) {
    body['dataInfo'] = request.dataInfo;
  }
  if (!Util.isUnset(request.metric)) {
    body['metric'] = request.metric;
  }
  if (!Util.isUnset(request.usageScenario)) {
    body['usageScenario'] = request.usageScenario;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CapacityPlan',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/assist/actions/capacity-plan`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Capacity Planning
 *
 * @param request CapacityPlanRequest
 * @return CapacityPlanResponse
 */
async function capacityPlan(request: CapacityPlanRequest): CapacityPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return capacityPlanWithOptions(request, headers, runtime);
}

model CloseDiagnosisRequest {
  clientToken?: string(name='ClientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  lang?: string(name='lang', example='spanish'),
}

model CloseDiagnosisResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model CloseDiagnosisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseDiagnosisResponseBody(name='body'),
}

/**
 * @summary 关闭实例的智能运维功能
 *
 * @param request CloseDiagnosisRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseDiagnosisResponse
 */
async function closeDiagnosisWithOptions(InstanceId: string, request: CloseDiagnosisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseDiagnosisResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseDiagnosis',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/close-diagnosis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 关闭实例的智能运维功能
 *
 * @param request CloseDiagnosisRequest
 * @return CloseDiagnosisResponse
 */
async function closeDiagnosis(InstanceId: string, request: CloseDiagnosisRequest): CloseDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeDiagnosisWithOptions(InstanceId, request, headers, runtime);
}

model CloseHttpsRequest {
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B350****'),
}

model CloseHttpsResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: boolean(name='Result', example='true'),
}

model CloseHttpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseHttpsResponseBody(name='body'),
}

/**
 * @param request CloseHttpsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseHttpsResponse
 */
async function closeHttpsWithOptions(InstanceId: string, request: CloseHttpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseHttpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseHttps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/close-https`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CloseHttpsRequest
 * @return CloseHttpsResponse
 */
async function closeHttps(InstanceId: string, request: CloseHttpsRequest): CloseHttpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeHttpsWithOptions(InstanceId, request, headers, runtime);
}

model CloseManagedIndexRequest {
  clientToken?: string(name='ClientToken', description='Used to ensure the idempotency of the request. Generated by the client, it must be unique across different requests and not exceed 64 ASCII characters.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CloseManagedIndexResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Indicates whether the index\\\\"s cloud management has been successfully closed:

- true: Success

- false: Failure', example='true'),
}

model CloseManagedIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseManagedIndexResponseBody(name='body'),
}

/**
 * @summary Disable Managed Index
 *
 * @param request CloseManagedIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseManagedIndexResponse
 */
async function closeManagedIndexWithOptions(InstanceId: string, Index: string, request: CloseManagedIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseManagedIndexResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseManagedIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/indices/${OpenApiUtil.getEncodeParam(Index)}/close-managed`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disable Managed Index
 *
 * @param request CloseManagedIndexRequest
 * @return CloseManagedIndexResponse
 */
async function closeManagedIndex(InstanceId: string, Index: string, request: CloseManagedIndexRequest): CloseManagedIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeManagedIndexWithOptions(InstanceId, Index, request, headers, runtime);
}

model CreateCollectorRequest {
  collectorPaths?: [ string ](name='collectorPaths'),
  configs?: [ 
    {
      content?: string(name='content', description='This parameter is required.', example='"filebeat.inputs:xxx"'),
      fileName?: string(name='fileName', description='This parameter is required.', example='filebeat.yml'),
    }
  ](name='configs', description='This parameter is required.'),
  dryRun?: boolean(name='dryRun', description='This parameter is required.', example='true'),
  extendConfigs?: [  map[string]any ](name='extendConfigs', description='This parameter is required.'),
  name?: string(name='name', description='This parameter is required.', example='ct-test'),
  resType?: string(name='resType', description='This parameter is required.', example='fileBeat'),
  resVersion?: string(name='resVersion', description='This parameter is required.', example='6.8.5_with_community'),
  vpcId?: string(name='vpcId', description='This parameter is required.', example='vpc-bp12nu14urf0upaf*****'),
  clientToken?: string(name='clientToken', description='The ID of the created crawer.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CreateCollectorResponseBody = {
  requestId?: string(name='RequestId', example='8466BDFB-C513-4B8D-B4E3-5AB256AB****'),
  result?: {
    resId?: string(name='resId', example='ct-cn-4135is2tj194p****'),
  }(name='Result'),
}

model CreateCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCollectorResponseBody(name='body'),
}

/**
 * @summary 创建收集器
 *
 * @param request CreateCollectorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCollectorResponse
 */
async function createCollectorWithOptions(request: CreateCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.collectorPaths)) {
    body['collectorPaths'] = request.collectorPaths;
  }
  if (!Util.isUnset(request.configs)) {
    body['configs'] = request.configs;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['dryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.extendConfigs)) {
    body['extendConfigs'] = request.extendConfigs;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.resType)) {
    body['resType'] = request.resType;
  }
  if (!Util.isUnset(request.resVersion)) {
    body['resVersion'] = request.resVersion;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['vpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建收集器
 *
 * @param request CreateCollectorRequest
 * @return CreateCollectorResponse
 */
async function createCollector(request: CreateCollectorRequest): CreateCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCollectorWithOptions(request, headers, runtime);
}

model CreateComponentIndexRequest {
  meta?: map[string]any(name='_meta', example='{       "description": "set number of shards to one"   }'),
  template?: {
    aliases?: map[string]any(name='aliases', example='{}'),
    mappings?: map[string]any(name='mappings', example='{ 			"properties": { 				"@timestamp": { 					"type": "date" 				} 			} 		}'),
    settings?: map[string]any(name='settings', example='{ 			"index.number_of_replicas": 0 		}'),
  }(name='template'),
}

model CreateComponentIndexResponseBody = {
  requestId?: string(name='RequestId', example='C20022BA-5382-4339-89FB-30AF48A05431'),
  result?: boolean(name='Result', example='true'),
}

model CreateComponentIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateComponentIndexResponseBody(name='body'),
}

/**
 * @summary 创建Elasticsearch组合模板
 *
 * @param request CreateComponentIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateComponentIndexResponse
 */
async function createComponentIndexWithOptions(InstanceId: string, name: string, request: CreateComponentIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateComponentIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meta)) {
    body['_meta'] = request.meta;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建Elasticsearch组合模板
 *
 * @param request CreateComponentIndexRequest
 * @return CreateComponentIndexResponse
 */
async function createComponentIndex(InstanceId: string, name: string, request: CreateComponentIndexRequest): CreateComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createComponentIndexWithOptions(InstanceId, name, request, headers, runtime);
}

model CreateDataStreamRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF***'),
  body?: string(name='body'),
}

model CreateDataStreamResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: {
    name?: string(name='name', example='ds-'),
  }(name='Result'),
}

model CreateDataStreamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataStreamResponseBody(name='body'),
}

/**
 * @summary 创建数据流
 *
 * @param request CreateDataStreamRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataStreamResponse
 */
async function createDataStreamWithOptions(InstanceId: string, request: CreateDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDataStreamResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateDataStream',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建数据流
 *
 * @param request CreateDataStreamRequest
 * @return CreateDataStreamResponse
 */
async function createDataStream(InstanceId: string, request: CreateDataStreamRequest): CreateDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDataStreamWithOptions(InstanceId, request, headers, runtime);
}

model CreateILMPolicyRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model CreateILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='my-policy'),
}

model CreateILMPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateILMPolicyResponseBody(name='body'),
}

/**
 * @summary 创建索引生命周期策略
 *
 * @param request CreateILMPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateILMPolicyResponse
 */
async function createILMPolicyWithOptions(InstanceId: string, request: CreateILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateILMPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建索引生命周期策略
 *
 * @param request CreateILMPolicyRequest
 * @return CreateILMPolicyResponse
 */
async function createILMPolicy(InstanceId: string, request: CreateILMPolicyRequest): CreateILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createILMPolicyWithOptions(InstanceId, request, headers, runtime);
}

model CreateIndexTemplateRequest {
  clientToken?: string(name='ClientToken', example='E1136AE9-4E49-4585-9358-6FDD2A6D****'),
  dataStream?: boolean(name='dataStream', description='This parameter is required.'),
  ilmPolicy?: string(name='ilmPolicy', example='policy-1'),
  indexPatterns?: [ string ](name='indexPatterns', description='This parameter is required.'),
  indexTemplate?: string(name='indexTemplate', description='This parameter is required.', example='index-template'),
  priority?: int32(name='priority', example='100'),
  template?: {
    aliases?: string(name='aliases', example='{"mydata": {}}'),
    mappings?: string(name='mappings', example='{"properties": {"created_at": {"type": "date","format": "EEE MMM dd HH:mm:ss Z yyyy"},"host_name": {"type": "keyword"}}}'),
    settings?: string(name='settings', example='{\\"index.refresh_interval\\":\\"1s\\"}'),
  }(name='template'),
}

model CreateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='index-template'),
}

model CreateIndexTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateIndexTemplateResponseBody(name='body'),
}

/**
 * @summary 创建索引模版
 *
 * @param request CreateIndexTemplateRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIndexTemplateResponse
 */
async function createIndexTemplateWithOptions(InstanceId: string, request: CreateIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.dataStream)) {
    body['dataStream'] = request.dataStream;
  }
  if (!Util.isUnset(request.ilmPolicy)) {
    body['ilmPolicy'] = request.ilmPolicy;
  }
  if (!Util.isUnset(request.indexPatterns)) {
    body['indexPatterns'] = request.indexPatterns;
  }
  if (!Util.isUnset(request.indexTemplate)) {
    body['indexTemplate'] = request.indexTemplate;
  }
  if (!Util.isUnset(request.priority)) {
    body['priority'] = request.priority;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建索引模版
 *
 * @param request CreateIndexTemplateRequest
 * @return CreateIndexTemplateResponse
 */
async function createIndexTemplate(InstanceId: string, request: CreateIndexTemplateRequest): CreateIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexTemplateWithOptions(InstanceId, request, headers, runtime);
}

model CreateLogstashRequest {
  description?: string(name='description', example='ls-cn-abc'),
  networkConfig?: {
    type?: string(name='type', example='vpc'),
    vpcId?: string(name='vpcId', description='This parameter is required.', example='vpc-bp16k1dvzxtmagcva****'),
    vsArea?: string(name='vsArea', description='This parameter is required.', example='cn-hangzhou-i'),
    vswitchId?: string(name='vswitchId', description='This parameter is required.', example='vsw-bp1k4ec6s7sjdbudw****'),
  }(name='networkConfig', description='This parameter is required.'),
  nodeAmount?: int32(name='nodeAmount', description='This parameter is required.', example='2'),
  nodeSpec?: {
    disk?: long(name='disk', example='50'),
    diskType?: string(name='diskType', example='cloud_ssd'),
    spec?: string(name='spec', description='This parameter is required.', example='logstash.n4.small'),
  }(name='nodeSpec', description='This parameter is required.'),
  paymentInfo?: {
    autoRenewDuration?: long(name='autoRenewDuration', example='3'),
    duration?: long(name='duration', example='1'),
    isAutoRenew?: boolean(name='isAutoRenew', example='false'),
    pricingCycle?: string(name='pricingCycle', example='Month'),
  }(name='paymentInfo'),
  paymentType?: string(name='paymentType', example='prepaid'),
  resourceGroupId?: string(name='resourceGroupId'),
  version?: string(name='version', description='This parameter is required.', example='6.7_with_X-Pack'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CreateLogstashResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE*****'),
  result?: Logstash(name='Result'),
}

model CreateLogstashResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLogstashResponseBody(name='body'),
}

/**
 * @summary 创建logstash实例
 *
 * @param request CreateLogstashRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLogstashResponse
 */
async function createLogstashWithOptions(request: CreateLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.networkConfig)) {
    body['networkConfig'] = request.networkConfig;
  }
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }
  if (!Util.isUnset(request.paymentInfo)) {
    body['paymentInfo'] = request.paymentInfo;
  }
  if (!Util.isUnset(request.paymentType)) {
    body['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建logstash实例
 *
 * @param request CreateLogstashRequest
 * @return CreateLogstashResponse
 */
async function createLogstash(request: CreateLogstashRequest): CreateLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogstashWithOptions(request, headers, runtime);
}

model CreatePipelinesRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: [ 
    {
      batchDelay?: int32(name='batchDelay', example='50'),
      batchSize?: int32(name='batchSize', example='125'),
      config?: string(name='config', description='This parameter is required.', example='input { } filter { } output { }'),
      description?: string(name='description', example='this is a test'),
      pipelineId?: string(name='pipelineId', description='This parameter is required.', example='pipeline-test'),
      queueCheckPointWrites?: int32(name='queueCheckPointWrites', example='1024'),
      queueMaxBytes?: int32(name='queueMaxBytes', example='1024'),
      queueType?: string(name='queueType', example='MEMORY'),
      workers?: int32(name='workers', example='2'),
    }
  ](name='body'),
  trigger?: boolean(name='trigger', example='false'),
}

model CreatePipelinesResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model CreatePipelinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePipelinesResponseBody(name='body'),
}

/**
 * @summary 创建Logstash管道任务
 *
 * @param request CreatePipelinesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePipelinesResponse
 */
async function createPipelinesWithOptions(InstanceId: string, request: CreatePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建Logstash管道任务
 *
 * @param request CreatePipelinesRequest
 * @return CreatePipelinesResponse
 */
async function createPipelines(InstanceId: string, request: CreatePipelinesRequest): CreatePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPipelinesWithOptions(InstanceId, request, headers, runtime);
}

model CreateSnapshotRequest {
  clientToken?: string(name='ClientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.

This parameter is required.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='Return results:

*   true: manual snapshot backup successfully
*   false: manual snapshot backup failed', example='true'),
}

model CreateSnapshotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSnapshotResponseBody(name='body'),
}

/**
 * @param request CreateSnapshotRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSnapshotResponse
 */
async function createSnapshotWithOptions(InstanceId: string, request: CreateSnapshotRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSnapshotResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'CreateSnapshot',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshots`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateSnapshotRequest
 * @return CreateSnapshotResponse
 */
async function createSnapshot(InstanceId: string, request: CreateSnapshotRequest): CreateSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSnapshotWithOptions(InstanceId, request, headers, runtime);
}

model CreateVpcEndpointRequest {
  clientToken?: string(name='ClientToken', description='The returned result details.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  serviceId?: string(name='serviceId', example='epsrv-hp3xdsq46ael67lo****'),
  zoneId?: string(name='zoneId', example='cn-hangzhou-i'),
  dryRun?: boolean(name='dryRun', description='The ID of the user endpoint service associated with the endpoint.', example='false'),
}

model CreateVpcEndpointResponseBody = {
  requestId?: string(name='RequestId', description='The endpoint domain name, which is used to configure the connection.', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: {
    endpointDomain?: string(name='endpointDomain', example='ep-bp1tah7zbrwmkjef****.epsrv-bp1w0p3jdirbfmt6****.cn-hangzhou.privatelink.aliyuncs.com'),
    endpointId?: string(name='endpointId', example='ep-bp1tah7zbrwmkjef****'),
    endpointName?: string(name='endpointName', example='vpcElasticSearchABC'),
    serviceId?: string(name='serviceId', description='The name of the service VPC-side endpoint.', example='epsrv-bp1w0p3jdirbfmt6****'),
  }(name='Result', description='The ID of the endpoint on the service VPC side.'),
}

model CreateVpcEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateVpcEndpointResponseBody(name='body'),
}

/**
 * @summary 创建私网链接VPC终端节点
 *
 * @description 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D\\*\\*\\*
 *
 * @param request CreateVpcEndpointRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVpcEndpointResponse
 */
async function createVpcEndpointWithOptions(InstanceId: string, request: CreateVpcEndpointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVpcEndpointResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceId)) {
    body['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.zoneId)) {
    body['zoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcEndpoint',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/vpc-endpoints`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建私网链接VPC终端节点
 *
 * @description 5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D\\*\\*\\*
 *
 * @param request CreateVpcEndpointRequest
 * @return CreateVpcEndpointResponse
 */
async function createVpcEndpoint(InstanceId: string, request: CreateVpcEndpointRequest): CreateVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVpcEndpointWithOptions(InstanceId, request, headers, runtime);
}

model DeactivateZonesRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='Used to ensure idempotency of the request. The client generates this parameter value and must guarantee its uniqueness across different requests, with a maximum length of 64 ASCII characters.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model DeactivateZonesResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return result:

- true: Zone offline successful
- false: Zone offline failed', example='true'),
}

model DeactivateZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeactivateZonesResponseBody(name='body'),
}

/**
 * @summary Invoke DeactivateZones to offline certain zones when there are multiple availability zones, and migrate nodes in the offline zones to other availability zones.
 *
 * @param request DeactivateZonesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeactivateZonesResponse
 */
async function deactivateZonesWithOptions(InstanceId: string, request: DeactivateZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeactivateZonesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'DeactivateZones',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/down-zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Invoke DeactivateZones to offline certain zones when there are multiple availability zones, and migrate nodes in the offline zones to other availability zones.
 *
 * @param request DeactivateZonesRequest
 * @return DeactivateZonesResponse
 */
async function deactivateZones(InstanceId: string, request: DeactivateZonesRequest): DeactivateZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deactivateZonesWithOptions(InstanceId, request, headers, runtime);
}

model DeleteCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model DeleteCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Indicates whether the shipper is deleted. Valid values:

*   true: The shipper is deleted.
*   false: The shipper fails to be deleted.', example='true'),
}

model DeleteCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCollectorResponseBody(name='body'),
}

/**
 * @summary Deletes a shipper.
 *
 * @param request DeleteCollectorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCollectorResponse
 */
async function deleteCollectorWithOptions(ResId: string, request: DeleteCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a shipper.
 *
 * @param request DeleteCollectorRequest
 * @return DeleteCollectorResponse
 */
async function deleteCollector(ResId: string, request: DeleteCollectorRequest): DeleteCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCollectorWithOptions(ResId, request, headers, runtime);
}

model DeleteComponentIndexResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: boolean(name='Result', example='true'),
}

model DeleteComponentIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteComponentIndexResponseBody(name='body'),
}

/**
 * @summary 删除组合索引模板
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteComponentIndexResponse
 */
async function deleteComponentIndexWithOptions(InstanceId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteComponentIndexResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除组合索引模板
 *
 * @return DeleteComponentIndexResponse
 */
async function deleteComponentIndex(InstanceId: string, name: string): DeleteComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteComponentIndexWithOptions(InstanceId, name, headers, runtime);
}

model DeleteConnectedClusterRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  connectedInstanceId?: string(name='connectedInstanceId', description='The ID of the remote instance for which the network connection is established.

This parameter is required.', example='es-cn-09k1rgid9000g****'),
}

model DeleteConnectedClusterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='Return results:

*   true: remove the interworking instance successfully
*   false: remove the interworking instance failed', example='true'),
}

model DeleteConnectedClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConnectedClusterResponseBody(name='body'),
}

/**
 * @param request DeleteConnectedClusterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConnectedClusterResponse
 */
async function deleteConnectedClusterWithOptions(InstanceId: string, request: DeleteConnectedClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConnectedClusterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectedInstanceId)) {
    query['connectedInstanceId'] = request.connectedInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConnectedCluster',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connected-clusters`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteConnectedClusterRequest
 * @return DeleteConnectedClusterResponse
 */
async function deleteConnectedCluster(InstanceId: string, request: DeleteConnectedClusterRequest): DeleteConnectedClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConnectedClusterWithOptions(InstanceId, request, headers, runtime);
}

model DeleteDataStreamRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model DeleteDataStreamResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model DeleteDataStreamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataStreamResponseBody(name='body'),
}

/**
 * @summary 删除数据流
 *
 * @param request DeleteDataStreamRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDataStreamResponse
 */
async function deleteDataStreamWithOptions(InstanceId: string, DataStream: string, request: DeleteDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataStreamResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataStream',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams/${OpenApiUtil.getEncodeParam(DataStream)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除数据流
 *
 * @param request DeleteDataStreamRequest
 * @return DeleteDataStreamResponse
 */
async function deleteDataStream(InstanceId: string, DataStream: string, request: DeleteDataStreamRequest): DeleteDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime);
}

model DeleteDataTaskRequest {
  clientToken?: string(name='ClientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.

This parameter is required.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  taskId?: string(name='taskId', description='The ID of the index migration task.

This parameter is required.', example='et_cn_0oyg09o96ib40****'),
}

model DeleteDataTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='The returned results.', example='true'),
}

model DeleteDataTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataTaskResponseBody(name='body'),
}

/**
 * @param request DeleteDataTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDataTaskResponse
 */
async function deleteDataTaskWithOptions(InstanceId: string, request: DeleteDataTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.taskId)) {
    query['taskId'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-task`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteDataTaskRequest
 * @return DeleteDataTaskResponse
 */
async function deleteDataTask(InstanceId: string, request: DeleteDataTaskRequest): DeleteDataTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataTaskWithOptions(InstanceId, request, headers, runtime);
}

model DeleteDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: boolean(name='Result', example='true'),
}

model DeleteDeprecatedTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDeprecatedTemplateResponseBody(name='body'),
}

/**
 * @summary 删除历史索引模板
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeprecatedTemplateResponse
 */
async function deleteDeprecatedTemplateWithOptions(InstanceId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDeprecatedTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeprecatedTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/deprecated-templates/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除历史索引模板
 *
 * @return DeleteDeprecatedTemplateResponse
 */
async function deleteDeprecatedTemplate(InstanceId: string, name: string): DeleteDeprecatedTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDeprecatedTemplateWithOptions(InstanceId, name, headers, runtime);
}

model DeleteILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='694FDC20-0FDD-47C4-B921-BFF902FA****'),
  result?: boolean(name='Result', example='true'),
}

model DeleteILMPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteILMPolicyResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteILMPolicyResponse
 */
async function deleteILMPolicyWithOptions(InstanceId: string, PolicyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteILMPolicyResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies/${OpenApiUtil.getEncodeParam(PolicyName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DeleteILMPolicyResponse
 */
async function deleteILMPolicy(InstanceId: string, PolicyName: string): DeleteILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteILMPolicyWithOptions(InstanceId, PolicyName, headers, runtime);
}

model DeleteIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='A0761F7E-0B50-46B9-8CAA-EBB3A420****'),
  result?: boolean(name='Result', example='true'),
}

model DeleteIndexTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteIndexTemplateResponseBody(name='body'),
}

/**
 * @summary 删除ES集群索引模版
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteIndexTemplateResponse
 */
async function deleteIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates/${OpenApiUtil.getEncodeParam(IndexTemplate)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除ES集群索引模版
 *
 * @return DeleteIndexTemplateResponse
 */
async function deleteIndexTemplate(InstanceId: string, IndexTemplate: string): DeleteIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexTemplateWithOptions(InstanceId, IndexTemplate, headers, runtime);
}

model DeleteInstanceRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  deleteType?: string(name='deleteType', example='protective'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='94B03BBA-A132-42C3-8367-0A0C1C45****'),
}

model DeleteInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInstanceResponseBody(name='body'),
}

/**
 * @param request DeleteInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInstanceResponse
 */
async function deleteInstanceWithOptions(InstanceId: string, request: DeleteInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deleteType)) {
    query['deleteType'] = request.deleteType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteInstanceRequest
 * @return DeleteInstanceResponse
 */
async function deleteInstance(InstanceId: string, request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteInstanceWithOptions(InstanceId, request, headers, runtime);
}

model DeleteLogstashRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  deleteType?: string(name='deleteType', description='The type of the release operation. Valid values:

*   immediate: The cluster is immediately deleted when it is released. After the cluster is deleted, the data stored in the cluster is deleted, and the system removes the cluster from the Logstash cluster list.
*   protective: The cluster is released 24 hours later. During the period of 24 hours, you can still find the cluster in the Logstash cluster list, and [restore the cluster](https://help.aliyun.com/document_detail/202205.html) or [immediately release the cluster](https://help.aliyun.com/document_detail/160591.html). After 24 hours elapse, the data stored in the cluster is deleted.', example='protective'),
}

model DeleteLogstashResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='94B03BBA-A132-42C3-8367-0A0C1C45****'),
}

model DeleteLogstashResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLogstashResponseBody(name='body'),
}

/**
 * @summary Releases a Logstash cluster.
 *
 * @description Before you call this operation, take note of the following information: After the cluster is released, the physical resources used by the cluster are reclaimed. The data stored in the cluster is deleted and cannot be recovered. The disks attached to the nodes in the cluster and the snapshots created for the cluster are released.
 *
 * @param request DeleteLogstashRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLogstashResponse
 */
async function deleteLogstashWithOptions(InstanceId: string, request: DeleteLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deleteType)) {
    query['deleteType'] = request.deleteType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Releases a Logstash cluster.
 *
 * @description Before you call this operation, take note of the following information: After the cluster is released, the physical resources used by the cluster are reclaimed. The data stored in the cluster is deleted and cannot be recovered. The disks attached to the nodes in the cluster and the snapshots created for the cluster are released.
 *
 * @param request DeleteLogstashRequest
 * @return DeleteLogstashResponse
 */
async function deleteLogstash(InstanceId: string, request: DeleteLogstashRequest): DeleteLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogstashWithOptions(InstanceId, request, headers, runtime);
}

model DeletePipelinesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  pipelineIds?: string(name='pipelineIds', description='The ID of the pipeline.', example='pipeline-test'),
}

model DeletePipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Indicates whether the pipeline is deleted. Valid values:

*   true: The pipeline is deleted.
*   false: The pipeline fails to be deleted.', example='true'),
}

model DeletePipelinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePipelinesResponseBody(name='body'),
}

/**
 * @summary Deletes a pipeline that is configured for a Logstash cluster.
 *
 * @param request DeletePipelinesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePipelinesResponse
 */
async function deletePipelinesWithOptions(InstanceId: string, request: DeletePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.pipelineIds)) {
    query['pipelineIds'] = request.pipelineIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a pipeline that is configured for a Logstash cluster.
 *
 * @param request DeletePipelinesRequest
 * @return DeletePipelinesResponse
 */
async function deletePipelines(InstanceId: string, request: DeletePipelinesRequest): DeletePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePipelinesWithOptions(InstanceId, request, headers, runtime);
}

model DeleteSnapshotRepoRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  repoPath?: string(name='repoPath', description='Reference instance ID.

This parameter is required.', example='es-cn-n6w1rux8i000w****'),
}

model DeleteSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: reference warehouse deleted successfully
*   false: reference warehouse deleted successfully failed', example='true'),
}

model DeleteSnapshotRepoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSnapshotRepoResponseBody(name='body'),
}

/**
 * @param request DeleteSnapshotRepoRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSnapshotRepoResponse
 */
async function deleteSnapshotRepoWithOptions(InstanceId: string, request: DeleteSnapshotRepoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSnapshotRepoResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.repoPath)) {
    query['repoPath'] = request.repoPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSnapshotRepo',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-repos`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSnapshotRepoRequest
 * @return DeleteSnapshotRepoResponse
 */
async function deleteSnapshotRepo(InstanceId: string, request: DeleteSnapshotRepoRequest): DeleteSnapshotRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSnapshotRepoWithOptions(InstanceId, request, headers, runtime);
}

model DeleteVpcEndpointRequest {
  clientToken?: string(name='ClientToken', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
}

model DeleteVpcEndpointResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: boolean(name='Result', example='true'),
}

model DeleteVpcEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteVpcEndpointResponseBody(name='body'),
}

/**
 * @summary 删除服务账号vpc下的终端节点
 *
 * @param request DeleteVpcEndpointRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVpcEndpointResponse
 */
async function deleteVpcEndpointWithOptions(InstanceId: string, EndpointId: string, request: DeleteVpcEndpointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVpcEndpointResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcEndpoint',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/vpc-endpoints/${OpenApiUtil.getEncodeParam(EndpointId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除服务账号vpc下的终端节点
 *
 * @param request DeleteVpcEndpointRequest
 * @return DeleteVpcEndpointResponse
 */
async function deleteVpcEndpoint(InstanceId: string, EndpointId: string, request: DeleteVpcEndpointRequest): DeleteVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVpcEndpointWithOptions(InstanceId, EndpointId, request, headers, runtime);
}

model DescribeAckOperatorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6615EE8D-FD9D-4FD3-997E-6FEA5B8D82ED'),
  result?: {
    status?: string(name='status', description='The installation status of ES-operator. Valid values:

*   deployed: ES-operator is installed.
*   not-deploy: ES-operator is not installed.
*   failed: ES-operator fails to be installed.
*   unknown: The installation status of ES-operator is unknown.', example='deployed'),
    version?: string(name='version', description='The version of ES-operator.', example='1'),
  }(name='Result', description='The returned result.'),
}

model DescribeAckOperatorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAckOperatorResponseBody(name='body'),
}

/**
 * @summary Queries the information of ES-operator that is installed for a specified Container Service for Kubernetes (ACK) cluster.
 *
 * @description > Before you install a shipper on an ACK cluster, you can call this operation to query the installation status of ES-operator for the ACK cluster.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAckOperatorResponse
 */
async function describeAckOperatorWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAckOperatorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeAckOperator',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters/${OpenApiUtil.getEncodeParam(ClusterId)}/operator`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information of ES-operator that is installed for a specified Container Service for Kubernetes (ACK) cluster.
 *
 * @description > Before you install a shipper on an ACK cluster, you can call this operation to query the installation status of ES-operator for the ACK cluster.
 *
 * @return DescribeAckOperatorResponse
 */
async function describeAckOperator(ClusterId: string): DescribeAckOperatorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAckOperatorWithOptions(ClusterId, headers, runtime);
}

model DescribeApmResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='97597D87-8066-5493-B692-5C50DA236D68'),
  result?: {
    apmServerDomain?: string(name='apmServerDomain', description='Instance domain.', example='apm-cn-i7m2fuae****.apm.elasticsearch.aliyuncs.com:8200'),
    createdAt?: string(name='createdAt', description='Creation time.', example='2021-11-16T07:15:51.967Z'),
    deployedReplica?: long(name='deployedReplica', description='Deployed replica count.', example='1'),
    description?: string(name='description', description='Instance name.', example='APMtest'),
    endTime?: long(name='endTime', description='Instance expiration time.', example='4792752000000'),
    instanceId?: string(name='instanceId', description='Instance ID.', example='apm-cn-i7m2fuae****'),
    nodeAmount?: long(name='nodeAmount', description='Number of nodes.', example='1'),
    outputES?: string(name='outputES', description='Associated Elasticsearch instance.', example='es-cn-i7m2fsfhc001x****'),
    outputESUserName?: string(name='outputESUserName', description='Username of the associated Elasticsearch instance.', example='elastic'),
    ownerId?: string(name='ownerId', description='User account ID.', example='133071096032****'),
    paymentType?: string(name='paymentType', description='Payment method, with the following values:

- postpaid: Pay-as-you-go.

- prepaid: Subscription.', example='postpaid'),
    region?: string(name='region', description='Region.', example='cn-hangzhou'),
    replica?: int32(name='replica', description='Replica count.', example='1'),
    resourceSpec?: string(name='resourceSpec', description='Specification, with the following values:

- C1M2 (1 core, 2 GB)

- C2M4 (2 cores, 4 GB)', example='C1M2'),
    status?: string(name='status', description='Lifecycle status, with the following values:

- CREATING: Creating.

- ACTIVATING: Activating.

- ACTIVE: Active.

- INACTIVE: Frozen.

- INVALID: Invalid.', example='active'),
    version?: string(name='version', description='Version information.', example='7.10.2'),
    vpcId?: string(name='vpcId', description='VPC ID.', example='vpc-bp1530vdhqkamm9s0****'),
    vsArea?: string(name='vsArea', description='Availability zone where the switch is located.', example='cn-hangzhou-i'),
    vswitchId?: string(name='vswitchId', description='Switch ID.', example='vsw-bp1j1mql6r9g5vfb4****'),
  }(name='Result', description='Request result.'),
}

model DescribeApmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeApmResponseBody(name='body'),
}

/**
 * @summary Describe APM
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeApmResponse
 */
async function describeApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Describe APM
 *
 * @return DescribeApmResponse
 */
async function describeApm(instanceId: string): DescribeApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApmWithOptions(instanceId, headers, runtime);
}

model DescribeCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content', description='The content of the file.', example='fileBeat.inputs:xxx'),
        fileName?: string(name='fileName', description='The name of the file.', example='filebeat.yml'),
      }
    ](name='configs', description='The information about the configuration file of the shipper.'),
    dryRun?: boolean(name='dryRun', description='Indicates whether a dry run is performed. Valid values:

*   true
*   false', example='false'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType', description='The configuration type. Valid values:

*   collectorTargetInstance
*   collectorDeployMachine
*   collectorElasticsearchForKibana', example='collectorDeployMachine'),
        enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether monitoring is enabled. This parameter is returned if the value of **configType** is **collectorTargetInstance**. Valid values:

*   true
*   false', example='true'),
        groupId?: string(name='groupId', description='The ID of the machine group. This parameter is returned if the value of **configType** is **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
        host?: string(name='host', description='The private endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId', description='The ID of the resource that is associated with the shipper. If the value of **configType** is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType** is **collectorDeployMachines** and the value of **type** is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='es-cn-n6w1o1****'),
        instanceType?: string(name='instanceType', description='The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='elasticsearch'),
        kibanaHost?: string(name='kibanaHost', description='The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values:

*   heartOk: The heartbeat is normal.
*   heartLost: The heartbeat is abnormal.
*   uninstalled: The shipper is not installed.
*   failed: The shipper fails to be installed.', example='heartOk'),
            instanceId?: string(name='instanceId', description='The IDs of the ECS instances.', example='i-bp1gyhphjaj73jsr****'),
          }
        ](name='machines', description='The information about the Elastic Compute Service (ECS) instances on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachines** and the value of **type** is **ECSInstanceId**.'),
        protocol?: string(name='protocol', description='The transmission protocol, which must be the same as the access protocol of the resource specified in the output configuration part of the shipper. Valid values: HTTP and HTTPS. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='HTTP'),
        successPodsCount?: string(name='successPodsCount', description='The number of pods from which data is succcessfully collected in the Container Service for Kubernetes (ACK) cluster.', example='8'),
        totalPodsCount?: string(name='totalPodsCount', description='The total number of pods from which data is collected in the ACK cluster.', example='10'),
        type?: string(name='type', description='The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
        userName?: string(name='userName', description='The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
      }
    ](name='extendConfigs', description='The extended configurations of the shipper.'),
    gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-06-20T07:26:47.000+0000'),
    name?: string(name='name', description='The name of the shipper.', example='ct-cn-4135is2tj194p****'),
    ownerId?: string(name='ownerId', description='The account ID.', example='16852099488*****'),
    resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-rg31ahn82m0qd****'),
    resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.', example='fileBeat'),
    resVersion?: string(name='resVersion', description='The version of the shipper.', example='6.8.5_with_community'),
    status?: string(name='status', description='The status of the shipper. Valid values:

*   activating
*   active', example='active'),
    vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) where the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
  }(name='Result', description='The returned result.'),
}

model DescribeCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCollectorResponseBody(name='body'),
}

/**
 * @summary Queries the details of a shipper.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCollectorResponse
 */
async function describeCollectorWithOptions(ResId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeCollectorResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a shipper.
 *
 * @return DescribeCollectorResponse
 */
async function describeCollector(ResId: string): DescribeCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeCollectorWithOptions(ResId, headers, runtime);
}

model DescribeComponentIndexResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: {
    meta?: map[string]any(name='_meta', example='{ "description": "set number of shards to one" }'),
    template?: {
      aliases?: map[string]any(name='aliases', example='{}'),
      mappings?: map[string]any(name='mappings', example='{ "properties": { "@timestamp": { "type": "date" } } }'),
      settings?: map[string]any(name='settings', example='{ "index.number_of_replicas": 0 }'),
    }(name='template'),
  }(name='Result'),
}

model DescribeComponentIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeComponentIndexResponseBody(name='body'),
}

/**
 * @summary 查看组合索引模板详情
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeComponentIndexResponse
 */
async function describeComponentIndexWithOptions(InstanceId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeComponentIndexResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看组合索引模板详情
 *
 * @return DescribeComponentIndexResponse
 */
async function describeComponentIndex(InstanceId: string, name: string): DescribeComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeComponentIndexWithOptions(InstanceId, name, headers, runtime);
}

model DescribeConnectableClustersRequest {
  alreadySetItems?: boolean(name='alreadySetItems', description='The ID of the instance that can communicate with each other.', example='true'),
}

model DescribeConnectableClustersResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      instances?: string(name='instances', example='es-cn-xxx'),
      networkType?: string(name='networkType', example='vpc'),
    }
  ](name='Result'),
}

model DescribeConnectableClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConnectableClustersResponseBody(name='body'),
}

/**
 * @param request DescribeConnectableClustersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConnectableClustersResponse
 */
async function describeConnectableClustersWithOptions(InstanceId: string, request: DescribeConnectableClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeConnectableClustersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.alreadySetItems)) {
    query['alreadySetItems'] = request.alreadySetItems;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConnectableClusters',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connectable-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeConnectableClustersRequest
 * @return DescribeConnectableClustersResponse
 */
async function describeConnectableClusters(InstanceId: string, request: DescribeConnectableClustersRequest): DescribeConnectableClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeConnectableClustersWithOptions(InstanceId, request, headers, runtime);
}

model DescribeDeprecatedTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: {
    dataStream?: boolean(name='dataStream', example='false'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate', example='openstore-index-template'),
    order?: long(name='order', example='100'),
    template?: {
      aliases?: string(name='aliases', example='"{}"'),
      mappings?: string(name='mappings', example='"{\\\\"properties\\\\":{\\\\"created_at\\\\":{\\\\"format\\\\":\\\\"EEE MMM dd HH:mm:ss Z yyyy\\\\",\\\\"type\\\\":\\\\"date\\\\"},\\\\"host_name\\\\":{\\\\"type\\\\":\\\\"keyword\\\\"}}}"'),
      settings?: string(name='settings', example='"{\\\\"index.number_of_shards\\\\":\\\\"1\\\\"}"'),
    }(name='template'),
    version?: string(name='version', example='70000'),
  }(name='Result'),
}

model DescribeDeprecatedTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDeprecatedTemplateResponseBody(name='body'),
}

/**
 * @summary DescribeDeprecatedTemplate
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDeprecatedTemplateResponse
 */
async function describeDeprecatedTemplateWithOptions(InstanceId: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDeprecatedTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeprecatedTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/deprecated-templates/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary DescribeDeprecatedTemplate
 *
 * @return DescribeDeprecatedTemplateResponse
 */
async function describeDeprecatedTemplate(InstanceId: string, name: string): DescribeDeprecatedTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDeprecatedTemplateWithOptions(InstanceId, name, headers, runtime);
}

model DescribeDiagnoseReportRequest {
  lang?: string(name='lang', example='en'),
}

model DescribeDiagnoseReportResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    createTime?: long(name='createTime', example='1535745731000'),
    diagnoseItems?: [ 
      {
        detail?: {
          desc?: string(name='desc', example='Check whether the number of replica shards is optimal and easy to maintain'),
          name?: string(name='name', example='Number of Replica Shards'),
          result?: string(name='result', example='You may need to adjust the numbers of replica shards of some indices as follows: [geoname08 : 0 -&gt; 1][geoname09 : 0 -&gt; 1][geonametest01 : 0 -&gt; 1]'),
          suggest?: string(name='suggest', example='You can call the following function in the Elasticsearch API....'),
          type?: string(name='type', example='ES_API'),
        }(name='detail'),
        health?: string(name='health', example='YELLOW'),
        item?: string(name='item', example='IndexAliasUseDiagnostic'),
      }
    ](name='diagnoseItems'),
    health?: string(name='health', example='YELLOW'),
    instanceId?: string(name='instanceId', example='es-cn-abc'),
    reportId?: string(name='reportId', example='trigger__2020-08-17T17:09:02'),
    state?: string(name='state', example='SUCCESS'),
    trigger?: string(name='trigger', example='SYSTEM'),
  }(name='Result'),
}

model DescribeDiagnoseReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDiagnoseReportResponseBody(name='body'),
}

/**
 * @param request DescribeDiagnoseReportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDiagnoseReportResponse
 */
async function describeDiagnoseReportWithOptions(InstanceId: string, ReportId: string, request: DescribeDiagnoseReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDiagnoseReportResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiagnoseReport',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/reports/${OpenApiUtil.getEncodeParam(ReportId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDiagnoseReportRequest
 * @return DescribeDiagnoseReportResponse
 */
async function describeDiagnoseReport(InstanceId: string, ReportId: string, request: DescribeDiagnoseReportRequest): DescribeDiagnoseReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDiagnoseReportWithOptions(InstanceId, ReportId, request, headers, runtime);
}

model DescribeDiagnosisSettingsRequest {
  lang?: string(name='lang', description='The language of the returned result. Default value: en.', example='en'),
}

model DescribeDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5E82B8A8-EED7-4557-A6E9-D1AD3E58****'),
  result?: {
    scene?: string(name='scene', description='Scenarios of intelligent maintenance.', example='Business Search'),
    updateTime?: long(name='updateTime', description='The timestamp of the last update for Intelligent Maintenance scenarios.', example='1588994035385'),
  }(name='Result', description='The return results.'),
}

model DescribeDiagnosisSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDiagnosisSettingsResponseBody(name='body'),
}

/**
 * @param request DescribeDiagnosisSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDiagnosisSettingsResponse
 */
async function describeDiagnosisSettingsWithOptions(InstanceId: string, request: DescribeDiagnosisSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDiagnosisSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiagnosisSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeDiagnosisSettingsRequest
 * @return DescribeDiagnosisSettingsResponse
 */
async function describeDiagnosisSettings(InstanceId: string, request: DescribeDiagnosisSettingsRequest): DescribeDiagnosisSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime);
}

model DescribeDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeDynamicSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDynamicSettingsResponseBody(name='body'),
}

/**
 * @summary 获取集群动态指标
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDynamicSettingsResponse
 */
async function describeDynamicSettingsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDynamicSettingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDynamicSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dynamic-settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取集群动态指标
 *
 * @return DescribeDynamicSettingsResponse
 */
async function describeDynamicSettings(InstanceId: string): DescribeDynamicSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDynamicSettingsWithOptions(InstanceId, headers, runtime);
}

model DescribeElasticsearchHealthResponseBody = {
  code?: string(name='Code', description='The response code returned.', example='200'),
  message?: string(name='Message', description='The response message returned.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0731F217-2C8A-4D42-8BCD-5C352866E3B7'),
  result?: string(name='Result', description='The color that indicates the health status of the cluster.', example='GREEN'),
}

model DescribeElasticsearchHealthResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeElasticsearchHealthResponseBody(name='body'),
}

/**
 * @summary Queries the health status of an Elasticsearch cluster.
 *
 * @description An Elasticsearch cluster can be in a health state indicated by one of the following colors:
 * *   GREEN: Primary shards and replica shards for the primary shards are normally allocated.
 * *   YELLOW: Primary shards are normally allocated, but replica shards for the primary shards are not normally allocated.
 * *   RED: Primary shards are not normally allocated.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeElasticsearchHealthResponse
 */
async function describeElasticsearchHealthWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeElasticsearchHealthResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeElasticsearchHealth',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/elasticsearch-health`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the health status of an Elasticsearch cluster.
 *
 * @description An Elasticsearch cluster can be in a health state indicated by one of the following colors:
 * *   GREEN: Primary shards and replica shards for the primary shards are normally allocated.
 * *   YELLOW: Primary shards are normally allocated, but replica shards for the primary shards are not normally allocated.
 * *   RED: Primary shards are not normally allocated.
 *
 * @return DescribeElasticsearchHealthResponse
 */
async function describeElasticsearchHealth(InstanceId: string): DescribeElasticsearchHealthResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeElasticsearchHealthWithOptions(InstanceId, headers, runtime);
}

model DescribeILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='FF44681E-FD41-4FDE-B8DF-295DCDD6****'),
  result?: {
    name?: string(name='name', example='ilm-history-ilm-policy'),
    phases?: map[string]any(name='phases', example='{"cold":{"minAge":"30d","actions":{"allocate":{"numberOfReplicas":1,"require":{"boxType":"warm"}},"setPriority":{"priority":100}}},"hot":{"minAge":"0s","actions":{"rollover":{"maxAge":"30d","maxDocs":10000,"maxSize":"50gb"},"setPriority":{"priority":1000}}},"delete":{"minAge":"30d","actions":{"delete":{}}}}'),
  }(name='Result'),
}

model DescribeILMPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeILMPolicyResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeILMPolicyResponse
 */
async function describeILMPolicyWithOptions(InstanceId: string, PolicyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeILMPolicyResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies/${OpenApiUtil.getEncodeParam(PolicyName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeILMPolicyResponse
 */
async function describeILMPolicy(InstanceId: string, PolicyName: string): DescribeILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeILMPolicyWithOptions(InstanceId, PolicyName, headers, runtime);
}

model DescribeIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='25DB38F8-82E4-4D16-82BB-FF077C7F****'),
  result?: {
    dataStream?: boolean(name='dataStream', example='true'),
    ilmPolicy?: string(name='ilmPolicy', example='cube_default_ilm_policy'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate', example='data-stream-default'),
    priority?: int32(name='priority', example='0'),
    template?: {
      aliases?: string(name='aliases', example='{\\\\"mydata\\\\":{}}'),
      mappings?: string(name='mappings', example='{\\\\"properties\\\\":{\\\\"created_at\\\\":{\\\\"format\\\\":\\\\"EEE MMM dd HH:mm:ss Z yyyy\\\\",\\\\"type\\\\":\\\\"date\\\\"},\\\\"host_name\\\\":{\\\\"type\\\\":\\\\"keyword\\\\"}}}'),
      settings?: string(name='settings', example='{\\\\"index.refresh_interval\\\\":\\\\"1s\\\\"}'),
    }(name='template'),
  }(name='Result'),
}

model DescribeIndexTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeIndexTemplateResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeIndexTemplateResponse
 */
async function describeIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeIndexTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates/${OpenApiUtil.getEncodeParam(IndexTemplate)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeIndexTemplateResponse
 */
async function describeIndexTemplate(InstanceId: string, IndexTemplate: string): DescribeIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeIndexTemplateWithOptions(InstanceId, IndexTemplate, headers, runtime);
}

model DescribeInstanceResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    advancedDedicateMaster?: boolean(name='advancedDedicateMaster', example='true'),
    advancedSetting?: {
      gcName?: string(name='gcName', example='CMS'),
    }(name='advancedSetting'),
    aliwsDicts?: [ 
      {
        fileSize?: long(name='fileSize', example='2782602'),
        name?: string(name='name', example='aliws_ext_dict.txt'),
        sourceType?: string(name='sourceType', example='OSS'),
        type?: string(name='type', example='ALI_WS'),
      }
    ](name='aliwsDicts'),
    archType?: string(name='archType'),
    clientNodeConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='40'),
      diskType?: string(name='diskType', example='cloud_efficiency'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
      specInfo?: string(name='specInfo'),
    }(name='clientNodeConfiguration'),
    createdAt?: string(name='createdAt', example='2018-07-13T03:58:07.253Z'),
    dedicateMaster?: boolean(name='dedicateMaster', example='false'),
    description?: string(name='description', example='es-cn-abc'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize', example='2782602'),
        name?: string(name='name', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', example='ORIGIN'),
        type?: string(name='type', example='MAIN'),
      }
    ](name='dictList'),
    domain?: string(name='domain', example='es-cn-3h4k3axh33th9****.elasticsearch.aliyuncs.com'),
    elasticDataNodeConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='20'),
      diskEncryption?: boolean(name='diskEncryption', example='true'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      spec?: string(name='spec', example='elasticsearch.sn2ne.large'),
      specInfo?: string(name='specInfo'),
    }(name='elasticDataNodeConfiguration'),
    enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork', example='false'),
    enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork', example='true'),
    enablePublic?: boolean(name='enablePublic', example='true'),
    endtime?: long(name='endtime'),
    esConfig?: map[string]any(name='esConfig', example='{"http.cors.allow-credentials":"false"}'),
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
    esIPWhitelist?: [ string ](name='esIPWhitelist'),
    esVersion?: string(name='esVersion', example='6.3.2_with_X-Pack'),
    extendConfigs?: [  map[string]any ](name='extendConfigs'),
    haveClientNode?: boolean(name='haveClientNode', example='true'),
    haveKibana?: boolean(name='haveKibana', example='true'),
    ikHotDicts?: [ 
      {
        fileSize?: int32(name='fileSize', example='6'),
        name?: string(name='name', example='deploy_0.dic'),
        sourceType?: string(name='sourceType', example='OSS'),
        type?: string(name='type', example='MAIN'),
      }
    ](name='ikHotDicts'),
    instanceCategory?: string(name='instanceCategory', example='advanced'),
    instanceId?: string(name='instanceId', example='es-cn-3h4k3axh33th9****'),
    isNewDeployment?: boolean(name='isNewDeployment', example='true'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', example='1'),
      disk?: int32(name='disk', example='20'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
      specInfo?: string(name='specInfo'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain', example='es-cn-3h4k3axh33th9****.kibana.elasticsearch.aliyuncs.com'),
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
    kibanaPort?: int32(name='kibanaPort', example='5601'),
    kibanaPrivateDomain?: string(name='kibanaPrivateDomain'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
    kibanaPrivatePort?: string(name='kibanaPrivatePort'),
    masterConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='40'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
      specInfo?: string(name='specInfo'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type', example='vpc'),
      vpcId?: string(name='vpcId', example='vpc-abc'),
      vsArea?: string(name='vsArea', example='cn-hangzhou-b'),
      vswitchId?: string(name='vswitchId', example='vsw-abc'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName', example='default'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType', example='PRIVATE_ES'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', example='0'),
      diskEncryption?: boolean(name='diskEncryption', example='true'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      performanceLevel?: string(name='performanceLevel', example='PL1'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
      specInfo?: string(name='specInfo'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType', example='postpaid'),
    port?: int32(name='port', example='9200'),
    postpaidServiceStatus?: string(name='postpaidServiceStatus', example='active'),
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
    protocol?: string(name='protocol', example='HTTP'),
    publicDomain?: string(name='publicDomain', example='es-cn-3h4k3axh33th9****.elasticsearch.aliyuncs.com'),
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
    publicPort?: int32(name='publicPort', example='9200'),
    resourceGroupId?: string(name='resourceGroupId', example='rg-aekzvowej3i****'),
    serviceVpc?: boolean(name='serviceVpc', example='true'),
    status?: string(name='status', example='active'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize', example='2782602'),
        name?: string(name='name', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', example='ORIGIN'),
        type?: string(name='type', example='STOP'),
      }
    ](name='synonymsDicts'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey', example='env'),
        tagValue?: string(name='tagValue', example='dev'),
      }
    ](name='tags'),
    updatedAt?: string(name='updatedAt', example='2018-07-13T03:58:07.253Z'),
    vpcInstanceId?: string(name='vpcInstanceId', example='vpc-bp1uag5jj38c****'),
    warmNode?: boolean(name='warmNode', example='true'),
    warmNodeConfiguration?: {
      amount?: int32(name='amount', example='6'),
      disk?: int32(name='disk', example='500'),
      diskEncryption?: boolean(name='diskEncryption', example='true'),
      diskType?: string(name='diskType', example='cloud_efficiency'),
      spec?: string(name='spec', example='elasticsearch.n4.small'),
      specInfo?: string(name='specInfo'),
    }(name='warmNodeConfiguration'),
    zoneCount?: int32(name='zoneCount', example='2'),
    zoneInfos?: [ 
      {
        status?: string(name='status', example='NORMAL'),
        zoneId?: string(name='zoneId', example='cn-hangzhou-b'),
      }
    ](name='zoneInfos'),
  }(name='Result'),
}

model DescribeInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceResponseBody(name='body'),
}

/**
 * @summary The name of the dictionary file.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceResponse
 */
async function describeInstanceWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The name of the dictionary file.
 *
 * @return DescribeInstanceResponse
 */
async function describeInstance(InstanceId: string): DescribeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInstanceWithOptions(InstanceId, headers, runtime);
}

model DescribeKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6D*****'),
  result?: map[string]any(name='Result', example='{"map.includeElasticMapsService": "false", "server.ssl.cert": "/home/admin/packages/kibana/config/cert/client.crt", "server.ssl.enabled": "true", "server.ssl.key": "/home/admin/packages/kibana/config/cert/client.key", "xpack.reporting.capture.browser.chromium.disableSandbox": "true"}'),
}

model DescribeKibanaSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeKibanaSettingsResponseBody(name='body'),
}

/**
 * @summary 获取Elasticsearch集群Kibana节点settings配置
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeKibanaSettingsResponse
 */
async function describeKibanaSettingsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeKibanaSettingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeKibanaSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Elasticsearch集群Kibana节点settings配置
 *
 * @return DescribeKibanaSettingsResponse
 */
async function describeKibanaSettings(InstanceId: string): DescribeKibanaSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeKibanaSettingsWithOptions(InstanceId, headers, runtime);
}

model DescribeLogstashResponseBody = {
  requestId?: string(name='RequestId', description='Detailed information about the instance.', example='C9334241-4837-46C2-B24B-9BDC517318DE'),
  result?: {
    extendConfigs?: [  map[string]any ](name='ExtendConfigs', description='The configuration information of the node.'),
    resourceGroupId?: string(name='ResourceGroupId', description='The number of data nodes.', example='rg-aekzvowej3i****'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey', description='The value of the tag.', example='env'),
        tagValue?: string(name='tagValue', description='The information about the zones.', example='dev'),
      }
    ](name='Tags', description='The key of the tag.'),
    zoneInfos?: [ 
      {
        status?: string(name='status', description='The zone ID of the new instance.', example='NORMAL'),
        zoneId?: string(name='zoneId', description='The configuration of cluster extension parameters.', example='cn-hangzhou-b'),
      }
    ](name='ZoneInfos', description='The status of the zone. Valid values:

*   ISOLATION: offline
*   NORMAL'),
    config?: map[string]any(name='config', description='The billing method of the instance. Valid values:

*   prepaid: subscription
*   postpaid: pay-as-you-go', example='{"slowlog.threshold.warn": "2s","slowlog.threshold.info": "1s","slowlog.threshold.debug": "500ms","slowlog.threshold.trace": "100ms" }'),
    createdAt?: string(name='createdAt', description='The state of the instance. Four states are supported:

*   Normal: active
*   Active: activating
*   Freeze: inactive
*   Invalid: invalid', example='2020-02-06T14:12:03.672Z'),
    description?: string(name='description', description='The time when the instance was created.', example='ls-cn-abc'),
    endpointList?: [ 
      {
        host?: string(name='host', description='The tags added to the ALB instance.', example='``172.16.**.**``'),
        port?: string(name='port', description='The IP address of the node.', example='9600'),
        zoneId?: string(name='zoneId', description='The port number.', example='cn-hangzhou-b'),
      }
    ](name='endpointList', description='The ID of the zone where the node resides.'),
    instanceId?: string(name='instanceId', description='The access information of the node.', example='ls-cn-abc'),
    networkConfig?: {
      type?: string(name='type', description='The ID of the vSwitch to which the instance is connected.', example='vpc'),
      vpcId?: string(name='vpcId', description='The zone where the cluster resides.', example='vpc-bp16k1dvzxtmagcva****'),
      vsArea?: string(name='vsArea', description='The network type of the instance. Valid values: Currently, only Virtual Private Cloud (VPC) are supported.', example='cn-hangzhou-*'),
      vswitchId?: string(name='vswitchId', example='vsw-bp1k4ec6s7sjdbudw****'),
    }(name='networkConfig', description='The ID of the virtual private cloud (VPC).'),
    nodeAmount?: int32(name='nodeAmount', description='The name of the instance.', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='Whether to use disk encryption:

*   true
*   false', example='20'),
      diskEncryption?: boolean(name='diskEncryption', description='The disk type of the node.', example='true'),
      diskType?: string(name='diskType', description='The network configurations.', example='cloud_ssd'),
      spec?: string(name='spec', description='The disk size of the node.', example='elasticsearch.sn1ne.large'),
    }(name='nodeSpec', description='The specifications of the node.'),
    paymentType?: string(name='paymentType', description='The ID of the resource group to which the instance belongs.', example='prepaid'),
    status?: string(name='status', description='The ID of the virtual private cloud (VPC) to which the elastic container instances belong.', example='active'),
    updatedAt?: string(name='updatedAt', description='The edition of the dedicated KMS instance.', example='2020-02-06T14:22:36.850Z'),
    version?: string(name='version', description='The ID of the instance.', example='7.4.0_with_X-Pack'),
    vpcInstanceId?: string(name='vpcInstanceId', description='The time when the instance was last updated.', example='vpc-bp16k1dvzxtmagcva****'),
  }(name='Result', description='The configurations of the instance.'),
}

model DescribeLogstashResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLogstashResponseBody(name='body'),
}

/**
 * @summary 查看Logstash实例详情
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogstashResponse
 */
async function describeLogstashWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeLogstashResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看Logstash实例详情
 *
 * @return DescribeLogstashResponse
 */
async function describeLogstash(InstanceId: string): DescribeLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeLogstashWithOptions(InstanceId, headers, runtime);
}

model DescribePipelineResponseBody = {
  requestId?: string(name='RequestId', description='The time when the pipeline was updated.', example='829F38F6-E2D6-4109-90A6-888160BD1***'),
  result?: {
    batchDelay?: int32(name='batchDelay', description='The time when the pipeline was created.', example='50'),
    batchSize?: int32(name='batchSize', example='125'),
    config?: string(name='config', description='The description of the pipeline.', example='input {  }  filter {  }  output {  }'),
    description?: string(name='description', description='The state of the MPS queue. Valid values:

*   NOT_DEPLOYED: The node is not deployed.
*   RUNNING
*   DELETED: Deleted. The console does not display this status.', example='this is a test'),
    gmtCreatedTime?: string(name='gmtCreatedTime', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The total capacity of the queue in bytes. Unit: MB.', example='2020-06-20T07:26:47.000+0000'),
    pipelineId?: string(name='pipelineId', description='Number of queue checkpoint writes.', example='pipeline_test'),
    pipelineStatus?: string(name='pipelineStatus', example='RUNNING'),
    queueCheckPointWrites?: int32(name='queueCheckPointWrites', description='Pipeline batch delay. Unit: milliseconds.', example='1024'),
    queueMaxBytes?: int32(name='queueMaxBytes', description='The number of pipeline workers.', example='1024'),
    queueType?: string(name='queueType', description='The specific configuration of the pipeline.', example='MEMORY'),
    workers?: int32(name='workers', description='The size of the pipeline batch.', example='2'),
  }(name='Result', description='The type of the queue. Valid values:

*   MEMORY: a traditional memory-based queue.
*   PERSISTED: disk-based ACKed queue (persistent queue).'),
}

model DescribePipelineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePipelineResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePipelineResponse
 */
async function describePipelineWithOptions(InstanceId: string, PipelineId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePipelineResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribePipeline',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines/${OpenApiUtil.getEncodeParam(PipelineId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribePipelineResponse
 */
async function describePipeline(InstanceId: string, PipelineId: string): DescribePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePipelineWithOptions(InstanceId, PipelineId, headers, runtime);
}

model DescribePipelineManagementConfigRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model DescribePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    endpoints?: string(name='endpoints', description='The access addresses of the Elasticsearch cluster. Specify each address in the `http://Endpoint of the Elasticsearch cluster:Port number` format.', example='["http://es-cn-n6w1o1x0w001c****.elasticsearch.aliyuncs.com:9200"]'),
    esInstanceId?: string(name='esInstanceId', description='The ID of the Elasticsearch cluster.', example='es-cn-n6w1o1x0w001c****'),
    pipelineIds?: [ string ](name='pipelineIds'),
    pipelineManagementType?: string(name='pipelineManagementType', description='The pipeline management method. Valid values: Kibana and MULTIPLE_PIPELINE.', example='MULTIPLE_PIPELINE'),
    userName?: string(name='userName', description='The username that is used to access the Elasticsearch cluster.', example='elastic'),
  }(name='Result', description='The returned result.'),
}

model DescribePipelineManagementConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePipelineManagementConfigResponseBody(name='body'),
}

/**
 * @summary Queries the management configurations of pipelines in a Logstash cluster.
 *
 * @param request DescribePipelineManagementConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePipelineManagementConfigResponse
 */
async function describePipelineManagementConfigWithOptions(InstanceId: string, request: DescribePipelineManagementConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePipelineManagementConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePipelineManagementConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipeline-management-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the management configurations of pipelines in a Logstash cluster.
 *
 * @param request DescribePipelineManagementConfigRequest
 * @return DescribePipelineManagementConfigResponse
 */
async function describePipelineManagementConfig(InstanceId: string, request: DescribePipelineManagementConfigRequest): DescribePipelineManagementConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime);
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId', description='The available status of the region.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1ADFG'),
  result?: [ 
    {
      consoleEndpoint?: string(name='consoleEndpoint', example='https://elasticsearch-cn-hangzhou.console.aliyun.com'),
      localName?: string(name='localName', example='China (Hangzhou)'),
      regionEndpoint?: string(name='regionEndpoint', example='elasticsearch.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='regionId', description='The name of the region.', example='cn-hangzhou'),
      status?: string(name='status', description='The endpoint of the region that is exposed in the console.', example='available'),
    }
  ](name='Result', description='The endpoint of the region.'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeRegionsResponse
 */
async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

model DescribeSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: {
    enable?: boolean(name='Enable', description='Whether to enable automatic backup.', example='true'),
    quartzRegex?: string(name='QuartzRegex', description='Automatic backup time configuration, using Quartz Cron expression.', example='0 0 01 ? * * *'),
  }(name='Result', description='The return results.'),
}

model DescribeSnapshotSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSnapshotSettingResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSnapshotSettingResponse
 */
async function describeSnapshotSettingWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSnapshotSettingResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnapshotSetting',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-setting`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeSnapshotSettingResponse
 */
async function describeSnapshotSetting(InstanceId: string): DescribeSnapshotSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSnapshotSettingWithOptions(InstanceId, headers, runtime);
}

model DescribeTemplatesResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      content?: string(name='content', example='{\\\\n\\\\t\\\\"persistent\\\\":{\\\\n\\\\t\\\\t\\\\"search\\\\":{\\\\n\\\\t\\\\t\\\\t\\\\"max_buckets\\\\":\\\\"10000\\\\"\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n}'),
      templateName?: string(name='templateName', example='dynamicSettings'),
    }
  ](name='Result'),
}

model DescribeTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTemplatesResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTemplatesResponse
 */
async function describeTemplatesWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTemplatesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return DescribeTemplatesResponse
 */
async function describeTemplates(InstanceId: string): DescribeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTemplatesWithOptions(InstanceId, headers, runtime);
}

model DescribeXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    enable?: boolean(name='enable', description='Indicates whether the X-Pack Monitoring feature is enabled. Valid values:

*   true: enabled
*   false: disabled', example='true'),
    endpoints?: [ string ](name='endpoints'),
    esInstanceId?: string(name='esInstanceId', description='The ID of the associated Elasticsearch cluster.', example='es-cn-n6w1o1x0w001c****'),
    pipelineIds?: [ string ](name='pipelineIds'),
    userName?: string(name='userName', description='The username that is used to access the associated Elasticsearch cluster.', example='elastic'),
  }(name='Result', description='The returned result.'),
}

model DescribeXpackMonitorConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeXpackMonitorConfigResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the X-Pack Monitoring feature of a Logstash cluster.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeXpackMonitorConfigResponse
 */
async function describeXpackMonitorConfigWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeXpackMonitorConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeXpackMonitorConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/xpack-monitor-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the configurations of the X-Pack Monitoring feature of a Logstash cluster.
 *
 * @return DescribeXpackMonitorConfigResponse
 */
async function describeXpackMonitorConfig(InstanceId: string): DescribeXpackMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeXpackMonitorConfigWithOptions(InstanceId, headers, runtime);
}

model DiagnoseInstanceRequest {
  clientToken?: string(name='ClientToken', description='The timestamp when the diagnostic report was generated.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  diagnoseItems?: [ string ](name='diagnoseItems'),
  indices?: [ string ](name='indices'),
  type?: string(name='type', example='ALL'),
  lang?: string(name='lang', description='The returned data.', example='en'),
}

model DiagnoseInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the report.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    createTime?: long(name='createTime', description='The ID of the diagnostic instance.', example='1535745731000'),
    instanceId?: string(name='instanceId', example='es-cn-n6w1o1x0w001c****'),
    reportId?: string(name='reportId', example='trigger__2020-08-17T17:09:02'),
    state?: string(name='state', example='RUNNING'),
  }(name='Result', description='The diagnosis status. Valid values: Supported: SUCCESS, FAILED, and RUNNING.'),
}

model DiagnoseInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DiagnoseInstanceResponseBody(name='body'),
}

/**
 * @summary 触发ES实例智能诊断
 *
 * @param request DiagnoseInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DiagnoseInstanceResponse
 */
async function diagnoseInstanceWithOptions(InstanceId: string, request: DiagnoseInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DiagnoseInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.diagnoseItems)) {
    body['diagnoseItems'] = request.diagnoseItems;
  }
  if (!Util.isUnset(request.indices)) {
    body['indices'] = request.indices;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DiagnoseInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/diagnose`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 触发ES实例智能诊断
 *
 * @param request DiagnoseInstanceRequest
 * @return DiagnoseInstanceResponse
 */
async function diagnoseInstance(InstanceId: string, request: DiagnoseInstanceRequest): DiagnoseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return diagnoseInstanceWithOptions(InstanceId, request, headers, runtime);
}

model DisableKibanaPvlNetworkResponseBody = {
  requestId?: string(name='RequestId', description='request id', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1DERFG'),
  result?: boolean(name='Result', example='true'),
}

model DisableKibanaPvlNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableKibanaPvlNetworkResponseBody(name='body'),
}

/**
 * @summary 关闭kibana私网
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableKibanaPvlNetworkResponse
 */
async function disableKibanaPvlNetworkWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DisableKibanaPvlNetworkResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DisableKibanaPvlNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/disable-kibana-private`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 关闭kibana私网
 *
 * @return DisableKibanaPvlNetworkResponse
 */
async function disableKibanaPvlNetwork(InstanceId: string): DisableKibanaPvlNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableKibanaPvlNetworkWithOptions(InstanceId, headers, runtime);
}

model EnableKibanaPvlNetworkRequest {
  endpointName?: string(name='endpointName', description='This parameter is required.', example='es-cn-27a3mul6l000xxx-kibana-endpoint'),
  securityGroups?: [ string ](name='securityGroups', description='This parameter is required.'),
  vSwitchIdsZone?: [ 
    {
      vswitchId?: string(name='vswitchId', description='This parameter is required.', example='vsw-xxxx'),
      zoneId?: string(name='zoneId', description='This parameter is required.', example='cn-hangzhou-h'),
    }
  ](name='vSwitchIdsZone', description='This parameter is required.'),
  vpcId?: string(name='vpcId', description='This parameter is required.', example='vpc-xxx'),
}

model EnableKibanaPvlNetworkResponseBody = {
  requestId?: string(name='RequestId', example='0DC92CFE-62AF-51AF-9D5B-F1078D7C451E'),
  result?: boolean(name='Result', example='true'),
}

model EnableKibanaPvlNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableKibanaPvlNetworkResponseBody(name='body'),
}

/**
 * @summary 开启v3 kibana私网
 *
 * @param request EnableKibanaPvlNetworkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableKibanaPvlNetworkResponse
 */
async function enableKibanaPvlNetworkWithOptions(InstanceId: string, request: EnableKibanaPvlNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableKibanaPvlNetworkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endpointName)) {
    body['endpointName'] = request.endpointName;
  }
  if (!Util.isUnset(request.securityGroups)) {
    body['securityGroups'] = request.securityGroups;
  }
  if (!Util.isUnset(request.vSwitchIdsZone)) {
    body['vSwitchIdsZone'] = request.vSwitchIdsZone;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['vpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableKibanaPvlNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/enable-kibana-private`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 开启v3 kibana私网
 *
 * @param request EnableKibanaPvlNetworkRequest
 * @return EnableKibanaPvlNetworkResponse
 */
async function enableKibanaPvlNetwork(InstanceId: string, request: EnableKibanaPvlNetworkRequest): EnableKibanaPvlNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableKibanaPvlNetworkWithOptions(InstanceId, request, headers, runtime);
}

model EstimatedLogstashRestartTimeRequest {
  body?: string(name='body'),
  force?: boolean(name='force', description='Specifies whether to forcibly restart the cluster. Default value: false.', example='false'),
}

model EstimatedLogstashRestartTimeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    unit?: string(name='unit', description='The unit.', example='second'),
    value?: long(name='value', description='The estimated restart time.', example='600'),
  }(name='Result', description='The returned result.'),
}

model EstimatedLogstashRestartTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EstimatedLogstashRestartTimeResponseBody(name='body'),
}

/**
 * @summary Queries the estimated time that is required to restart a Logstash cluster.
 *
 * @param request EstimatedLogstashRestartTimeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return EstimatedLogstashRestartTimeResponse
 */
async function estimatedLogstashRestartTimeWithOptions(InstanceId: string, request: EstimatedLogstashRestartTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EstimatedLogstashRestartTimeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'EstimatedLogstashRestartTime',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/estimated-time/restart-time`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the estimated time that is required to restart a Logstash cluster.
 *
 * @param request EstimatedLogstashRestartTimeRequest
 * @return EstimatedLogstashRestartTimeResponse
 */
async function estimatedLogstashRestartTime(InstanceId: string, request: EstimatedLogstashRestartTimeRequest): EstimatedLogstashRestartTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return estimatedLogstashRestartTimeWithOptions(InstanceId, request, headers, runtime);
}

model EstimatedRestartTimeRequest {
  body?: string(name='body'),
  force?: boolean(name='force', description='Specifies whether to forcibly restart the cluster. Default value: false.', example='false'),
}

model EstimatedRestartTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    unit?: string(name='unit', description='The unit.', example='second'),
    value?: long(name='value', description='The estimated restart time.', example='50'),
  }(name='Result', description='The returned result.'),
}

model EstimatedRestartTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EstimatedRestartTimeResponseBody(name='body'),
}

/**
 * @summary Queries the estimated time that is required to restart an Elasticsearch cluster.
 *
 * @param request EstimatedRestartTimeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return EstimatedRestartTimeResponse
 */
async function estimatedRestartTimeWithOptions(InstanceId: string, request: EstimatedRestartTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EstimatedRestartTimeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'EstimatedRestartTime',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/estimated-time/restart-time`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the estimated time that is required to restart an Elasticsearch cluster.
 *
 * @param request EstimatedRestartTimeRequest
 * @return EstimatedRestartTimeResponse
 */
async function estimatedRestartTime(InstanceId: string, request: EstimatedRestartTimeRequest): EstimatedRestartTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return estimatedRestartTimeWithOptions(InstanceId, request, headers, runtime);
}

model GetClusterDataInformationRequest {
  body?: string(name='body'),
}

model GetClusterDataInformationResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    connectable?: boolean(name='connectable', description='Whether it is connectable.', example='true'),
    metaInfo?: {
      fields?: [ string ](name='fields', description='The fields in the Mapping for the index.'),
      indices?: [ string ](name='indices', description='The index list of the cluster.'),
      mapping?: string(name='mapping', description='The Mapping configuration of the cluster.', example='{\\\\"_doc\\\\":{\\\\"properties\\\\":{\\\\"user\\\\":{\\\\"properties\\\\":{\\\\"last\\\\":{\\\\"type\\\\":\\\\"text\\\\",...}}}}}}'),
      settings?: string(name='settings', description='The Settings of the cluster.', example='{\\\\n  \\\\"index\\\\": {\\\\n    \\\\"replication\\\\": {\\\\n}.....}}'),
      typeName?: [ string ](name='typeName', description='Specifies the type of the index.'),
    }(name='metaInfo', description='The metadata of the cluster.'),
  }(name='Result', description='The return results.'),
}

model GetClusterDataInformationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterDataInformationResponseBody(name='body'),
}

/**
 * @summary Call GetClusterDataInformation to obtain the data information about the cluster.
 *
 * @param request GetClusterDataInformationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterDataInformationResponse
 */
async function getClusterDataInformationWithOptions(request: GetClusterDataInformationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterDataInformationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetClusterDataInformation',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/cluster/data-information`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call GetClusterDataInformation to obtain the data information about the cluster.
 *
 * @param request GetClusterDataInformationRequest
 * @return GetClusterDataInformationResponse
 */
async function getClusterDataInformation(request: GetClusterDataInformationRequest): GetClusterDataInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterDataInformationWithOptions(request, headers, runtime);
}

model GetElastictaskResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression', example='0 0 0 ? * MON'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression', example='4 4 4 ? * WED'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model GetElastictaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetElastictaskResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetElastictaskResponse
 */
async function getElastictaskWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetElastictaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetElastictask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/elastic-task`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return GetElastictaskResponse
 */
async function getElastictask(InstanceId: string): GetElastictaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getElastictaskWithOptions(InstanceId, headers, runtime);
}

model GetEmonGrafanaAlertsRequest {
  body?: string(name='body'),
}

model GetEmonGrafanaAlertsResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='08FA74C7-5654-4309-9729-D555AF587B7F'),
  success?: boolean(name='Success', example='true'),
}

model GetEmonGrafanaAlertsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEmonGrafanaAlertsResponseBody(name='body'),
}

/**
 * @summary 获取高级监控报警自定义Grafana监控报警项
 *
 * @param request GetEmonGrafanaAlertsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEmonGrafanaAlertsResponse
 */
async function getEmonGrafanaAlertsWithOptions(ProjectId: string, request: GetEmonGrafanaAlertsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonGrafanaAlertsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetEmonGrafanaAlerts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/grafana/proxy/api/alerts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取高级监控报警自定义Grafana监控报警项
 *
 * @param request GetEmonGrafanaAlertsRequest
 * @return GetEmonGrafanaAlertsResponse
 */
async function getEmonGrafanaAlerts(ProjectId: string, request: GetEmonGrafanaAlertsRequest): GetEmonGrafanaAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonGrafanaAlertsWithOptions(ProjectId, request, headers, runtime);
}

model GetEmonGrafanaDashboardsRequest {
  body?: string(name='body'),
}

model GetEmonGrafanaDashboardsResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='1E9D9827-2092-4385-9DA1-FC5A8D1DB3F5'),
  success?: boolean(name='Success', example='true'),
}

model GetEmonGrafanaDashboardsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEmonGrafanaDashboardsResponseBody(name='body'),
}

/**
 * @summary 获取高级监控报警自定义Grafana监控大盘列表
 *
 * @param request GetEmonGrafanaDashboardsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEmonGrafanaDashboardsResponse
 */
async function getEmonGrafanaDashboardsWithOptions(ProjectId: string, request: GetEmonGrafanaDashboardsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonGrafanaDashboardsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetEmonGrafanaDashboards',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/grafana/proxy/api/search`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取高级监控报警自定义Grafana监控大盘列表
 *
 * @param request GetEmonGrafanaDashboardsRequest
 * @return GetEmonGrafanaDashboardsResponse
 */
async function getEmonGrafanaDashboards(ProjectId: string, request: GetEmonGrafanaDashboardsRequest): GetEmonGrafanaDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonGrafanaDashboardsWithOptions(ProjectId, request, headers, runtime);
}

model GetEmonMonitorDataRequest {
  body?: string(name='body'),
}

model GetEmonMonitorDataResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='2D184B55-FA51-43F7-A1EF-E68A0545****'),
  result?: [ 
    {
      dps?: map[string]any(name='dps', example='{ "1586249280": 465.1980465119913, "1586249300": 213.45243650423305 }'),
      integrity?: float(name='integrity', example='1.0'),
      messageWatermark?: long(name='messageWatermark', example='1522127381471'),
      metric?: string(name='metric', example='elasticbuild.elasticsearch.source.total_doc_count'),
      summary?: float(name='summary', example='10'),
      tags?: map[string]any(name='tags', example='{"taskName":"et-xxx","userId":"123456"}'),
    }
  ](name='Result'),
  success?: boolean(name='Success', example='true'),
}

model GetEmonMonitorDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEmonMonitorDataResponseBody(name='body'),
}

/**
 * @param request GetEmonMonitorDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEmonMonitorDataResponse
 */
async function getEmonMonitorDataWithOptions(ProjectId: string, request: GetEmonMonitorDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonMonitorDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'GetEmonMonitorData',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/metrics/query`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetEmonMonitorDataRequest
 * @return GetEmonMonitorDataResponse
 */
async function getEmonMonitorData(ProjectId: string, request: GetEmonMonitorDataRequest): GetEmonMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonMonitorDataWithOptions(ProjectId, request, headers, runtime);
}

model GetOpenStoreUsageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1DE2491-804F-4C86-BAB4-548DD70B****'),
  result?: {
    currentUsage?: long(name='currentUsage', description='The current OpenStore storage capacity (estimated value based on actual indexes). Unit: Byte.', example='204800'),
    lastDayUsage?: long(name='lastDayUsage', description='The storage capacity of OpenStore yesterday. Unit: bytes.', example='184320'),
  }(name='Result', description='The current request result.'),
}

model GetOpenStoreUsageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOpenStoreUsageResponseBody(name='body'),
}

/**
 * @summary 统计OpenStore实例的存储容量和使用情况
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpenStoreUsageResponse
 */
async function getOpenStoreUsageWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOpenStoreUsageResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetOpenStoreUsage',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/openstore/usage`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 统计OpenStore实例的存储容量和使用情况
 *
 * @return GetOpenStoreUsageResponse
 */
async function getOpenStoreUsage(InstanceId: string): GetOpenStoreUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOpenStoreUsageWithOptions(InstanceId, headers, runtime);
}

model GetRegionConfigurationRequest {
  zoneId?: string(name='zoneId', example='cn-hangzhou-f'),
}

model GetRegionConfigurationResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6F******'),
  result?: {
    clientNodeAmountRange?: {
      maxAmount?: int32(name='maxAmount', example='25'),
      minAmount?: int32(name='minAmount', example='2'),
    }(name='clientNodeAmountRange'),
    clientNodeDiskList?: [ 
      {
        diskType?: string(name='diskType', example='cloud_efficiency'),
        maxSize?: int32(name='maxSize', example='20'),
        minSize?: int32(name='minSize', example='20'),
        scaleLimit?: int32(name='scaleLimit', example='18'),
      }
    ](name='clientNodeDiskList'),
    clientNodeSpec?: [ string ](name='clientNodeSpec'),
    createUrl?: string(name='createUrl', example='https://common-buy.aliyun.com/?commodityCode=elasticsearch&orderType=BUY#/buy'),
    dataDiskList?: [ 
      {
        diskType?: string(name='diskType', example='cloud_ssd'),
        maxSize?: int32(name='maxSize', example='5120'),
        minSize?: int32(name='minSize', example='20'),
        scaleLimit?: int32(name='scaleLimit', example='2048'),
        valueLimitSet?: [ string ](name='valueLimitSet'),
      }
    ](name='dataDiskList'),
    elasticNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount', example='25'),
        minAmount?: int32(name='minAmount', example='2'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption', example='true'),
          diskType?: string(name='diskType', example='cloud_ssd'),
          maxSize?: int32(name='maxSize', example='5120'),
          minSize?: int32(name='minSize', example='500'),
          scaleLimit?: int32(name='scaleLimit', example='2048'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='elasticNodeProperties'),
    env?: string(name='env', example='production'),
    esVersions?: [ string ](name='esVersions'),
    esVersionsLatestList?: [ 
      {
        key?: string(name='key', example='5.5_with_X-Pack'),
        value?: string(name='value', example='5.5.3_with_X-Pack'),
      }
    ](name='esVersionsLatestList'),
    instanceSupportNodes?: [ string ](name='instanceSupportNodes'),
    jvmConfine?: {
      memory?: int32(name='memory', example='32'),
      supportEsVersions?: [ string ](name='supportEsVersions'),
      supportGcs?: [ string ](name='supportGcs'),
    }(name='jvmConfine'),
    kibanaNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount', example='20'),
        minAmount?: int32(name='minAmount', example='1'),
      }(name='amountRange'),
      spec?: [ string ](name='spec'),
    }(name='kibanaNodeProperties'),
    logstashZones?: [ string ](name='logstashZones'),
    masterDiskList?: [ 
      {
        diskType?: string(name='diskType', example='cloud_ssd'),
        maxSize?: int32(name='maxSize', example='20'),
        minSize?: int32(name='minSize', example='20'),
        scaleLimit?: int32(name='scaleLimit', example='20'),
      }
    ](name='masterDiskList'),
    masterSpec?: [ string ](name='masterSpec'),
    node?: {
      maxAmount?: int32(name='maxAmount', example='50'),
      minAmount?: int32(name='minAmount', example='2'),
    }(name='node'),
    nodeSpecList?: [ 
      {
        cpuCount?: int32(name='cpuCount', example='16'),
        disk?: int32(name='disk', example='44000'),
        diskType?: string(name='diskType', example='local_efficiency'),
        enable?: boolean(name='enable', example='true'),
        memorySize?: int32(name='memorySize', example='64'),
        spec?: string(name='spec', example='elasticsearch.sn2ne.large'),
        specGroupType?: string(name='specGroupType', example='local_efficiency'),
      }
    ](name='nodeSpecList'),
    regionId?: string(name='regionId', example='cn-hangzhou'),
    supportVersions?: [ 
      {
        instanceCategory?: string(name='instanceCategory', example='x-pack'),
        supportVersionList?: [ 
          {
            key?: string(name='key', example='5.5'),
            value?: string(name='value', example='5.5.3'),
          }
        ](name='supportVersionList'),
      }
    ](name='supportVersions'),
    warmNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount', example='50'),
        minAmount?: int32(name='minAmount', example='2'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption', example='true'),
          diskType?: string(name='diskType', example='cloud_efficiency'),
          maxSize?: int32(name='maxSize', example='5120'),
          minSize?: int32(name='minSize', example='500'),
          scaleLimit?: int32(name='scaleLimit', example='2048'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='warmNodeProperties'),
    zones?: [ string ](name='zones'),
  }(name='Result'),
}

model GetRegionConfigurationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRegionConfigurationResponseBody(name='body'),
}

/**
 * @summary The maximum number of nodes.
 *
 * @param request GetRegionConfigurationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRegionConfigurationResponse
 */
async function getRegionConfigurationWithOptions(request: GetRegionConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.zoneId)) {
    query['zoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRegionConfiguration',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/region`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The maximum number of nodes.
 *
 * @param request GetRegionConfigurationRequest
 * @return GetRegionConfigurationResponse
 */
async function getRegionConfiguration(request: GetRegionConfigurationRequest): GetRegionConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionConfigurationWithOptions(request, headers, runtime);
}

model GetRegionalInstanceConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    clientNodeAmountRange?: {
      maxAmount?: int32(name='maxAmount'),
      minAmount?: int32(name='minAmount'),
    }(name='clientNodeAmountRange'),
    clientNodeDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
      }
    ](name='clientNodeDiskList'),
    clientSpecs?: [ string ](name='clientSpecs'),
    dataNodeAmountRange?: {
      maxAmount?: int32(name='maxAmount'),
      minAmount?: int32(name='minAmount'),
    }(name='dataNodeAmountRange'),
    dataNodeDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
        subClassificationConfines?: [ 
          {
            maxSize?: int32(name='maxSize'),
            minSize?: int32(name='minSize'),
            performanceLevel?: string(name='performanceLevel'),
          }
        ](name='subClassificationConfines'),
        valueLimitSet?: [ int32 ](name='valueLimitSet'),
      }
    ](name='dataNodeDiskList'),
    dataNodeSpecs?: [ string ](name='dataNodeSpecs'),
    kibanaSpecs?: [ string ](name='kibanaSpecs'),
    masterAmountRange?: [ string ](name='masterAmountRange'),
    masterDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
        subClassificationConfines?: [ 
          {
            maxSize?: int32(name='maxSize'),
            minSize?: int32(name='minSize'),
            performanceLevel?: string(name='performanceLevel'),
          }
        ](name='subClassificationConfines'),
      }
    ](name='masterDiskList'),
    masterSpecs?: [ string ](name='masterSpecs'),
    specInfoMap?: map[string]ResultSpecInfoMapValue(name='specInfoMap'),
    versions?: [ string ](name='versions'),
    warmNodeAmountRange?: {
      maxAmount?: int32(name='maxAmount'),
      minAmount?: int32(name='minAmount'),
    }(name='warmNodeAmountRange'),
    warmNodeDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
        subClassificationConfines?: [ 
          {
            maxSize?: int32(name='maxSize'),
            minSize?: int32(name='minSize'),
            performanceLevel?: string(name='performanceLevel'),
          }
        ](name='subClassificationConfines'),
        valueLimitSet?: [ int32 ](name='valueLimitSet'),
      }
    ](name='warmNodeDiskList'),
    warmNodeSpecs?: [ string ](name='warmNodeSpecs'),
  }(name='Result'),
}

model GetRegionalInstanceConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRegionalInstanceConfigResponseBody(name='body'),
}

/**
 * @summary 实例区域商品化配置
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRegionalInstanceConfigResponse
 */
async function getRegionalInstanceConfigWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionalInstanceConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRegionalInstanceConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/regions/instance-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 实例区域商品化配置
 *
 * @return GetRegionalInstanceConfigResponse
 */
async function getRegionalInstanceConfig(): GetRegionalInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionalInstanceConfigWithOptions(headers, runtime);
}

model GetSuggestShrinkableNodesRequest {
  count?: int32(name='count', description='The number of nodes that you want to remove.

This parameter is required.', example='1'),
  ignoreStatus?: boolean(name='ignoreStatus', description='Specifies whether to ignore the instance status. Default value: false.', example='false'),
  nodeType?: string(name='nodeType', description='The type of removing nodes. WORKER indicates hot node and WORKER_WARM indicates warm node.

This parameter is required.', example='WORKER'),
}

model GetSuggestShrinkableNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      host?: string(name='host', description='The IP address of the node.', example='``192.168.**.**``'),
      port?: int32(name='port', description='The access port number of the node.', example='9200'),
    }
  ](name='Result', description='The return results.'),
}

model GetSuggestShrinkableNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSuggestShrinkableNodesResponseBody(name='body'),
}

/**
 * @summary ES集群可缩容节点
 *
 * @param request GetSuggestShrinkableNodesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSuggestShrinkableNodesResponse
 */
async function getSuggestShrinkableNodesWithOptions(InstanceId: string, request: GetSuggestShrinkableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSuggestShrinkableNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query['ignoreStatus'] = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSuggestShrinkableNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/suggest-shrinkable-nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ES集群可缩容节点
 *
 * @param request GetSuggestShrinkableNodesRequest
 * @return GetSuggestShrinkableNodesResponse
 */
async function getSuggestShrinkableNodes(InstanceId: string, request: GetSuggestShrinkableNodesRequest): GetSuggestShrinkableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSuggestShrinkableNodesWithOptions(InstanceId, request, headers, runtime);
}

model GetTransferableNodesRequest {
  count?: int32(name='count', description='The number of nodes to be migrated.

This parameter is required.', example='1'),
  nodeType?: string(name='nodeType', description='The type of nodes.**WORKER**represents a hot node,**WORKER_WARM** represents a warm node.

This parameter is required.', example='WORKER'),
}

model GetTransferableNodesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      host?: string(name='host', description='The IP address of the node.', example='``192.168.**.**``'),
      port?: int32(name='port', description='The access port of the node.', example='9200'),
    }
  ](name='Result', description='The return results.'),
}

model GetTransferableNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTransferableNodesResponseBody(name='body'),
}

/**
 * @summary 获取可数据迁移节点
 *
 * @param request GetTransferableNodesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTransferableNodesResponse
 */
async function getTransferableNodesWithOptions(InstanceId: string, request: GetTransferableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTransferableNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTransferableNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/transferable-nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取可数据迁移节点
 *
 * @param request GetTransferableNodesRequest
 * @return GetTransferableNodesResponse
 */
async function getTransferableNodes(InstanceId: string, request: GetTransferableNodesRequest): GetTransferableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTransferableNodesWithOptions(InstanceId, request, headers, runtime);
}

model InitializeOperationRoleRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model InitializeOperationRoleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='29101430-4797-4D1D-96C3-9FCBCCA8F845'),
  result?: boolean(name='Result', description='Indicates whether the service-linked role is created. Valid values:

*   true: The service-linked role is created.
*   false: The service-linked role fails to be created.', example='true'),
}

model InitializeOperationRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InitializeOperationRoleResponseBody(name='body'),
}

/**
 * @summary Creates a service-linked role.
 *
 * @description > Before you perform auto scaling for a cluster at the China site (aliyun.com) or you use shippers to collect logs, you must create a service-linked role.
 *
 * @param request InitializeOperationRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InitializeOperationRoleResponse
 */
async function initializeOperationRoleWithOptions(request: InitializeOperationRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InitializeOperationRoleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InitializeOperationRole',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/user/slr`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a service-linked role.
 *
 * @description > Before you perform auto scaling for a cluster at the China site (aliyun.com) or you use shippers to collect logs, you must create a service-linked role.
 *
 * @param request InitializeOperationRoleRequest
 * @return InitializeOperationRoleResponse
 */
async function initializeOperationRole(request: InitializeOperationRoleRequest): InitializeOperationRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initializeOperationRoleWithOptions(request, headers, runtime);
}

model InstallAckOperatorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model InstallAckOperatorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EFA88951-7A6F-4A8E-AB8F-2BB7132BA751'),
  result?: boolean(name='Result', description='Indicates whether ES-operator is installed. Valid values:

*   true
*   false', example='true'),
}

model InstallAckOperatorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallAckOperatorResponseBody(name='body'),
}

/**
 * @summary Installs ES-operator for a Container Service for Kubernetes (ACK) cluster.
 *
 * @description > Before you install a shipper for an ACK cluster, you must call this operation to install ES-operator for the cluster.
 *
 * @param request InstallAckOperatorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallAckOperatorResponse
 */
async function installAckOperatorWithOptions(ClusterId: string, request: InstallAckOperatorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallAckOperatorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallAckOperator',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters/${OpenApiUtil.getEncodeParam(ClusterId)}/operator`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Installs ES-operator for a Container Service for Kubernetes (ACK) cluster.
 *
 * @description > Before you install a shipper for an ACK cluster, you must call this operation to install ES-operator for the cluster.
 *
 * @param request InstallAckOperatorRequest
 * @return InstallAckOperatorResponse
 */
async function installAckOperator(ClusterId: string, request: InstallAckOperatorRequest): InstallAckOperatorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installAckOperatorWithOptions(ClusterId, request, headers, runtime);
}

model InstallKibanaSystemPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InstallKibanaSystemPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: [ string ](name='Result', description='The list of plug-ins to be installed.'),
}

model InstallKibanaSystemPluginResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallKibanaSystemPluginResponseBody(name='body'),
}

/**
 * @summary Call InstallKibanaSystemPlugin to install the Kibana plug-in. The Kibana specification must be 2-Core 4 GB or higher.
 *
 * @param request InstallKibanaSystemPluginRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallKibanaSystemPluginResponse
 */
async function installKibanaSystemPluginWithOptions(InstanceId: string, request: InstallKibanaSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallKibanaSystemPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallKibanaSystemPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-plugins/system/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call InstallKibanaSystemPlugin to install the Kibana plug-in. The Kibana specification must be 2-Core 4 GB or higher.
 *
 * @param request InstallKibanaSystemPluginRequest
 * @return InstallKibanaSystemPluginResponse
 */
async function installKibanaSystemPlugin(InstanceId: string, request: InstallKibanaSystemPluginRequest): InstallKibanaSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installKibanaSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

model InstallLogstashSystemPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InstallLogstashSystemPluginResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC4****'),
  result?: [ string ](name='Result'),
}

model InstallLogstashSystemPluginResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallLogstashSystemPluginResponseBody(name='body'),
}

/**
 * @summary The returned data also contains **Headers** parameters, indicating that header information is returned.
 *
 * @description ls-cn-oew1qbgl\\*\\*\\*\\*
 *
 * @param request InstallLogstashSystemPluginRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallLogstashSystemPluginResponse
 */
async function installLogstashSystemPluginWithOptions(InstanceId: string, request: InstallLogstashSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallLogstashSystemPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallLogstashSystemPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/system/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The returned data also contains **Headers** parameters, indicating that header information is returned.
 *
 * @description ls-cn-oew1qbgl\\*\\*\\*\\*
 *
 * @param request InstallLogstashSystemPluginRequest
 * @return InstallLogstashSystemPluginResponse
 */
async function installLogstashSystemPlugin(InstanceId: string, request: InstallLogstashSystemPluginRequest): InstallLogstashSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installLogstashSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

model InstallSystemPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InstallSystemPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ string ](name='Result', description='The list of plug-ins to be installed.'),
}

model InstallSystemPluginResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallSystemPluginResponseBody(name='body'),
}

/**
 * @summary Call InstallSystemPlugin to install a system preset plug-in.
 *
 * @param request InstallSystemPluginRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallSystemPluginResponse
 */
async function installSystemPluginWithOptions(InstanceId: string, request: InstallSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallSystemPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallSystemPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/system/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call InstallSystemPlugin to install a system preset plug-in.
 *
 * @param request InstallSystemPluginRequest
 * @return InstallSystemPluginResponse
 */
async function installSystemPlugin(InstanceId: string, request: InstallSystemPluginRequest): InstallSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

model InstallUserPluginsRequest {
  body?: string(name='body'),
}

model InstallUserPluginsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6F*****'),
  result?: [ string ](name='Result'),
}

model InstallUserPluginsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallUserPluginsResponseBody(name='body'),
}

/**
 * @summary Installs custom plug-ins that are uploaded to the Elasticsearch console.
 *
 * @param request InstallUserPluginsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallUserPluginsResponse
 */
async function installUserPluginsWithOptions(InstanceId: string, request: InstallUserPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallUserPluginsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'InstallUserPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/user/actions/install`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Installs custom plug-ins that are uploaded to the Elasticsearch console.
 *
 * @param request InstallUserPluginsRequest
 * @return InstallUserPluginsResponse
 */
async function installUserPlugins(InstanceId: string, request: InstallUserPluginsRequest): InstallUserPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installUserPluginsWithOptions(InstanceId, request, headers, runtime);
}

model InterruptElasticsearchTaskRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InterruptElasticsearchTaskResponseBody = {
  code?: string(name='Code', description='The error code. Only displayed if an exception is returned.', example='InstanceStatusNotSupportCurrentAction'),
  message?: string(name='Message', description='The error message. Only displayed if an exception is returned.', example='The cluster is running tasks or in an error status. Try again later.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: boolean(name='Result', description='Return results:

*   true: interrupted change successfully
*   false: interrupted change failed', example='true'),
}

model InterruptElasticsearchTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InterruptElasticsearchTaskResponseBody(name='body'),
}

/**
 * @param request InterruptElasticsearchTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InterruptElasticsearchTaskResponse
 */
async function interruptElasticsearchTaskWithOptions(InstanceId: string, request: InterruptElasticsearchTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InterruptElasticsearchTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InterruptElasticsearchTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/interrupt`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request InterruptElasticsearchTaskRequest
 * @return InterruptElasticsearchTaskResponse
 */
async function interruptElasticsearchTask(InstanceId: string, request: InterruptElasticsearchTaskRequest): InterruptElasticsearchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return interruptElasticsearchTaskWithOptions(InstanceId, request, headers, runtime);
}

model InterruptLogstashTaskRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model InterruptLogstashTaskResponseBody = {
  code?: string(name='Code', description='The error code returned. If the API operation is successfully called, this parameter is not returned.', example='.'),
  message?: string(name='Message', description='The error message returned. If the API operation is successfully called, this parameter is not returned.', example='.'),
  requestId?: string(name='RequestId', description='The request ID.', example='0FA05123-745C-42FD-A69B-AFF48EF9****'),
  result?: boolean(name='Result', description='Indicates whether the task is suspended. Valid values:

*   true
*   false', example='true'),
}

model InterruptLogstashTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InterruptLogstashTaskResponseBody(name='body'),
}

/**
 * @summary After the task is suspended, the Logstash cluster is in the suspended state.
 *
 * @param request InterruptLogstashTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InterruptLogstashTaskResponse
 */
async function interruptLogstashTaskWithOptions(InstanceId: string, request: InterruptLogstashTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InterruptLogstashTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InterruptLogstashTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/interrupt`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary After the task is suspended, the Logstash cluster is in the suspended state.
 *
 * @param request InterruptLogstashTaskRequest
 * @return InterruptLogstashTaskResponse
 */
async function interruptLogstashTask(InstanceId: string, request: InterruptLogstashTaskRequest): InterruptLogstashTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return interruptLogstashTaskWithOptions(InstanceId, request, headers, runtime);
}

model ListAckClustersRequest {
  page?: int32(name='page', description='The number of the page to return.', example='3'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='20'),
  vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) to which the ACK clusters belong.', example='vpc-bp12nu14urf0upaf4****'),
}

model ListAckClustersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F93EAA49-284F-4FCE-9E67-FA23FB4BB512'),
  result?: [ 
    {
      clusterId?: string(name='clusterId', description='The ID of cluster.', example='c5ea2c2d9a3cf499481292f60425d****'),
      clusterType?: string(name='clusterType', description='The type of the cluster. The value is fixed as ManagedKubernetes.', example='ManagedKubernetes'),
      name?: string(name='name', description='The name of the cluster.', example='test'),
      vpcId?: string(name='vpcId', description='The ID of the VPC to which the cluster belongs.', example='vpc-bp12nu14urf0upaf4****'),
    }
  ](name='Result', description='The returned result.'),
}

model ListAckClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAckClustersResponseBody(name='body'),
}

/**
 * @summary Queries a list of Container Service for Kubernetes (ACK) clusters.
 *
 * @param request ListAckClustersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAckClustersResponse
 */
async function listAckClustersWithOptions(request: ListAckClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAckClustersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['vpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAckClusters',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of Container Service for Kubernetes (ACK) clusters.
 *
 * @param request ListAckClustersRequest
 * @return ListAckClustersResponse
 */
async function listAckClusters(request: ListAckClustersRequest): ListAckClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAckClustersWithOptions(request, headers, runtime);
}

model ListAckNamespacesRequest {
  page?: int32(name='page', description='The number of the page to return.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='10'),
}

model ListAckNamespacesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='95789100-A329-473B-9D14-9E0B7DB4BD5A'),
  result?: [ 
    {
      namespace?: string(name='namespace', description='The namespace of the cluster.', example='logging'),
      status?: string(name='status', description='The status of the namespace.', example='Active'),
    }
  ](name='Result', description='The returned result.'),
}

model ListAckNamespacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAckNamespacesResponseBody(name='body'),
}

/**
 * @summary Queries all namespaces in a specified Container Service for Kubernetes (ACK) cluster.
 *
 * @description > When you install a shipper on an ACK cluster, you must specify a namespace. You can call this operation to query all namespaces in the ACK cluster, and select a namespace based on your business requirements.
 *
 * @param request ListAckNamespacesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAckNamespacesResponse
 */
async function listAckNamespacesWithOptions(ClusterId: string, request: ListAckNamespacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAckNamespacesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAckNamespaces',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ack-clusters/${OpenApiUtil.getEncodeParam(ClusterId)}/namespaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all namespaces in a specified Container Service for Kubernetes (ACK) cluster.
 *
 * @description > When you install a shipper on an ACK cluster, you must specify a namespace. You can call this operation to query all namespaces in the ACK cluster, and select a namespace based on your business requirements.
 *
 * @param request ListAckNamespacesRequest
 * @return ListAckNamespacesResponse
 */
async function listAckNamespaces(ClusterId: string, request: ListAckNamespacesRequest): ListAckNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAckNamespacesWithOptions(ClusterId, request, headers, runtime);
}

model ListActionRecordsRequest {
  actionNames?: string(name='actionNames'),
  endTime?: long(name='endTime'),
  filter?: string(name='filter'),
  page?: int32(name='page'),
  requestId?: string(name='requestId'),
  size?: int32(name='size'),
  startTime?: long(name='startTime'),
  userId?: string(name='userId'),
}

model ListActionRecordsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      actionName?: string(name='ActionName'),
      actionParams?: map[string]any(name='ActionParams'),
      actionResultAccessList?: [ string ](name='ActionResultAccessList'),
      endTime?: long(name='EndTime'),
      instanceId?: string(name='InstanceId'),
      metaNow?: string(name='MetaNow'),
      metaOld?: string(name='MetaOld'),
      ownerId?: string(name='OwnerId'),
      process?: string(name='Process'),
      recordDiff?: map[string]any(name='RecordDiff'),
      recordIds?: [ string ](name='RecordIds'),
      requestId?: string(name='RequestId'),
      startTime?: long(name='StartTime'),
      stateType?: string(name='StateType'),
      statusInfo?: [ 
        {
          completeNodeCount?: int32(name='completeNodeCount'),
          endTime?: long(name='endTime'),
          exception?: string(name='exception'),
          latencyMills?: long(name='latencyMills'),
          nodeCount?: int32(name='nodeCount'),
          process?: string(name='process'),
          startTime?: long(name='startTime'),
          stateType?: string(name='stateType'),
          subState?: string(name='subState'),
          subStatusInfo?: [ 
            {
              completeNodeCount?: int32(name='completeNodeCount'),
              endTime?: long(name='endTime'),
              exception?: string(name='exception'),
              latencyMills?: long(name='latencyMills'),
              nodeCount?: int32(name='nodeCount'),
              process?: string(name='process'),
              startTime?: long(name='startTime'),
              stateType?: string(name='stateType'),
              subState?: string(name='subState'),
            }
          ](name='subStatusInfo'),
        }
      ](name='StatusInfo'),
      userId?: string(name='UserId'),
      userInfo?: string(name='UserInfo'),
      userType?: string(name='UserType'),
    }
  ](name='Result'),
}

model ListActionRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListActionRecordsResponseBody(name='body'),
}

/**
 * @summary 变更记录 变更详情
 *
 * @param request ListActionRecordsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListActionRecordsResponse
 */
async function listActionRecordsWithOptions(InstanceId: string, request: ListActionRecordsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListActionRecordsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.actionNames)) {
    query['actionNames'] = request.actionNames;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filter)) {
    query['filter'] = request.filter;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.requestId)) {
    query['requestId'] = request.requestId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.userId)) {
    query['userId'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListActionRecords',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/action-records`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 变更记录 变更详情
 *
 * @param request ListActionRecordsRequest
 * @return ListActionRecordsResponse
 */
async function listActionRecords(InstanceId: string, request: ListActionRecordsRequest): ListActionRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listActionRecordsWithOptions(InstanceId, request, headers, runtime);
}

model ListAllNodeRequest {
  extended?: boolean(name='extended', description='The Java Virtual Machine (JVM) heap memory usage of the node.', example='false'),
}

model ListAllNodeResponseBody = {
  requestId?: string(name='RequestId', description='The zone ID of the node.', example='0D71B597-F3FF-5B56-88D7-74F9D3F7****'),
  result?: [ 
    {
      cpuPercent?: string(name='cpuPercent', description='The disk usage.', example='4.2%'),
      diskUsedPercent?: string(name='diskUsedPercent', description='The health status of the node. Valid values: GREEN, YELLOW, RED, and GRAY.', example='1.0%'),
      health?: string(name='health', example='GREEN'),
      heapPercent?: string(name='heapPercent', description='The IP address of the node.', example='21.6%'),
      host?: string(name='host', description='The port that is used to connect to the node.', example='10.15.XX.XX'),
      loadOneM?: string(name='loadOneM', example='0.12'),
      nodeType?: string(name='nodeType', description='The 1-minute load of the node.', example='WORKER'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', description='The type of the nodes. Valid values:

*   MASTER: dedicated master node
*   WORKER: hot node
*   WORKER_WARM: warm node
*   COORDINATING: client node
*   KIBANA: Kibana node', example='cn-hangzhou-i'),
    }
  ](name='Result', description='The CPU utilization.

>  If the **extended** request parameter is set to **true** and the monitoring information of the nodes in the cluster is being synchronized, the value of the cpuPercent parameter is null. In this case, you need to send a request again after 10 seconds to obtain the value of the cpuPercent parameter.'),
}

model ListAllNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAllNodeResponseBody(name='body'),
}

/**
 * @summary es-cn-tl32cpgwa002l\\*\\*\\*\\*
 *
 * @param request ListAllNodeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAllNodeResponse
 */
async function listAllNodeWithOptions(InstanceId: string, request: ListAllNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAllNodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.extended)) {
    query['extended'] = request.extended;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAllNode',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary es-cn-tl32cpgwa002l\\*\\*\\*\\*
 *
 * @param request ListAllNodeRequest
 * @return ListAllNodeResponse
 */
async function listAllNode(InstanceId: string, request: ListAllNodeRequest): ListAllNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAllNodeWithOptions(InstanceId, request, headers, runtime);
}

model ListAlternativeSnapshotReposRequest {
  alreadySetItems?: boolean(name='alreadySetItems', description='Indicates whether to return the OSS reference repository added. The return value. Valid values: true and false.', example='true'),
}

model ListAlternativeSnapshotReposResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      instanceId?: string(name='instanceId', description='The ID of the instance.', example='es-cn-6ja1ro4jt000c****'),
      repoPath?: string(name='repoPath', description='The address of the repository.', example='RepoPath'),
    }
  ](name='Result', description='The return results.'),
}

model ListAlternativeSnapshotReposResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAlternativeSnapshotReposResponseBody(name='body'),
}

/**
 * @summary 实例可添加的OSS引用仓库
 *
 * @param request ListAlternativeSnapshotReposRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAlternativeSnapshotReposResponse
 */
async function listAlternativeSnapshotReposWithOptions(InstanceId: string, request: ListAlternativeSnapshotReposRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlternativeSnapshotReposResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.alreadySetItems)) {
    query['alreadySetItems'] = request.alreadySetItems;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlternativeSnapshotRepos',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/alternative-snapshot-repos`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 实例可添加的OSS引用仓库
 *
 * @param request ListAlternativeSnapshotReposRequest
 * @return ListAlternativeSnapshotReposResponse
 */
async function listAlternativeSnapshotRepos(InstanceId: string, request: ListAlternativeSnapshotReposRequest): ListAlternativeSnapshotReposResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlternativeSnapshotReposWithOptions(InstanceId, request, headers, runtime);
}

model ListApmRequest {
  description?: string(name='description', example='APMtest'),
  instanceId?: string(name='instanceId', example='apm-cn-i7m2fuae****'),
  output?: string(name='output', example='es-cn-i7m2fsfhc001x****'),
  page?: long(name='page', example='1'),
  size?: long(name='size', example='10'),
}

model ListApmResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='1'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='080D3399-76CF-519D-A540-2C44BC056EB7'),
  result?: [ 
    {
      createdAt?: string(name='createdAt', example='2021-11-16T07:15:51.967Z'),
      deployedReplica?: long(name='deployedReplica', example='1'),
      description?: string(name='description', example='APMtest'),
      instanceId?: string(name='instanceId', example='apm-cn-i7m2fuae****'),
      nodeAmount?: long(name='nodeAmount', example='1'),
      outputES?: string(name='outputES', example='es-cn-i7m2fsfhc001x****'),
      outputESUserName?: string(name='outputESUserName', example='elastic'),
      ownerId?: string(name='ownerId', example='133071096032****'),
      paymentType?: string(name='paymentType', example='postpaid'),
      region?: string(name='region', example='cn-hangzhou'),
      replica?: long(name='replica', example='1'),
      resourceSpec?: string(name='resourceSpec', example='C1M2'),
      status?: string(name='status', example='active'),
      version?: string(name='version', example='7.10.2'),
      vpcId?: string(name='vpcId', example='vpc-bp1530vdhqkamm9s0****'),
      vsArea?: string(name='vsArea', example='cn-hangzhou-i'),
      vswitchId?: string(name='vswitchId', example='vsw-bp1j1mql6r9g5vfb4****'),
    }
  ](name='Result'),
}

model ListApmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListApmResponseBody(name='body'),
}

/**
 * @summary ListApm
 *
 * @param request ListApmRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListApmResponse
 */
async function listApmWithOptions(request: ListApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListApmResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.output)) {
    query['output'] = request.output;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ListApm
 *
 * @param request ListApmRequest
 * @return ListApmResponse
 */
async function listApm(request: ListApmRequest): ListApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listApmWithOptions(request, headers, runtime);
}

model ListAvailableEsInstanceIdsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      description?: string(name='description', description='The name of the Elasticsearch cluster.', example='instanceName'),
      endpoint?: string(name='endpoint', description='The address that is used to access the Elasticsearch cluster over the Internet.', example='http://es-cn-n6w1o1x0w001c****.elasticsearch.aliyuncs.com:9200'),
      esInstanceId?: string(name='esInstanceId', description='The ID of the Elasticsearch cluster.', example='es-cn-n6w1o1x0w001c****'),
      kibanaEndpoint?: string(name='kibanaEndpoint', description='The address that is used to access the Kibana console of the Elasticsearch cluster over the Internet.', example='https://es-cn-n6w1o1x0w001c****.kibana.elasticsearch.aliyuncs.com:5601'),
    }
  ](name='Result', description='The returned result.'),
}

model ListAvailableEsInstanceIdsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAvailableEsInstanceIdsResponseBody(name='body'),
}

/**
 * @summary Queries the Elasticsearch clusters that can be associated with a Logstash cluster when you configure the X-Pack Monitoring feature for the Logstash cluster.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAvailableEsInstanceIdsResponse
 */
async function listAvailableEsInstanceIdsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListAvailableEsInstanceIdsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableEsInstanceIds',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/available-elasticsearch-for-centralized-management`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the Elasticsearch clusters that can be associated with a Logstash cluster when you configure the X-Pack Monitoring feature for the Logstash cluster.
 *
 * @return ListAvailableEsInstanceIdsResponse
 */
async function listAvailableEsInstanceIds(InstanceId: string): ListAvailableEsInstanceIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAvailableEsInstanceIdsWithOptions(InstanceId, headers, runtime);
}

model ListCollectorsRequest {
  instanceId?: string(name='instanceId', description='The ID of the resource with which the shipper is associated.', example='es-cn-nif1q8auz0003****'),
  name?: string(name='name', description='The name of the shipper.', example='collectorName1'),
  page?: int32(name='page', description='The number of the page to return. Valid values: 1 to 200. Default value: 1.', example='1'),
  resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-77uqof2s7rg5c****'),
  size?: int32(name='size', description='The number of entries to return on each page. Valid values: 1 to 500. Default value: 20.', example='10'),
  sourceType?: string(name='sourceType', description='The type of the machine on which the shipper is deployed. If you leave this parameter empty, shippers deployed on all types of machines are returned. Valid values:

*   ECS
*   ACK', example='ECS'),
}

model ListCollectorsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='5'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      collectorPaths?: [ string ](name='collectorPaths'),
      configs?: [ 
        {
          content?: string(name='content', description='The content of the file.', example='- key: log\\\\n title: Log file content\\\\n description: >\\\\n Contains log file lines.\\\\n ....'),
          fileName?: string(name='fileName', description='The name of the file.', example='fields.yml'),
        }
      ](name='configs', description='The information about the configuration file of the shipper.'),
      dryRun?: boolean(name='dryRun', description='Indicates whether a dry run is performed. Valid values:

*   true
*   false', example='false'),
      extendConfigs?: [ 
        {
          configType?: string(name='configType', description='The configuration type. Valid values:

*   collectorTargetInstance
*   collectorDeployMachine
*   collectorElasticsearchForKibana', example='collectorDeployMachine'),
          enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether monitoring is enabled. This parameter is returned if the value of **configType** is **collectorTargetInstance** and the value of **instanceType** is **elasticsearch**. Valid values:

*   true
*   false', example='true'),
          groupId?: string(name='groupId', description='The ID of the machine group. This parameter is returned if the value of **configType** is **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
          host?: string(name='host', description='The internal endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
          hosts?: [ string ](name='hosts'),
          instanceId?: string(name='instanceId', description='The ID of the resource with which the shipper is associated. If the value of **configType** is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='es-cn-nif1z89fz003i****'),
          instanceType?: string(name='instanceType', description='The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='elasticsearch'),
          kibanaHost?: string(name='kibanaHost', description='The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601'),
          machines?: [ 
            {
              agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values:

*   heartOk
*   heartLost
*   uninstalled
*   failed', example='heartOk'),
              instanceId?: string(name='instanceId', description='The IDs of the ECS instances.', example='i-bp13y63575oypr9d****'),
            }
          ](name='machines', description='The information about the ECS instances on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ECSInstanceId**.'),
          protocol?: string(name='protocol', description='The transmission protocol, which must be the same as the access protocol of the resource specified in the output configuration part of the shipper. Valid values: HTTP and HTTPS. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='HTTP'),
          successPodsCount?: string(name='successPodsCount', description='The number of pods from which data is successfully collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='8'),
          totalPodsCount?: string(name='totalPodsCount', description='The total number of pods from which data is collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='10'),
          type?: string(name='type', description='The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
          userName?: string(name='userName', description='The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
        }
      ](name='extendConfigs', description='The extended configurations of the shipper.'),
      gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-08-18T02:06:12.000+0000'),
      gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-08-18T09:40:43.000+0000'),
      name?: string(name='name', description='The name of the shipper.', example='FileBeat001'),
      ownerId?: string(name='ownerId', description='The account ID.', example='168520994880****'),
      resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-0v3xj86085dvq****'),
      resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.', example='fileBeat'),
      resVersion?: string(name='resVersion', description='The version of the shipper.', example='6.8.5_with_community'),
      status?: string(name='status', description='The status of the shipper. Valid values:

*   activating
*   active', example='active'),
      vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) where the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
    }
  ](name='Result', description='The returned result.'),
}

model ListCollectorsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCollectorsResponseBody(name='body'),
}

/**
 * @summary Queries shippers.
 *
 * @param request ListCollectorsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCollectorsResponse
 */
async function listCollectorsWithOptions(request: ListCollectorsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCollectorsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.resId)) {
    query['resId'] = request.resId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['sourceType'] = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCollectors',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries shippers.
 *
 * @param request ListCollectorsRequest
 * @return ListCollectorsResponse
 */
async function listCollectors(request: ListCollectorsRequest): ListCollectorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCollectorsWithOptions(request, headers, runtime);
}

model ListComponentIndicesRequest {
  name?: string(name='name', example='template'),
  page?: int32(name='page', example='5', nullable=true),
  size?: int32(name='size', example='10', nullable=true),
}

model ListComponentIndicesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='10'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      composed?: [ string ](name='composed'),
      content?: {
        meta?: map[string]any(name='_meta', example='{ "description": "set number of shards to one" }'),
        template?: {
          settings?: {
            index?: {
              codec?: string(name='codec', example='best_compression'),
              lifecycle?: {
                name?: string(name='name', example='synthetics'),
              }(name='lifecycle'),
            }(name='index'),
          }(name='settings'),
        }(name='template'),
        version?: long(name='version', example='0'),
      }(name='content'),
      name?: string(name='name', example='synthetics-settings'),
    }
  ](name='Result'),
}

model ListComponentIndicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListComponentIndicesResponseBody(name='body'),
}

/**
 * @summary ES集群组合索引列表
 *
 * @param request ListComponentIndicesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListComponentIndicesResponse
 */
async function listComponentIndicesWithOptions(InstanceId: string, request: ListComponentIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListComponentIndicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListComponentIndices',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ES集群组合索引列表
 *
 * @param request ListComponentIndicesRequest
 * @return ListComponentIndicesResponse
 */
async function listComponentIndices(InstanceId: string, request: ListComponentIndicesRequest): ListComponentIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listComponentIndicesWithOptions(InstanceId, request, headers, runtime);
}

model ListConnectedClustersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    result?: [ 
    {
      instances?: string(name='instances', description='The ID of the remote instance that is connected to the network of the current instance.', example='es-cn-09k1rocex0006****'),
      networkType?: string(name='networkType', description='The network type of the instance.', example='vpc'),
    }
  ](name='Result')
  }(name='Result', description='The return results.'),
}

model ListConnectedClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConnectedClustersResponseBody(name='body'),
}

/**
 * @summary 获取与当前实例进行网络互通的实例列表
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConnectedClustersResponse
 */
async function listConnectedClustersWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListConnectedClustersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListConnectedClusters',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/connected-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取与当前实例进行网络互通的实例列表
 *
 * @return ListConnectedClustersResponse
 */
async function listConnectedClusters(InstanceId: string): ListConnectedClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConnectedClustersWithOptions(InstanceId, headers, runtime);
}

model ListDataStreamsRequest {
  isManaged?: boolean(name='isManaged', example='false'),
  name?: string(name='name', example='Log1'),
}

model ListDataStreamsResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count', example='100'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize', example='143993923932990'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      health?: string(name='health', example='Green'),
      ilmPolicyName?: string(name='ilmPolicyName', example='rollver1'),
      indexTemplateName?: string(name='indexTemplateName', example='template1'),
      indices?: [ 
        {
          createTime?: string(name='createTime', example='2018-07-13T03:58:07.253Z'),
          health?: string(name='health', example='Green'),
          isManaged?: boolean(name='isManaged', example='false'),
          managedStatus?: string(name='managedStatus', example='following'),
          name?: string(name='name', example='Log1'),
          size?: long(name='size', example='15393899'),
        }
      ](name='indices'),
      managedStorageSize?: long(name='managedStorageSize', example='1788239393298'),
      name?: string(name='name', example='my-index-0001'),
      totalStorageSize?: long(name='totalStorageSize', example='1788239393298'),
    }
  ](name='Result'),
}

model ListDataStreamsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataStreamsResponseBody(name='body'),
}

/**
 * @param request ListDataStreamsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataStreamsResponse
 */
async function listDataStreamsWithOptions(InstanceId: string, request: ListDataStreamsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataStreamsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.isManaged)) {
    query['isManaged'] = request.isManaged;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataStreams',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDataStreamsRequest
 * @return ListDataStreamsResponse
 */
async function listDataStreams(InstanceId: string, request: ListDataStreamsRequest): ListDataStreamsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataStreamsWithOptions(InstanceId, request, headers, runtime);
}

model ListDataTasksResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The time when the site monitoring task was created.', example='2020-07-30 06:32:18'),
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType', description='The type of the target cluster. Default value: elasticsearch.', example='1'),
        endpoint?: string(name='endpoint', description='The public network access address of the target cluster.', example='http://192.168.xx.xx:4101'),
        index?: string(name='index', description='The target index.', example='product_info'),
        type?: string(name='type', description='The type of the destination index.', example='_doc'),
        vpcId?: string(name='vpcId', description='The ID of the VPC to which the cluster belongs.', example='vpc-2ze55voww95g82gak****'),
        vpcInstanceId?: string(name='vpcInstanceId', description='The instance ID or Server Load Balancer (SLB) ID of the current cluster.', example='es-cn-09k1rnu3g0002****-worker'),
        vpcInstancePort?: string(name='vpcInstancePort', description='The access port number of the cluster.', example='9200'),
      }(name='sinkCluster', description='The information of the target cluster.'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType', description='The type of the source cluster. Default value: elasticsearch.', example='1'),
        index?: string(name='index', description='The index whose data you want to migrate.', example='product_info'),
        mapping?: string(name='mapping', description='The Mapping configuration of the cluster.', example='{\\\\"_doc\\\\":{\\\\"properties\\\\":{\\\\"user\\\\":{\\\\"properties\\\\":{\\\\"last\\\\":{\\\\"type\\\\":\\\\"text\\\\",...}}}}}}'),
        routing?: string(name='routing', description='The routing field to index the table. It is set to the primary key by default.', example='_id'),
        settings?: string(name='settings', description='The Settings of the cluster.', example='{\\\\n  \\\\"index\\\\": {\\\\n    \\\\"replication\\\\": {\\\\n}.....}}'),
        type?: string(name='type', description='The type of the destination index.', example='_doc'),
      }(name='sourceCluster', description='The information about the source cluster.'),
      status?: string(name='status', description='The status of the task.', example='SUCCESS'),
      taskId?: string(name='taskId', description='The ID of the task.', example='et_cn_mfv1233r47272****'),
    }
  ](name='Result', description='The return results.'),
}

model ListDataTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDataTasksResponseBody(name='body'),
}

/**
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataTasksResponse
 */
async function listDataTasksWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataTasksResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataTasks',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-task`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListDataTasksResponse
 */
async function listDataTasks(InstanceId: string): ListDataTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataTasksWithOptions(InstanceId, headers, runtime);
}

model ListDefaultCollectorConfigurationsRequest {
  resType?: string(name='resType', description='The shipper type. Valid values:

*   fileBeat
*   metricBeat
*   heartBeat
*   auditBeat

This parameter is required.', example='fileBeat'),
  resVersion?: string(name='resVersion', description='The shipper version. The shipper version varies based on the type of the machine on which the shipper is deployed. Valid values:

*   ECS: 6.8.5_with_community
*   ACK: 6.8.13_with_community

This parameter is required.', example='6.8.5_with_community'),
  sourceType?: string(name='sourceType', description='The type of the machine on which the shipper is deployed. If you do not configure this parameter, the default configuration files of shippers deployed on all types of machines are returned. Valid values:

*   ECS: ECS instance
*   ACK: ACK cluster', example='ECS'),
}

model ListDefaultCollectorConfigurationsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8BAE3C32-8E4A-47D6-B4B0-95B5DE643BF5'),
  result?: [ 
    {
      content?: string(name='content', description='The content of the configuration file.', example='- key: log\\\\n  title: Log file content\\\\n  description: >\\\\n    Contains log file lines.\\\\n  fields:\\\\n ......'),
      fileName?: string(name='fileName', description='The name of the configuration file.', example='fields.yml'),
    }
  ](name='Result', description='The returned result.'),
}

model ListDefaultCollectorConfigurationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDefaultCollectorConfigurationsResponseBody(name='body'),
}

/**
 * @summary Queries the default configuration files of shippers.
 *
 * @param request ListDefaultCollectorConfigurationsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDefaultCollectorConfigurationsResponse
 */
async function listDefaultCollectorConfigurationsWithOptions(request: ListDefaultCollectorConfigurationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDefaultCollectorConfigurationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resType)) {
    query['resType'] = request.resType;
  }
  if (!Util.isUnset(request.resVersion)) {
    query['resVersion'] = request.resVersion;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['sourceType'] = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDefaultCollectorConfigurations',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/beats/default-configurations`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the default configuration files of shippers.
 *
 * @param request ListDefaultCollectorConfigurationsRequest
 * @return ListDefaultCollectorConfigurationsResponse
 */
async function listDefaultCollectorConfigurations(request: ListDefaultCollectorConfigurationsRequest): ListDefaultCollectorConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDefaultCollectorConfigurationsWithOptions(request, headers, runtime);
}

model ListDeprecatedTemplatesRequest {
  name?: string(name='name', example='component-openstore-index-template'),
  page?: int32(name='page', example='5'),
  size?: int32(name='size', example='10', nullable=true),
}

model ListDeprecatedTemplatesResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='5'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream', example='false'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate', example='openstore-index-template'),
      order?: long(name='order', example='100'),
      template?: {
        aliases?: string(name='aliases', example='"{}"'),
        mappings?: string(name='mappings', example='"{\\\\"properties\\\\":{\\\\"created_at\\\\":{\\\\"format\\\\":\\\\"EEE MMM dd HH:mm:ss Z yyyy\\\\",\\\\"type\\\\":\\\\"date\\\\"},\\\\"host_name\\\\":{\\\\"type\\\\":\\\\"keyword\\\\"}}}"'),
        settings?: string(name='settings', example='"{\\\\"index.number_of_shards\\\\":\\\\"1\\\\"}"'),
      }(name='template'),
      version?: string(name='version', example='70000'),
    }
  ](name='Result'),
}

model ListDeprecatedTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDeprecatedTemplatesResponseBody(name='body'),
}

/**
 * @summary ListDeprecatedTemplates
 *
 * @param request ListDeprecatedTemplatesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDeprecatedTemplatesResponse
 */
async function listDeprecatedTemplatesWithOptions(InstanceId: string, request: ListDeprecatedTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeprecatedTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeprecatedTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/deprecated-templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ListDeprecatedTemplates
 *
 * @param request ListDeprecatedTemplatesRequest
 * @return ListDeprecatedTemplatesResponse
 */
async function listDeprecatedTemplates(InstanceId: string, request: ListDeprecatedTemplatesRequest): ListDeprecatedTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeprecatedTemplatesWithOptions(InstanceId, request, headers, runtime);
}

model ListDiagnoseIndicesRequest {
  lang?: string(name='lang', description='The language. Multiple languages are supported.', example='en'),
}

model ListDiagnoseIndicesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F05ED12E-140A-4ACB-B059-3A508A69F2E1'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseIndicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDiagnoseIndicesResponseBody(name='body'),
}

/**
 * @summary Queries the indexes for health diagnosis performed on an Elasticsearch cluster.
 *
 * @param request ListDiagnoseIndicesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDiagnoseIndicesResponse
 */
async function listDiagnoseIndicesWithOptions(InstanceId: string, request: ListDiagnoseIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseIndicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnoseIndices',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/indices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the indexes for health diagnosis performed on an Elasticsearch cluster.
 *
 * @param request ListDiagnoseIndicesRequest
 * @return ListDiagnoseIndicesResponse
 */
async function listDiagnoseIndices(InstanceId: string, request: ListDiagnoseIndicesRequest): ListDiagnoseIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseIndicesWithOptions(InstanceId, request, headers, runtime);
}

model ListDiagnoseReportRequest {
  detail?: boolean(name='detail', description='SYSTEM', example='true'),
  endTime?: long(name='endTime', description='1

This parameter is required.', example='1595174399999'),
  lang?: string(name='lang', description='1594569600000', example='spanish'),
  page?: int32(name='page', description='20', example='1'),
  size?: int32(name='size', description='true', example='20'),
  startTime?: long(name='startTime', description='1595174399999

This parameter is required.', example='1594569600000'),
  trigger?: string(name='trigger', description='The ID of the request.', example='SYSTEM'),
}

model ListDiagnoseReportResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The returned results.', example='15'),
  }(name='Headers', description='The total number of entries returned.'),
  requestId?: string(name='RequestId', description='The header of the response.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      createTime?: long(name='createTime', description='The ID of the report.', example='1535745731000'),
      diagnoseItems?: [ 
        {
          detail?: {
            desc?: string(name='desc', description='The diagnosis.', example='Check whether the number of replica shards is optimal and easy to maintain'),
            name?: string(name='name', description='The description of the diagnostic item.', example='Number of Replica Shards'),
            result?: string(name='result', description='The suggestion for the diagnosis.', example='You may need to adjust the numbers of replica shards of some indices as follows:  [geoname08 : 0 -&gt; 1][geoname09 : 0 -&gt; 1][geonametest01 : 0 -&gt; 1]'),
            suggest?: string(name='suggest', example='You can call the following function in the Elasticsearch API....'),
            type?: string(name='type', description='The full name of the diagnostic item.', example='ES_API'),
          }(name='detail', description='The type of the diagnostic result. Valid values:

*   TEXT: text description
*   CONSOLE_API: console-triggered
*   ES_API: API triggered'),
          health?: string(name='health', description='The details of the diagnostic item.', example='YELLOW'),
          item?: string(name='item', description='The health of the diagnostic item. Supported: GREEN, YELLOW, RED, and UNKNOWN.', example='IndexAliasUseDiagnostic'),
        }
      ](name='diagnoseItems', description='The name of the item.'),
      health?: string(name='health', description='Reports the list of diagnostic item information.', example='YELLOW'),
      instanceId?: string(name='instanceId', description='The overall health of the cluster in the report. Supported: GREEN, YELLOW, RED, and UNKNOWN.', example='es-cn-abc'),
      reportId?: string(name='reportId', description='The diagnosis status. Valid values: Supported: SUCCESS, FAILED, and RUNNING.', example='trigger__2020-08-17T17:09:02f'),
      state?: string(name='state', description='The ID of the instance for diagnosis.', example='SUCCESS'),
      trigger?: string(name='trigger', description='The timestamp when the report was created.', example='USER'),
    }
  ](name='Result', description='The trigger mode of health diagnostics. Valid values:

*   SYSTEM: The system is automatically triggered.
*   INNER: internal trigger
*   USER: manually triggered by the user'),
}

model ListDiagnoseReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDiagnoseReportResponseBody(name='body'),
}

/**
 * @summary 获取集群诊断报告列表
 *
 * @param request ListDiagnoseReportRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDiagnoseReportResponse
 */
async function listDiagnoseReportWithOptions(InstanceId: string, request: ListDiagnoseReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseReportResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.detail)) {
    query['detail'] = request.detail;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnoseReport',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/reports`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取集群诊断报告列表
 *
 * @param request ListDiagnoseReportRequest
 * @return ListDiagnoseReportResponse
 */
async function listDiagnoseReport(InstanceId: string, request: ListDiagnoseReportRequest): ListDiagnoseReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseReportWithOptions(InstanceId, request, headers, runtime);
}

model ListDiagnoseReportIdsRequest {
  endTime?: long(name='endTime', description='The end of the time range to query. The value must be a UNIX timestamp.

This parameter is required.', example='1595174399999'),
  lang?: string(name='lang', description='The language of the reports.', example='spanish'),
  page?: int32(name='page', description='The number of the page to return. Valid values: 1 to 200. Default value: 1.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page. Valid values: 1 to 500. Default value: 10.', example='15'),
  startTime?: long(name='startTime', description='The beginning of the time range to query. The value must be a UNIX timestamp.

This parameter is required.', example='1595088000000'),
  trigger?: string(name='trigger', description='The method that is used to trigger health diagnostics. Valid values: SYSTEM, INNER, and USER.', example='SYSTEM'),
}

model ListDiagnoseReportIdsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='1'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseReportIdsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDiagnoseReportIdsResponseBody(name='body'),
}

/**
 * @summary Queries the IDs of the historical intelligent O&M reports of an Elasticsearch cluster.
 *
 * @param request ListDiagnoseReportIdsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDiagnoseReportIdsResponse
 */
async function listDiagnoseReportIdsWithOptions(InstanceId: string, request: ListDiagnoseReportIdsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseReportIdsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnoseReportIds',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/report-ids`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the IDs of the historical intelligent O&M reports of an Elasticsearch cluster.
 *
 * @param request ListDiagnoseReportIdsRequest
 * @return ListDiagnoseReportIdsResponse
 */
async function listDiagnoseReportIds(InstanceId: string, request: ListDiagnoseReportIdsRequest): ListDiagnoseReportIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseReportIdsWithOptions(InstanceId, request, headers, runtime);
}

model ListDiagnosisItemsRequest {
  lang?: string(name='lang', example='en'),
}

model ListDiagnosisItemsResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ 
    {
      description?: string(name='description', example='诊断集群写数据是否有堆积当集群的数据写入存在堆积时，会造成BulkReject异常，可能会导致数据丢失，且会造成系统资源消耗严重'),
      key?: string(name='key', example='ClusterBulkRejectDiagnostic'),
      name?: string(name='name', example='索引写入BulkReject诊断'),
    }
  ](name='Result'),
}

model ListDiagnosisItemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDiagnosisItemsResponseBody(name='body'),
}

/**
 * @summary The diagnostic item is used to check whether data write requests of a cluster are accumulated. If data write requests are accumulated, a bulk rejection occurs. This may cause data loss and severely consume system resources.
 *
 * @param request ListDiagnosisItemsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDiagnosisItemsResponse
 */
async function listDiagnosisItemsWithOptions(request: ListDiagnosisItemsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnosisItemsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDiagnosisItems',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/items`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The diagnostic item is used to check whether data write requests of a cluster are accumulated. If data write requests are accumulated, a bulk rejection occurs. This may cause data loss and severely consume system resources.
 *
 * @param request ListDiagnosisItemsRequest
 * @return ListDiagnosisItemsResponse
 */
async function listDiagnosisItems(request: ListDiagnosisItemsRequest): ListDiagnosisItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnosisItemsWithOptions(request, headers, runtime);
}

model ListDictInformationRequest {
  analyzerType?: string(name='analyzerType', example='ALIWS'),
  bucketName?: string(name='bucketName', description='This parameter is required.', example='search-cloud-test-cn-****'),
  key?: string(name='key', description='This parameter is required.', example='oss/dic_0.dic'),
}

model ListDictInformationResponseBody = {
  requestId?: string(name='RequestId', example='7C4334EA-D22B-48BD-AE28-08EE68******'),
  result?: {
    fileSize?: long(name='fileSize', example='2202301'),
    ossObject?: {
      bucketName?: string(name='bucketName', example='es-osstest*'),
      etag?: string(name='etag', example='2ABAB5E70BBF631145647F6BE533****'),
      key?: string(name='key', example='oss/dict_0*.dic'),
    }(name='ossObject'),
    type?: string(name='type', example='STOP'),
  }(name='Result'),
}

model ListDictInformationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDictInformationResponseBody(name='body'),
}

/**
 * @param request ListDictInformationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDictInformationResponse
 */
async function listDictInformationWithOptions(InstanceId: string, request: ListDictInformationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDictInformationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.analyzerType)) {
    query['analyzerType'] = request.analyzerType;
  }
  if (!Util.isUnset(request.bucketName)) {
    query['bucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.key)) {
    query['key'] = request.key;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDictInformation',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dict/_info`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListDictInformationRequest
 * @return ListDictInformationResponse
 */
async function listDictInformation(InstanceId: string, request: ListDictInformationRequest): ListDictInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDictInformationWithOptions(InstanceId, request, headers, runtime);
}

model ListDictsRequest {
  analyzerType?: string(name='analyzerType', description='The type of the dictionary. Valid values:

*   IK: IK dictionary after a standard update
*   IK_HOT: IK dictionary after a rolling update
*   SYNONYMS: synonym dictionary
*   ALIWS: Alibaba Cloud dictionary

This parameter is required.', example='IK'),
  name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
}

model ListDictsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='1'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2937F832-F39E-41EF-89BA-B528342A2A3A'),
  result?: [ 
    {
      downloadUrl?: string(name='downloadUrl', description='The link that is used to download the dictionary over the Internet. The link is valid for 90s.', example='http://test_bucket.oss-cn-hangzhou.aliyuncs.com/AliyunEs/test.dic?Expires=162573****&OSSAccessKeyId=LTAI*****V9&Signature=PNPO********BBGsJDO4V3VfU4sE%3D'),
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: byte.', example='2782602'),
      name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
      sourceType?: string(name='sourceType', description='The source type.', example='ORIGIN'),
      type?: string(name='type', description='The type of the IK dictionary. Valid values:

*   MAIN: main dictionary
*   STOP: stopword list', example='MAIN'),
    }
  ](name='Result', description='The returned result.'),
}

model ListDictsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDictsResponseBody(name='body'),
}

/**
 * @summary Queries the details of a specified type of dictionary.
 *
 * @param request ListDictsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDictsResponse
 */
async function listDictsWithOptions(InstanceId: string, request: ListDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDictsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.analyzerType)) {
    query['analyzerType'] = request.analyzerType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDicts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dicts`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a specified type of dictionary.
 *
 * @param request ListDictsRequest
 * @return ListDictsResponse
 */
async function listDicts(InstanceId: string, request: ListDictsRequest): ListDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDictsWithOptions(InstanceId, request, headers, runtime);
}

model ListEcsInstancesRequest {
  ecsInstanceIds?: string(name='ecsInstanceIds', description='test', example='["i-bp13y63575oypr9d****","i-bp1gyhphjaj73jsr****"]'),
  ecsInstanceName?: string(name='ecsInstanceName', description='[{ "tagKey":"a","tagValue":"b"}]', example='test'),
  page?: int32(name='page', description='10', example='1'),
  size?: int32(name='size', description='["i-bp13y63575oypr9d\\\\*\\\\*\\\\*\\\\*","i-bp1gyhphjaj73jsr\\\\*\\\\*\\\\*\\\\*"]', example='10'),
  tags?: string(name='tags', description='vpc-bp16k1dvzxtmagcva\\\\*\\\\*\\\\*\\\\*', example='[{ "tagKey":"a","tagValue":"b"}]'),
  vpcId?: string(name='vpcId', description='The ID of the request.', example='vpc-bp16k1dvzxtmagcva****'),
}

model ListEcsInstancesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The returned data.', example='11'),
  }(name='Headers', description='The number of returned records.'),
  requestId?: string(name='RequestId', description='The header of the response.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      cloudAssistantStatus?: string(name='cloudAssistantStatus', description='The name of the ECS instance.', example='true'),
      collectors?: [ 
        {
          collectorPaths?: [ string ](name='collectorPaths'),
          configs?: [ 
            {
              content?: string(name='content', description='The name of the file.', example='- key: log\\\\n title: Log file content\\\\n description: >\\\\n Contains log file lines.\\\\n ....'),
              fileName?: string(name='fileName', description='The information about the extended parameter.', example='fields.yml'),
            }
          ](name='configs', description='The content of the file.'),
          dryRun?: boolean(name='dryRun', description='The ID of the Alibaba Cloud account.', example='false'),
          extendConfigs?: [ 
            {
              configType?: string(name='configType', description='The instance type specified by Collector Output. Supports Elasticsearch and Logstash. Displayed when the **configType** is **collectorTargetInstance**.', example='collectorDeployMachine'),
              enableMonitoring?: boolean(name='enableMonitoring', description='The ID of the host group. Displayed when the **configType** is **collectorDeployMachine**.', example='true'),
              groupId?: string(name='groupId', description='The configuration type. Valid values:

*   collectorTargetInstance: Collector Output
*   collectorDeployMachine: Collector Deployment Machine
*   Collector Elasticsearch ForKibana: Elasticsearch instance information that supports the Kibana dashboard', example='default_ct-cn-5i2l75bz4776****'),
              hosts?: [ string ](name='hosts', description='The path in which Filebeat is collected.'),
              instanceId?: string(name='instanceId', description='The list of ECS instances on which the collector is deployed. Displayed when the **configType** is **collectorDeployMachines** and the **type** is **ECSInstanceId**.', example='es-cn-nif1z89fz003i****'),
              instanceType?: string(name='instanceType', description='The transmission protocol, which must be the same as the access protocol of the instance specified by Output. HTTP and HTTPS. Displayed when the **configType** is **collectorTargetInstance**.', example='elasticsearch'),
              machines?: [ 
                {
                  agentStatus?: string(name='agentStatus', description='The IDs of ECS instances.', example='heartOk'),
                  instanceId?: string(name='instanceId', description='The list of access addresses of the specified instance for the output of the collector. Displayed when the **configType** is **collectorTargetInstance**.', example='i-bp13y63575oypr9d****'),
                }
              ](name='machines', description='The status of each crawl on the ECS instance. Valid values:

*   heartOk: The heartbeat is normal.
*   heartLost: The heartbeat is abnormal.
*   uninstalled
*   failed: The installation failed.'),
              protocol?: string(name='protocol', description='The username that is used to access the instance. The default value is elastic. Displayed when the **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='HTTP'),
              type?: string(name='type', description='The ID of the instance that is associated with the crawker. If the **configType** parameter is set to **collectorTargetInstance**, the value of this parameter is the ID of the output collector. If the **configType** parameter is set to **collectorDeployMachines** and the **type** parameter is set to **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='ECSInstanceId'),
              userName?: string(name='userName', description='The type of the machine on which the Collector is deployed. This parameter is displayed when the **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId:ECS
*   ACKCluster: Container Kubernetes', example='elastic'),
            }
          ](name='extendConfigs', description='Whether Monitoring is enabled. This field is displayed when the **configType** is **collectorTargetInstance** and the **instanceType** is **Elasticsearch**. Valid values:

*   true
*   false'),
          gmtCreatedTime?: string(name='gmtCreatedTime', description='The status of the collector. Valid values:

*   activating: The project is taking effect.
*   active: The instance has taken effect.', example='2020-06-20T07:26:47.000+0000'),
          gmtUpdateTime?: string(name='gmtUpdateTime', description='Specifies whether to verify and create a crawer. Valid values:

*   true: only verifies and does not create a
*   false: verifies and creates a', example='2020-06-20T07:26:47.000+0000'),
          name?: string(name='name', description='The configuration file information of the collector.', example='ct-testAbc'),
          ownerId?: string(name='ownerId', description='The ID of the Virtual Private Cloud to which the collector belongs.', example='16852***488*****'),
          resId?: string(name='resId', description='The time when the collector was updated.', example='ct-cn-0v3xj86085dvq****'),
          resType?: string(name='resType', description='The version of the collector. If the machine type of the collector is ECS, only **6.8.5_with_community** is supported.', example='fileBeat'),
          resVersion?: string(name='resVersion', description='The time when the crawl collector was created.', example='6.8.5_with_community'),
          status?: string(name='status', description='The name of the collector.', example='activing'),
          vpcId?: string(name='vpcId', description='The type of the collector. FileBeat, metricBeat, heartBeat, and auditBeat are supported.', example='vpc-bp16k1dvzxtm******'),
        }
      ](name='collectors', description='The ID of the collector instance.'),
      ecsInstanceId?: string(name='ecsInstanceId', description='The tags of the ECS instance.', example='i-bp14ncqge8wy3l3d****'),
      ecsInstanceName?: string(name='ecsInstanceName', description='The ID of the ECS instance.', example='ecsTestName'),
      ipAddress?: [ 
        {
          host?: string(name='host', description='The information about the collectors on the ECS instance.', example='172.16.xx.xx'),
          ipType?: string(name='ipType', description='The IP address of the endpoint.', example='private'),
        }
      ](name='ipAddress', description='The type of the IP address that is used by the instance. Valid values:

*   public: public endpoint
*   private: private network address'),
      osType?: string(name='osType', description='The status of the ECS instance. Valid values:

*   running: The master instance is running
*   starting
*   stopping: The task is being stopped.
*   stopped: The node is stopped.', example='linux'),
      status?: string(name='status', description='The IP address of the ECS instance.', example='running'),
      tags?: string(name='tags', description='The operating system type of the ECS instance. Valid values:

*   windows:Windows operating system
*   linux:Linux operating system', example='[ { "tagKey": "a", "tagValue": "b" } ]'),
    }
  ](name='Result', description='Cloud Assistant the installation status, support:

*   true: The Prometheus agent was installed.
*   false: The Prometheus agent was not installed.'),
}

model ListEcsInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEcsInstancesResponseBody(name='body'),
}

/**
 * @description **Important** To call this operation, you must create the Aliyun Elasticsearch AccessingOOSRole and the system service role AliyunOOSAccessingECS 4ESRole to Elasticsearch the service account to obtain the ECS access permissions of the primary account. For more information, see [Collect ECS service logs](https://help.aliyun.com/document_detail/146446.html).
 *
 * @param request ListEcsInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEcsInstancesResponse
 */
async function listEcsInstancesWithOptions(request: ListEcsInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEcsInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.ecsInstanceIds)) {
    query['ecsInstanceIds'] = request.ecsInstanceIds;
  }
  if (!Util.isUnset(request.ecsInstanceName)) {
    query['ecsInstanceName'] = request.ecsInstanceName;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['vpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEcsInstances',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/ecs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @description **Important** To call this operation, you must create the Aliyun Elasticsearch AccessingOOSRole and the system service role AliyunOOSAccessingECS 4ESRole to Elasticsearch the service account to obtain the ECS access permissions of the primary account. For more information, see [Collect ECS service logs](https://help.aliyun.com/document_detail/146446.html).
 *
 * @param request ListEcsInstancesRequest
 * @return ListEcsInstancesResponse
 */
async function listEcsInstances(request: ListEcsInstancesRequest): ListEcsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEcsInstancesWithOptions(request, headers, runtime);
}

model ListExtendfilesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      filePath?: string(name='filePath', description='The path of the driver file.'),
      fileSize?: long(name='fileSize', description='The size of the driver file.', example='968668'),
      name?: string(name='name', description='The name of the driver file.', example='mysql-connector-java-5.1.35.jar'),
      sourceType?: string(name='sourceType', description='The source type.', example='ORIGIN'),
    }
  ](name='Result', description='The returned result.'),
}

model ListExtendfilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExtendfilesResponseBody(name='body'),
}

/**
 * @summary Queries the driver files of a Logstash cluster.
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListExtendfilesResponse
 */
async function listExtendfilesWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListExtendfilesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListExtendfiles',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/extendfiles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the driver files of a Logstash cluster.
 *
 * @return ListExtendfilesResponse
 */
async function listExtendfiles(InstanceId: string): ListExtendfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExtendfilesWithOptions(InstanceId, headers, runtime);
}

model ListILMPoliciesRequest {
  policyName?: string(name='policyName', example='policy-1'),
}

model ListILMPoliciesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      name?: string(name='name', example='policy-1'),
      phases?: map[string]any(name='phases', example='{"hot":{"minAge":"0ms","actions":{"rollover":{"maxSize":"50gb","maxAge":"30d"},"setPriority":{"priority":100}}},"delete":{"minAge":"3d","actions":{"delete":{}}}}'),
    }
  ](name='Result'),
}

model ListILMPoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListILMPoliciesResponseBody(name='body'),
}

/**
 * @param request ListILMPoliciesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListILMPoliciesResponse
 */
async function listILMPoliciesWithOptions(InstanceId: string, request: ListILMPoliciesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListILMPoliciesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.policyName)) {
    query['policyName'] = request.policyName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListILMPolicies',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListILMPoliciesRequest
 * @return ListILMPoliciesResponse
 */
async function listILMPolicies(InstanceId: string, request: ListILMPoliciesRequest): ListILMPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listILMPoliciesWithOptions(InstanceId, request, headers, runtime);
}

model ListIndexTemplatesRequest {
  indexTemplate?: string(name='indexTemplate', example='my-template'),
  page?: int32(name='page', example='5'),
  size?: int32(name='size', example='50'),
}

model ListIndexTemplatesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream', example='true'),
      ilmPolicy?: string(name='ilmPolicy', example='my_ilm_policy'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate', example='my-template'),
      priority?: int32(name='priority', example='100'),
      template?: {
        aliases?: string(name='aliases', example='{\\\\"index.number_of_shards\\\\":\\\\"1\\\\"}'),
        mappings?: string(name='mappings', example='{\\\\"properties\\\\":{\\\\"created_at\\\\":{\\\\"format\\\\":\\\\"EEE MMM dd HH:mm:ss Z yyyy\\\\",\\\\"type\\\\":\\\\"date\\\\"},\\\\"host_name\\\\":{\\\\"type\\\\":\\\\"keyword\\\\"}}}'),
        settings?: string(name='settings', example='{\\\\"mydata\\\\":{}}'),
      }(name='template'),
    }
  ](name='Result'),
}

model ListIndexTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIndexTemplatesResponseBody(name='body'),
}

/**
 * @param request ListIndexTemplatesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIndexTemplatesResponse
 */
async function listIndexTemplatesWithOptions(InstanceId: string, request: ListIndexTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIndexTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.indexTemplate)) {
    query['indexTemplate'] = request.indexTemplate;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIndexTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListIndexTemplatesRequest
 * @return ListIndexTemplatesResponse
 */
async function listIndexTemplates(InstanceId: string, request: ListIndexTemplatesRequest): ListIndexTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIndexTemplatesWithOptions(InstanceId, request, headers, runtime);
}

model ListInstanceRequest {
  description?: string(name='description', description='cn-hangzhou-i', example='aliyunes_test1'),
  esVersion?: string(name='esVersion', description='advanced', example='6.7_with_X-Pack'),
  instanceCategory?: string(name='instanceCategory', description='The number of data nodes.', example='advanced'),
  instanceId?: string(name='instanceId', description='postpaid', example='es-cn-v641a0ta3000g****'),
  page?: int32(name='page', description='[{"tagKey":"key1","tagValue":"value1"}]', example='1'),
  paymentType?: string(name='paymentType', description='Specifies whether to include dedicated master nodes. Valid values:

*   true: The files contain data that is dumped to the IA storage medium.
*   false: The files do not contain data that is dumped to the IA storage medium.', example='postpaid'),
  resourceGroupId?: string(name='resourceGroupId', description='The ID of the request.', example='rg-aekzvowej3i****'),
  size?: int32(name='size', description='vpc-bp16k1dvzxtmagcva\\\\*\\\\*\\\\*\\\\*', example='10'),
  tags?: string(name='tags', description='The header of the response.', example='[{"tagKey":"key1","tagValue":"value1"}]'),
  vpcId?: string(name='vpcId', description='The number of entries returned per page.', example='vpc-bp16k1dvzxtmagcva****'),
  zoneId?: string(name='zoneId', description='The returned data.', example='cn-hangzhou-i'),
}

model ListInstanceResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='Specifies whether to include dedicated master nodes (obsolete). Valid values:

*   true: The files contain data that is dumped to the IA storage medium.
*   false: The files do not contain data that is dumped to the IA storage medium.', example='10'),
  }(name='Headers', description='The status of the instance. Valid values:

*   active: normal
*   activating: taking effect
*   inactive: frozen
*   invalid: invalid'),
  requestId?: string(name='RequestId', description='The time when the node is created.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      advancedDedicateMaster?: boolean(name='advancedDedicateMaster', description='The billing method of the instance. Valid values:

*   **prepaid**: subscription
*   **postpaid**: pay-as-you-go', example='false'),
      archType?: string(name='archType'),
      clientNodeConfiguration?: {
        amount?: int32(name='amount', description='The size of the node storage space. Unit: GB.', example='3'),
        disk?: int32(name='disk', description='Specifies whether to enable disk encryption for the node. Valid values:

*   true: enables instant image cache.
*   false: disables reuse of image cache layers.', example='20'),
        diskType?: string(name='diskType', description='The storage type of the node. Valid values:

*   cloud_ssd: SSD.
*   cloud_essd: ESSD.
*   cloud_efficiency: ultra disk', example='cloud_efficiency'),
        spec?: string(name='spec', description='The number of nodes.', example='elasticsearch.sn2ne.large'),
        specInfo?: string(name='specInfo'),
      }(name='clientNodeConfiguration', description='The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).'),
      createdAt?: string(name='createdAt', description='The status of the pay-as-you-go service that is overlaid on a subscription instance. Valid values:

*   **active**: normal
*   **closed**: Close
*   **indebt**: Overdue payments are frozen', example='2018-07-13T03:58:07.253Z'),
      dedicateMaster?: boolean(name='dedicateMaster', description='The edition of the dedicated KMS instance.', example='false'),
      description?: string(name='description', description='The key of the tag.', example='es-cn-abc'),
      domain?: string(name='domain'),
      elasticDataNodeConfiguration?: {
        amount?: int32(name='amount', description='The number of nodes.', example='3'),
        disk?: int32(name='disk', description='The size of the node storage space. Unit: GB.', example='20'),
        diskEncryption?: boolean(name='diskEncryption', description='The storage type of the node.', example='true'),
        diskType?: string(name='diskType', description='The configuration of dedicated master nodes.', example='cloud_ssd'),
        spec?: string(name='spec', description='The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).', example='elasticsearch.sn2ne.large'),
        specInfo?: string(name='specInfo'),
      }(name='elasticDataNodeConfiguration', description='The configuration of Kibana nodes.'),
      endTime?: long(name='endTime'),
      esVersion?: string(name='esVersion', description='The value of the tag.', example='6.7_with_X-Pack'),
      extendConfigs?: [  map[string]any ](name='extendConfigs', description='The configurations of elastic data nodes.'),
      instanceId?: string(name='instanceId', description='The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).', example='es-cn-v641a0ta3000g****'),
      isNewDeployment?: string(name='isNewDeployment', description='The configuration of cluster extension parameters.', example='true'),
      kibanaConfiguration?: {
        amount?: int32(name='amount', description='The size of the node storage space. Unit: GB.', example='1'),
        disk?: int32(name='disk', description='The storage type of the node. Only cloud_ssd(SSD cloud disk) is supported.', example='20'),
        diskType?: string(name='diskType', description='The network configurations.', example='cloud_ssd'),
        spec?: string(name='spec', description='The number of nodes.', example='elasticsearch.n4.small'),
        specInfo?: string(name='specInfo'),
      }(name='kibanaConfiguration', description='The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).'),
      kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
      kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
      masterConfiguration?: {
        amount?: int32(name='amount', description='The network type. Only Virtual Private Cloud (VPC) is supported.', example='3'),
        disk?: int32(name='disk', description='The vSwitch ID of the cluster.', example='20'),
        diskType?: string(name='diskType', description='The configuration of data nodes.', example='cloud_ssd'),
        spec?: string(name='spec', description='The zone where the cluster resides.', example='elasticsearch.sn2ne.large'),
        specInfo?: string(name='specInfo'),
      }(name='masterConfiguration', description='The VPC ID of the cluster.'),
      networkConfig?: {
        type?: string(name='type', description='The storage type of the node. Valid values:

*   cloud_ssd: standard SSD
*   cloud_efficiency: ultra disk', example='vpc'),
        vpcId?: string(name='vpcId', description='The storage space of the node. Unit: GB.', example='vpc-abc'),
        vsArea?: string(name='vsArea', description='Specifies whether to use disk encryption. Valid values:

*   true
*   false', example='cn-hangzhou-e'),
        vswitchId?: string(name='vswitchId', description='The performance level of the ESSD. This parameter is required when the diskType parameter is set to cloud_essd. Valid values: PL1, PL2, and PL3.', example='vsw-def'),
        whiteIpGroupList?: [ 
          {
            groupName?: string(name='groupName', example='default'),
            ips?: [ string ](name='ips'),
            whiteIpType?: string(name='whiteIpType', example='PUBLIC_KIBANA'),
          }
        ](name='whiteIpGroupList'),
      }(name='networkConfig', description='The instance type of the node. For more information, see [Specifications](https://help.aliyun.com/document_detail/271718.html).'),
      nodeAmount?: int32(name='nodeAmount', description='The ID of the resource group.', example='2'),
      nodeSpec?: {
        disk?: int32(name='disk', example='50'),
        diskEncryption?: boolean(name='diskEncryption', example='false'),
        diskType?: string(name='diskType', example='cloud_ssd'),
        performanceLevel?: string(name='performanceLevel', example='PL1'),
        spec?: string(name='spec', example='elasticsearch.n4.small'),
        specInfo?: string(name='specInfo'),
      }(name='nodeSpec', description='The VPC ID of the cluster.'),
      paymentType?: string(name='paymentType', description='The time when the instance was last updated.', example='postpaid'),
      postpaidServiceStatus?: string(name='postpaidServiceStatus', description='The tags of the instance. Each tag is a key-value pair.', example='active'),
      privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
      publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
      resourceGroupId?: string(name='resourceGroupId', description='The ID of the instance.', example='rg-aekzvowej3i****'),
      serviceVpc?: boolean(name='serviceVpc', description='Specifies whether to deploy the new architecture.', example='true'),
      status?: string(name='status', description='The name of the instance.', example='active'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey', description='The size of the node storage space. Unit: GB.', example='env'),
          tagValue?: string(name='tagValue', description='The storage type of the node. Only ultra disks (cloud_efficiency) are supported.', example='dev'),
        }
      ](name='tags', description='The number of nodes.'),
      updatedAt?: string(name='updatedAt', description='Coordination node configuration.', example='2018-07-18T10:10:04.484Z'),
      vpcInstanceId?: string(name='vpcInstanceId', example='vpc-bp1uag5jj38c****'),
    }
  ](name='Result', description='Indicates whether it is a service VPC.'),
}

model ListInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceResponseBody(name='body'),
}

/**
 * @summary 查询Elasticsearch实例列表
 *
 * @param request ListInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceResponse
 */
async function listInstanceWithOptions(request: ListInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.esVersion)) {
    query['esVersion'] = request.esVersion;
  }
  if (!Util.isUnset(request.instanceCategory)) {
    query['instanceCategory'] = request.instanceCategory;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.paymentType)) {
    query['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['vpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['zoneId'] = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询Elasticsearch实例列表
 *
 * @param request ListInstanceRequest
 * @return ListInstanceResponse
 */
async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceWithOptions(request, headers, runtime);
}

model ListInstanceHistoryEventsRequest {
  body?: [ 
    {
      desc?: boolean(name='desc', example='true'),
      sortField?: string(name='sortField', example='event_time'),
    }
  ](name='body'),
  eventCreateEndTime?: string(name='eventCreateEndTime', example='1645596516000'),
  eventCreateStartTime?: string(name='eventCreateStartTime', example='1645596516000'),
  eventCycleStatus?: [ string ](name='eventCycleStatus'),
  eventExecuteEndTime?: string(name='eventExecuteEndTime', example='1645596516000'),
  eventExecuteStartTime?: string(name='eventExecuteStartTime', example='1645596516000'),
  eventFinashEndTime?: string(name='eventFinashEndTime', example='1645596516000'),
  eventFinashStartTime?: string(name='eventFinashStartTime', example='1645596516000'),
  eventLevel?: [ string ](name='eventLevel'),
  eventType?: [ string ](name='eventType'),
  instanceId?: string(name='instanceId', example='es-cn-2r42l7a740005****'),
  nodeIP?: string(name='nodeIP', example='10.1.xx.xx'),
  page?: int32(name='page', example='0'),
  size?: int32(name='size', example='10'),
}

model ListInstanceHistoryEventsShrinkRequest {
  body?: [ 
    {
      desc?: boolean(name='desc', example='true'),
      sortField?: string(name='sortField', example='event_time'),
    }
  ](name='body'),
  eventCreateEndTime?: string(name='eventCreateEndTime', example='1645596516000'),
  eventCreateStartTime?: string(name='eventCreateStartTime', example='1645596516000'),
  eventCycleStatusShrink?: string(name='eventCycleStatus'),
  eventExecuteEndTime?: string(name='eventExecuteEndTime', example='1645596516000'),
  eventExecuteStartTime?: string(name='eventExecuteStartTime', example='1645596516000'),
  eventFinashEndTime?: string(name='eventFinashEndTime', example='1645596516000'),
  eventFinashStartTime?: string(name='eventFinashStartTime', example='1645596516000'),
  eventLevelShrink?: string(name='eventLevel'),
  eventTypeShrink?: string(name='eventType'),
  instanceId?: string(name='instanceId', example='es-cn-2r42l7a740005****'),
  nodeIP?: string(name='nodeIP', example='10.1.xx.xx'),
  page?: int32(name='page', example='0'),
  size?: int32(name='size', example='10'),
}

model ListInstanceHistoryEventsResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count', example='15'),
    xTotalFailed?: long(name='X-Total-Failed', example='2'),
    xTotalSuccess?: long(name='X-Total-Success', example='13'),
  }(name='Headers'),
  requestId?: string(name='RequestId', example='D1A6830A-F59B-4E05-BFAC-9496C21DBBA7'),
  result?: [ 
    {
      ecsId?: string(name='ecsId', example='i-2ze8s9cjdf2cv969****'),
      eventCreateTime?: string(name='eventCreateTime', example='2017-12-07T00:00:00Z'),
      eventCycleStatus?: string(name='eventCycleStatus', example='EXECUTED'),
      eventExecuteTime?: string(name='eventExecuteTime', example='2017-12-07T00:00:00Z'),
      eventFinashTime?: string(name='eventFinashTime', example='2017-12-07T00:00:00Z'),
      eventLevel?: string(name='eventLevel', example='INFO'),
      eventType?: string(name='eventType', example='ECS:AUTO_RESTART'),
      instanceId?: string(name='instanceId', example='es-cn-2r42l7a740005****'),
      nodeIP?: string(name='nodeIP', example='10.1.xx.xx'),
      regionId?: string(name='regionId', example='cn-hangzhou'),
    }
  ](name='Result'),
}

model ListInstanceHistoryEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceHistoryEventsResponseBody(name='body'),
}

/**
 * @summary 集群触发的硬件运维事件列表
 *
 * @param tmpReq ListInstanceHistoryEventsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceHistoryEventsResponse
 */
async function listInstanceHistoryEventsWithOptions(tmpReq: ListInstanceHistoryEventsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceHistoryEventsResponse {
  Util.validateModel(tmpReq);
  var request = new ListInstanceHistoryEventsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.eventCycleStatus)) {
    request.eventCycleStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventCycleStatus, 'eventCycleStatus', 'simple');
  }
  if (!Util.isUnset(tmpReq.eventLevel)) {
    request.eventLevelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventLevel, 'eventLevel', 'simple');
  }
  if (!Util.isUnset(tmpReq.eventType)) {
    request.eventTypeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventType, 'eventType', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.eventCreateEndTime)) {
    query['eventCreateEndTime'] = request.eventCreateEndTime;
  }
  if (!Util.isUnset(request.eventCreateStartTime)) {
    query['eventCreateStartTime'] = request.eventCreateStartTime;
  }
  if (!Util.isUnset(request.eventCycleStatusShrink)) {
    query['eventCycleStatus'] = request.eventCycleStatusShrink;
  }
  if (!Util.isUnset(request.eventExecuteEndTime)) {
    query['eventExecuteEndTime'] = request.eventExecuteEndTime;
  }
  if (!Util.isUnset(request.eventExecuteStartTime)) {
    query['eventExecuteStartTime'] = request.eventExecuteStartTime;
  }
  if (!Util.isUnset(request.eventFinashEndTime)) {
    query['eventFinashEndTime'] = request.eventFinashEndTime;
  }
  if (!Util.isUnset(request.eventFinashStartTime)) {
    query['eventFinashStartTime'] = request.eventFinashStartTime;
  }
  if (!Util.isUnset(request.eventLevelShrink)) {
    query['eventLevel'] = request.eventLevelShrink;
  }
  if (!Util.isUnset(request.eventTypeShrink)) {
    query['eventType'] = request.eventTypeShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeIP)) {
    query['nodeIP'] = request.nodeIP;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceHistoryEvents',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/events`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 集群触发的硬件运维事件列表
 *
 * @param request ListInstanceHistoryEventsRequest
 * @return ListInstanceHistoryEventsResponse
 */
async function listInstanceHistoryEvents(request: ListInstanceHistoryEventsRequest): ListInstanceHistoryEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceHistoryEventsWithOptions(request, headers, runtime);
}

model ListInstanceIndicesRequest {
  all?: boolean(name='all', description='false', example='false'),
  isManaged?: boolean(name='isManaged', description='15', example='false'),
  isOpenstore?: boolean(name='isOpenstore', description='The ID of the request.', example='false'),
  name?: string(name='name', description='1', example='log-0001'),
  page?: int32(name='page', description='The header of the response.', example='1'),
  size?: int32(name='size', description='The total size of the index in Cloud Hosting. Unit: bytes.', example='15'),
}

model ListInstanceIndicesResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count', description='The details of the index list.', example='15'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize', description='The total number of indexes in the OpenStore cold phase.', example='18093942932'),
    xOSSCount?: int32(name='X-OSS-Count', description='The time when the index list was queried.', example='5'),
    xOSSStorageSize?: long(name='X-OSS-StorageSize', description='This parameter is deprecated.', example='9093942932'),
  }(name='Headers', description='The total size of the OpenStore cold stage index for this instance. Unit: bytes.'),
  requestId?: string(name='RequestId', description='The total number of indexes in Cloud Hosting.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      createTime?: string(name='createTime', description='The name of the Elasticsearch index.', example='2021-01-11T05:49:41.114Z'),
      health?: string(name='health', example='green'),
      ilmExplain?: string(name='ilmExplain', example='{    "indices": {         ".ds-console-2021.08.18-000002": {             "index": ".ds-console-2021.08.18-000002",             "managed": true,             "policy": "console",             "lifecycle_date_millis": 1629277498775,             "age": "2.64h",             "phase": "hot",             "phase_time_millis": 1629277450334,             "action": "complete",             "action_time_millis": 1629278605586,             "step": "complete",             "step_time_millis": 1629278605586,             "phase_execution": {                 "policy": "console",                 "phase_definition": {                     "min_age": "0s",                     "actions": {                         "rollover": {                             "max_size": "1gb",                             "max_age": "1d",                             "max_docs": 10000                         },                         "set_priority": {                             "priority": 1000                         }                     }                 },                 "version": 1,                 "modified_date_in_millis": 1629277370953             }         }     } }'),
      isManaged?: string(name='isManaged', description='The managed status of the index. The following three statuses are supported:

*   following: Hosting.
*   closing: The instance is being unhosted.
*   closed: unmanaged.', example='false'),
      managedStatus?: string(name='managedStatus', description='The current storage lifecycle. Value meaning:

*   warm: warm.
*   cold: the cold phase.
*   hot: hot phase.
*   delete: deletes a stage.

>  If this parameter is empty, the current index is not managed by the lifecycle.', example='closing'),
      name?: string(name='name', description='The full lifecycle status of the current index.', example='.kibana_task_manager_1'),
      phase?: string(name='phase', example='warm'),
      size?: long(name='size', description='The running status of the index. The following three statuses are supported:

*   green: healthy.
*   yellow: alerts.
*   red: an exception.', example='49298589'),
    }
  ](name='Result', description='The total storage space occupied by the current index. Unit: bytes.'),
}

model ListInstanceIndicesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceIndicesResponseBody(name='body'),
}

/**
 * @summary 获取当前实例先特定的索引列表
 *
 * @param request ListInstanceIndicesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceIndicesResponse
 */
async function listInstanceIndicesWithOptions(InstanceId: string, request: ListInstanceIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceIndicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['all'] = request.all;
  }
  if (!Util.isUnset(request.isManaged)) {
    query['isManaged'] = request.isManaged;
  }
  if (!Util.isUnset(request.isOpenstore)) {
    query['isOpenstore'] = request.isOpenstore;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceIndices',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/indices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取当前实例先特定的索引列表
 *
 * @param request ListInstanceIndicesRequest
 * @return ListInstanceIndicesResponse
 */
async function listInstanceIndices(InstanceId: string, request: ListInstanceIndicesRequest): ListInstanceIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceIndicesWithOptions(InstanceId, request, headers, runtime);
}

model ListKibanaPluginsRequest {
  page?: string(name='page', description='The number of the page to return. Default value: 1.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='10'),
}

model ListKibanaPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The total number of entries returned.', example='3'),
  }(name='Headers', description='The request header.'),
  requestId?: string(name='RequestId', description='The request ID.', example='11234B4A-34CE-473B-8E61-AD95702E****'),
  result?: [ 
    {
      description?: string(name='description', description='The description of the plug-in.', example='Customize DSL statements to query data.'),
      name?: string(name='name', description='The name of the plug-in.', example='bsearch_querybuilder'),
      source?: string(name='source', description='The source of the plug-in.', example='SYSTEM'),
      specificationUrl?: string(name='specificationUrl', description='The URL of the introduction to the plug-in. The value null is supported.', example='https://xxxx'),
      state?: string(name='state', description='The installation status of the plug-in.', example='INSTALLED'),
    }
  ](name='Result', description='The information about the plug-ins.'),
}

model ListKibanaPluginsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListKibanaPluginsResponseBody(name='body'),
}

/**
 * @summary Queries a list of Kibana plug-ins.
 *
 * @param request ListKibanaPluginsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListKibanaPluginsResponse
 */
async function listKibanaPluginsWithOptions(InstanceId: string, request: ListKibanaPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListKibanaPluginsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListKibanaPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of Kibana plug-ins.
 *
 * @param request ListKibanaPluginsRequest
 * @return ListKibanaPluginsResponse
 */
async function listKibanaPlugins(InstanceId: string, request: ListKibanaPluginsRequest): ListKibanaPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listKibanaPluginsWithOptions(InstanceId, request, headers, runtime);
}

model ListKibanaPvlNetworkResponseBody = {
  requestId?: string(name='RequestId', description='request id', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      createTime?: string(name='createTime', example='2024-03-07T06:26:28Z'),
      endpointId?: string(name='endpointId', example='ep-bp1tah7zbrwmkjef****'),
      endpointName?: string(name='endpointName', example='es-cn-xxdjfia****-kibana'),
      endpointStatus?: string(name='endpointStatus', example='Connected'),
      pvlId?: string(name='pvlId', example='es-cn-27a3mul6l***-kibana-internal'),
      securityGroups?: [ string ](name='securityGroups'),
      vSwitchIdsZone?: [ 
        {
          vswitchId?: string(name='vswitchId', example='vsw-xdefafns***'),
          zoneId?: string(name='zoneId', example='cn-hangzhou-e'),
        }
      ](name='vSwitchIdsZone'),
      vpcId?: string(name='vpcId', example='vpc-bp16k1dvzxtma*****'),
    }
  ](name='Result'),
}

model ListKibanaPvlNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListKibanaPvlNetworkResponseBody(name='body'),
}

/**
 * @summary 查询kibana私网连接信息
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListKibanaPvlNetworkResponse
 */
async function listKibanaPvlNetworkWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListKibanaPvlNetworkResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListKibanaPvlNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/get-kibana-private`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询kibana私网连接信息
 *
 * @return ListKibanaPvlNetworkResponse
 */
async function listKibanaPvlNetwork(InstanceId: string): ListKibanaPvlNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listKibanaPvlNetworkWithOptions(InstanceId, headers, runtime);
}

model ListLogstashRequest {
  description?: string(name='description', description='rg-acfm2h5vbzd\\\\*\\\\*\\\\*\\\\*', example='ls-cn-abc'),
  instanceId?: string(name='instanceId', description='[{"tagKey":"key1","tagValue":"value1"}]', example='ls-cn-n6w1o5jq****'),
  page?: int32(name='page', description='ls-cn-n6w1o5jq\\\\*\\\\*\\\\*\\\\*', example='1'),
  resourceGroupId?: string(name='resourceGroupId', description='Details of the request header.', example='rg-acfm2h5vbzd****'),
  size?: int32(name='size', description='5.5.3_with_X-Pack', example='10'),
  tags?: string(name='tags', description='The number of entries returned per page.', example='[{"tagKey":"key1","tagValue":"value1"}]'),
  version?: string(name='version', description='The ID of the request.', example='5.5.3_with_X-Pack'),
}

model ListLogstashResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The number of data nodes.', example='10'),
  }(name='Headers', description='The billing method of the instance. Supported: prepaid (subscription) and postpaid (pay-as-you-go).'),
  requestId?: string(name='RequestId', description='Detailed information about the matching instances.', example='AC442F2F-5068-4434-AA21-E78947A9****'),
  result?: [ 
    {
      tags?: [ 
        {
          tagKey?: string(name='TagKey', description='The disk size of the node.', example='env'),
          tagValue?: string(name='TagValue', description='The instance type of the ECS instance.', example='dev'),
        }
      ](name='Tags', description='The configuration information of the data node.'),
      createdAt?: string(name='createdAt', description='The ID of the instance.', example='2018-07-13T03:58:07.253Z'),
      description?: string(name='description', description='The time when the instance was last updated.', example='ls-cn-abc'),
      instanceId?: string(name='instanceId', description='The tag value of the cloud disk.', example='ls-cn-n6w1o5jq****'),
      networkConfig?: {
        type?: string(name='type', example='vpc'),
        vpcId?: string(name='vpcId', description='The ID of the vSwitch.', example='vpc-abc'),
        vsArea?: string(name='vsArea', example='cn-hangzhou-*'),
        vswitchId?: string(name='vswitchId', example='vsw-def'),
      }(name='networkConfig', description='The network type. Currently, only Virtual Private Cloud (VPC) is supported.'),
      nodeAmount?: int32(name='nodeAmount', description='The state of the instance. Valid values: Normal, Active, Inactive, and Invalid.', example='2'),
      nodeSpec?: {
        disk?: int32(name='disk', description='The network configurations.', example='50'),
        diskEncryption?: boolean(name='diskEncryption', description='The ID of the VPC.', example='false'),
        diskType?: string(name='diskType', description='The zone where the cluster resides.', example='cloud_ssd'),
        spec?: string(name='spec', description='The type of the disk.', example='logstash.n4.small'),
      }(name='nodeSpec', description='Specifies whether to use disk encryption. Valid values:

*   true: Enables the concurrent query feature for queries other than aggregate queries.
*   false: Disables the concurrent query feature for queries other than aggregate queries.'),
      paymentType?: string(name='paymentType', description='The time when the instance was created.', example='postpaid'),
      resourceGroupId?: string(name='resourceGroupId'),
      status?: string(name='status', description='The version of the instance. Currently, only 6.7.0_with_X-Pack and 7.4.0_with_X-Pack are supported.', example='active'),
      updatedAt?: string(name='updatedAt', description='The tag of the instance. Valid values:', example='2018-07-18T10:10:04.484Z'),
      version?: string(name='version', description='The tag key of the cloud disk.', example='6.7.0_with_X-Pack'),
    }
  ](name='Result', description='The name of the VPC.'),
}

model ListLogstashResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogstashResponseBody(name='body'),
}

/**
 * @summary Logstash集群列表
 *
 * @param request ListLogstashRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogstashResponse
 */
async function listLogstashWithOptions(request: ListLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['instanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }
  if (!Util.isUnset(request.version)) {
    query['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Logstash集群列表
 *
 * @param request ListLogstashRequest
 * @return ListLogstashResponse
 */
async function listLogstash(request: ListLogstashRequest): ListLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashWithOptions(request, headers, runtime);
}

model ListLogstashLogRequest {
  beginTime?: long(name='beginTime', description='20', example='1531910852074'),
  endTime?: long(name='endTime', description='The ID of the request.', example='1531910852074'),
  page?: int32(name='page', description='The returned data.', example='1'),
  query?: string(name='query', description='1

This parameter is required.', example='host:10.7.xx.xx AND level:info AND content:opening'),
  size?: int32(name='size', description='The severity level of the log entry. Including trace, debug, info, warn, error, etc. (GC logs have no level).', example='20'),
  type?: string(name='type', description='1531910852074

This parameter is required.', example='LOGSTASH_INSTANCE_LOG'),
}

model ListLogstashLogResponseBody = {
  requestId?: string(name='RequestId', description='The details of the log.', example='7F40EAA1-6F1D-4DD9-8DB8-C5F00C4E****'),
  result?: [ 
    {
      content?: string(name='content', description='The IP address of the node that generates the log.'),
      host?: string(name='host', example='192.168.xx.xx'),
      instanceId?: string(name='instanceId', example='ls-cn-v0h1kzca****'),
      level?: string(name='level', description='The ID of the instance.', example='info'),
      timestamp?: long(name='timestamp', example='1531985112420'),
    }
  ](name='Result', description='The timestamp of log generation. Unit: ms.'),
}

model ListLogstashLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogstashLogResponseBody(name='body'),
}

/**
 * @summary 获取Logstash日志
 *
 * @param request ListLogstashLogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogstashLogResponse
 */
async function listLogstashLogWithOptions(InstanceId: string, request: ListLogstashLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashLogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    query['beginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogstashLog',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/search-log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Logstash日志
 *
 * @param request ListLogstashLogRequest
 * @return ListLogstashLogResponse
 */
async function listLogstashLog(InstanceId: string, request: ListLogstashLogRequest): ListLogstashLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashLogWithOptions(InstanceId, request, headers, runtime);
}

model ListLogstashPluginsRequest {
  name?: string(name='name', description='USER', example='logstash-filter-clone'),
  page?: int32(name='page', description='The ID of the request.', example='10'),
  size?: int32(name='size', description='The returned results.', example='3'),
  source?: string(name='source', description='The description of the plug-in.', example='USER'),
}

model ListLogstashPluginsResponseBody = {
  requestId?: string(name='RequestId', description='The address of the documentation for the plug-in.', example='99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ 
    {
      description?: string(name='description', description='The source of the plug-in.', example='The clone filter is for duplicating events.'),
      name?: string(name='name', example='logstash-filter-clone'),
      source?: string(name='source', example='SYSTEM'),
      specificationUrl?: string(name='specificationUrl', description='The name of the plug-in.', example='https://xxx.html'),
      state?: string(name='state', example='INSTALLED'),
    }
  ](name='Result', description='The status of the plug-in. Valid values:

*   INSTALLED: Installed
*   UNINSTALLED: Not installed
*   INSTALLING: The instance is being installed.
*   UNINSTALLING: The instance is being uninstalled.
*   UPGRADING: The backup gateway is being upgraded.
*   FAILED: Installation failed
*   UNKNOWN: The cluster is lost and cannot be created.'),
}

model ListLogstashPluginsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogstashPluginsResponseBody(name='body'),
}

/**
 * @summary Logstash插件列表
 *
 * @param request ListLogstashPluginsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogstashPluginsResponse
 */
async function listLogstashPluginsWithOptions(InstanceId: string, request: ListLogstashPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashPluginsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogstashPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Logstash插件列表
 *
 * @param request ListLogstashPluginsRequest
 * @return ListLogstashPluginsResponse
 */
async function listLogstashPlugins(InstanceId: string, request: ListLogstashPluginsRequest): ListLogstashPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashPluginsWithOptions(InstanceId, request, headers, runtime);
}

model ListNodesRequest {
  ecsInstanceIds?: string(name='ecsInstanceIds', description='The IDs of the ECS instances.', example='i-bp1ei8ysh7orb6eq****'),
  ecsInstanceName?: string(name='ecsInstanceName', description='The name of the ECS instance.', example='test'),
  page?: int32(name='page', description='The number of the page to return.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page.', example='10'),
  tags?: string(name='tags', description='The tags of the ECS instance. You must configure tagKey and tagValue.', example='[{"tagKey":"abc","tagValue":"xyz"}]'),
}

model ListNodesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The number of entries returned.', example='10'),
  }(name='Headers', description='The header of the response.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1FD7642-7C40-4FF2-9C0F-21F1A1746F70'),
  result?: [ 
    {
      agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values:

*   heartOk: The heartbeat is normal.
*   heartLost: The heartbeat is abnormal.
*   uninstalled: The shipper is not installed.
*   failed: The shipper fails to be installed.', example='heartOk'),
      cloudAssistantStatus?: string(name='cloudAssistantStatus', description='Indicates whether the Cloud Assistant client is installed. Valid values:

*   true: installed
*   false: not installed', example='true'),
      ecsInstanceId?: string(name='ecsInstanceId', description='The ID of the ECS instance.', example='i-bp13y63575oypr****'),
      ecsInstanceName?: string(name='ecsInstanceName', description='The name of the ECS instance.', example='ECS_beat'),
      ipAddress?: [ 
        {
          host?: string(name='host', description='The IP address.', example='192.168.xx.xx'),
          ipType?: string(name='ipType', description='The type of the IP address. Valid values:

*   public: public IP address
*   private: private IP address', example='public'),
        }
      ](name='ipAddress', description='The IP addresses of the ECS instance.'),
      osType?: string(name='osType', description='The operating system type of the ECS instance. Valid values:

*   windows: Windows Server
*   linux: Linux', example='linux'),
      status?: string(name='status', description='The status of the ECS instance. Valid values:

*   running: The instance is running.
*   starting: The instance is being started.
*   stopping: The instance is being stopped.
*   stopped: The instance is stopped.', example='running'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey', description='The key of the tag.', example='abc'),
          tagValue?: string(name='tagValue', description='The value of the tag.', example='xyz'),
        }
      ](name='tags', description='The tags of the ECS instance.'),
    }
  ](name='Result', description='The returned result.'),
}

model ListNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNodesResponseBody(name='body'),
}

/**
 * @summary Queries the statuses of Elastic Compute Service (ECS) instances on which a shipper is installed.
 *
 * @param request ListNodesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNodesResponse
 */
async function listNodesWithOptions(ResId: string, request: ListNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.ecsInstanceIds)) {
    query['ecsInstanceIds'] = request.ecsInstanceIds;
  }
  if (!Util.isUnset(request.ecsInstanceName)) {
    query['ecsInstanceName'] = request.ecsInstanceName;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/nodes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the statuses of Elastic Compute Service (ECS) instances on which a shipper is installed.
 *
 * @param request ListNodesRequest
 * @return ListNodesResponse
 */
async function listNodes(ResId: string, request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodesWithOptions(ResId, request, headers, runtime);
}

model ListPipelineRequest {
  page?: int32(name='page', description='The header of the response.', example='1'),
  pipelineId?: string(name='pipelineId', description='The ID of the request.', example='pipeline_test'),
  size?: int32(name='size', description='The total number of returned entries.', example='15'),
}

model ListPipelineResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The time when the pipeline was updated.', example='2'),
  }(name='Headers', description='The ID of the ApsaraVideo Media Processing (MPS) queue that is used to run the job.'),
  requestId?: string(name='RequestId', description='The response.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      gmtCreatedTime?: string(name='gmtCreatedTime', example='2020-08-05T03:10:38.188Z'),
      gmtUpdateTime?: string(name='gmtUpdateTime', example='2020-08-05T08:43:31.757Z'),
      pipelineId?: string(name='pipelineId', description='The status of the pipeline. Supported:

*   NOT_DEPLOYED: The node is not deployed.
*   RUNNING
*   DELETED: Deleted. The console does not display this status.', example='pipeline_test'),
      pipelineStatus?: string(name='pipelineStatus', example='NOT_DEPLOYED'),
    }
  ](name='Result', description='The time when the pipeline was created.'),
}

model ListPipelineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPipelineResponseBody(name='body'),
}

/**
 * @param request ListPipelineRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPipelineResponse
 */
async function listPipelineWithOptions(InstanceId: string, request: ListPipelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['pipelineId'] = request.pipelineId;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipeline',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListPipelineRequest
 * @return ListPipelineResponse
 */
async function listPipeline(InstanceId: string, request: ListPipelineRequest): ListPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineWithOptions(InstanceId, request, headers, runtime);
}

model ListPipelineIdsRequest {
  body?: string(name='body', example='{     "userName":"elastic",     "password":"xxxxxx" }'),
}

model ListPipelineIdsResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      available?: boolean(name='available', example='true'),
      code?: string(name='code', example='OK'),
      message?: string(name='message', example='OK'),
      pipelineId?: string(name='pipelineId', example='testKibanaManagement'),
    }
  ](name='Result'),
}

model ListPipelineIdsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPipelineIdsResponseBody(name='body'),
}

/**
 * @summary The error message returned.
 *
 * @param request ListPipelineIdsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPipelineIdsResponse
 */
async function listPipelineIdsWithOptions(InstanceId: string, request: ListPipelineIdsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineIdsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ListPipelineIds',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/pipeline-ids`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The error message returned.
 *
 * @param request ListPipelineIdsRequest
 * @return ListPipelineIdsResponse
 */
async function listPipelineIds(InstanceId: string, request: ListPipelineIdsRequest): ListPipelineIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineIdsWithOptions(InstanceId, request, headers, runtime);
}

model ListPluginsRequest {
  name?: string(name='name', description='SYSTEM', example='analysis-ik'),
  page?: string(name='page', description='The ID of the request.', example='1'),
  size?: int32(name='size', description='The header of the response.', example='10'),
  source?: string(name='source', description='The total number of entries returned.', example='SYSTEM'),
}

model ListPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The address of the plug-in description document.', example='2'),
  }(name='Headers', description='The description of the plug-in.'),
  requestId?: string(name='RequestId', description='The return results.', example='5A5D8E74-565C-43DC-B031-29289FA9****'),
  result?: [ 
    {
      description?: string(name='description', description='The source type of the plug-in.', example='IK analysis plug-in for Elasticsearch.'),
      name?: string(name='name', example='analysis-ik'),
      source?: string(name='source', example='SYSTEM'),
      specificationUrl?: string(name='specificationUrl', description='The name of the plug-in.', example='https://xxxx.html'),
      state?: string(name='state', example='INSTALLED'),
    }
  ](name='Result', description='The status of the plug-in.'),
}

model ListPluginsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPluginsResponseBody(name='body'),
}

/**
 * @summary ES系统插件列表
 *
 * @param request ListPluginsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPluginsResponse
 */
async function listPluginsWithOptions(InstanceId: string, request: ListPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPluginsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query['source'] = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPlugins',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ES系统插件列表
 *
 * @param request ListPluginsRequest
 * @return ListPluginsResponse
 */
async function listPlugins(InstanceId: string, request: ListPluginsRequest): ListPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPluginsWithOptions(InstanceId, request, headers, runtime);
}

model ListSearchLogRequest {
  beginTime?: long(name='beginTime', description='20', example='1531910852074'),
  endTime?: long(name='endTime', description='The ID of the request.', example='1531910852074'),
  page?: int32(name='page', description='The header of the response.', example='1'),
  query?: string(name='query', description='1

This parameter is required.', example='host:``172.16.**.**`` AND content:netty'),
  size?: int32(name='size', description='The number of entries returned per page.', example='20'),
  type?: string(name='type', description='1531910852074

This parameter is required.', example='INSTANCELOG'),
}

model ListSearchLogResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The IP address of the node that generates the log.', example='1000'),
  }(name='Headers', description='The level of the log. Valid values:

*   warn: warning log
*   info: information log
*   error: error log
*   trace: trace logs
*   debug: debug logs

The level information has been migrated to the contentCollection field.'),
  requestId?: string(name='RequestId', description='The list of logs returned by the request.', example='7F40EAA1-6F1D-4DD9-8DB8-C5F00C4E****'),
  result?: [ 
    {
      content?: string(name='content', description='The ID of the instance.', example='[GC (Allocation Failure) 2018-07-19T17:24:20.682+0800: 7516.513: [ParNew: 6604768K->81121K(7341504K), 0.0760606 secs] 7226662K->703015K(31813056K), 0.0762507 secs] [Times: user=0.52 sys=0.00, real=0.07 secs]'),
      contentCollection?: map[string]any(name='contentCollection', example='{"level": "info", "host": "``192.168.**.**``", "time": "2019-03-18T08:16:12.741Z","content": "[o.e.c.r.a.AllocationService] [MnNASM_] Cluster health status changed from [YELLOW] to [GREEN] (reason: [shards started [[my_index][3]] ...])."}'),
      host?: string(name='host', description='Details of the log entry. Different content fields are returned for different log types.', example='``192.168.**.**``'),
      instanceId?: string(name='instanceId', example='es-cn-n6w1o1x0w001c****'),
      level?: string(name='level', description='The timestamp when the log is generated. Unit: ms.', example='info'),
      timestamp?: long(name='timestamp', example='1531985112420'),
    }
  ](name='Result', description='The content of the log entry. Migrated to the contentCollection field.'),
}

model ListSearchLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSearchLogResponseBody(name='body'),
}

/**
 * @summary 查看Elasticsearch集群各种类型的日志
 *
 * @param request ListSearchLogRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSearchLogResponse
 */
async function listSearchLogWithOptions(InstanceId: string, request: ListSearchLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSearchLogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    query['beginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSearchLog',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/search-log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看Elasticsearch集群各种类型的日志
 *
 * @param request ListSearchLogRequest
 * @return ListSearchLogResponse
 */
async function listSearchLog(InstanceId: string, request: ListSearchLogRequest): ListSearchLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSearchLogWithOptions(InstanceId, request, headers, runtime);
}

model ListShardRecoveriesRequest {
  activeOnly?: boolean(name='activeOnly', description='Specifies whether to return information about data restoration of shards. Valid values:

*   true: returns information about data restoration of shards that are being restored.
*   false: returns information about data restoration of all shards.', example='true'),
}

model ListShardRecoveriesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      bytesPercent?: string(name='bytesPercent', description='The data restoration progress.', example='80%'),
      bytesTotal?: long(name='bytesTotal', description='The total amount of data that is restored.', example='12086'),
      filesPercent?: string(name='filesPercent', description='The file execution progress.', example='80.0%'),
      filesTotal?: long(name='filesTotal', description='The total number of files.', example='79'),
      index?: string(name='index', description='The name of the index.', example='my-index-000001'),
      sourceHost?: string(name='sourceHost', description='The IP address of the source node.', example='192.168.XX.XX'),
      sourceNode?: string(name='sourceNode', description='The name of the source node.', example='2Kni3dJ'),
      stage?: string(name='stage', description='The data restoration status. Valid values:

*   done: Data restoration is complete.
*   finalize: Data is being cleared.
*   index: Index metadata is being read, and bytes are being copied from source to destination.
*   init: Data restoration is not started.
*   start: Data restoration is started.
*   translog: Translogs are being redone.', example='done'),
      targetHost?: string(name='targetHost', description='The IP address of the destination node.', example='192.168.XX.XX'),
      targetNode?: string(name='targetNode', description='The name of the destination node.', example='YVVKLmW'),
      translogOps?: long(name='translogOps', description='The number of translog operations to be restored.', example='12086'),
      translogOpsPercent?: string(name='translogOpsPercent', description='The restoration progress of translog operations.', example='80%'),
    }
  ](name='Result', description='The returned result.'),
}

model ListShardRecoveriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListShardRecoveriesResponseBody(name='body'),
}

/**
 * @summary Queries the information about shards that are being restored or shards that are restored. By default, this operation returns only the information about shards that are being restored after you call this operation.
 *
 * @description > The restoration of a shard is a process of synchronizing data from a primary shard to a replica shard. After the restoration is complete, the replica shard is available for data searches.
 *
 * @param request ListShardRecoveriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListShardRecoveriesResponse
 */
async function listShardRecoveriesWithOptions(InstanceId: string, request: ListShardRecoveriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListShardRecoveriesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.activeOnly)) {
    query['activeOnly'] = request.activeOnly;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListShardRecoveries',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/cat-recovery`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about shards that are being restored or shards that are restored. By default, this operation returns only the information about shards that are being restored after you call this operation.
 *
 * @description > The restoration of a shard is a process of synchronizing data from a primary shard to a replica shard. After the restoration is complete, the replica shard is available for data searches.
 *
 * @param request ListShardRecoveriesRequest
 * @return ListShardRecoveriesResponse
 */
async function listShardRecoveries(InstanceId: string, request: ListShardRecoveriesRequest): ListShardRecoveriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShardRecoveriesWithOptions(InstanceId, request, headers, runtime);
}

model ListSnapshotReposByInstanceIdResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ 
    {
      instanceId?: string(name='instanceId', description='Reference instance ID.', example='es-cn-6ja1ro4jt000c****'),
      repoPath?: string(name='repoPath', description='The address of the repository.', example='es-cn-6ja1ro4jt000c****'),
      snapWarehouse?: string(name='snapWarehouse', description='Reference warehouse name.', example='aliyun_snapshot_from_es-cn-6ja1ro4jt000c****'),
      status?: string(name='status', description='Reference warehouse status. available indicates that it is valid. unavailable indicates that it is invalid.', example='available'),
    }
  ](name='Result', description='The return results.'),
}

model ListSnapshotReposByInstanceIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSnapshotReposByInstanceIdResponseBody(name='body'),
}

/**
 * @summary 获取跨集群索引仓库列表
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSnapshotReposByInstanceIdResponse
 */
async function listSnapshotReposByInstanceIdWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSnapshotReposByInstanceIdResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSnapshotReposByInstanceId',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-repos`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取跨集群索引仓库列表
 *
 * @return ListSnapshotReposByInstanceIdResponse
 */
async function listSnapshotReposByInstanceId(InstanceId: string): ListSnapshotReposByInstanceIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSnapshotReposByInstanceIdWithOptions(InstanceId, headers, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The number of the returned page.', example='1d2db86sca4384811e0b5e8707e******'),
  page?: int32(name='Page', description='1d2db86sca4384811e0b5e8707e\\\\*\\\\*\\\\*\\\\*\\\\*\\\\*', example='1', deprecated=true),
  resourceIds?: string(name='ResourceIds', description='The ID of the request.', example='["es-cn-aaa","es-cn-bbb"]'),
  resourceType?: string(name='ResourceType', description='[{"key":"env","value","dev"},{"key":"dev", "value":"IT"}]

This parameter is required.', example='INSTANCE'),
  size?: int32(name='Size', description='["es-cn-aaa","es-cn-bbb"]', example='10', deprecated=true),
  tags?: string(name='Tags', description='The header of the response. This parameter is empty and is for reference only. You cannot force this parameter to be relied on in the program.

>  The return examples does not contain this parameter.', example='[{"key":"env","value","dev"},{"key":"dev",  "value":"IT"}]'),
}

model ListTagResourcesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count', description='The value of the tag.', example='10'),
  }(name='Headers', description='The labels of the resource.'),
  pageSize?: int32(name='PageSize', description='The number of resources to query.', example='1'),
  requestId?: string(name='RequestId', description='A list of resources that have tags.', example='F99407AB-2FA9-489E-A259-40CF6D******'),
  tagResources?: {
    tagResource?: [ 
      {
        resourceId?: string(name='ResourceId', example='es-cn-oew1q8bev0002****'),
        resourceType?: string(name='ResourceType', example='ALIYUN::ELASTICSEARCH::INSTANCE'),
        tagKey?: string(name='TagKey', example='env'),
        tagValue?: string(name='TagValue', description='The tag key.', example='dev'),
      }
    ](name='TagResource', description='Indicates the ID of a resource.'),
  }(name='TagResources', description='The type of the resource. Fixed to `ALIYUN::ELASTICSEARCH::INSTANCE`.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary 查看资源和标签关系
 *
 * @param request ListTagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看资源和标签关系
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

model ListTagsRequest {
  pageSize?: int32(name='pageSize', description='The return results.', example='20'),
  resourceType?: string(name='resourceType', description='The tag value of the ENI.', example='INSTANCE'),
}

model ListTagsResponseBody = {
  requestId?: string(name='RequestId', description='The key of the tag.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: [ 
    {
      tagKey?: string(name='TagKey', example='env'),
      tagValue?: string(name='TagValue', example='dev'),
    }
  ](name='Result'),
}

model ListTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagsResponseBody(name='body'),
}

/**
 * @summary 查看所有已常见的标签
 *
 * @param request ListTagsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagsResponse
 */
async function listTagsWithOptions(request: ListTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTags',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags/all-tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查看所有已常见的标签
 *
 * @param request ListTagsRequest
 * @return ListTagsResponse
 */
async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagsWithOptions(request, headers, runtime);
}

model ListVpcEndpointsRequest {
  page?: int32(name='page', description='The number of the page to return.

Pages start from page 1. Default value: 1.', example='1'),
  size?: int32(name='size', description='The number of entries to return on each page. Default value: 20.', example='10'),
}

model ListVpcEndpointsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
  result?: [ 
    {
      connectionStatus?: string(name='connectionStatus', description='The status of the endpoint connection. Valid values:

*   Pending
*   Connecting
*   Connected
*   Disconnecting
*   Disconnected
*   Deleting
*   ServiceDeleted', example='Disconnected'),
      createTime?: string(name='createTime', description='The time when the endpoint was created.', example='2021-07-22T01:19:24Z'),
      endpointBusinessStatus?: string(name='endpointBusinessStatus', description='The business status of the endpoint. Valid values:

*   Normal
*   FinancialLocked', example='Normal'),
      endpointDomain?: string(name='endpointDomain', description='The domain name of the endpoint. The domain name is used for connection configuration.', example='ep-bp18s6wy9420wdi4****.epsrv-bp1bz3efowa4kc0****.cn-hangzhou.privatelink.aliyuncs.com'),
      endpointId?: string(name='endpointId', description='The ID of the endpoint.', example='ep-bp1tah7zbrwmkjef****'),
      endpointName?: string(name='endpointName', description='The name of the endpoint.', example='test'),
      endpointStatus?: string(name='endpointStatus', description='The status of the endpoint. Valid values:

*   Creating
*   Active
*   Pending
*   Deleting', example='Active'),
      serviceId?: string(name='serviceId', description='The ID of the endpoint service with which the endpoint is associated.', example='epsrv-bp1w0p3jdirbfmt6****'),
      serviceName?: string(name='serviceName', description='The name of the endpoint service with which the endpoint is associated.', example='com.aliyuncs.privatelink.cn-hangzhou.epsrv-bp1w0p3jdirbfmt6****'),
    }
  ](name='Result', description='The details of the endpoints.'),
}

model ListVpcEndpointsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVpcEndpointsResponseBody(name='body'),
}

/**
 * @summary Queries the statuses of endpoints in the virtual private cloud (VPC) within the Elasticsearch service account.
 *
 * @param request ListVpcEndpointsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVpcEndpointsResponse
 */
async function listVpcEndpointsWithOptions(InstanceId: string, request: ListVpcEndpointsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcEndpointsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.page)) {
    query['page'] = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query['size'] = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVpcEndpoints',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/vpc-endpoints`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the statuses of endpoints in the virtual private cloud (VPC) within the Elasticsearch service account.
 *
 * @param request ListVpcEndpointsRequest
 * @return ListVpcEndpointsResponse
 */
async function listVpcEndpoints(InstanceId: string, request: ListVpcEndpointsRequest): ListVpcEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcEndpointsWithOptions(InstanceId, request, headers, runtime);
}

model MigrateToOtherZoneRequest {
  body?: string(name='body'),
  dryRun?: boolean(name='dryRun', description='Verify whether the zone node can be migrated. true indicates that the data is only verified and the migration task is not executed. false indicates that the migration task is executed after the verification is successful.

This parameter is required.', example='false'),
}

model MigrateToOtherZoneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: migration succeeded
*   false: The migration fails', example='true'),
}

model MigrateToOtherZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MigrateToOtherZoneResponseBody(name='body'),
}

/**
 * @summary Call the MigrateToOtherZone to migrate the nodes in the specified zone to the destination zone.
 *
 * @description If the specifications in your zone are insufficient, you can upgrade your instance to nodes in another zone. Before calling this interface, you must ensure that:
 * *   The error message returned because the current account is in a zone that has sufficient resources.
 *     After migrating nodes with current specifications to another zone, you need to manually [upgrade cluster](https://help.aliyun.com/document_detail/96650.html) because the cluster will not be upgraded during the migration process. Therefore, select a zone with sufficient resources to avoid cluster upgrade failure. We recommend that you choose new zones that are in lower alphabetical order. For example, for cn-hangzhou-e and cn-hangzhou-h zones, choose cn-hangzhou-h first.
 * *   The cluster is in the healthy state.
 *     Can be passed`  GET _cat/health?v  `command to view the health status of the cluster.
 *
 * @param request MigrateToOtherZoneRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return MigrateToOtherZoneResponse
 */
async function migrateToOtherZoneWithOptions(InstanceId: string, request: MigrateToOtherZoneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateToOtherZoneResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'MigrateToOtherZone',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/migrate-zones`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call the MigrateToOtherZone to migrate the nodes in the specified zone to the destination zone.
 *
 * @description If the specifications in your zone are insufficient, you can upgrade your instance to nodes in another zone. Before calling this interface, you must ensure that:
 * *   The error message returned because the current account is in a zone that has sufficient resources.
 *     After migrating nodes with current specifications to another zone, you need to manually [upgrade cluster](https://help.aliyun.com/document_detail/96650.html) because the cluster will not be upgraded during the migration process. Therefore, select a zone with sufficient resources to avoid cluster upgrade failure. We recommend that you choose new zones that are in lower alphabetical order. For example, for cn-hangzhou-e and cn-hangzhou-h zones, choose cn-hangzhou-h first.
 * *   The cluster is in the healthy state.
 *     Can be passed`  GET _cat/health?v  `command to view the health status of the cluster.
 *
 * @param request MigrateToOtherZoneRequest
 * @return MigrateToOtherZoneResponse
 */
async function migrateToOtherZone(InstanceId: string, request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateToOtherZoneWithOptions(InstanceId, request, headers, runtime);
}

model ModifyDeployMachineRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model ModifyDeployMachineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C37CE536-6C0F-4778-9B59-6D94C7F7EB63'),
  result?: boolean(name='Result', description='Indicates whether the ECS instances are changed. Valid values:

*   true
*   false', example='true'),
}

model ModifyDeployMachineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDeployMachineResponseBody(name='body'),
}

/**
 * @summary Changes the Elastic Compute Service (ECS) instances on which a shipper is installed.
 *
 * @param request ModifyDeployMachineRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDeployMachineResponse
 */
async function modifyDeployMachineWithOptions(ResId: string, request: ModifyDeployMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyDeployMachineResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyDeployMachine',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/modify-deploy-machines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the Elastic Compute Service (ECS) instances on which a shipper is installed.
 *
 * @param request ModifyDeployMachineRequest
 * @return ModifyDeployMachineResponse
 */
async function modifyDeployMachine(ResId: string, request: ModifyDeployMachineRequest): ModifyDeployMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyDeployMachineWithOptions(ResId, request, headers, runtime);
}

model ModifyElastictaskRequest {
  body?: string(name='body'),
}

model ModifyElastictaskResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression', example='0 0 0 ? * MON'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression', example='4 4 4 ? * WED'),
      elasticNodeCount?: int32(name='elasticNodeCount', example='2'),
      replicaCount?: int32(name='replicaCount', example='2'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType', example='crontab'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model ModifyElastictaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyElastictaskResponseBody(name='body'),
}

/**
 * @param request ModifyElastictaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyElastictaskResponse
 */
async function modifyElastictaskWithOptions(InstanceId: string, request: ModifyElastictaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyElastictaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyElastictask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/elastic-task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ModifyElastictaskRequest
 * @return ModifyElastictaskResponse
 */
async function modifyElastictask(InstanceId: string, request: ModifyElastictaskRequest): ModifyElastictaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyElastictaskWithOptions(InstanceId, request, headers, runtime);
}

model ModifyInstanceMaintainTimeRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body', example='{     "openMaintainTime": true,     "maintainStartTime": "03:00Z",     "maintainEndTime": "04:00Z" }'),
}

model ModifyInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model ModifyInstanceMaintainTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyInstanceMaintainTimeResponseBody(name='body'),
}

/**
 * @summary ## RequestBody
 * You must also specify the following parameters in the RequestBody parameter to specify the maintenance window information.  
 * | Parameter | Type | Required | Example | Description |
 * | --------- | ---- | -------- | ------- | ----------- |
 * | maintainStartTime | String | No | 02:00Z | The start time of the maintenance window. Specify the time in the HH:mmZ format. The time must be in UTC. |
 * | maintainEndTime | String | No | 06:00Z | The end time of the maintenance window. Specify the time in the HH:mmZ format. The time must be displayed in UTC. |
 * | openMaintainTime | boolean | Yes | true | Specifies whether to enable the maintenance window feature. Only **true** is supported, indicating that the feature is enabled. |
 * Examples: 
 * ```
 * {
 *     "openMaintainTime": true,
 *     "maintainStartTime": "03:00Z",
 *     "maintainEndTime": "04:00Z"
 * }
 * ```
 *
 * @description es-cn-n6w1o1x0w001c\\*\\*\\*\\*
 *
 * @param request ModifyInstanceMaintainTimeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInstanceMaintainTimeResponse
 */
async function modifyInstanceMaintainTimeWithOptions(InstanceId: string, request: ModifyInstanceMaintainTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyInstanceMaintainTimeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceMaintainTime',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/modify-maintaintime`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ## RequestBody
 * You must also specify the following parameters in the RequestBody parameter to specify the maintenance window information.  
 * | Parameter | Type | Required | Example | Description |
 * | --------- | ---- | -------- | ------- | ----------- |
 * | maintainStartTime | String | No | 02:00Z | The start time of the maintenance window. Specify the time in the HH:mmZ format. The time must be in UTC. |
 * | maintainEndTime | String | No | 06:00Z | The end time of the maintenance window. Specify the time in the HH:mmZ format. The time must be displayed in UTC. |
 * | openMaintainTime | boolean | Yes | true | Specifies whether to enable the maintenance window feature. Only **true** is supported, indicating that the feature is enabled. |
 * Examples: 
 * ```
 * {
 *     "openMaintainTime": true,
 *     "maintainStartTime": "03:00Z",
 *     "maintainEndTime": "04:00Z"
 * }
 * ```
 *
 * @description es-cn-n6w1o1x0w001c\\*\\*\\*\\*
 *
 * @param request ModifyInstanceMaintainTimeRequest
 * @return ModifyInstanceMaintainTimeResponse
 */
async function modifyInstanceMaintainTime(InstanceId: string, request: ModifyInstanceMaintainTimeRequest): ModifyInstanceMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyInstanceMaintainTimeWithOptions(InstanceId, request, headers, runtime);
}

model ModifyWhiteIpsRequest {
  modifyMode?: string(name='modifyMode', description='The information about the IP address whitelist that you want to update. You can specify only one whitelist.

> You cannot configure both the whiteIpList and whiteIpGroup parameters.', example='Cover'),
  networkType?: string(name='networkType', description='The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.

> You cannot configure both the whiteIpList and whiteIpGroup parameters.', example='PUBLIC'),
  nodeType?: string(name='nodeType', description='The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.', example='WORKER'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='The type of the IP address whitelist. Valid values:

*   PRIVATE_KIBANA
*   PRIVATE_ES
*   PUBLIC_ES
*   PUBLIC_KIBANA', example='test_group'),
    ips?: [ string ](name='ips', description='The returned result.'),
    whiteIpType?: string(name='whiteIpType', description='The request ID.', example='PRIVATE_ES'),
  }(name='whiteIpGroup', description='The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  whiteIpList?: [ string ](name='whiteIpList', description='The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  clientToken?: string(name='clientToken', description='The network type. This parameter is required if you configure the whiteIpList parameter. Valid values:

*   PRIVATE
*   PUBLIC', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model ModifyWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1DERFG'),
  result?: boolean(name='Result', example='true'),
}

model ModifyWhiteIpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWhiteIpsResponseBody(name='body'),
}

/**
 * @summary >  If you want to add an IP address whitelist, you can set the modifyMode parameter only to Cover. If you set this parameter to Delete or Append, you can only update an IP address whitelist.
 * *   If you set the modifyMode parameter to Cover and leave the ips parameter empty, the system deletes the specified whitelist. If the whitelist specified by using the groupName parameter does not exist, the system creates such a whitelist.
 * *   If you set the modifyMode parameter to Delete, at least one IP address must be retained for the specified whitelist.
 * *   If you set the modifyMode parameter to Append, you must make sure that the specified whitelist exists. Otherwise, the system reports the NotFound error.
 *
 * @description The ID of the cluster.
 *
 * @param request ModifyWhiteIpsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWhiteIpsResponse
 */
async function modifyWhiteIpsWithOptions(InstanceId: string, request: ModifyWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.modifyMode)) {
    body['modifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.networkType)) {
    body['networkType'] = request.networkType;
  }
  if (!Util.isUnset(request.nodeType)) {
    body['nodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body['whiteIpGroup'] = request.whiteIpGroup;
  }
  if (!Util.isUnset(request.whiteIpList)) {
    body['whiteIpList'] = request.whiteIpList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/modify-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary >  If you want to add an IP address whitelist, you can set the modifyMode parameter only to Cover. If you set this parameter to Delete or Append, you can only update an IP address whitelist.
 * *   If you set the modifyMode parameter to Cover and leave the ips parameter empty, the system deletes the specified whitelist. If the whitelist specified by using the groupName parameter does not exist, the system creates such a whitelist.
 * *   If you set the modifyMode parameter to Delete, at least one IP address must be retained for the specified whitelist.
 * *   If you set the modifyMode parameter to Append, you must make sure that the specified whitelist exists. Otherwise, the system reports the NotFound error.
 *
 * @description The ID of the cluster.
 *
 * @param request ModifyWhiteIpsRequest
 * @return ModifyWhiteIpsResponse
 */
async function modifyWhiteIps(InstanceId: string, request: ModifyWhiteIpsRequest): ModifyWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model MoveResourceGroupRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    createdAt?: string(name='createdAt', description='The time when the cluster was created.', example='2020-07-06T10:18:48.662Z'),
    description?: string(name='description', description='The name of the cluster.', example='es-cn-abc'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The type of the source of the dictionary file. Valid values:

*   OSS: Object Storage Service (OSS). You must make sure that the access control list (ACL) of the related OSS bucket is public read.
*   ORIGIN: previously uploaded dictionary.', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: stopword list
*   MAIN: main dictionary
*   SYNONYMS: synonym dictionary
*   ALI_WS: Alibaba Cloud dictionary', example='MAIN'),
      }
    ](name='dictList', description='The configurations of IK dictionaries.'),
    domain?: string(name='domain', description='The internal endpoint of the cluster.', example='es-cn-nif1q8auz0003****.elasticsearch.aliyuncs.com'),
    esVersion?: string(name='esVersion', description='The version of the cluster.', example='6.7.0_with_X-Pack'),
    instanceId?: string(name='instanceId', description='The ID of the cluster.', example='es-cn-n6w1o1x0w001c****'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', description='The number of nodes.', example='1'),
      disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification category.', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration', description='The configurations of Kibana nodes.'),
    kibanaDomain?: string(name='kibanaDomain', description='The public endpoint of the Kibana console of the cluster.', example='es-cn-nif1q8auz0003****.kibana.elasticsearch.aliyuncs.com'),
    kibanaPort?: int32(name='kibanaPort', description='The port number that is used to access the Kibana console of the cluster over the Internet.', example='5601'),
    masterConfiguration?: {
      amount?: int32(name='amount', description='The number of nodes.', example='3'),
      disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification category.', example='elasticsearch.sn2ne.large'),
    }(name='masterConfiguration', description='The configurations of dedicated master nodes.'),
    networkConfig?: {
      type?: string(name='type', description='The network type. Only the VPC is supported.', example='vpc'),
      vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp16k1dvzxtmagcva****'),
      vsArea?: string(name='vsArea', description='The zone where the cluster resides.', example='cn-hangzhou-i'),
      vswitchId?: string(name='vswitchId', description='The ID of the vSwitch.', example='vsw-bp1k4ec6s7sjdbudw****'),
    }(name='networkConfig', description='The network configurations.'),
    nodeAmount?: int32(name='nodeAmount', description='The number of data nodes in the cluster.', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='The storage capacity. Unit: GB.', example='50'),
      diskType?: string(name='diskType', description='The storage type.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification category.', example='elasticsearch.n4.small'),
    }(name='nodeSpec', description='The configurations of data nodes.'),
    paymentType?: string(name='paymentType', description='The billing method of the cluster. Valid values:

*   prepaid: subscription
*   postpaid: pay-as-you-go', example='postpaid'),
    publicDomain?: string(name='publicDomain', description='The public endpoint of the cluster.', example='es-cn-n6w1o1x0w001c****.public.elasticsearch.aliyuncs.com'),
    publicPort?: int32(name='publicPort', description='The port number that is used to access the cluster over the Internet.', example='9200'),
    status?: string(name='status', description='The status of the cluster. Valid values:

*   active: The cluster is normal.
*   activating: The cluster is being activated.
*   Inactive: The cluster is frozen.
*   invalid: The cluster is valid.', example='active'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The type of the source of the dictionary file. Valid values:

*   OSS: Object Storage Service (OSS). You must make sure that the ACL of the related OSS bucket is public read.
*   ORIGIN: previously uploaded dictionary.', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: stopword list
*   MAIN: main dictionary
*   SYNONYMS: synonym dictionary
*   ALI_WS: Alibaba Cloud dictionary', example='STOP'),
      }
    ](name='synonymsDicts', description='The configurations of synonym dictionaries.'),
    updatedAt?: string(name='updatedAt', description='The time when the cluster was last updated.', example='2018-07-18T10:10:04.484Z'),
  }(name='Result', description='The returned result.'),
}

model MoveResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveResourceGroupResponseBody(name='body'),
}

/**
 * @summary Migrates an Elasticsearch cluster to a specified resource group.
 *
 * @param request MoveResourceGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveResourceGroupResponse
 */
async function moveResourceGroupWithOptions(InstanceId: string, request: MoveResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'MoveResourceGroup',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/resourcegroup`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Migrates an Elasticsearch cluster to a specified resource group.
 *
 * @param request MoveResourceGroupRequest
 * @return MoveResourceGroupResponse
 */
async function moveResourceGroup(InstanceId: string, request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return moveResourceGroupWithOptions(InstanceId, request, headers, runtime);
}

model OpenDiagnosisRequest {
  clientToken?: string(name='ClientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  lang?: string(name='lang', example='en'),
}

model OpenDiagnosisResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model OpenDiagnosisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenDiagnosisResponseBody(name='body'),
}

/**
 * @param request OpenDiagnosisRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenDiagnosisResponse
 */
async function openDiagnosisWithOptions(InstanceId: string, request: OpenDiagnosisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenDiagnosisResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenDiagnosis',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/open-diagnosis`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request OpenDiagnosisRequest
 * @return OpenDiagnosisResponse
 */
async function openDiagnosis(InstanceId: string, request: OpenDiagnosisRequest): OpenDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openDiagnosisWithOptions(InstanceId, request, headers, runtime);
}

model OpenHttpsRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model OpenHttpsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: open the HTTPS protocol successfully
*   false: open the HTTPS protocol failed', example='true'),
}

model OpenHttpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenHttpsResponseBody(name='body'),
}

/**
 * @description >  To ensure data security, we recommend that you enable HTTPS.
 *
 * @param request OpenHttpsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenHttpsResponse
 */
async function openHttpsWithOptions(InstanceId: string, request: OpenHttpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenHttpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenHttps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/open-https`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @description >  To ensure data security, we recommend that you enable HTTPS.
 *
 * @param request OpenHttpsRequest
 * @return OpenHttpsResponse
 */
async function openHttps(InstanceId: string, request: OpenHttpsRequest): OpenHttpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openHttpsWithOptions(InstanceId, request, headers, runtime);
}

model PostEmonTryAlarmRuleRequest {
  body?: string(name='body'),
}

model PostEmonTryAlarmRuleResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='""'),
  requestId?: string(name='RequestId', example='3EC5731F-0944-4E4F-9DD5-1F976B3FCC3D'),
  success?: boolean(name='Success', example='true'),
}

model PostEmonTryAlarmRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PostEmonTryAlarmRuleResponseBody(name='body'),
}

/**
 * @param request PostEmonTryAlarmRuleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PostEmonTryAlarmRuleResponse
 */
async function postEmonTryAlarmRuleWithOptions(ProjectId: string, AlarmGroupId: string, request: PostEmonTryAlarmRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PostEmonTryAlarmRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'PostEmonTryAlarmRule',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/emon/projects/${OpenApiUtil.getEncodeParam(ProjectId)}/alarm-groups/${OpenApiUtil.getEncodeParam(AlarmGroupId)}/alarm-rules/_test`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PostEmonTryAlarmRuleRequest
 * @return PostEmonTryAlarmRuleResponse
 */
async function postEmonTryAlarmRule(ProjectId: string, AlarmGroupId: string, request: PostEmonTryAlarmRuleRequest): PostEmonTryAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return postEmonTryAlarmRuleWithOptions(ProjectId, AlarmGroupId, request, headers, runtime);
}

model RecommendTemplatesRequest {
  usageScenario?: string(name='usageScenario', description='*
*
*
*
*

**

****

This parameter is required.', example='general'),
}

model RecommendTemplatesResponseBody = {
  requestId?: string(name='RequestId', example='66B060CF-7381-49C7-9B89-7757927FDA16'),
  result?: [ 
    {
      content?: string(name='content', example='{\\\\n\\\\t\\\\"persistent\\\\": {\\\\n\\\\t\\\\t\\\\"search\\\\": {\\\\n\\\\t\\\\t\\\\t\\\\"max_buckets\\\\": \\\\"10000\\\\"\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n}'),
      templateName?: string(name='templateName', description='*
*
*
*

**

****', example='dynamicSettings'),
    }
  ](name='Result'),
}

model RecommendTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RecommendTemplatesResponseBody(name='body'),
}

/**
 * @param request RecommendTemplatesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RecommendTemplatesResponse
 */
async function recommendTemplatesWithOptions(InstanceId: string, request: RecommendTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RecommendTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.usageScenario)) {
    query['usageScenario'] = request.usageScenario;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecommendTemplates',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/recommended-templates`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RecommendTemplatesRequest
 * @return RecommendTemplatesResponse
 */
async function recommendTemplates(InstanceId: string, request: RecommendTemplatesRequest): RecommendTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return recommendTemplatesWithOptions(InstanceId, request, headers, runtime);
}

model ReinstallCollectorRequest {
  clientToken?: string(name='ClientToken', description='The request body parameters. For more information, see the Request body section in this topic.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body', description='Indicates whether the shipper is installed. Valid values:

*   true: The shipper is installed.
*   false: The shipper fails to be installed.', example='{
  "restartType": "nodeEcsId",
  "nodes":["i-bp1gyhphjaj73jsr****","i-bp10piq1mkfnyw9t****"]
}'),
}

model ReinstallCollectorResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The ID of the request.', example='true'),
}

model ReinstallCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReinstallCollectorResponseBody(name='body'),
}

/**
 * @summary Installs a shipper that failed to be installed when you create the shipper.
 *
 * @param request ReinstallCollectorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReinstallCollectorResponse
 */
async function reinstallCollectorWithOptions(ResId: string, request: ReinstallCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReinstallCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ReinstallCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/reinstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Installs a shipper that failed to be installed when you create the shipper.
 *
 * @param request ReinstallCollectorRequest
 * @return ReinstallCollectorResponse
 */
async function reinstallCollector(ResId: string, request: ReinstallCollectorRequest): ReinstallCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return reinstallCollectorWithOptions(ResId, request, headers, runtime);
}

model RemoveApmResponseBody = {
  requestId?: string(name='RequestId', example='29A879FB-86BF-54CA-9426-B769A099E1A1'),
  result?: boolean(name='Result', example='true'),
}

model RemoveApmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveApmResponseBody(name='body'),
}

/**
 * @summary RemoveApm
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveApmResponse
 */
async function removeApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveApmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary RemoveApm
 *
 * @return RemoveApmResponse
 */
async function removeApm(instanceId: string): RemoveApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeApmWithOptions(instanceId, headers, runtime);
}

model RenewInstanceRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='This parameter is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B350****'),
}

model RenewInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Return results:

*   true: renewal successfully
*   false: renewal failed', example='true'),
}

model RenewInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenewInstanceResponseBody(name='body'),
}

/**
 * @summary Call RenewInstance to renew a subscription instance.
 *
 * @param request RenewInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenewInstanceResponse
 */
async function renewInstanceWithOptions(InstanceId: string, request: RenewInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/renew`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call RenewInstance to renew a subscription instance.
 *
 * @param request RenewInstanceRequest
 * @return RenewInstanceResponse
 */
async function renewInstance(InstanceId: string, request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewInstanceWithOptions(InstanceId, request, headers, runtime);
}

model RenewLogstashRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model RenewLogstashResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: boolean(name='Result', description='The returned result. Valid values:

*   true: The cluster is renewed.
*   false: The cluster fails to be renewed.', example='true'),
}

model RenewLogstashResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenewLogstashResponseBody(name='body'),
}

/**
 * @summary Renews a Logstash cluster.
 *
 * @param request RenewLogstashRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenewLogstashResponse
 */
async function renewLogstashWithOptions(InstanceId: string, request: RenewLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RenewLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/renew`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Renews a Logstash cluster.
 *
 * @param request RenewLogstashRequest
 * @return RenewLogstashResponse
 */
async function renewLogstash(InstanceId: string, request: RenewLogstashRequest): RenewLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewLogstashWithOptions(InstanceId, request, headers, runtime);
}

model RestartCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model RestartCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='84B4038A-AF38-4BF4-9FAD-EA92A4FFF00A'),
  result?: boolean(name='Result', description='Indicates whether the shipper is restarted. Valid values:

*   true: The shipper is restarted.
*   false: The shipper fails to be restarted.', example='true'),
}

model RestartCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartCollectorResponseBody(name='body'),
}

/**
 * @summary Restarts a shipper.
 *
 * @param request RestartCollectorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartCollectorResponse
 */
async function restartCollectorWithOptions(ResId: string, request: RestartCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restarts a shipper.
 *
 * @param request RestartCollectorRequest
 * @return RestartCollectorResponse
 */
async function restartCollector(ResId: string, request: RestartCollectorRequest): RestartCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartCollectorWithOptions(ResId, request, headers, runtime);
}

model RestartInstanceRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. The maximum length of the token is 64 ASCII characters.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  force?: boolean(name='force', description='Specifies whether to ignore the status of the instance and forcibly restart the instance.', example='false'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC****'),
  result?: {
    createdAt?: string(name='createdAt', description='The time when the instance was created.', example='2020-07-06T10:18:48.662Z'),
    description?: string(name='description', description='The name of the instance.', example='es-cn-abc'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the Dictionary File. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The source type. Valid values:

*   OSS: OSS open storage (need to ensure that OSS storage space is public readable.)
*   ORIGIN: Open source Elasticsearch
*   UPLOAD: Uploaded files', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: The STOP word.
*   MAIN: MAIN Dictionary
*   SYNONYMS: SYNONYMS
*   ALI_WS: an Alibaba Dictionary.', example='MAIN'),
      }
    ](name='dictList', description='The configuration of the IK dictionaries.'),
    domain?: string(name='domain', description='The intranet access address of the instance.', example='es-cn-nif1q8auz0003****.elasticsearch.aliyuncs.com'),
    esVersion?: string(name='esVersion', description='The version of the instance.', example='6.7.0_with_X-Pack'),
    instanceId?: string(name='instanceId', description='The ID of the instance.', example='es-cn-n6w1o1x0w001c****'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', description='The number of performance metrics.', example='1'),
      disk?: int32(name='disk', description='The size of the node storage space. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type of the node.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification of data nodes.', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration', description='The configuration of Kibana nodes.'),
    kibanaDomain?: string(name='kibanaDomain', description='The public network access address of Kibana.', example='es-cn-nif1q8auz0003****.kibana.elasticsearch.aliyuncs.com'),
    kibanaPort?: int32(name='kibanaPort', description='The public port of the Kibana network.', example='5601'),
    masterConfiguration?: {
      amount?: int32(name='amount', description='The number of nodes in the cluster.', example='3'),
      disk?: int32(name='disk', description='The size of the node storage space. Unit: GB.', example='20'),
      diskType?: string(name='diskType', description='The storage type of the node. This tool only supports cloud_ssd (cloud SSD) disks.', example='cloud_ssd'),
      spec?: string(name='spec', description='The node specifications of the cluster.', example='elasticsearch.sn2ne.large'),
    }(name='masterConfiguration', description='The configuration of dedicated master nodes.'),
    networkConfig?: {
      type?: string(name='type', description='The network type. Only Virtual Private Cloud (VPC) is supported.', example='vpc'),
      vpcId?: string(name='vpcId', description='The ID of the VPC.', example='vpc-bp16k1dvzxtmagcva****'),
      vsArea?: string(name='vsArea', description='The zone where the instance is deployed.', example='cn-hangzhou-i'),
      vswitchId?: string(name='vswitchId', description='The ID of the vSwitch associated with the specified VPC.', example='vsw-bp1k4ec6s7sjdbudw****'),
    }(name='networkConfig', description='The network configuration.'),
    nodeAmount?: int32(name='nodeAmount', description='The number of data nodes.', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='The storage space size per data node. Unit: GB.', example='50'),
      diskType?: string(name='diskType', description='The storage type of the node. Valid values: cloud_ssd and cloud_efficiency.', example='cloud_ssd'),
      spec?: string(name='spec', description='The specification of data nodes.', example='elasticsearch.n4.small'),
    }(name='nodeSpec', description='The configuration of data nodes.'),
    paymentType?: string(name='paymentType', description='The billing method of the created ECS instance.

Valid values: prepaid and postpaid.', example='postpaid'),
    publicDomain?: string(name='publicDomain', description='The public network access address.', example='es-cn-n6w1o1x0w001c****.public.elasticsearch.aliyuncs.com'),
    publicPort?: int32(name='publicPort', description='The public network port.', example='9200'),
    status?: string(name='status', description='The state of the cluster.

Supported: active (normal), activating (initializing), inactive (blocked), and invalid (expired).', example='active'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize', description='The size of the Dictionary File. Unit: bytes.', example='2782602'),
        name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
        sourceType?: string(name='sourceType', description='The source type. Valid values:

*   OSS:OSS open storage (the OSS storage space must be publicly readable.)
*   ORIGIN: open-source Elasticsearch
*   UPLOAD', example='ORIGIN'),
        type?: string(name='type', description='The type of the dictionary. Valid values:

*   STOP: The STOP word.
*   MAIN: MAIN Dictionary
*   SYNONYMS: SYNONYMS
*   ALI_WS: an Alibaba Dictionary.', example='STOP'),
      }
    ](name='synonymsDicts', description='The configuration of the synonym dictionaries.'),
    updatedAt?: string(name='updatedAt', description='The time when the instance was last updated.', example='2018-07-18T10:10:04.484Z'),
  }(name='Result', description='The return results.'),
}

model RestartInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartInstanceResponseBody(name='body'),
}

/**
 * @summary You can call this operation to restart a specified Elasticsearch instance.
 *
 * @description >  After the instance is restarted, the instance enters the activating state. After the instance is restarted, its status changes to active. Alibaba Cloud Elasticsearch supports restarting a single node. Restarting a node can be divided into normal restart and blue-green restart.
 *
 * @param request RestartInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartInstanceResponse
 */
async function restartInstanceWithOptions(InstanceId: string, request: RestartInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RestartInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call this operation to restart a specified Elasticsearch instance.
 *
 * @description >  After the instance is restarted, the instance enters the activating state. After the instance is restarted, its status changes to active. Alibaba Cloud Elasticsearch supports restarting a single node. Restarting a node can be divided into normal restart and blue-green restart.
 *
 * @param request RestartInstanceRequest
 * @return RestartInstanceResponse
 */
async function restartInstance(InstanceId: string, request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartInstanceWithOptions(InstanceId, request, headers, runtime);
}

model RestartLogstashRequest {
  batchCount?: double(name='batchCount', example='20%'),
  blueGreenDep?: boolean(name='blueGreenDep', example='false'),
  nodeTypes?: [ string ](name='nodeTypes'),
  nodes?: [ string ](name='nodes'),
  restartType?: string(name='restartType', example='instance'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  force?: boolean(name='force', example='true'),
}

model RestartLogstashResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: Logstash(name='Result'),
}

model RestartLogstashResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartLogstashResponseBody(name='body'),
}

/**
 * @summary 重启Logstash集群
 *
 * @param request RestartLogstashRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartLogstashResponse
 */
async function restartLogstashWithOptions(InstanceId: string, request: RestartLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.batchCount)) {
    body['batchCount'] = request.batchCount;
  }
  if (!Util.isUnset(request.blueGreenDep)) {
    body['blueGreenDep'] = request.blueGreenDep;
  }
  if (!Util.isUnset(request.nodeTypes)) {
    body['nodeTypes'] = request.nodeTypes;
  }
  if (!Util.isUnset(request.nodes)) {
    body['nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.restartType)) {
    body['restartType'] = request.restartType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestartLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/restart`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 重启Logstash集群
 *
 * @param request RestartLogstashRequest
 * @return RestartLogstashResponse
 */
async function restartLogstash(InstanceId: string, request: RestartLogstashRequest): RestartLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartLogstashWithOptions(InstanceId, request, headers, runtime);
}

model ResumeElasticsearchTaskRequest {
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model ResumeElasticsearchTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: resume the interrupted change successfully
*   false: resume the interrupted change successfully failed', example='true'),
}

model ResumeElasticsearchTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResumeElasticsearchTaskResponseBody(name='body'),
}

/**
 * @param request ResumeElasticsearchTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResumeElasticsearchTaskResponse
 */
async function resumeElasticsearchTaskWithOptions(InstanceId: string, request: ResumeElasticsearchTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeElasticsearchTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumeElasticsearchTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ResumeElasticsearchTaskRequest
 * @return ResumeElasticsearchTaskResponse
 */
async function resumeElasticsearchTask(InstanceId: string, request: ResumeElasticsearchTaskRequest): ResumeElasticsearchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeElasticsearchTaskWithOptions(InstanceId, request, headers, runtime);
}

model ResumeLogstashTaskRequest {
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model ResumeLogstashTaskResponseBody = {
  code?: string(name='Code', description='The error code returned. If the API operation is successfully called, this parameter is not returned.', example='InstanceNotFound'),
  message?: string(name='Message', description='The error message returned. If the API operation is successfully called, this parameter is not returned.', example='The specified cluster does not exist. Check the cluster status and try again.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0FA05123-745C-42FD-A69B-AFF48EF9****'),
  result?: boolean(name='Result', description='Indicates whether the change task is resumed. Valid values:

*   true: The change task is resumed.
*   false: The change task fails to be resumed.', example='true'),
}

model ResumeLogstashTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResumeLogstashTaskResponseBody(name='body'),
}

/**
 * @summary Resumes a change task of a Logstash cluster. After the task is resumed, the Logstash cluster is in the activating state.
 *
 * @param request ResumeLogstashTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResumeLogstashTaskResponse
 */
async function resumeLogstashTaskWithOptions(InstanceId: string, request: ResumeLogstashTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeLogstashTaskResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumeLogstashTask',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/resume`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Resumes a change task of a Logstash cluster. After the task is resumed, the Logstash cluster is in the activating state.
 *
 * @param request ResumeLogstashTaskRequest
 * @return ResumeLogstashTaskResponse
 */
async function resumeLogstashTask(InstanceId: string, request: ResumeLogstashTaskRequest): ResumeLogstashTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeLogstashTaskWithOptions(InstanceId, request, headers, runtime);
}

model RolloverDataStreamRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model RolloverDataStreamResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model RolloverDataStreamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RolloverDataStreamResponseBody(name='body'),
}

/**
 * @summary 滚动数据流，生成新索引
 *
 * @param request RolloverDataStreamRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RolloverDataStreamResponse
 */
async function rolloverDataStreamWithOptions(InstanceId: string, DataStream: string, request: RolloverDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RolloverDataStreamResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RolloverDataStream',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/data-streams/${OpenApiUtil.getEncodeParam(DataStream)}/rollover`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 滚动数据流，生成新索引
 *
 * @param request RolloverDataStreamRequest
 * @return RolloverDataStreamResponse
 */
async function rolloverDataStream(InstanceId: string, DataStream: string, request: RolloverDataStreamRequest): RolloverDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rolloverDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime);
}

model RunPipelinesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model RunPipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result. Valid values:

*   true: successful
*   false: failed', example='true'),
}

model RunPipelinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunPipelinesResponseBody(name='body'),
}

/**
 * @summary Runs pipelines in a Logstash cluster.
 *
 * @param request RunPipelinesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RunPipelinesResponse
 */
async function runPipelinesWithOptions(InstanceId: string, request: RunPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RunPipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'RunPipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines/action/run`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Runs pipelines in a Logstash cluster.
 *
 * @param request RunPipelinesRequest
 * @return RunPipelinesResponse
 */
async function runPipelines(InstanceId: string, request: RunPipelinesRequest): RunPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runPipelinesWithOptions(InstanceId, request, headers, runtime);
}

model ShrinkNodeRequest {
  body?: [ 
    {
      host?: string(name='host', example='192.168.xx.xx'),
      hostName?: string(name='hostName', example='es-cn-pl32xxxxxxx-data-f-1'),
      nodeType?: string(name='nodeType', example='WORKER'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  count?: int32(name='count', example='2'),
  ignoreStatus?: boolean(name='ignoreStatus', example='false'),
  nodeType?: string(name='nodeType', description='This parameter is required.', example='WORKER'),
}

model ShrinkNodeResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model ShrinkNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ShrinkNodeResponseBody(name='body'),
}

/**
 * @summary ES集群缩节点
 *
 * @param request ShrinkNodeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ShrinkNodeResponse
 */
async function shrinkNodeWithOptions(InstanceId: string, request: ShrinkNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ShrinkNodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query['ignoreStatus'] = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ShrinkNode',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/shrink`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ES集群缩节点
 *
 * @param request ShrinkNodeRequest
 * @return ShrinkNodeResponse
 */
async function shrinkNode(InstanceId: string, request: ShrinkNodeRequest): ShrinkNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return shrinkNodeWithOptions(InstanceId, request, headers, runtime);
}

model StartApmResponseBody = {
  requestId?: string(name='RequestId', example='526F30AB-4A43-55BA-910F-ACD275FD5F14'),
  result?: boolean(name='Result', example='true'),
}

model StartApmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartApmResponseBody(name='body'),
}

/**
 * @summary StartApm
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartApmResponse
 */
async function startApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartApmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}/actions/start`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary StartApm
 *
 * @return StartApmResponse
 */
async function startApm(instanceId: string): StartApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startApmWithOptions(instanceId, headers, runtime);
}

model StartCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model StartCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result.', example='true'),
}

model StartCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartCollectorResponseBody(name='body'),
}

/**
 * @summary Starts a collector to collect data.
 *
 * @param request StartCollectorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartCollectorResponse
 */
async function startCollectorWithOptions(ResId: string, request: StartCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/start`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Starts a collector to collect data.
 *
 * @param request StartCollectorRequest
 * @return StartCollectorResponse
 */
async function startCollector(ResId: string, request: StartCollectorRequest): StartCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startCollectorWithOptions(ResId, request, headers, runtime);
}

model StopApmResponseBody = {
  requestId?: string(name='RequestId', example='FEC32FE6-4697-5110-9668-C6016EAEB5DE'),
  result?: boolean(name='Result', example='true'),
}

model StopApmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopApmResponseBody(name='body'),
}

/**
 * @summary StopApm
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopApmResponse
 */
async function stopApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopApmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}/actions/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary StopApm
 *
 * @return StopApmResponse
 */
async function stopApm(instanceId: string): StopApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopApmWithOptions(instanceId, headers, runtime);
}

model StopCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model StopCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result.', example='true'),
}

model StopCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopCollectorResponseBody(name='body'),
}

/**
 * @summary Stops a shipper.
 *
 * @param request StopCollectorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopCollectorResponse
 */
async function stopCollectorWithOptions(ResId: string, request: StopCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops a shipper.
 *
 * @param request StopCollectorRequest
 * @return StopCollectorResponse
 */
async function stopCollector(ResId: string, request: StopCollectorRequest): StopCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopCollectorWithOptions(ResId, request, headers, runtime);
}

model StopPipelinesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model StopPipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='The returned result. Valid values:

*   true: The pipelines are stopped.
*   false: The pipelines fail to be stopped.', example='true'),
}

model StopPipelinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopPipelinesResponseBody(name='body'),
}

/**
 * @summary Stops pipelines in a Logstash cluster.
 *
 * @param request StopPipelinesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopPipelinesResponse
 */
async function stopPipelinesWithOptions(InstanceId: string, request: StopPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopPipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'StopPipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines/action/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops pipelines in a Logstash cluster.
 *
 * @param request StopPipelinesRequest
 * @return StopPipelinesResponse
 */
async function stopPipelines(InstanceId: string, request: StopPipelinesRequest): StopPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopPipelinesWithOptions(InstanceId, request, headers, runtime);
}

model TagResourcesRequest {
  resourceIds?: [ string ](name='ResourceIds', description='A tag.

This parameter is required.'),
  resourceType?: string(name='ResourceType', description='The request ID.

This parameter is required.', example='INSTANCE'),
  tags?: [ 
    {
      key?: string(name='key', description='The returned object.

This parameter is required.', example='env'),
      value?: string(name='value', description='Indicates whether tags are added to the clusters. Valid values:

*   true
*   false

This parameter is required.', example='IT'),
    }
  ](name='Tags', description='The value of the tag.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', example='3D8795D9-8FF5-46B2-86E6-E3B407*******'),
  result?: boolean(name='Result', example='true'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary The information about the clusters and tags.
 *
 * @param request TagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceIds)) {
    body['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The information about the clusters and tags.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

model TransferNodeRequest {
  body?: [ 
    {
      host?: string(name='host', example='192.168.xx.xx'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  nodeType?: string(name='nodeType', description='This parameter is required.', example='WORKER'),
}

model TransferNodeResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model TransferNodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TransferNodeResponseBody(name='body'),
}

/**
 * @summary 缩节点，数据迁移
 *
 * @param request TransferNodeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TransferNodeResponse
 */
async function transferNodeWithOptions(InstanceId: string, request: TransferNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TransferNodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TransferNode',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/transfer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 缩节点，数据迁移
 *
 * @param request TransferNodeRequest
 * @return TransferNodeResponse
 */
async function transferNode(InstanceId: string, request: TransferNodeRequest): TransferNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return transferNodeWithOptions(InstanceId, request, headers, runtime);
}

model TriggerNetworkRequest {
  actionType?: string(name='actionType', description='This parameter is required.', example='OPEN'),
  networkType?: string(name='networkType', description='This parameter is required.', example='PUBLIC'),
  nodeType?: string(name='nodeType', description='This parameter is required.', example='KIBANA'),
  clientToken?: string(name='clientToken', example='407d02b74c49beb5bfdac7ec8bde2488'),
}

model TriggerNetworkResponseBody = {
  requestId?: string(name='RequestId', example='5A5D8E74-565C-43DC-B031-29289FA****'),
  result?: boolean(name='Result', example='true'),
}

model TriggerNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TriggerNetworkResponseBody(name='body'),
}

/**
 * @summary 开关ES集群及Kibana节点公私网访问
 *
 * @param request TriggerNetworkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TriggerNetworkResponse
 */
async function triggerNetworkWithOptions(InstanceId: string, request: TriggerNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TriggerNetworkResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.actionType)) {
    body['actionType'] = request.actionType;
  }
  if (!Util.isUnset(request.networkType)) {
    body['networkType'] = request.networkType;
  }
  if (!Util.isUnset(request.nodeType)) {
    body['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TriggerNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/network-trigger`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 开关ES集群及Kibana节点公私网访问
 *
 * @param request TriggerNetworkRequest
 * @return TriggerNetworkResponse
 */
async function triggerNetwork(InstanceId: string, request: TriggerNetworkRequest): TriggerNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return triggerNetworkWithOptions(InstanceId, request, headers, runtime);
}

model UninstallKibanaPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UninstallKibanaPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ string ](name='Result', description='The returned result shows a list of uninstalled plug-ins.'),
}

model UninstallKibanaPluginResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UninstallKibanaPluginResponseBody(name='body'),
}

/**
 * @summary Call the UninstallKibanaPlugin to uninstall the Kibana plug-in.
 *
 * @param request UninstallKibanaPluginRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallKibanaPluginResponse
 */
async function uninstallKibanaPluginWithOptions(InstanceId: string, request: UninstallKibanaPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallKibanaPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UninstallKibanaPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-plugins/actions/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call the UninstallKibanaPlugin to uninstall the Kibana plug-in.
 *
 * @param request UninstallKibanaPluginRequest
 * @return UninstallKibanaPluginResponse
 */
async function uninstallKibanaPlugin(InstanceId: string, request: UninstallKibanaPluginRequest): UninstallKibanaPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallKibanaPluginWithOptions(InstanceId, request, headers, runtime);
}

model UninstallLogstashPluginRequest {
  body?: [ string ](name='body', example='["logstash-input-datahub", "logstash-input-maxcompute" ]'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UninstallLogstashPluginResponseBody = {
  headers?: map[string]any(name='Headers'),
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ string ](name='Result'),
}

model UninstallLogstashPluginResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UninstallLogstashPluginResponseBody(name='body'),
}

/**
 * @summary 卸载Logstash实例已安装的插件
 *
 * @param request UninstallLogstashPluginRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallLogstashPluginResponse
 */
async function uninstallLogstashPluginWithOptions(InstanceId: string, request: UninstallLogstashPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallLogstashPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UninstallLogstashPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/actions/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 卸载Logstash实例已安装的插件
 *
 * @param request UninstallLogstashPluginRequest
 * @return UninstallLogstashPluginResponse
 */
async function uninstallLogstashPlugin(InstanceId: string, request: UninstallLogstashPluginRequest): UninstallLogstashPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallLogstashPluginWithOptions(InstanceId, request, headers, runtime);
}

model UninstallPluginRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  force?: boolean(name='force'),
}

model UninstallPluginResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: [ string ](name='Result', description='The list of plug-ins to be unloaded. If the unloading fails, an exception is returned.'),
}

model UninstallPluginResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UninstallPluginResponseBody(name='body'),
}

/**
 * @summary Call UninstallPlugin to uninstall the preset plug-in.
 *
 * @param request UninstallPluginRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallPluginResponse
 */
async function uninstallPluginWithOptions(InstanceId: string, request: UninstallPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallPluginResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UninstallPlugin',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/plugins/actions/uninstall`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call UninstallPlugin to uninstall the preset plug-in.
 *
 * @param request UninstallPluginRequest
 * @return UninstallPluginResponse
 */
async function uninstallPlugin(InstanceId: string, request: UninstallPluginRequest): UninstallPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallPluginWithOptions(InstanceId, request, headers, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to delete all parts. Default value: **false** . This parameter is valid only when **TagKeys** is not specified.', example='false'),
  resourceIds?: string(name='ResourceIds', description='The resource list that you want to delete.', example='["es-cn-09k1rocex0006****","es-cn-oew1rgiev0009****"]'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Fixed to **INSTANCE** .', example='INSTANCE'),
  tagKeys?: string(name='TagKeys', description='The list of tags that you want to delete. The list can contain up to 20 subitems.', example='["tagKey1","tagKey2"]'),
  body?: string(name='body'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6D******'),
  result?: boolean(name='Result', description='Return results:

*   true: deleted
*   false: Failed', example='true'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary 删除ES集群实例的用户可见标签
 *
 * @description When you call this operation, take note of the following items:
 * *   You can only delete user tags.
 * > User labels are manually added to instances by users. A system Tag is a tag that Alibaba Cloud services add to instances. System labels are divided into visible labels and invisible labels.
 * *   If you delete a resource tag relationship that is not associated with any resources, you must delete the tags.
 *
 * @param request UntagResourcesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['TagKeys'] = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除ES集群实例的用户可见标签
 *
 * @description When you call this operation, take note of the following items:
 * *   You can only delete user tags.
 * > User labels are manually added to instances by users. A system Tag is a tag that Alibaba Cloud services add to instances. System labels are divided into visible labels and invisible labels.
 * *   If you delete a resource tag relationship that is not associated with any resources, you must delete the tags.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

model UpdateAdminPasswordRequest {
  esAdminPassword?: string(name='esAdminPassword', example='es_password'),
  clientToken?: string(name='clientToken', description='Indicates whether the password was updated. Valid values:

*   true: The call was successful.
*   false: The call failed.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateAdminPasswordResponseBody = {
  requestId?: string(name='RequestId', example='0FA05123-745C-42FD-A69B-AFF48EF9****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateAdminPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAdminPasswordResponseBody(name='body'),
}

/**
 * @summary 修改ES集群密码
 *
 * @description 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
 *
 * @param request UpdateAdminPasswordRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAdminPasswordResponse
 */
async function updateAdminPasswordWithOptions(InstanceId: string, request: UpdateAdminPasswordRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAdminPasswordResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.esAdminPassword)) {
    body['esAdminPassword'] = request.esAdminPassword;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAdminPassword',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/admin-pwd`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改ES集群密码
 *
 * @description 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
 *
 * @param request UpdateAdminPasswordRequest
 * @return UpdateAdminPasswordResponse
 */
async function updateAdminPassword(InstanceId: string, request: UpdateAdminPasswordRequest): UpdateAdminPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAdminPasswordWithOptions(InstanceId, request, headers, runtime);
}

model UpdateAdvancedSettingRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateAdvancedSettingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: boolean(name='Result', description='Return results:

*   true: garbage collector configuration changed successfully
*   false: garbage collector configuration changed successfully failed', example='true'),
}

model UpdateAdvancedSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAdvancedSettingResponseBody(name='body'),
}

/**
 * @summary Call UpdateAdvancedSetting to change the garbage collector configuration for the specified instance.
 *
 * @param request UpdateAdvancedSettingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAdvancedSettingResponse
 */
async function updateAdvancedSettingWithOptions(InstanceId: string, request: UpdateAdvancedSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAdvancedSettingResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateAdvancedSetting',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-advanced-setting`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call UpdateAdvancedSetting to change the garbage collector configuration for the specified instance.
 *
 * @param request UpdateAdvancedSettingRequest
 * @return UpdateAdvancedSettingResponse
 */
async function updateAdvancedSetting(InstanceId: string, request: UpdateAdvancedSettingRequest): UpdateAdvancedSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAdvancedSettingWithOptions(InstanceId, request, headers, runtime);
}

model UpdateAliwsDictRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateAliwsDictResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='6226'),
      name?: string(name='name', description='The name of the uploaded dictionary file.', example='aliws_ext_dict.txt'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='OSS'),
      type?: string(name='type', description='The dictionary type. The value is fixed as ALI_WS.', example='ALI_WS'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateAliwsDictResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAliwsDictResponseBody(name='body'),
}

/**
 * @summary Updates the dictionary file of the analysis-aliws plug-in.
 *
 * @description Before you call this operation, take note of the following items:
 * *   Elasticsearch V5.X clusters do not support the analysis-aliws plug-in.
 * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
 * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
 *
 * @param request UpdateAliwsDictRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAliwsDictResponse
 */
async function updateAliwsDictWithOptions(InstanceId: string, request: UpdateAliwsDictRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAliwsDictResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateAliwsDict',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/aliws-dict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the dictionary file of the analysis-aliws plug-in.
 *
 * @description Before you call this operation, take note of the following items:
 * *   Elasticsearch V5.X clusters do not support the analysis-aliws plug-in.
 * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
 * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
 *
 * @param request UpdateAliwsDictRequest
 * @return UpdateAliwsDictResponse
 */
async function updateAliwsDict(InstanceId: string, request: UpdateAliwsDictRequest): UpdateAliwsDictResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAliwsDictWithOptions(InstanceId, request, headers, runtime);
}

model UpdateApmRequest {
  description?: string(name='description', example='APMtest'),
  outputES?: string(name='outputES', example='es-cn-i7m2fsfhc001x****'),
  outputESPassword?: string(name='outputESPassword', example='ESPassword****'),
  outputESUserName?: string(name='outputESUserName', example='elastic'),
  token?: string(name='token', example='AMPPassword****'),
}

model UpdateApmResponseBody = {
  requestId?: string(name='RequestId', example='18061926-CC50-5F9B-9600-034C29F1D5B0'),
  result?: boolean(name='Result', example='true'),
}

model UpdateApmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateApmResponseBody(name='body'),
}

/**
 * @summary 修改APM实规格配置
 *
 * @param request UpdateApmRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateApmResponse
 */
async function updateApmWithOptions(instanceId: string, request: UpdateApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApmResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.outputES)) {
    body['outputES'] = request.outputES;
  }
  if (!Util.isUnset(request.outputESPassword)) {
    body['outputESPassword'] = request.outputESPassword;
  }
  if (!Util.isUnset(request.outputESUserName)) {
    body['outputESUserName'] = request.outputESUserName;
  }
  if (!Util.isUnset(request.token)) {
    body['token'] = request.token;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApm',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/apm/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改APM实规格配置
 *
 * @param request UpdateApmRequest
 * @return UpdateApmResponse
 */
async function updateApm(instanceId: string, request: UpdateApmRequest): UpdateApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApmWithOptions(instanceId, request, headers, runtime);
}

model UpdateBlackIpsRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateBlackIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
  }(name='Result'),
}

model UpdateBlackIpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateBlackIpsResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI UpdateBlackIps is deprecated
 *
 * @summary 修改ES实例访问黑名单，已废弃
 *
 * @param request UpdateBlackIpsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateBlackIpsResponse
 */
// Deprecated
async function updateBlackIpsWithOptions(InstanceId: string, request: UpdateBlackIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateBlackIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBlackIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/black-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI UpdateBlackIps is deprecated
 *
 * @summary 修改ES实例访问黑名单，已废弃
 *
 * @param request UpdateBlackIpsRequest
 * @return UpdateBlackIpsResponse
 */
// Deprecated
async function updateBlackIps(InstanceId: string, request: UpdateBlackIpsRequest): UpdateBlackIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateBlackIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateCollectorRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateCollectorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content', description='The content of the configuration file.', example='filebeat.inputs:xxx'),
        fileName?: string(name='fileName', description='The name of the configuration file.', example='filebeat.yml'),
      }
    ](name='configs', description='The information about the configuration file for the shipper.'),
    dryRun?: boolean(name='dryRun', description='Indicates whether the shipper is checked and updated. Valid values:

*   true: The shipper is only checked.
*   false: The shipper is checked and updated.', example='false'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType', description='The type of the configuration items. Valid values:

*   collectorTargetInstance: indicates the information about the output of the shipper.
*   collectorDeployMachine: indicates the information about the machine on which the shipper is installed.
*   collectorElasticsearchForKibana: indicates the information about the Elasticsearch cluster for which Kibana Dashboard is enabled.', example='collectorDeployMachine'),
        enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether Kibana Monitoring is enabled. This parameter is returned only when **configType** is set to **collectorTargetInstance** and **instanceType** is set to **elasticsearch**. Valid values: true and false.', example='true'),
        groupId?: string(name='groupId', description='The machine group ID. This parameter is returned only when **configType** is set to **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
        host?: string(name='host', description='The address that is used to access Kibana over an internal network after you enable Kibana Dashboard. This parameter is returned only when **configType** is set to **collectorElasticsearchForKibana**.', example='es-cn-n6w1o1x0w001c****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId', description='The ID of the object that is associated with the shipper. If **configType** is set to **collectorTargetInstance**, the value of this parameter is the ID of the output of the shipper. If **configType** is set to **collectorDeployMachines** and **type** is set to **ACKCluster**, the value of this parameter is the ID of an ACK cluster.', example='es-cn-nif1z89fz003i****'),
        instanceType?: string(name='instanceType', description='The type of the output of the shipper. Valid values: elasticsearch and logstash. This parameter is returned only when **configType** is set to **collectorTargetInstance**.', example='elasticsearch'),
        kibanaHost?: string(name='kibanaHost', description='The address that is used to access Kibana over the Internet after you enable Kibana Dashboard. This parameter is returned only when **configType** is set to **collectorElasticsearchForKibana**.', example='https://es-cn-nif1z89fz003i****.kibana.elasticsearch.aliyuncs.com:5601'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus', description='The installation status of the shipper on an ECS instance. Valid values:

*   heartOk
*   heartLost
*   uninstalled
*   failed', example='heartOk'),
            instanceId?: string(name='instanceId', description='The ID of the ECS instance on which the shipper is installed.', example='i-bp13y63575oypr9d****'),
          }
        ](name='machines', description='This parameter is returned only when configType is set to collectorDeployMachine.

This parameter indicates the information about the ECS instances or ACK clusters on which the shipper is installed.'),
        protocol?: string(name='protocol', description='The transfer protocol that is used. It is the same as the protocol over which you can access the output of the shipper. Valid values: HTTP and HTTPS. This parameter is returned only when **configType** is set to **collectorTargetInstance**.', example='HTTP'),
        successPodsCount?: string(name='successPodsCount', description='The number of pods from which logs are successfully collected in the ACK cluster. This parameter is returned only when **configType** is set to **collectorDeployMachines** and **type** is set to **ACKCluster**.', example='8'),
        totalPodsCount?: string(name='totalPodsCount', description='The number of pods from which logs needed to be collected in the ACK cluster. This parameter is returned only when **configType** is set to **collectorDeployMachines** and **type** is set to **ACKCluster**.', example='10'),
        type?: string(name='type', description='The type of the machine on which the shipper is installed. This parameter is returned only when **configType** is set to **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
        userName?: string(name='userName', description='The username that is used to access the output of the shipper. Default value: elastic. This parameter is returned only when **configType** is set to **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
      }
    ](name='extendConfigs', description='The extended parameters that are configured for the shipper.'),
    gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-06-20T07:26:47.000+0000'),
    name?: string(name='name', description='The name of the shipper.', example='ct-test'),
    ownerId?: string(name='ownerId', description='The account ID.', example='16852099488*****'),
    resId?: string(name='resId', description='The shipper ID.', example='ct-cn-0v3xj86085dvq****'),
    resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and auditBeat.', example='fileBeat'),
    resVersion?: string(name='resVersion', description='The version of the shipper.', example='6.8.5_with_community'),
    status?: string(name='status', description='The status of the shipper. Valid values:

*   activing: The shipper is being initialized.
*   active: The shipper is in effect.', example='active'),
    vpcId?: string(name='vpcId', description='The ID of the VPC in which the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
  }(name='Result', description='The returned result.'),
}

model UpdateCollectorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCollectorResponseBody(name='body'),
}

/**
 * @summary Updates the configurations of a shipper.
 *
 * @param request UpdateCollectorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCollectorResponse
 */
async function updateCollectorWithOptions(ResId: string, request: UpdateCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateCollector',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the configurations of a shipper.
 *
 * @param request UpdateCollectorRequest
 * @return UpdateCollectorResponse
 */
async function updateCollector(ResId: string, request: UpdateCollectorRequest): UpdateCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCollectorWithOptions(ResId, request, headers, runtime);
}

model UpdateCollectorNameRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateCollectorNameResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content', description='The content of the file.', example='- key: log\\\\n title: Log file content\\\\n description: >\\\\n Contains log file lines.\\\\n ....'),
        fileName?: string(name='fileName', description='The name of the file.', example='fields.yml'),
      }
    ](name='configs', description='The information about the configuration file of the shipper.'),
    dryRun?: boolean(name='dryRun', description='Indicates whether a dry run is performed. Valid values:

*   true
*   false', example='false'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType', description='The configuration type. Valid values:

*   collectorTargetInstance
*   collectorDeployMachine
*   collectorElasticsearchForKibana', example='collectorDeployMachine'),
        enableMonitoring?: boolean(name='enableMonitoring', description='Indicates whether monitoring is enabled. This parameter is returned if the value of **configType** is **collectorTargetInstance** and the value of **instanceType** is **elasticsearch**. Valid values:

*   true
*   false', example='true'),
        groupId?: string(name='groupId', description='The ID of the machine group. This parameter is returned if the value of **configType** is **collectorDeployMachine**.', example='default_ct-cn-5i2l75bz4776****'),
        host?: string(name='host', description='The private endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='es-cn-4591jumei000u****-kibana.internal.elasticsearch.aliyuncs.com:5601'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId', description='The ID of the resource that is associated with the shipper. If the value of **configType** is **collectorTargetInstance**, the value of this parameter is the ID of the resource specified in the output configuration part of the shipper. If the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**, the value of this parameter is the ID of the ACK cluster.', example='es-cn-n6w1o1****'),
        instanceType?: string(name='instanceType', description='The type of the cluster specified in the output configuration part of the shipper. Valid values: elasticsearch and logstash. This parameter is returned if the value of **configType** is **collectorTargetInstance**.', example='elasticsearch'),
        kibanaHost?: string(name='kibanaHost', description='The public endpoint of Kibana after you enable the Kibana dashboard. This parameter is returned if the value of **configType** is **collectorElasticsearchForKibana**.', example='https://es-cn-4591jumei000u****.kibana.elasticsearch.aliyuncs.com:5601'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus', description='The status of the shipper on the ECS instance. Valid values: **heartOk**, **heartLost**, **uninstalled**, and **failed**.', example='heartOk'),
            instanceId?: string(name='instanceId', description='The IDs of the ECS instances.', example='c1b9fde5172b84f82b9928e825a7b8988'),
          }
        ](name='machines', description='The information about the ECS instances on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ECSInstanceId**.'),
        protocol?: string(name='protocol', description='The transmission protocol. Valid values: **HTTP** and **HTTPS**.', example='HTTP'),
        successPodsCount?: string(name='successPodsCount', description='The number of pods from which data is successfully collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='8'),
        totalPodsCount?: string(name='totalPodsCount', description='The total number of pods from which data is collected in the ACK cluster. This parameter is returned if the value of **configType** is **collectorDeployMachine** and the value of **type** is **ACKCluster**.', example='10'),
        type?: string(name='type', description='The type of the machine on which the shipper is deployed. This parameter is returned if the value of **configType** is **collectorDeployMachine**. Valid values:

*   ECSInstanceId
*   ACKCluster', example='ECSInstanceId'),
        userName?: string(name='userName', description='The username that is used to access the resource specified in the output configuration part of the shipper. The default value is elastic. This parameter is returned if the value of **configType** is **collectorTargetInstance** or **collectorElasticsearchForKibana**.', example='elastic'),
      }
    ](name='extendConfigs', description='The extended configurations of the shipper.'),
    gmtCreatedTime?: string(name='gmtCreatedTime', description='The time when the shipper was created.', example='2020-06-20T07:26:47.000+0000'),
    gmtUpdateTime?: string(name='gmtUpdateTime', description='The time when the shipper was updated.', example='2020-06-20T07:26:47.000+0000'),
    name?: string(name='name', description='The name of the shipper.', example='ct-test'),
    ownerId?: string(name='ownerId', description='The account ID.', example='16852099488*****'),
    resId?: string(name='resId', description='The ID of the shipper.', example='ct-cn-77uqof2s7rg5c****'),
    resType?: string(name='resType', description='The type of the shipper. Valid values: fileBeat, metricBeat, heartBeat, and audiBeat.', example='fileBeat'),
    resVersion?: string(name='resVersion', description='The version of the shipper. The version of a shipper depends on the type of the machine on which the shipper is deployed.

*   Elastic Compute Service (ECS) instance: 6.8.5_with_community
*   Container Service for Kubernetes (ACK) cluster: 6.8.13_with_community', example='6.8.5_with_community'),
    status?: string(name='status', description='The status of the shipper. Valid values: activating and active.', example='active'),
    vpcId?: string(name='vpcId', description='The ID of the virtual private cloud (VPC) where the shipper resides.', example='vpc-bp16k1dvzxtma*****'),
  }(name='Result', description='The returned result.'),
}

model UpdateCollectorNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCollectorNameResponseBody(name='body'),
}

/**
 * @summary Changes the name of a shipper.
 *
 * @param request UpdateCollectorNameRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCollectorNameResponse
 */
async function updateCollectorNameWithOptions(ResId: string, request: UpdateCollectorNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCollectorNameResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateCollectorName',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/collectors/${OpenApiUtil.getEncodeParam(ResId)}/actions/rename`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the name of a shipper.
 *
 * @param request UpdateCollectorNameRequest
 * @return UpdateCollectorNameResponse
 */
async function updateCollectorName(ResId: string, request: UpdateCollectorNameRequest): UpdateCollectorNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCollectorNameWithOptions(ResId, request, headers, runtime);
}

model UpdateComponentIndexRequest {
  meta?: map[string]any(name='_meta', example='{ "description": "set number of shards to one" }'),
  template?: {
    aliases?: map[string]any(name='aliases', example='{}'),
    mappings?: map[string]any(name='mappings', example='{ "properties": { "@timestamp": { "type": "date" } } }'),
    settings?: map[string]any(name='settings', example='{ "index.number_of_replicas": 0 }'),
  }(name='template'),
}

model UpdateComponentIndexResponseBody = {
  requestId?: string(name='requestId', example='F99407AB-2FA9-489E-A259-40CF6DCC47D9'),
}

model UpdateComponentIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateComponentIndexResponseBody(name='body'),
}

/**
 * @summary 修改ES集群动态索引
 *
 * @param request UpdateComponentIndexRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateComponentIndexResponse
 */
async function updateComponentIndexWithOptions(InstanceId: string, name: string, request: UpdateComponentIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateComponentIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.meta)) {
    body['_meta'] = request.meta;
  }
  if (!Util.isUnset(request.template)) {
    body['template'] = request.template;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateComponentIndex',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/component-index/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改ES集群动态索引
 *
 * @param request UpdateComponentIndexRequest
 * @return UpdateComponentIndexResponse
 */
async function updateComponentIndex(InstanceId: string, name: string, request: UpdateComponentIndexRequest): UpdateComponentIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateComponentIndexWithOptions(InstanceId, name, request, headers, runtime);
}

model UpdateDescriptionRequest {
  description?: string(name='description', example='aliyunes_name_test'),
  clientToken?: string(name='clientToken', description='The new name of the instance.', example='5A2CFF0E-5718-45B5-9D4D-70B350****'),
}

model UpdateDescriptionResponseBody = {
  requestId?: string(name='RequestId', example='FDF34727-1664-44C1-A8DA-3EB72D60****'),
  result?: {
    description?: string(name='description', example='aliyunes_test_name'),
  }(name='Result'),
}

model UpdateDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDescriptionResponseBody(name='body'),
}

/**
 * @summary 修改elasticsearch实例名称名称
 *
 * @param request UpdateDescriptionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDescriptionResponse
 */
async function updateDescriptionWithOptions(InstanceId: string, request: UpdateDescriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDescriptionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDescription',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/description`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改elasticsearch实例名称名称
 *
 * @param request UpdateDescriptionRequest
 * @return UpdateDescriptionResponse
 */
async function updateDescription(InstanceId: string, request: UpdateDescriptionRequest): UpdateDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDescriptionWithOptions(InstanceId, request, headers, runtime);
}

model UpdateDiagnosisSettingsRequest {
  clientToken?: string(name='ClientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
  lang?: string(name='lang', description='The language of the response. Default value: en.', example='en'),
}

model UpdateDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Return results:

*   true: update successfully
*   false: update failed', example='true'),
}

model UpdateDiagnosisSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDiagnosisSettingsResponseBody(name='body'),
}

/**
 * @summary Call UpdateDiagnosisSettings to update the instance of intelligent operation&maintenance (O&M) scene settings.
 *
 * @param request UpdateDiagnosisSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDiagnosisSettingsResponse
 */
async function updateDiagnosisSettingsWithOptions(InstanceId: string, request: UpdateDiagnosisSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDiagnosisSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query['lang'] = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateDiagnosisSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/diagnosis/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/settings`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call UpdateDiagnosisSettings to update the instance of intelligent operation&maintenance (O&M) scene settings.
 *
 * @param request UpdateDiagnosisSettingsRequest
 * @return UpdateDiagnosisSettingsResponse
 */
async function updateDiagnosisSettings(InstanceId: string, request: UpdateDiagnosisSettingsRequest): UpdateDiagnosisSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateDictRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateDictResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='2782602'),
      name?: string(name='name', description='The name of the dictionary file.', example='SYSTEM_MAIN.dic'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='ORIGIN'),
      type?: string(name='type', description='The dictionary type. Valid values:

*   MAIN: IK main dicrionary
*   STOP: IK stopword list', example='MAIN'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateDictResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDictResponseBody(name='body'),
}

/**
 * @summary Updates a dictionary of an Elasticsearch cluster.
 *
 * @description Before you call this operation, take note of the following items:
 * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
 * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
 *
 * @param request UpdateDictRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDictResponse
 */
async function updateDictWithOptions(InstanceId: string, request: UpdateDictRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDictResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateDict',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a dictionary of an Elasticsearch cluster.
 *
 * @description Before you call this operation, take note of the following items:
 * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
 * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
 *
 * @param request UpdateDictRequest
 * @return UpdateDictResponse
 */
async function updateDict(InstanceId: string, request: UpdateDictRequest): UpdateDictResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDictWithOptions(InstanceId, request, headers, runtime);
}

model UpdateDynamicSettingsRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  body?: string(name='body'),
  mode?: string(name='mode'),
}

model UpdateDynamicSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateDynamicSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDynamicSettingsResponseBody(name='body'),
}

/**
 * @summary 修改集群动态配置
 *
 * @param request UpdateDynamicSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDynamicSettingsResponse
 */
async function updateDynamicSettingsWithOptions(InstanceId: string, request: UpdateDynamicSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDynamicSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.mode)) {
    query['mode'] = request.mode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateDynamicSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/dynamic-settings`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改集群动态配置
 *
 * @param request UpdateDynamicSettingsRequest
 * @return UpdateDynamicSettingsResponse
 */
async function updateDynamicSettings(InstanceId: string, request: UpdateDynamicSettingsRequest): UpdateDynamicSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDynamicSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateExtendConfigRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateExtendConfigResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', example='true'),
}

model UpdateExtendConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateExtendConfigResponseBody(name='body'),
}

/**
 * @param request UpdateExtendConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateExtendConfigResponse
 */
async function updateExtendConfigWithOptions(InstanceId: string, request: UpdateExtendConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExtendConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateExtendConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/extend-configs/actions/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateExtendConfigRequest
 * @return UpdateExtendConfigResponse
 */
async function updateExtendConfig(InstanceId: string, request: UpdateExtendConfigRequest): UpdateExtendConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExtendConfigWithOptions(InstanceId, request, headers, runtime);
}

model UpdateExtendfilesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateExtendfilesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the driver file. Unit: byte.', example='1853083'),
      name?: string(name='name', description='The name of the driver file.', example='mysql-connector-java-6.0.2.jar'),
      sourceType?: string(name='sourceType', description='The source of the driver file. This parameter is fixed as ORIGIN, which indicates that the driver file is retained.', example='ORIGIN'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateExtendfilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateExtendfilesResponseBody(name='body'),
}

/**
 * @summary Updates the driver files of a Logstash cluster.
 *
 * @description When you call this operation, take note of the following items: You can call this operation only to delete the driver files that are uploaded to a Logstash cluster in the Alibaba Cloud Management Console. You can add or modify driver files only in the Alibaba Cloud Management Console.
 *
 * @param request UpdateExtendfilesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateExtendfilesResponse
 */
async function updateExtendfilesWithOptions(InstanceId: string, request: UpdateExtendfilesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExtendfilesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateExtendfiles',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/extendfiles`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the driver files of a Logstash cluster.
 *
 * @description When you call this operation, take note of the following items: You can call this operation only to delete the driver files that are uploaded to a Logstash cluster in the Alibaba Cloud Management Console. You can add or modify driver files only in the Alibaba Cloud Management Console.
 *
 * @param request UpdateExtendfilesRequest
 * @return UpdateExtendfilesResponse
 */
async function updateExtendfiles(InstanceId: string, request: UpdateExtendfilesRequest): UpdateExtendfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExtendfilesWithOptions(InstanceId, request, headers, runtime);
}

model UpdateHotIkDictsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateHotIkDictsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='6'),
      name?: string(name='name', description='The name of the dictionary file.', example='deploy_0.dic'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='OSS'),
      type?: string(name='type', description='The type of the dictionaries. Valid values:

*   MAIN: IK main dictionary
*   STOP: IK stopword list', example='MAIN'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateHotIkDictsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateHotIkDictsResponseBody(name='body'),
}

/**
 * @summary Performs a rolling update for the IK dictionaries of an Elasticsearch cluster.
 *
 * @description Before you call this operation, take note of the following items:
 * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
 * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
 *
 * @param request UpdateHotIkDictsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateHotIkDictsResponse
 */
async function updateHotIkDictsWithOptions(InstanceId: string, request: UpdateHotIkDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateHotIkDictsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateHotIkDicts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ik-hot-dict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Performs a rolling update for the IK dictionaries of an Elasticsearch cluster.
 *
 * @description Before you call this operation, take note of the following items:
 * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
 * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
 *
 * @param request UpdateHotIkDictsRequest
 * @return UpdateHotIkDictsResponse
 */
async function updateHotIkDicts(InstanceId: string, request: UpdateHotIkDictsRequest): UpdateHotIkDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHotIkDictsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateILMPolicyRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateILMPolicyResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='my-policy'),
}

model UpdateILMPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateILMPolicyResponseBody(name='body'),
}

/**
 * @summary 修改ES集群索引生命周期策略
 *
 * @param request UpdateILMPolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateILMPolicyResponse
 */
async function updateILMPolicyWithOptions(InstanceId: string, PolicyName: string, request: UpdateILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateILMPolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateILMPolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/ilm-policies/${OpenApiUtil.getEncodeParam(PolicyName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改ES集群索引生命周期策略
 *
 * @param request UpdateILMPolicyRequest
 * @return UpdateILMPolicyResponse
 */
async function updateILMPolicy(InstanceId: string, PolicyName: string, request: UpdateILMPolicyRequest): UpdateILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateILMPolicyWithOptions(InstanceId, PolicyName, request, headers, runtime);
}

model UpdateIndexTemplateRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: string(name='Result', example='my-template'),
}

model UpdateIndexTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateIndexTemplateResponseBody(name='body'),
}

/**
 * @summary 修改ES集群索引模版配置
 *
 * @param request UpdateIndexTemplateRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIndexTemplateResponse
 */
async function updateIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, request: UpdateIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIndexTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateIndexTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/index-templates/${OpenApiUtil.getEncodeParam(IndexTemplate)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改ES集群索引模版配置
 *
 * @param request UpdateIndexTemplateRequest
 * @return UpdateIndexTemplateResponse
 */
async function updateIndexTemplate(InstanceId: string, IndexTemplate: string, request: UpdateIndexTemplateRequest): UpdateIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIndexTemplateWithOptions(InstanceId, IndexTemplate, request, headers, runtime);
}

model UpdateInstanceRequest {
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  instanceCategory?: string(name='instanceCategory', example='advanced'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  nodeAmount?: int32(name='nodeAmount', example='3'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  clientToken?: string(name='clientToken', description='The result of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  force?: boolean(name='force', example='false'),
  orderActionType?: string(name='orderActionType', description='The number of data nodes.', example='upgrade'),
}

model UpdateInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='The time when the instance was created.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    createdAt?: string(name='createdAt', description='The private domain name of the instance.', example='2018-07-13T03:58:07.253Z'),
    description?: string(name='description', description='The configuration of data nodes.', example='test'),
    domain?: string(name='domain', description='The ID of the instance.', example='es-cn-abc.elasticsearch.aliyuncs.com'),
    esVersion?: string(name='esVersion', description='The node specifications.', example='5.5.3_with_X-Pack'),
    instanceId?: string(name='instanceId', description='The storage space of the node. Unit: GB.', example='es-cn-abc'),
    kibanaConfiguration?: {
      amount?: int32(name='amount', description='The configuration of dedicated master nodes.', example='1'),
      disk?: int32(name='disk', description='The node specifications.', example='20'),
      diskType?: string(name='diskType', description='The number of nodes.', example='cloud_ssd'),
      spec?: string(name='spec', description='The storage type of the node. This parameter can be ignored.', example='elasticsearch.n4.small'),
    }(name='kibanaConfiguration', description='The size of the node storage space.'),
    masterConfiguration?: {
      amount?: int32(name='amount', example='3'),
      disk?: int32(name='disk', example='20'),
      diskType?: string(name='diskType', example='cloud_ssd'),
      spec?: string(name='spec', description='The storage type of the node. Only cloud_ssd(SSD cloud disk) is supported.', example='elasticsearch.sn2ne.large'),
    }(name='masterConfiguration', description='The storage space of the node. Unit: GB.'),
    nodeAmount?: int32(name='nodeAmount', description='The billing method of the instance. Valid values:

*   prepaid: subscription
*   postpaid: pay-as-you-go', example='2'),
    nodeSpec?: {
      disk?: int32(name='disk', description='The node specifications.', example='40'),
      diskType?: string(name='diskType', description='The number of nodes.', example='cloud_ssd'),
      spec?: string(name='spec', description='The configuration of Kibana nodes.', example='elasticsearch.sn2ne.xlarge'),
    }(name='nodeSpec', description='The storage type of the node. Valid values:

*   cloud_ssd: standard SSD
*   cloud_efficiency: ultra disk'),
    paymentType?: string(name='paymentType', description='The edition of the dedicated KMS instance.', example='postpaid'),
    status?: string(name='status', description='The name of the instance.', example='active'),
  }(name='Result', description='The state of the instance. Valid values:

*   active: normal
*   activating: taking effect
*   inactive: frozen
*   invalid: invalid'),
}

model UpdateInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceResponseBody(name='body'),
}

/**
 * @summary 修改ES集群节点配置
 *
 * @description es-cn-n6w1ptcb30009\\*\\*\\*\\*
 *
 * @param request UpdateInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceResponse
 */
async function updateInstanceWithOptions(InstanceId: string, request: UpdateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }
  if (!Util.isUnset(request.orderActionType)) {
    query['orderActionType'] = request.orderActionType;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.clientNodeConfiguration)) {
    body['clientNodeConfiguration'] = request.clientNodeConfiguration;
  }
  if (!Util.isUnset(request.elasticDataNodeConfiguration)) {
    body['elasticDataNodeConfiguration'] = request.elasticDataNodeConfiguration;
  }
  if (!Util.isUnset(request.instanceCategory)) {
    body['instanceCategory'] = request.instanceCategory;
  }
  if (!Util.isUnset(request.kibanaConfiguration)) {
    body['kibanaConfiguration'] = request.kibanaConfiguration;
  }
  if (!Util.isUnset(request.masterConfiguration)) {
    body['masterConfiguration'] = request.masterConfiguration;
  }
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }
  if (!Util.isUnset(request.warmNodeConfiguration)) {
    body['warmNodeConfiguration'] = request.warmNodeConfiguration;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改ES集群节点配置
 *
 * @description es-cn-n6w1ptcb30009\\*\\*\\*\\*
 *
 * @param request UpdateInstanceRequest
 * @return UpdateInstanceResponse
 */
async function updateInstance(InstanceId: string, request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceWithOptions(InstanceId, request, headers, runtime);
}

model UpdateInstanceChargeTypeRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateInstanceChargeTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: boolean(name='Result', description='Return results:

*   true: conversion successful
*   false: conversion failed', example='true'),
}

model UpdateInstanceChargeTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceChargeTypeResponseBody(name='body'),
}

/**
 * @summary Call UpdateInstanceChargeType to change the billing method of a pay-as-you-go instance to subscription.
 *
 * @param request UpdateInstanceChargeTypeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceChargeTypeResponse
 */
async function updateInstanceChargeTypeWithOptions(InstanceId: string, request: UpdateInstanceChargeTypeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceChargeTypeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceChargeType',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/convert-pay-type`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call UpdateInstanceChargeType to change the billing method of a pay-as-you-go instance to subscription.
 *
 * @param request UpdateInstanceChargeTypeRequest
 * @return UpdateInstanceChargeTypeResponse
 */
async function updateInstanceChargeType(InstanceId: string, request: UpdateInstanceChargeTypeRequest): UpdateInstanceChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceChargeTypeWithOptions(InstanceId, request, headers, runtime);
}

model UpdateInstanceSettingsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateInstanceSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BB1C321A-211C-4FD7-BD8B-7F2FABE2****'),
}

model UpdateInstanceSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceSettingsResponseBody(name='body'),
}

/**
 * @summary Call UpdateInstanceSettings to update the YML configuration of a specified instance.
 *
 * @description When you call this operation, take note of the following items:
 * When the instance is in the activating, invalid, or inactive state, you cannot update the configuration.
 *
 * @param request UpdateInstanceSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceSettingsResponse
 */
async function updateInstanceSettingsWithOptions(InstanceId: string, request: UpdateInstanceSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/instance-settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call UpdateInstanceSettings to update the YML configuration of a specified instance.
 *
 * @description When you call this operation, take note of the following items:
 * When the instance is in the activating, invalid, or inactive state, you cannot update the configuration.
 *
 * @param request UpdateInstanceSettingsRequest
 * @return UpdateInstanceSettingsResponse
 */
async function updateInstanceSettings(InstanceId: string, request: UpdateInstanceSettingsRequest): UpdateInstanceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateKibanaPvlNetworkRequest {
  endpointName?: string(name='endpointName', example='es-cn-27a3mul6l00***-kibana'),
  securityGroups?: [ string ](name='securityGroups'),
  pvlId?: string(name='pvlId', description='This parameter is required.', example='es-cn-27a3mul6l0***-kibana-internal'),
}

model UpdateKibanaPvlNetworkResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateKibanaPvlNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateKibanaPvlNetworkResponseBody(name='body'),
}

/**
 * @summary 更新kibana私网链接
 *
 * @param request UpdateKibanaPvlNetworkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateKibanaPvlNetworkResponse
 */
async function updateKibanaPvlNetworkWithOptions(InstanceId: string, request: UpdateKibanaPvlNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateKibanaPvlNetworkResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pvlId)) {
    query['pvlId'] = request.pvlId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.endpointName)) {
    body['endpointName'] = request.endpointName;
  }
  if (!Util.isUnset(request.securityGroups)) {
    body['securityGroups'] = request.securityGroups;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateKibanaPvlNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-kibana-private`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新kibana私网链接
 *
 * @param request UpdateKibanaPvlNetworkRequest
 * @return UpdateKibanaPvlNetworkResponse
 */
async function updateKibanaPvlNetwork(InstanceId: string, request: UpdateKibanaPvlNetworkRequest): UpdateKibanaPvlNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateKibanaPvlNetworkWithOptions(InstanceId, request, headers, runtime);
}

model UpdateKibanaSettingsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='This parameter is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B350****'),
}

model UpdateKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DC*****'),
  result?: boolean(name='Result', description='Return results:

*   true: The Kibana language modified successfully
*   false: The Kibana language modified failed', example='true'),
}

model UpdateKibanaSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateKibanaSettingsResponseBody(name='body'),
}

/**
 * @summary Call UpdateKibanaSettings to modify the Kibana configuration. Currently, you can only modify the Kibana language configuration.
 *
 * @param request UpdateKibanaSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateKibanaSettingsResponse
 */
async function updateKibanaSettingsWithOptions(InstanceId: string, request: UpdateKibanaSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateKibanaSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateKibanaSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-kibana-settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call UpdateKibanaSettings to modify the Kibana configuration. Currently, you can only modify the Kibana language configuration.
 *
 * @param request UpdateKibanaSettingsRequest
 * @return UpdateKibanaSettingsResponse
 */
async function updateKibanaSettings(InstanceId: string, request: UpdateKibanaSettingsRequest): UpdateKibanaSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateKibanaSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateKibanaWhiteIpsRequest {
  kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist', description='The IP address whitelists. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.

You cannot configure both the kibanaIPWhitelist and whiteIpGroup parameters.'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='The type of the whitelist. Set the value to PUBLIC_KIBANA. This value indicates a public IP address whitelist.', example='test_group_name'),
    ips?: [ string ](name='ips', description='The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
    whiteIpType?: string(name='whiteIpType', description='The IP addresses in the whitelist.', example='PUBLIC_KIBANA'),
  }(name='whiteIpGroup', description='The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  clientToken?: string(name='clientToken', description='The update mode. Valid values:

*   Cover: overwrites the IP addresses in the specified IP address whitelist with the IP addresses specified by using the ips parameter. This is the default value.
*   Append: adds the IP addresses specified by using the ips parameter to the specified IP address whitelist.
*   Delete: deletes the IP addresses specified by using the ips parameter from the specified IP address whitelist. At least one IP address must be retained for the whitelist.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  modifyMode?: string(name='modifyMode', description='The body of the request.', example='Cover'),
}

model UpdateKibanaWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', description='The details of the Elasticsearch cluster.', example='E5EF11F1-DBAE-4020-AC24-DFA6C4345CAE'),
  result?: {
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist', description='The public IP address whitelists for access to the Kibana console of the cluster.'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist', description='The private IP address whitelists for access to the Kibana console of the cluster.'),
    networkConfig?: {
      type?: string(name='type', description='The IP address whitelists.', example='vpc'),
      vpcId?: string(name='vpcId', description='The ID of the vSwitch.', example='vpc-bp1jy348ibzulk6hn****'),
      vsArea?: string(name='vsArea', description='The network type.', example='cn-hangzhou-h'),
      vswitchId?: string(name='vswitchId', description='The region ID.', example='vsw-bp1a0mifpletdd1da****'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName', description='The IP addresses in the whitelist.', example='test_group_name'),
          ips?: [ string ](name='ips', description='The IP addresses in the whitelist.'),
          whiteIpType?: string(name='whiteIpType', example='PUBLIC_KIBANA'),
        }
      ](name='whiteIpGroupList', description='The IP address whitelists.'),
    }(name='networkConfig', description='The ID of the virtual private cloud (VPC).'),
  }(name='Result', description='The private IP address whitelists for access to the Kibana console of the cluster.'),
}

model UpdateKibanaWhiteIpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateKibanaWhiteIpsResponseBody(name='body'),
}

/**
 * @summary Updates an IP address whitelist for access to the Kibana console of a specified Elasticsearch cluster.
 *
 * @description *   Before you call this operation, you must make sure that the cluster is not in the activating, invalid, or inactive state.
 * *   You can update an IP address whitelist by using the following parameters:
 *     *   kibanaIPWhitelist
 *     *   modifyMode and whiteIpGroup
 * *   You cannot specify private IP addresses for public IP address whitelists and cannot specify public IP addresses for private IP address whitelists.
 *
 * @param request UpdateKibanaWhiteIpsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateKibanaWhiteIpsResponse
 */
async function updateKibanaWhiteIpsWithOptions(InstanceId: string, request: UpdateKibanaWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateKibanaWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.kibanaIPWhitelist)) {
    body['kibanaIPWhitelist'] = request.kibanaIPWhitelist;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body['whiteIpGroup'] = request.whiteIpGroup;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateKibanaWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/kibana-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates an IP address whitelist for access to the Kibana console of a specified Elasticsearch cluster.
 *
 * @description *   Before you call this operation, you must make sure that the cluster is not in the activating, invalid, or inactive state.
 * *   You can update an IP address whitelist by using the following parameters:
 *     *   kibanaIPWhitelist
 *     *   modifyMode and whiteIpGroup
 * *   You cannot specify private IP addresses for public IP address whitelists and cannot specify public IP addresses for private IP address whitelists.
 *
 * @param request UpdateKibanaWhiteIpsRequest
 * @return UpdateKibanaWhiteIpsResponse
 */
async function updateKibanaWhiteIps(InstanceId: string, request: UpdateKibanaWhiteIpsRequest): UpdateKibanaWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateKibanaWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateLogstashRequest {
  nodeAmount?: int32(name='nodeAmount', example='3'),
  nodeSpec?: {
    disk?: int32(name='disk', example='20'),
    diskType?: string(name='diskType', example='cloud_efficiency'),
    spec?: string(name='spec', example='elasticsearch.sn1ne.large'),
  }(name='nodeSpec'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateLogstashResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateLogstashResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLogstashResponseBody(name='body'),
}

/**
 * @summary 修改Logstash节点规格磁盘配置
 *
 * @param request UpdateLogstashRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLogstashResponse
 */
async function updateLogstashWithOptions(InstanceId: string, request: UpdateLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstash',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改Logstash节点规格磁盘配置
 *
 * @param request UpdateLogstashRequest
 * @return UpdateLogstashResponse
 */
async function updateLogstash(InstanceId: string, request: UpdateLogstashRequest): UpdateLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashWithOptions(InstanceId, request, headers, runtime);
}

model UpdateLogstashChargeTypeRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateLogstashChargeTypeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', description='Indicates whether the billing method of the cluster is switched. Valid values:

*   true: The billing method is switched.
*   false: The billing method fails to be switched.', example='true'),
}

model UpdateLogstashChargeTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLogstashChargeTypeResponseBody(name='body'),
}

/**
 * @summary Switches the billing method of a Logstash cluster from pay-as-you-go to subscription.
 *
 * @param request UpdateLogstashChargeTypeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLogstashChargeTypeResponse
 */
async function updateLogstashChargeTypeWithOptions(InstanceId: string, request: UpdateLogstashChargeTypeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashChargeTypeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstashChargeType',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/convert-pay-type`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Switches the billing method of a Logstash cluster from pay-as-you-go to subscription.
 *
 * @param request UpdateLogstashChargeTypeRequest
 * @return UpdateLogstashChargeTypeResponse
 */
async function updateLogstashChargeType(InstanceId: string, request: UpdateLogstashChargeTypeRequest): UpdateLogstashChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashChargeTypeWithOptions(InstanceId, request, headers, runtime);
}

model UpdateLogstashDescriptionRequest {
  description?: string(name='description'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateLogstashDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: {
    description?: string(name='description', description='The name of the cluster.', example='logstash_name'),
  }(name='Result', description='The result returned.'),
}

model UpdateLogstashDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLogstashDescriptionResponseBody(name='body'),
}

/**
 * @summary Changes the name of a specified Logstash cluster.
 *
 * @description When you call this operation, take note of the following items: You cannot change the name of a cluster that is in the activating, invalid, or inactive state.
 *
 * @param request UpdateLogstashDescriptionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLogstashDescriptionResponse
 */
async function updateLogstashDescriptionWithOptions(InstanceId: string, request: UpdateLogstashDescriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashDescriptionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstashDescription',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/description`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the name of a specified Logstash cluster.
 *
 * @description When you call this operation, take note of the following items: You cannot change the name of a cluster that is in the activating, invalid, or inactive state.
 *
 * @param request UpdateLogstashDescriptionRequest
 * @return UpdateLogstashDescriptionResponse
 */
async function updateLogstashDescription(InstanceId: string, request: UpdateLogstashDescriptionRequest): UpdateLogstashDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashDescriptionWithOptions(InstanceId, request, headers, runtime);
}

model UpdateLogstashSettingsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='5A2CFF0E-5718-45B5-9D4D-70B3FF\\\\*\\\\*\\\\*\\\\*', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateLogstashSettingsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='71D0D1DA-B22F-58CB-AF5B-D1657A6A****'),
}

model UpdateLogstashSettingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLogstashSettingsResponseBody(name='body'),
}

/**
 * @summary Updates the configuration of a specified Logstash cluster.
 *
 * @description When you call this operation, take note of the following items:
 * If the instance is in the Active (activating), Invalid (invalid), and Inactive (inactive) state, the information cannot be updated.
 *
 * @param request UpdateLogstashSettingsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLogstashSettingsResponse
 */
async function updateLogstashSettingsWithOptions(InstanceId: string, request: UpdateLogstashSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashSettingsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateLogstashSettings',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/instance-settings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the configuration of a specified Logstash cluster.
 *
 * @description When you call this operation, take note of the following items:
 * If the instance is in the Active (activating), Invalid (invalid), and Inactive (inactive) state, the information cannot be updated.
 *
 * @param request UpdateLogstashSettingsRequest
 * @return UpdateLogstashSettingsResponse
 */
async function updateLogstashSettings(InstanceId: string, request: UpdateLogstashSettingsRequest): UpdateLogstashSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashSettingsWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePipelineManagementConfigRequest {
  endpoints?: [ string ](name='endpoints'),
  esInstanceId?: string(name='esInstanceId'),
  password?: string(name='password', example='******'),
  pipelineIds?: [ string ](name='pipelineIds'),
  pipelineManagementType?: string(name='pipelineManagementType', example='ES'),
  userName?: string(name='userName', example='elastic'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdatePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdatePipelineManagementConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePipelineManagementConfigResponseBody(name='body'),
}

/**
 * @summary 修改Logstash管道配置
 *
 * @param request UpdatePipelineManagementConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePipelineManagementConfigResponse
 */
async function updatePipelineManagementConfigWithOptions(InstanceId: string, request: UpdatePipelineManagementConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePipelineManagementConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.endpoints)) {
    body['endpoints'] = request.endpoints;
  }
  if (!Util.isUnset(request.esInstanceId)) {
    body['esInstanceId'] = request.esInstanceId;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.pipelineIds)) {
    body['pipelineIds'] = request.pipelineIds;
  }
  if (!Util.isUnset(request.pipelineManagementType)) {
    body['pipelineManagementType'] = request.pipelineManagementType;
  }
  if (!Util.isUnset(request.userName)) {
    body['userName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipelineManagementConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipeline-management-config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改Logstash管道配置
 *
 * @param request UpdatePipelineManagementConfigRequest
 * @return UpdatePipelineManagementConfigResponse
 */
async function updatePipelineManagementConfig(InstanceId: string, request: UpdatePipelineManagementConfigRequest): UpdatePipelineManagementConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePipelinesRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  trigger?: boolean(name='trigger', description='Specifies whether to deploy the pipeline immediately.', example='false'),
}

model UpdatePipelinesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', description='Indicates whether the pipeline is updated. Valid values:

*   true: The pipeline is updated.
*   false: The pipeline fails to be updated.', example='true'),
}

model UpdatePipelinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePipelinesResponseBody(name='body'),
}

/**
 * @summary Updates a pipeline of a Logstash cluster.
 *
 * @param request UpdatePipelinesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePipelinesResponse
 */
async function updatePipelinesWithOptions(InstanceId: string, request: UpdatePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePipelinesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.trigger)) {
    query['trigger'] = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePipelines',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/pipelines`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a pipeline of a Logstash cluster.
 *
 * @param request UpdatePipelinesRequest
 * @return UpdatePipelinesResponse
 */
async function updatePipelines(InstanceId: string, request: UpdatePipelinesRequest): UpdatePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePipelinesWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePrivateNetworkWhiteIpsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  modifyMode?: string(name='modifyMode', description='The results that are returned.', example='Cover'),
}

model UpdatePrivateNetworkWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', example='6DEBE5EE-0368-4757-8F82-EF9C3972****'),
  result?: {
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  }(name='Result'),
}

model UpdatePrivateNetworkWhiteIpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePrivateNetworkWhiteIpsResponseBody(name='body'),
}

/**
 * @summary ## RequestBody
 * | Property | Type | Required | Example | Description |
 * | -------- | ---- | -------- | ------- | ----------- |
 * | privateNetworkIpWhiteList | List<String> | No | ["0.0.XX.XX","10.2.XX.XX","192.168.XX.XX/25"] | The list of IP address whitelists. This parameter is available if whiteIpGroup is left empty. The value of this parameter updates the IP address whitelist configurations in the Default whitelist group.  
 * You cannot configure both privateNetworkIpWhiteList and whiteIpGroup. |
 * | whiteIpGroup | Object | No |  | You can update the whitelist configurations of an instance by using a whitelist group. You can update only one whitelist group.  
 * You cannot configure both privateNetworkIpWhiteList and whiteIpGroup. |
 * | └ groupName | String | No | test_group_name | The group name of the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
 * | └ ips | List<String> | No | ["0.0.0.0", "10.2.XX.XX"] | The list of IP addresses in the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
 * > **Notice**  The addition and deletion of whitelist groups are implemented by calling modifyMode to Cover. Delete and Append cannot add or delete whitelist groups at the same time. You can only modify the IP address list in the whitelist group. Take note of the following items: - If the modifyMode parameter is set to Cover, the whitelist group is deleted if ips is empty. If groupName is not in the list of existing whitelist group names, a whitelist group is created.
 * - If the modifyMode parameter is set to Delete, you must retain at least one IP address for the deleted ips.
 * - If the modifyMode parameter is set to Append, make sure that the whitelist group name has been created. Otherwise, the NotFound error message appears.
 *
 * @description >  In the following returned example, only the parameters in the returned data list are guaranteed to be included, and the parameters not mentioned are for reference only. For more information about the parameters, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force a dependency in a program to get these parameters.
 *
 * @param request UpdatePrivateNetworkWhiteIpsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePrivateNetworkWhiteIpsResponse
 */
async function updatePrivateNetworkWhiteIpsWithOptions(InstanceId: string, request: UpdatePrivateNetworkWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePrivateNetworkWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePrivateNetworkWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/private-network-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ## RequestBody
 * | Property | Type | Required | Example | Description |
 * | -------- | ---- | -------- | ------- | ----------- |
 * | privateNetworkIpWhiteList | List<String> | No | ["0.0.XX.XX","10.2.XX.XX","192.168.XX.XX/25"] | The list of IP address whitelists. This parameter is available if whiteIpGroup is left empty. The value of this parameter updates the IP address whitelist configurations in the Default whitelist group.  
 * You cannot configure both privateNetworkIpWhiteList and whiteIpGroup. |
 * | whiteIpGroup | Object | No |  | You can update the whitelist configurations of an instance by using a whitelist group. You can update only one whitelist group.  
 * You cannot configure both privateNetworkIpWhiteList and whiteIpGroup. |
 * | └ groupName | String | No | test_group_name | The group name of the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
 * | └ ips | List<String> | No | ["0.0.0.0", "10.2.XX.XX"] | The list of IP addresses in the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
 * > **Notice**  The addition and deletion of whitelist groups are implemented by calling modifyMode to Cover. Delete and Append cannot add or delete whitelist groups at the same time. You can only modify the IP address list in the whitelist group. Take note of the following items: - If the modifyMode parameter is set to Cover, the whitelist group is deleted if ips is empty. If groupName is not in the list of existing whitelist group names, a whitelist group is created.
 * - If the modifyMode parameter is set to Delete, you must retain at least one IP address for the deleted ips.
 * - If the modifyMode parameter is set to Append, make sure that the whitelist group name has been created. Otherwise, the NotFound error message appears.
 *
 * @description >  In the following returned example, only the parameters in the returned data list are guaranteed to be included, and the parameters not mentioned are for reference only. For more information about the parameters, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force a dependency in a program to get these parameters.
 *
 * @param request UpdatePrivateNetworkWhiteIpsRequest
 * @return UpdatePrivateNetworkWhiteIpsResponse
 */
async function updatePrivateNetworkWhiteIps(InstanceId: string, request: UpdatePrivateNetworkWhiteIpsRequest): UpdatePrivateNetworkWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePrivateNetworkWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePublicNetworkRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='A unique token generated by the client to guarantee the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdatePublicNetworkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2A88ECA1-D827-4581-AD39-05149586****'),
  result?: {
    enablePublic?: boolean(name='enablePublic', description='The status of the public network access switch.', example='false'),
  }(name='Result', description='The return results.'),
}

model UpdatePublicNetworkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePublicNetworkResponseBody(name='body'),
}

/**
 * @summary Call UpdatePublicNetwork to open or close the public network address of the specified elasticsearch instance.
 *
 * @description When you call this operation, take note of the following items:
 * When the instance is in the activating, invalid, or inactive state, its configuration cannot be updated.
 *
 * @param request UpdatePublicNetworkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublicNetworkResponse
 */
async function updatePublicNetworkWithOptions(InstanceId: string, request: UpdatePublicNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePublicNetworkResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicNetwork',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/public-network`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call UpdatePublicNetwork to open or close the public network address of the specified elasticsearch instance.
 *
 * @description When you call this operation, take note of the following items:
 * When the instance is in the activating, invalid, or inactive state, its configuration cannot be updated.
 *
 * @param request UpdatePublicNetworkRequest
 * @return UpdatePublicNetworkResponse
 */
async function updatePublicNetwork(InstanceId: string, request: UpdatePublicNetworkRequest): UpdatePublicNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePublicNetworkWithOptions(InstanceId, request, headers, runtime);
}

model UpdatePublicWhiteIpsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The ID of the request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  modifyMode?: string(name='modifyMode', description='The results that are returned.', example='Cover'),
}

model UpdatePublicWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', example='C82758DD-282F-4D48-934F-92170A33****'),
  result?: {
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  }(name='Result'),
}

model UpdatePublicWhiteIpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdatePublicWhiteIpsResponseBody(name='body'),
}

/**
 * @summary ## RequestBody
 * | Property | Type | Required | Example | Description |
 * | -------- | ---- | -------- | ------- | ----------- |
 * | publicIpWhitelist | List<String> | Yes | ["0.0.0.0/0","0.0.0.0/1"] | The list of IP address whitelists. This parameter is available if whiteIpGroup is left empty. The value of this parameter updates the IP address whitelist configurations in the Default whitelist group.  
 * You cannot configure both publicIpWhitelist and whiteIpGroup. |
 * | whiteIpGroup | Object | No |  | You can update the whitelist configurations of an instance by using a whitelist group. You can update only one whitelist group.  
 * You cannot configure both publicIpWhitelist and whiteIpGroup. |
 * | └ groupName | String | No | test_group_name | The group name of the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
 * | └ ips | List<String> | No | ["0.0.0.0", "10.2.XX.XX"] | The list of IP addresses in the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
 * > **Notice**  The addition and deletion of whitelist groups are implemented by calling modifyMode to Cover. Delete and Append cannot add or delete whitelist groups at the same time. You can only modify the IP address list in the whitelist group. Take note of the following items: - If the modifyMode parameter is set to Cover, the whitelist group is deleted if ips is empty. If groupName is not in the list of existing whitelist group names, a whitelist group is created.
 * - If the modifyMode parameter is set to Delete, you must retain at least one IP address for the deleted ips.
 * - If the modifyMode parameter is set to Append, make sure that the whitelist group name has been created. Otherwise, the NotFound error message appears.
 *
 * @description >  In the following example, only the parameters in the returned data list are guaranteed to be included. The parameters that are not mentioned are for reference only. For more information about the parameters, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force a dependency in a program to get these parameters.
 *
 * @param request UpdatePublicWhiteIpsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdatePublicWhiteIpsResponse
 */
async function updatePublicWhiteIpsWithOptions(InstanceId: string, request: UpdatePublicWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePublicWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdatePublicWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/public-white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ## RequestBody
 * | Property | Type | Required | Example | Description |
 * | -------- | ---- | -------- | ------- | ----------- |
 * | publicIpWhitelist | List<String> | Yes | ["0.0.0.0/0","0.0.0.0/1"] | The list of IP address whitelists. This parameter is available if whiteIpGroup is left empty. The value of this parameter updates the IP address whitelist configurations in the Default whitelist group.  
 * You cannot configure both publicIpWhitelist and whiteIpGroup. |
 * | whiteIpGroup | Object | No |  | You can update the whitelist configurations of an instance by using a whitelist group. You can update only one whitelist group.  
 * You cannot configure both publicIpWhitelist and whiteIpGroup. |
 * | └ groupName | String | No | test_group_name | The group name of the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
 * | └ ips | List<String> | No | ["0.0.0.0", "10.2.XX.XX"] | The list of IP addresses in the whitelist group. This parameter is required if the whiteIpGroup parameter is optional. |
 * > **Notice**  The addition and deletion of whitelist groups are implemented by calling modifyMode to Cover. Delete and Append cannot add or delete whitelist groups at the same time. You can only modify the IP address list in the whitelist group. Take note of the following items: - If the modifyMode parameter is set to Cover, the whitelist group is deleted if ips is empty. If groupName is not in the list of existing whitelist group names, a whitelist group is created.
 * - If the modifyMode parameter is set to Delete, you must retain at least one IP address for the deleted ips.
 * - If the modifyMode parameter is set to Append, make sure that the whitelist group name has been created. Otherwise, the NotFound error message appears.
 *
 * @description >  In the following example, only the parameters in the returned data list are guaranteed to be included. The parameters that are not mentioned are for reference only. For more information about the parameters, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force a dependency in a program to get these parameters.
 *
 * @param request UpdatePublicWhiteIpsRequest
 * @return UpdatePublicWhiteIpsResponse
 */
async function updatePublicWhiteIps(InstanceId: string, request: UpdatePublicWhiteIpsRequest): UpdatePublicWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePublicWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateReadWritePolicyRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model UpdateReadWritePolicyResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateReadWritePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateReadWritePolicyResponseBody(name='body'),
}

/**
 * @summary 更改ES集群高可用策略
 *
 * @param request UpdateReadWritePolicyRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateReadWritePolicyResponse
 */
async function updateReadWritePolicyWithOptions(InstanceId: string, request: UpdateReadWritePolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateReadWritePolicyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateReadWritePolicy',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/update-read-write-policy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更改ES集群高可用策略
 *
 * @param request UpdateReadWritePolicyRequest
 * @return UpdateReadWritePolicyResponse
 */
async function updateReadWritePolicy(InstanceId: string, request: UpdateReadWritePolicyRequest): UpdateReadWritePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateReadWritePolicyWithOptions(InstanceId, request, headers, runtime);
}

model UpdateSnapshotSettingRequest {
  body?: string(name='body'),
}

model UpdateSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D****'),
  result?: {
    enable?: boolean(name='enable', description='Specifies whether to enable automatic backup.', example='true'),
    quartzRegex?: string(name='quartzRegex', description='The start time of automatic backup.', example='0 0 01 ? * * *'),
  }(name='Result', description='The return results.'),
}

model UpdateSnapshotSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSnapshotSettingResponseBody(name='body'),
}

/**
 * @summary Call UpdateSnapshotSetting to update the data backup configuration of the specified instance.
 *
 * @param request UpdateSnapshotSettingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSnapshotSettingResponse
 */
async function updateSnapshotSettingWithOptions(InstanceId: string, request: UpdateSnapshotSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSnapshotSettingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateSnapshotSetting',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/snapshot-setting`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Call UpdateSnapshotSetting to update the data backup configuration of the specified instance.
 *
 * @param request UpdateSnapshotSettingRequest
 * @return UpdateSnapshotSettingResponse
 */
async function updateSnapshotSetting(InstanceId: string, request: UpdateSnapshotSettingRequest): UpdateSnapshotSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSnapshotSettingWithOptions(InstanceId, request, headers, runtime);
}

model UpdateSynonymsDictsRequest {
  body?: string(name='body'),
  clientToken?: string(name='clientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model UpdateSynonymsDictsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7C5622CC-B312-426F-85AA-B0271*******'),
  result?: [ 
    {
      fileSize?: long(name='fileSize', description='The size of the dictionary file. Unit: bytes.', example='220'),
      name?: string(name='name', description='The name of the dictionary file.', example='deploy_0.txt'),
      sourceType?: string(name='sourceType', description='The source type of the dictionary file. Valid values:

*   OSS
*   ORIGIN', example='OSS'),
      type?: string(name='type', description='The dictionary type. The value is fixed as SYNONYMS.', example='SYNONYMS'),
    }
  ](name='Result', description='The returned result.'),
}

model UpdateSynonymsDictsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateSynonymsDictsResponseBody(name='body'),
}

/**
 * @summary Updates the synonym dictionaries of an Elasticsearch cluster.
 *
 * @description Before you call this operation, take note of the following items:
 * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
 * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
 *
 * @param request UpdateSynonymsDictsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSynonymsDictsResponse
 */
async function updateSynonymsDictsWithOptions(InstanceId: string, request: UpdateSynonymsDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSynonymsDictsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateSynonymsDicts',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/synonymsDict`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the synonym dictionaries of an Elasticsearch cluster.
 *
 * @description Before you call this operation, take note of the following items:
 * *   If the dictionary file is stored in an Object Storage Service (OSS) bucket, you must make sure that the access control list (ACL) of the bucket is public read.
 * *   If you do not set sourceType to ORIGIN for an uploaded dictionary file, the file will be deleted after you call this operation.
 *
 * @param request UpdateSynonymsDictsRequest
 * @return UpdateSynonymsDictsResponse
 */
async function updateSynonymsDicts(InstanceId: string, request: UpdateSynonymsDictsRequest): UpdateSynonymsDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSynonymsDictsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateTemplateRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body', example='{     "content": "{\\\\n\\\\t\\\\"persistent\\\\":{\\\\n\\\\t\\\\t\\\\"search\\\\":{\\\\n\\\\t\\\\t\\\\t\\\\"max_buckets\\\\":\\\\"10000\\\\"\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n}" }'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1****'),
  result?: boolean(name='Result', example='true'),
}

model UpdateTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTemplateResponseBody(name='body'),
}

/**
 * @param request UpdateTemplateRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTemplateResponse
 */
async function updateTemplateWithOptions(InstanceId: string, TemplateName: string, request: UpdateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'UpdateTemplate',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/templates/${OpenApiUtil.getEncodeParam(TemplateName)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateTemplateRequest
 * @return UpdateTemplateResponse
 */
async function updateTemplate(InstanceId: string, TemplateName: string, request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTemplateWithOptions(InstanceId, TemplateName, request, headers, runtime);
}

model UpdateWhiteIpsRequest {
  esIPWhitelist?: [ string ](name='esIPWhitelist', description='The name of the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  whiteIpGroup?: {
    groupName?: string(name='groupName', description='The type of the whitelist. Set the value to **PRIVATE_ES**. This value indicates a private IP address whitelist.', example='test_group'),
    ips?: [ string ](name='ips', description='The returned result.'),
    whiteIpType?: string(name='whiteIpType', description='The returned result.', example='PRIVATE_ES'),
  }(name='whiteIpGroup', description='The IP addresses in the whitelist. This parameter is required if you configure the whiteIpGroup parameter.'),
  clientToken?: string(name='clientToken', description='The IP addresses in the whitelist.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  modifyMode?: string(name='modifyMode', description='The IP addresses in the whitelist. This parameter is available if the whiteIpGroup parameter is left empty. The default IP address whitelist is updated based on the value of this parameter.

>  You cannot configure both the esIPWhitelist and whiteIpGroup parameters.', example='Cover'),
}

model UpdateWhiteIpsResponseBody = {
  requestId?: string(name='RequestId', description='The updated whitelist.', example='8D58B014-BBD7-4D80-B219-00B9D5C6860C'),
  result?: {
    esIPWhitelist?: [ string ](name='esIPWhitelist', description='The list of whitelists.'),
    networkConfig?: {
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName', description='The type of the whitelist. The value of this parameter is fixed as PRIVATE_ES, which indicates a private IP address whitelist.', example='test_group'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType', example='PRIVATE_ES'),
        }
      ](name='whiteIpGroupList', description='The IP addresses in the whitelist.'),
    }(name='networkConfig', description='The name of the whitelist. By default, the default whitelist is included.'),
  }(name='Result', description='The network configurations.'),
}

model UpdateWhiteIpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWhiteIpsResponseBody(name='body'),
}

/**
 * @summary >  If you want to add an IP address whitelist, you can set the modifyMode parameter only to Cover. If you set this parameter to Delete or Append, you can only update an IP address whitelist.
 * *   If you set the modifyMode parameter to Cover and leave the ips parameter empty, the system deletes the specified whitelist. If the whitelist specified by using the groupName parameter does not exist, the system creates such a whitelist.
 * *   If you set the modifyMode parameter to Delete, at least one IP address must be retained for the specified whitelist.
 * *   If you set the modifyMode parameter to Append, you must make sure that the specified whitelist exists. Otherwise, the system reports the NotFound error.
 *
 * @description > For more information about the parameters displayed in the following sample code but not provided in the preceding tables, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force your program to obtain these parameters.
 *
 * @param request UpdateWhiteIpsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWhiteIpsResponse
 */
async function updateWhiteIpsWithOptions(InstanceId: string, request: UpdateWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateWhiteIpsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['modifyMode'] = request.modifyMode;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.esIPWhitelist)) {
    body['esIPWhitelist'] = request.esIPWhitelist;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body['whiteIpGroup'] = request.whiteIpGroup;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWhiteIps',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/white-ips`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary >  If you want to add an IP address whitelist, you can set the modifyMode parameter only to Cover. If you set this parameter to Delete or Append, you can only update an IP address whitelist.
 * *   If you set the modifyMode parameter to Cover and leave the ips parameter empty, the system deletes the specified whitelist. If the whitelist specified by using the groupName parameter does not exist, the system creates such a whitelist.
 * *   If you set the modifyMode parameter to Delete, at least one IP address must be retained for the specified whitelist.
 * *   If you set the modifyMode parameter to Append, you must make sure that the specified whitelist exists. Otherwise, the system reports the NotFound error.
 *
 * @description > For more information about the parameters displayed in the following sample code but not provided in the preceding tables, see [ListInstance](https://help.aliyun.com/document_detail/142230.html). You cannot force your program to obtain these parameters.
 *
 * @param request UpdateWhiteIpsRequest
 * @return UpdateWhiteIpsResponse
 */
async function updateWhiteIps(InstanceId: string, request: UpdateWhiteIpsRequest): UpdateWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

model UpdateXpackMonitorConfigRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  enable?: boolean(name='enable', example='true'),
  endpoints?: [ string ](name='endpoints'),
  password?: string(name='password', example='******', nullable=true),
  userName?: string(name='userName', example='elastic', nullable=true),
}

model UpdateXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', example='true'),
}

model UpdateXpackMonitorConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateXpackMonitorConfigResponseBody(name='body'),
}

/**
 * @summary 修改Logstash实例的X-Pack监控报警配置。
 *
 * @param request UpdateXpackMonitorConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateXpackMonitorConfigResponse
 */
async function updateXpackMonitorConfigWithOptions(InstanceId: string, request: UpdateXpackMonitorConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateXpackMonitorConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.enable)) {
    body['enable'] = request.enable;
  }
  if (!Util.isUnset(request.endpoints)) {
    body['endpoints'] = request.endpoints;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    body['userName'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateXpackMonitorConfig',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/xpack-monitor-config`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改Logstash实例的X-Pack监控报警配置。
 *
 * @param request UpdateXpackMonitorConfigRequest
 * @return UpdateXpackMonitorConfigResponse
 */
async function updateXpackMonitorConfig(InstanceId: string, request: UpdateXpackMonitorConfigRequest): UpdateXpackMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateXpackMonitorConfigWithOptions(InstanceId, request, headers, runtime);
}

model UpgradeEngineVersionRequest {
  plugins?: [ 
    {
      enable?: string(name='enable'),
      fileVersion?: string(name='fileVersion'),
      name?: string(name='name'),
      version?: string(name='version'),
    }
  ](name='plugins'),
  type?: string(name='type', example='engineVersion'),
  version?: string(name='version', example='6.7'),
  clientToken?: string(name='clientToken', description='The moderation results.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  dryRun?: boolean(name='dryRun', description='The monitoring type. Valid values:

*   checkClusterHealth: Cluster Health Status
*   checkConfigCompatible: Configuration Compatibility Status
*   checkClusterResource: resource space status
*   checkClusterSnapshot: Whether a snapshot exists', example='false'),
}

model UpgradeEngineVersionResponseBody = {
  requestId?: string(name='RequestId', description='The verification information.', example='F99407AB-2FA9-489E-A259-40CF6DC*****'),
  result?: [ 
    {
      status?: string(name='status', example='success'),
      validateResult?: [ 
        {
          errorCode?: string(name='errorCode', example='ClusterStatusNotHealth'),
          errorMsg?: string(name='errorMsg', example='The cluster status is not health'),
          errorType?: string(name='errorType', description='The verification is passed. Valid values:

*   success: through
*   failed: failed', example='clusterStatus'),
        }
      ](name='validateResult', description='The error message returned.'),
      validateType?: string(name='validateType', description='The error code returned if the request failed.', example='checkClusterHealth'),
    }
  ](name='Result', description='The type of the error. Valid values:

*   clusterStatus: the health status of the cluster.
*   clusterConfigYml: Cluster YML File
*   clusterConfigPlugins: Cluster Configuration File
*   clusterResource: cluster resources
*   clusterSnapshot: cluster snapshot'),
}

model UpgradeEngineVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeEngineVersionResponseBody(name='body'),
}

/**
 * @summary ES集群版本升级
 *
 * @description 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
 *
 * @param request UpgradeEngineVersionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeEngineVersionResponse
 */
async function upgradeEngineVersionWithOptions(InstanceId: string, request: UpgradeEngineVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpgradeEngineVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['dryRun'] = request.dryRun;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.plugins)) {
    body['plugins'] = request.plugins;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeEngineVersion',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/actions/upgrade-version`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary ES集群版本升级
 *
 * @description 5A2CFF0E-5718-45B5-9D4D-70B3FF\\*\\*\\*\\*
 *
 * @param request UpgradeEngineVersionRequest
 * @return UpgradeEngineVersionResponse
 */
async function upgradeEngineVersion(InstanceId: string, request: UpgradeEngineVersionRequest): UpgradeEngineVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeEngineVersionWithOptions(InstanceId, request, headers, runtime);
}

model ValidateConnectionRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  body?: string(name='body'),
}

model ValidateConnectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5FFD9ED4-C2EC-4E89-B22B-1ACB6FE1D***'),
  result?: boolean(name='Result', description='Indicates whether the connectivity is normal. Valid values:

*   true
*   false', example='true'),
}

model ValidateConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateConnectionResponseBody(name='body'),
}

/**
 * @summary Tests the connectivity between a Logstash cluster and its associated Elasticsearch cluster when you configure the X-Pack Monitoring feature for the Logstash cluster.
 *
 * @description > Before you enable the X-Pack Monitoring feature for a Logstash cluster, you must associate the Logstash cluster with an Elasticsearch cluster. This way, you can view the monitoring data of the Logstash cluster in the Kibana console of the Elasticsearch cluster.
 *
 * @param request ValidateConnectionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidateConnectionResponse
 */
async function validateConnectionWithOptions(InstanceId: string, request: ValidateConnectionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateConnectionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var params = new OpenApi.Params{
    action = 'ValidateConnection',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/logstashes/${OpenApiUtil.getEncodeParam(InstanceId)}/validate-connection`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Tests the connectivity between a Logstash cluster and its associated Elasticsearch cluster when you configure the X-Pack Monitoring feature for the Logstash cluster.
 *
 * @description > Before you enable the X-Pack Monitoring feature for a Logstash cluster, you must associate the Logstash cluster with an Elasticsearch cluster. This way, you can view the monitoring data of the Logstash cluster in the Kibana console of the Elasticsearch cluster.
 *
 * @param request ValidateConnectionRequest
 * @return ValidateConnectionResponse
 */
async function validateConnection(InstanceId: string, request: ValidateConnectionRequest): ValidateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateConnectionWithOptions(InstanceId, request, headers, runtime);
}

model ValidateShrinkNodesRequest {
  body?: [ 
    {
      host?: string(name='host', example='192.168.xx.xx'),
      hostName?: string(name='hostName', example='es-cn-pl32xxxxxxx-data-f-1'),
      nodeType?: string(name='nodeType', example='WORKER'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body'),
  count?: int32(name='count', example='2'),
  ignoreStatus?: boolean(name='ignoreStatus', description='The ID of the request.', example='false'),
  nodeType?: string(name='nodeType', description='Returned results:

*   true: can be scaled in
*   false: cannot be scaled in.

This parameter is required.', example='WORKER'),
}

model ValidateShrinkNodesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model ValidateShrinkNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateShrinkNodesResponseBody(name='body'),
}

/**
 * @summary 校验缩节点合法性
 *
 * @param request ValidateShrinkNodesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidateShrinkNodesResponse
 */
async function validateShrinkNodesWithOptions(InstanceId: string, request: ValidateShrinkNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateShrinkNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.count)) {
    query['count'] = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query['ignoreStatus'] = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateShrinkNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/validate-shrink-nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 校验缩节点合法性
 *
 * @param request ValidateShrinkNodesRequest
 * @return ValidateShrinkNodesResponse
 */
async function validateShrinkNodes(InstanceId: string, request: ValidateShrinkNodesRequest): ValidateShrinkNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateShrinkNodesWithOptions(InstanceId, request, headers, runtime);
}

model ValidateSlrPermissionRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
  rolename?: string(name='rolename', description='This parameter is required.', example='AliyunServiceRoleForElasticsearchCollector'),
}

model ValidateSlrPermissionResponseBody = {
  requestId?: string(name='RequestId', example='BC4ED7DD-8C84-49B5-8A95-456F82E44D13'),
  result?: boolean(name='Result', example='true'),
}

model ValidateSlrPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateSlrPermissionResponseBody(name='body'),
}

/**
 * @param request ValidateSlrPermissionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidateSlrPermissionResponse
 */
async function validateSlrPermissionWithOptions(request: ValidateSlrPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateSlrPermissionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.rolename)) {
    query['rolename'] = request.rolename;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ValidateSlrPermission',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/user/servicerolepermission`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ValidateSlrPermissionRequest
 * @return ValidateSlrPermissionResponse
 */
async function validateSlrPermission(request: ValidateSlrPermissionRequest): ValidateSlrPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateSlrPermissionWithOptions(request, headers, runtime);
}

model ValidateTransferableNodesRequest {
  body?: [ 
    {
      host?: string(name='host', example='172.16.xx.xx'),
      port?: int32(name='port', example='9200'),
      zoneId?: string(name='zoneId', example='cn-shanghai-c'),
    }
  ](name='body'),
  nodeType?: string(name='nodeType', description='This parameter is required.', example='WORKER'),
}

model ValidateTransferableNodesResponseBody = {
  requestId?: string(name='RequestId', example='F99407AB-2FA9-489E-A259-40CF6DCC****'),
  result?: boolean(name='Result', example='true'),
}

model ValidateTransferableNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ValidateTransferableNodesResponseBody(name='body'),
}

/**
 * @summary 缩节点校验数据迁移合法性
 *
 * @param request ValidateTransferableNodesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ValidateTransferableNodesResponse
 */
async function validateTransferableNodesWithOptions(InstanceId: string, request: ValidateTransferableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateTransferableNodesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nodeType)) {
    query['nodeType'] = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = Util.toArray(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ValidateTransferableNodes',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances/${OpenApiUtil.getEncodeParam(InstanceId)}/validate-transfer-nodes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 缩节点校验数据迁移合法性
 *
 * @param request ValidateTransferableNodesRequest
 * @return ValidateTransferableNodesResponse
 */
async function validateTransferableNodes(InstanceId: string, request: ValidateTransferableNodesRequest): ValidateTransferableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateTransferableNodesWithOptions(InstanceId, request, headers, runtime);
}

model CreateInstanceRequest {
  clientNodeConfiguration?: ClientNodeConfiguration(name='clientNodeConfiguration'),
  description?: string(name='description', example='es'),
  elasticDataNodeConfiguration?: ElasticDataNodeConfiguration(name='elasticDataNodeConfiguration'),
  esAdminPassword?: string(name='esAdminPassword', description='This parameter is required.', example='es_password'),
  esVersion?: string(name='esVersion', description='This parameter is required.', example='5.5.3_with_X-Pack'),
  instanceCategory?: string(name='instanceCategory', example='advanced'),
  kibanaConfiguration?: KibanaNodeConfiguration(name='kibanaConfiguration'),
  masterConfiguration?: MasterNodeConfiguration(name='masterConfiguration'),
  networkConfig?: NetworkConfig(name='networkConfig', description='This parameter is required.'),
  nodeAmount?: int32(name='nodeAmount', description='This parameter is required.', example='3'),
  nodeSpec?: NodeSpec(name='nodeSpec'),
  paymentInfo?: PaymentInfo(name='paymentInfo'),
  paymentType?: string(name='paymentType', example='postpaid'),
  resourceGroupId?: string(name='resourceGroupId', example='rg-aekzu7tsu4nem4q'),
  tags?: [ 
    {
      tagKey?: string(name='tagKey'),
      tagValue?: string(name='tagValue'),
    }
  ](name='tags'),
  warmNodeConfiguration?: WarmNodeConfiguration(name='warmNodeConfiguration'),
  zoneCount?: int32(name='zoneCount', example='2'),
  clientToken?: string(name='clientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF****'),
}

model CreateInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary The configurations of dedicated master nodes.
 *
 * @description The configurations of warm nodes.
 *
 * @param request CreateInstanceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInstanceResponse
 */
async function createInstanceWithOptions(request: CreateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    query['clientToken'] = request.clientToken;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.clientNodeConfiguration)) {
    body['clientNodeConfiguration'] = request.clientNodeConfiguration;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.elasticDataNodeConfiguration)) {
    body['elasticDataNodeConfiguration'] = request.elasticDataNodeConfiguration;
  }
  if (!Util.isUnset(request.esAdminPassword)) {
    body['esAdminPassword'] = request.esAdminPassword;
  }
  if (!Util.isUnset(request.esVersion)) {
    body['esVersion'] = request.esVersion;
  }
  if (!Util.isUnset(request.instanceCategory)) {
    body['instanceCategory'] = request.instanceCategory;
  }
  if (!Util.isUnset(request.kibanaConfiguration)) {
    body['kibanaConfiguration'] = request.kibanaConfiguration;
  }
  if (!Util.isUnset(request.masterConfiguration)) {
    body['masterConfiguration'] = request.masterConfiguration;
  }
  if (!Util.isUnset(request.networkConfig)) {
    body['networkConfig'] = request.networkConfig;
  }
  if (!Util.isUnset(request.nodeAmount)) {
    body['nodeAmount'] = request.nodeAmount;
  }
  if (!Util.isUnset(request.nodeSpec)) {
    body['nodeSpec'] = request.nodeSpec;
  }
  if (!Util.isUnset(request.paymentInfo)) {
    body['paymentInfo'] = request.paymentInfo;
  }
  if (!Util.isUnset(request.paymentType)) {
    body['paymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['resourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }
  if (!Util.isUnset(request.warmNodeConfiguration)) {
    body['warmNodeConfiguration'] = request.warmNodeConfiguration;
  }
  if (!Util.isUnset(request.zoneCount)) {
    body['zoneCount'] = request.zoneCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'createInstance',
    version = '2017-06-13',
    protocol = 'HTTPS',
    pathname = `/openapi/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The configurations of dedicated master nodes.
 *
 * @description The configurations of warm nodes.
 *
 * @param request CreateInstanceRequest
 * @return CreateInstanceResponse
 */
async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createInstanceWithOptions(request, headers, runtime);
}

