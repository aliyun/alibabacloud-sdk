/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('elasticsearch', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model ActivateZonesRequest {
  clientToken?: string(name='clientToken'),
}

model ActivateZonesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ActivateZonesResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateZonesResponseBody(name='body'),
}

async function activateZones(InstanceId: string, request: ActivateZonesRequest): ActivateZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return activateZonesWithOptions(InstanceId, request, headers, runtime);
}

async function activateZonesWithOptions(InstanceId: string, request: ActivateZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ActivateZonesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ActivateZones', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/recover-zones`, 'json', req, runtime);
}

model AddConnectableClusterRequest {
  clientToken?: string(name='clientToken'),
}

model AddConnectableClusterResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model AddConnectableClusterResponse = {
  headers: map[string]string(name='headers'),
  body: AddConnectableClusterResponseBody(name='body'),
}

async function addConnectableCluster(InstanceId: string, request: AddConnectableClusterRequest): AddConnectableClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addConnectableClusterWithOptions(InstanceId, request, headers, runtime);
}

async function addConnectableClusterWithOptions(InstanceId: string, request: AddConnectableClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddConnectableClusterResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('AddConnectableCluster', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/connected-clusters`, 'json', req, runtime);
}

model AddSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model AddSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  body: AddSnapshotRepoResponseBody(name='body'),
}

async function addSnapshotRepo(InstanceId: string): AddSnapshotRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addSnapshotRepoWithOptions(InstanceId, headers, runtime);
}

async function addSnapshotRepoWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): AddSnapshotRepoResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('AddSnapshotRepo', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/snapshot-repos`, 'json', req, runtime);
}

model CancelDeletionRequest {
  clientToken?: string(name='clientToken'),
}

model CancelDeletionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelDeletionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelDeletionResponseBody(name='body'),
}

async function cancelDeletion(InstanceId: string, request: CancelDeletionRequest): CancelDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelDeletionWithOptions(InstanceId, request, headers, runtime);
}

async function cancelDeletionWithOptions(InstanceId: string, request: CancelDeletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelDeletionResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CancelDeletion', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/cancel-deletion`, 'json', req, runtime);
}

model CancelLogstashDeletionRequest {
  clientToken?: string(name='clientToken'),
}

model CancelLogstashDeletionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelLogstashDeletionResponse = {
  headers: map[string]string(name='headers'),
  body: CancelLogstashDeletionResponseBody(name='body'),
}

async function cancelLogstashDeletion(InstanceId: string, request: CancelLogstashDeletionRequest): CancelLogstashDeletionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelLogstashDeletionWithOptions(InstanceId, request, headers, runtime);
}

async function cancelLogstashDeletionWithOptions(InstanceId: string, request: CancelLogstashDeletionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelLogstashDeletionResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CancelLogstashDeletion', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/actions/cancel-deletion`, 'json', req, runtime);
}

model CancelTaskRequest {
  clientToken?: string(name='clientToken'),
  taskType?: string(name='taskType'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTask(InstanceId: string, request: CancelTaskRequest): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelTaskWithOptions(InstanceId, request, headers, runtime);
}

async function cancelTaskWithOptions(InstanceId: string, request: CancelTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelTaskResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.taskType)) {
    query.taskType = request.taskType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CancelTask', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/cancel-task`, 'json', req, runtime);
}

model CapacityPlanRequest {
  complexQueryAvailable?: boolean(name='complexQueryAvailable'),
  dataInfo?: [ 
    {
      code?: string(name='code'),
      size?: long(name='size'),
      totalCount?: int32(name='totalCount'),
      type?: string(name='type'),
      unit?: string(name='unit'),
    }
  ](name='dataInfo'),
  metric?: [ 
    {
      averageQps?: int32(name='averageQps'),
      code?: string(name='code'),
      concurrent?: long(name='concurrent'),
      peakQps?: int32(name='peakQps'),
      responseTime?: int32(name='responseTime'),
      throughput?: long(name='throughput'),
      type?: string(name='type'),
    }
  ](name='metric'),
  usageScenario?: string(name='usageScenario'),
}

model CapacityPlanResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    extendConfigs?: [ 
      {
        configType?: string(name='ConfigType'),
        disk?: long(name='Disk'),
        diskType?: string(name='DiskType'),
      }
    ](name='ExtendConfigs'),
    instanceCategory?: string(name='InstanceCategory'),
    nodeConfigurations?: [ 
      {
        amount?: long(name='Amount'),
        cpu?: long(name='Cpu'),
        disk?: long(name='Disk'),
        diskType?: string(name='DiskType'),
        memory?: long(name='Memory'),
        nodeType?: string(name='NodeType'),
      }
    ](name='NodeConfigurations'),
    oversizedCluster?: boolean(name='OversizedCluster'),
  }(name='Result'),
}

model CapacityPlanResponse = {
  headers: map[string]string(name='headers'),
  body: CapacityPlanResponseBody(name='body'),
}

async function capacityPlan(request: CapacityPlanRequest): CapacityPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return capacityPlanWithOptions(request, headers, runtime);
}

async function capacityPlanWithOptions(request: CapacityPlanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CapacityPlanResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.complexQueryAvailable)) {
    body.complexQueryAvailable = request.complexQueryAvailable;
  }
  if (!Util.isUnset(request.dataInfo)) {
    body.dataInfo = request.dataInfo;
  }
  if (!Util.isUnset(request.metric)) {
    body.metric = request.metric;
  }
  if (!Util.isUnset(request.usageScenario)) {
    body.usageScenario = request.usageScenario;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CapacityPlan', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/assist/actions/capacity-plan`, 'json', req, runtime);
}

model CloseDiagnosisRequest {
  clientToken?: string(name='ClientToken'),
  lang?: string(name='lang'),
}

model CloseDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CloseDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: CloseDiagnosisResponseBody(name='body'),
}

async function closeDiagnosis(InstanceId: string, request: CloseDiagnosisRequest): CloseDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeDiagnosisWithOptions(InstanceId, request, headers, runtime);
}

async function closeDiagnosisWithOptions(InstanceId: string, request: CloseDiagnosisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseDiagnosisResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query.lang = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CloseDiagnosis', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/diagnosis/instances/${InstanceId}/actions/close-diagnosis`, 'json', req, runtime);
}

model CloseHttpsRequest {
  clientToken?: string(name='clientToken'),
}

model CloseHttpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CloseHttpsResponse = {
  headers: map[string]string(name='headers'),
  body: CloseHttpsResponseBody(name='body'),
}

async function closeHttps(InstanceId: string, request: CloseHttpsRequest): CloseHttpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeHttpsWithOptions(InstanceId, request, headers, runtime);
}

async function closeHttpsWithOptions(InstanceId: string, request: CloseHttpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseHttpsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CloseHttps', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/close-https`, 'json', req, runtime);
}

model CloseManagedIndexRequest {
  clientToken?: string(name='ClientToken'),
}

model CloseManagedIndexResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CloseManagedIndexResponse = {
  headers: map[string]string(name='headers'),
  body: CloseManagedIndexResponseBody(name='body'),
}

async function closeManagedIndex(InstanceId: string, Index: string, request: CloseManagedIndexRequest): CloseManagedIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return closeManagedIndexWithOptions(InstanceId, Index, request, headers, runtime);
}

async function closeManagedIndexWithOptions(InstanceId: string, Index: string, request: CloseManagedIndexRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloseManagedIndexResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  Index = OpenApiUtil.getEncodeParam(Index);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CloseManagedIndex', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/indices/${Index}/close-managed`, 'json', req, runtime);
}

model CreateCollectorRequest {
  clientToken?: string(name='clientToken'),
}

model CreateCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    resId?: string(name='resId'),
  }(name='Result'),
}

model CreateCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCollectorResponseBody(name='body'),
}

async function createCollector(request: CreateCollectorRequest): CreateCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCollectorWithOptions(request, headers, runtime);
}

async function createCollectorWithOptions(request: CreateCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCollectorResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateCollector', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/collectors`, 'json', req, runtime);
}

model CreateDataStreamRequest {
  clientToken?: string(name='ClientToken'),
}

model CreateDataStreamResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    name?: string(name='name'),
  }(name='Result'),
}

model CreateDataStreamResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataStreamResponseBody(name='body'),
}

async function createDataStream(InstanceId: string, request: CreateDataStreamRequest): CreateDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDataStreamWithOptions(InstanceId, request, headers, runtime);
}

async function createDataStreamWithOptions(InstanceId: string, request: CreateDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDataStreamResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateDataStream', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/data-streams`, 'json', req, runtime);
}

model CreateDataTasksRequest {
  clientToken?: string(name='ClientToken'),
}

model CreateDataTasksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        index?: string(name='index'),
        mapping?: string(name='mapping'),
        password?: string(name='password'),
        routing?: string(name='routing'),
        settings?: string(name='settings'),
        type?: string(name='type'),
        username?: string(name='username'),
        vpcId?: string(name='vpcId'),
        vpcInstanceId?: string(name='vpcInstanceId'),
        vpcInstancePort?: string(name='vpcInstancePort'),
      }(name='sinkCluster'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        endpoint?: string(name='endpoint'),
        index?: string(name='index'),
        password?: string(name='password'),
        type?: string(name='type'),
        username?: string(name='username'),
        vpcId?: string(name='vpcId'),
        vpcInstanceId?: string(name='vpcInstanceId'),
        vpcInstancePort?: int32(name='vpcInstancePort'),
      }(name='sourceCluster'),
    }
  ](name='Result'),
}

model CreateDataTasksResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataTasksResponseBody(name='body'),
}

async function createDataTasks(InstanceId: string, request: CreateDataTasksRequest): CreateDataTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDataTasksWithOptions(InstanceId, request, headers, runtime);
}

async function createDataTasksWithOptions(InstanceId: string, request: CreateDataTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDataTasksResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateDataTasks', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/data-task`, 'json', req, runtime);
}

model CreateILMPolicyRequest {
  clientToken?: string(name='ClientToken'),
}

model CreateILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateILMPolicyResponseBody(name='body'),
}

async function createILMPolicy(InstanceId: string, request: CreateILMPolicyRequest): CreateILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createILMPolicyWithOptions(InstanceId, request, headers, runtime);
}

async function createILMPolicyWithOptions(InstanceId: string, request: CreateILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateILMPolicyResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateILMPolicy', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/ilm-policies`, 'json', req, runtime);
}

model CreateIndexTemplateRequest {
  clientToken?: string(name='ClientToken'),
}

model CreateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIndexTemplateResponseBody(name='body'),
}

async function createIndexTemplate(InstanceId: string, request: CreateIndexTemplateRequest): CreateIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIndexTemplateWithOptions(InstanceId, request, headers, runtime);
}

async function createIndexTemplateWithOptions(InstanceId: string, request: CreateIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIndexTemplateResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateIndexTemplate', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/index-templates`, 'json', req, runtime);
}

model CreateLogstashRequest {
  clientToken?: string(name='clientToken'),
}

model CreateLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    instanceId?: string(name='instanceId'),
  }(name='Result'),
}

model CreateLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLogstashResponseBody(name='body'),
}

async function createLogstash(request: CreateLogstashRequest): CreateLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLogstashWithOptions(request, headers, runtime);
}

async function createLogstashWithOptions(request: CreateLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateLogstash', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes`, 'json', req, runtime);
}

model CreatePipelinesRequest {
  clientToken?: string(name='ClientToken'),
  trigger?: boolean(name='trigger'),
}

model CreatePipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CreatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePipelinesResponseBody(name='body'),
}

async function createPipelines(InstanceId: string, request: CreatePipelinesRequest): CreatePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function createPipelinesWithOptions(InstanceId: string, request: CreatePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePipelinesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.trigger)) {
    query.trigger = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreatePipelines', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/pipelines`, 'json', req, runtime);
}

model CreateSnapshotRequest {
  clientToken?: string(name='ClientToken'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshot(InstanceId: string, request: CreateSnapshotRequest): CreateSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSnapshotWithOptions(InstanceId, request, headers, runtime);
}

async function createSnapshotWithOptions(InstanceId: string, request: CreateSnapshotRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSnapshotResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateSnapshot', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/snapshots`, 'json', req, runtime);
}

model CreateVpcEndpointRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='dryRun'),
}

model CreateVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    endpointDomain?: string(name='endpointDomain'),
    endpointId?: string(name='endpointId'),
    endpointName?: string(name='endpointName'),
    serviceId?: string(name='serviceId'),
  }(name='Result'),
}

model CreateVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVpcEndpointResponseBody(name='body'),
}

async function createVpcEndpoint(InstanceId: string, request: CreateVpcEndpointRequest): CreateVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVpcEndpointWithOptions(InstanceId, request, headers, runtime);
}

async function createVpcEndpointWithOptions(InstanceId: string, request: CreateVpcEndpointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVpcEndpointResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query.dryRun = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateVpcEndpoint', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/vpc-endpoints`, 'json', req, runtime);
}

model DeactivateZonesRequest {
  clientToken?: string(name='clientToken'),
}

model DeactivateZonesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeactivateZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DeactivateZonesResponseBody(name='body'),
}

async function deactivateZones(InstanceId: string, request: DeactivateZonesRequest): DeactivateZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deactivateZonesWithOptions(InstanceId, request, headers, runtime);
}

async function deactivateZonesWithOptions(InstanceId: string, request: DeactivateZonesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeactivateZonesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeactivateZones', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/down-zones`, 'json', req, runtime);
}

model DeleteCollectorRequest {
  clientToken?: string(name='ClientToken'),
}

model DeleteCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCollectorResponseBody(name='body'),
}

async function deleteCollector(ResId: string, request: DeleteCollectorRequest): DeleteCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCollectorWithOptions(ResId, request, headers, runtime);
}

async function deleteCollectorWithOptions(ResId: string, request: DeleteCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCollectorResponse {
  Util.validateModel(request);
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteCollector', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/collectors/${ResId}`, 'json', req, runtime);
}

model DeleteConnectedClusterRequest {
  clientToken?: string(name='clientToken'),
  connectedInstanceId?: string(name='connectedInstanceId'),
}

model DeleteConnectedClusterResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteConnectedClusterResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConnectedClusterResponseBody(name='body'),
}

async function deleteConnectedCluster(InstanceId: string, request: DeleteConnectedClusterRequest): DeleteConnectedClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConnectedClusterWithOptions(InstanceId, request, headers, runtime);
}

async function deleteConnectedClusterWithOptions(InstanceId: string, request: DeleteConnectedClusterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConnectedClusterResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.connectedInstanceId)) {
    query.connectedInstanceId = request.connectedInstanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteConnectedCluster', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/instances/${InstanceId}/connected-clusters`, 'json', req, runtime);
}

model DeleteDataStreamRequest {
  clientToken?: string(name='ClientToken'),
}

model DeleteDataStreamResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteDataStreamResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataStreamResponseBody(name='body'),
}

async function deleteDataStream(InstanceId: string, DataStream: string, request: DeleteDataStreamRequest): DeleteDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime);
}

async function deleteDataStreamWithOptions(InstanceId: string, DataStream: string, request: DeleteDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataStreamResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  DataStream = OpenApiUtil.getEncodeParam(DataStream);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteDataStream', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/instances/${InstanceId}/data-streams/${DataStream}`, 'json', req, runtime);
}

model DeleteDataTaskRequest {
  clientToken?: string(name='ClientToken'),
  taskId?: string(name='taskId'),
}

model DeleteDataTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteDataTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataTaskResponseBody(name='body'),
}

async function deleteDataTask(InstanceId: string, request: DeleteDataTaskRequest): DeleteDataTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataTaskWithOptions(InstanceId, request, headers, runtime);
}

async function deleteDataTaskWithOptions(InstanceId: string, request: DeleteDataTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataTaskResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.taskId)) {
    query.taskId = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteDataTask', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/instances/${InstanceId}/data-task`, 'json', req, runtime);
}

model DeleteILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteILMPolicyResponseBody(name='body'),
}

async function deleteILMPolicy(InstanceId: string, PolicyName: string): DeleteILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteILMPolicyWithOptions(InstanceId, PolicyName, headers, runtime);
}

async function deleteILMPolicyWithOptions(InstanceId: string, PolicyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteILMPolicyResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  PolicyName = OpenApiUtil.getEncodeParam(PolicyName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteILMPolicy', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/instances/${InstanceId}/ilm-policies/${PolicyName}`, 'json', req, runtime);
}

model DeleteIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIndexTemplateResponseBody(name='body'),
}

async function deleteIndexTemplate(InstanceId: string, IndexTemplate: string): DeleteIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIndexTemplateWithOptions(InstanceId, IndexTemplate, headers, runtime);
}

async function deleteIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIndexTemplateResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  IndexTemplate = OpenApiUtil.getEncodeParam(IndexTemplate);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteIndexTemplate', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/instances/${InstanceId}/index-templates/${IndexTemplate}`, 'json', req, runtime);
}

model DeleteInstanceRequest {
  clientToken?: string(name='clientToken'),
  deleteType?: string(name='deleteType'),
}

model DeleteInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstance(InstanceId: string, request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function deleteInstanceWithOptions(InstanceId: string, request: DeleteInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.deleteType)) {
    query.deleteType = request.deleteType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteInstance', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/instances/${InstanceId}`, 'json', req, runtime);
}

model DeleteLogstashRequest {
  clientToken?: string(name='clientToken'),
  deleteType?: string(name='deleteType'),
}

model DeleteLogstashResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLogstashResponseBody(name='body'),
}

async function deleteLogstash(InstanceId: string, request: DeleteLogstashRequest): DeleteLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLogstashWithOptions(InstanceId, request, headers, runtime);
}

async function deleteLogstashWithOptions(InstanceId: string, request: DeleteLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLogstashResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.deleteType)) {
    query.deleteType = request.deleteType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteLogstash', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/logstashes/${InstanceId}`, 'json', req, runtime);
}

model DeletePipelinesRequest {
  clientToken?: string(name='ClientToken'),
  pipelineIds?: string(name='pipelineIds'),
}

model DeletePipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeletePipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePipelinesResponseBody(name='body'),
}

async function deletePipelines(InstanceId: string, request: DeletePipelinesRequest): DeletePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function deletePipelinesWithOptions(InstanceId: string, request: DeletePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePipelinesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.pipelineIds)) {
    query.pipelineIds = request.pipelineIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeletePipelines', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/logstashes/${InstanceId}/pipelines`, 'json', req, runtime);
}

model DeleteSnapshotRepoRequest {
  clientToken?: string(name='clientToken'),
  repoPath?: string(name='repoPath'),
}

model DeleteSnapshotRepoResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteSnapshotRepoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotRepoResponseBody(name='body'),
}

async function deleteSnapshotRepo(InstanceId: string, request: DeleteSnapshotRepoRequest): DeleteSnapshotRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSnapshotRepoWithOptions(InstanceId, request, headers, runtime);
}

async function deleteSnapshotRepoWithOptions(InstanceId: string, request: DeleteSnapshotRepoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSnapshotRepoResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.repoPath)) {
    query.repoPath = request.repoPath;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteSnapshotRepo', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/instances/${InstanceId}/snapshot-repos`, 'json', req, runtime);
}

model DeleteVpcEndpointRequest {
  clientToken?: string(name='ClientToken'),
}

model DeleteVpcEndpointResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVpcEndpointResponseBody(name='body'),
}

async function deleteVpcEndpoint(InstanceId: string, EndpointId: string, request: DeleteVpcEndpointRequest): DeleteVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVpcEndpointWithOptions(InstanceId, EndpointId, request, headers, runtime);
}

async function deleteVpcEndpointWithOptions(InstanceId: string, EndpointId: string, request: DeleteVpcEndpointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVpcEndpointResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  EndpointId = OpenApiUtil.getEncodeParam(EndpointId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteVpcEndpoint', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/instances/${InstanceId}/vpc-endpoints/${EndpointId}`, 'json', req, runtime);
}

model DescribeAckOperatorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    status?: string(name='status'),
    version?: string(name='version'),
  }(name='Result'),
}

model DescribeAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAckOperatorResponseBody(name='body'),
}

async function describeAckOperator(ClusterId: string): DescribeAckOperatorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAckOperatorWithOptions(ClusterId, headers, runtime);
}

async function describeAckOperatorWithOptions(ClusterId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAckOperatorResponse {
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeAckOperator', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/ack-clusters/${ClusterId}/operator`, 'json', req, runtime);
}

model DescribeApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    apmServerDomain?: string(name='apmServerDomain'),
    createdAt?: string(name='createdAt'),
    deployedReplica?: long(name='deployedReplica'),
    description?: string(name='description'),
    endTime?: long(name='endTime'),
    instanceId?: string(name='instanceId'),
    nodeAmount?: long(name='nodeAmount'),
    outputES?: string(name='outputES'),
    outputESUserName?: string(name='outputESUserName'),
    outputEsDescription?: string(name='outputEsDescription'),
    ownerId?: string(name='ownerId'),
    paymentType?: string(name='paymentType'),
    region?: string(name='region'),
    replica?: int32(name='replica'),
    resourceSpec?: string(name='resourceSpec'),
    status?: string(name='status'),
    version?: string(name='version'),
    vpcId?: string(name='vpcId'),
    vsArea?: string(name='vsArea'),
    vswitchId?: string(name='vswitchId'),
  }(name='Result'),
}

model DescribeApmResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApmResponseBody(name='body'),
}

async function describeApm(instanceId: string): DescribeApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApmWithOptions(instanceId, headers, runtime);
}

async function describeApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApmResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeApm', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/apm/${instanceId}`, 'json', req, runtime);
}

model DescribeCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content'),
        fileName?: string(name='fileName'),
      }
    ](name='configs'),
    dryRun?: boolean(name='dryRun'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType'),
        enableMonitoring?: boolean(name='enableMonitoring'),
        groupId?: string(name='groupId'),
        host?: string(name='host'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId'),
        instanceType?: string(name='instanceType'),
        kibanaHost?: string(name='kibanaHost'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus'),
            instanceId?: string(name='instanceId'),
          }
        ](name='machines'),
        protocol?: string(name='protocol'),
        successPodsCount?: string(name='successPodsCount'),
        totalPodsCount?: string(name='totalPodsCount'),
        type?: string(name='type'),
        userName?: string(name='userName'),
      }
    ](name='extendConfigs'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    name?: string(name='name'),
    ownerId?: string(name='ownerId'),
    resId?: string(name='resId'),
    resType?: string(name='resType'),
    resVersion?: string(name='resVersion'),
    status?: string(name='status'),
    vpcId?: string(name='vpcId'),
  }(name='Result'),
}

model DescribeCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCollectorResponseBody(name='body'),
}

async function describeCollector(ResId: string): DescribeCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeCollectorWithOptions(ResId, headers, runtime);
}

async function describeCollectorWithOptions(ResId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeCollectorResponse {
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeCollector', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/collectors/${ResId}`, 'json', req, runtime);
}

model DescribeConnectableClustersRequest {
  alreadySetItems?: boolean(name='alreadySetItems'),
}

model DescribeConnectableClustersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      instances?: string(name='instances'),
      networkType?: string(name='networkType'),
    }
  ](name='Result'),
}

model DescribeConnectableClustersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeConnectableClustersResponseBody(name='body'),
}

async function describeConnectableClusters(InstanceId: string, request: DescribeConnectableClustersRequest): DescribeConnectableClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeConnectableClustersWithOptions(InstanceId, request, headers, runtime);
}

async function describeConnectableClustersWithOptions(InstanceId: string, request: DescribeConnectableClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeConnectableClustersResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.alreadySetItems)) {
    query.alreadySetItems = request.alreadySetItems;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DescribeConnectableClusters', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/connectable-clusters`, 'json', req, runtime);
}

model DescribeDiagnoseReportRequest {
  lang?: string(name='lang'),
}

model DescribeDiagnoseReportResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createTime?: long(name='createTime'),
    diagnoseItems?: [ 
      {
        detail?: {
          desc?: string(name='desc'),
          name?: string(name='name'),
          result?: string(name='result'),
          suggest?: string(name='suggest'),
          type?: string(name='type'),
        }(name='detail'),
        health?: string(name='health'),
        item?: string(name='item'),
      }
    ](name='diagnoseItems'),
    health?: string(name='health'),
    instanceId?: string(name='instanceId'),
    reportId?: string(name='reportId'),
    state?: string(name='state'),
    trigger?: string(name='trigger'),
  }(name='Result'),
}

model DescribeDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnoseReportResponseBody(name='body'),
}

async function describeDiagnoseReport(InstanceId: string, ReportId: string, request: DescribeDiagnoseReportRequest): DescribeDiagnoseReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDiagnoseReportWithOptions(InstanceId, ReportId, request, headers, runtime);
}

async function describeDiagnoseReportWithOptions(InstanceId: string, ReportId: string, request: DescribeDiagnoseReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDiagnoseReportResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  ReportId = OpenApiUtil.getEncodeParam(ReportId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.lang)) {
    query.lang = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DescribeDiagnoseReport', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/diagnosis/instances/${InstanceId}/reports/${ReportId}`, 'json', req, runtime);
}

model DescribeDiagnosisSettingsRequest {
  lang?: string(name='lang'),
}

model DescribeDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    scene?: string(name='scene'),
    updateTime?: long(name='updateTime'),
  }(name='Result'),
}

model DescribeDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnosisSettingsResponseBody(name='body'),
}

async function describeDiagnosisSettings(InstanceId: string, request: DescribeDiagnosisSettingsRequest): DescribeDiagnosisSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function describeDiagnosisSettingsWithOptions(InstanceId: string, request: DescribeDiagnosisSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDiagnosisSettingsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.lang)) {
    query.lang = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DescribeDiagnosisSettings', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/diagnosis/instances/${InstanceId}/settings`, 'json', req, runtime);
}

model DescribeElasticsearchHealthResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeElasticsearchHealthResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeElasticsearchHealthResponseBody(name='body'),
}

async function describeElasticsearchHealth(InstanceId: string): DescribeElasticsearchHealthResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeElasticsearchHealthWithOptions(InstanceId, headers, runtime);
}

async function describeElasticsearchHealthWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeElasticsearchHealthResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeElasticsearchHealth', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/elasticsearch-health`, 'json', req, runtime);
}

model DescribeILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    name?: string(name='name'),
    phases?: map[string]any(name='phases'),
  }(name='Result'),
}

model DescribeILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeILMPolicyResponseBody(name='body'),
}

async function describeILMPolicy(InstanceId: string, PolicyName: string): DescribeILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeILMPolicyWithOptions(InstanceId, PolicyName, headers, runtime);
}

async function describeILMPolicyWithOptions(InstanceId: string, PolicyName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeILMPolicyResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  PolicyName = OpenApiUtil.getEncodeParam(PolicyName);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeILMPolicy', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/ilm-policies/${PolicyName}`, 'json', req, runtime);
}

model DescribeIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    dataStream?: boolean(name='dataStream'),
    ilmPolicy?: string(name='ilmPolicy'),
    indexPatterns?: [ string ](name='indexPatterns'),
    indexTemplate?: string(name='indexTemplate'),
    priority?: int32(name='priority'),
    template?: {
      aliases?: string(name='aliases'),
      mappings?: string(name='mappings'),
      settings?: string(name='settings'),
    }(name='template'),
  }(name='Result'),
}

model DescribeIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIndexTemplateResponseBody(name='body'),
}

async function describeIndexTemplate(InstanceId: string, IndexTemplate: string): DescribeIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeIndexTemplateWithOptions(InstanceId, IndexTemplate, headers, runtime);
}

async function describeIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeIndexTemplateResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  IndexTemplate = OpenApiUtil.getEncodeParam(IndexTemplate);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeIndexTemplate', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/index-templates/${IndexTemplate}`, 'json', req, runtime);
}

model DescribeInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
    advancedSetting?: {
      gcName?: string(name='gcName'),
    }(name='advancedSetting'),
    aliwsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='aliwsDicts'),
    clientNodeConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='clientNodeConfiguration'),
    createdAt?: string(name='createdAt'),
    dedicateMaster?: boolean(name='dedicateMaster'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    elasticDataNodeConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='elasticDataNodeConfiguration'),
    enableKibanaPrivateNetwork?: boolean(name='enableKibanaPrivateNetwork'),
    enableKibanaPublicNetwork?: boolean(name='enableKibanaPublicNetwork'),
    enablePublic?: boolean(name='enablePublic'),
    esConfig?: map[string]any(name='esConfig'),
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
    esIPWhitelist?: [ string ](name='esIPWhitelist'),
    esVersion?: string(name='esVersion'),
    extendConfigs?: [  map[string]any ](name='extendConfigs'),
    haveClientNode?: boolean(name='haveClientNode'),
    haveKibana?: boolean(name='haveKibana'),
    instanceId?: string(name='instanceId'),
    isNewDeployment?: boolean(name='isNewDeployment'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
    kibanaPort?: int32(name='kibanaPort'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
      whiteIpGroupList?: [ 
        {
          groupName?: string(name='groupName'),
          ips?: [ string ](name='ips'),
          whiteIpType?: string(name='whiteIpType'),
        }
      ](name='whiteIpGroupList'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    port?: int32(name='port'),
    postpaidServiceStatus?: string(name='postpaidServiceStatus'),
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
    protocol?: string(name='protocol'),
    publicDomain?: string(name='publicDomain'),
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
    publicPort?: int32(name='publicPort'),
    resourceGroupId?: string(name='resourceGroupId'),
    serviceVpc?: boolean(name='serviceVpc'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey'),
        tagValue?: string(name='tagValue'),
      }
    ](name='tags'),
    updatedAt?: string(name='updatedAt'),
    vpcInstanceId?: string(name='vpcInstanceId'),
    warmNode?: boolean(name='warmNode'),
    warmNodeConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='warmNodeConfiguration'),
    zoneCount?: int32(name='zoneCount'),
    zoneInfos?: [ 
      {
        status?: string(name='status'),
        zoneId?: string(name='zoneId'),
      }
    ](name='zoneInfos'),
  }(name='Result'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstance(InstanceId: string): DescribeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInstanceWithOptions(InstanceId, headers, runtime);
}

async function describeInstanceWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeInstanceResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeInstance', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}`, 'json', req, runtime);
}

model DescribeKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: map[string]any(name='Result'),
}

model DescribeKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeKibanaSettingsResponseBody(name='body'),
}

async function describeKibanaSettings(InstanceId: string): DescribeKibanaSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeKibanaSettingsWithOptions(InstanceId, headers, runtime);
}

async function describeKibanaSettingsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeKibanaSettingsResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeKibanaSettings', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/kibana-settings`, 'json', req, runtime);
}

model DescribeLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    extendConfigs?: [  map[string]any ](name='ExtendConfigs'),
    resourceGroupId?: string(name='ResourceGroupId'),
    tags?: [ 
      {
        tagKey?: string(name='tagKey'),
        tagValue?: string(name='tagValue'),
      }
    ](name='Tags'),
    zoneInfos?: [ 
      {
        status?: string(name='status'),
        zoneId?: string(name='zoneId'),
      }
    ](name='ZoneInfos'),
    config?: map[string]any(name='config'),
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    endpointList?: [ 
      {
        host?: string(name='host'),
        port?: string(name='port'),
        zoneId?: string(name='zoneId'),
      }
    ](name='endpointList'),
    instanceId?: string(name='instanceId'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskEncryption?: boolean(name='diskEncryption'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    status?: string(name='status'),
    updatedAt?: string(name='updatedAt'),
    version?: string(name='version'),
    vpcInstanceId?: string(name='vpcInstanceId'),
  }(name='Result'),
}

model DescribeLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLogstashResponseBody(name='body'),
}

async function describeLogstash(InstanceId: string): DescribeLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeLogstashWithOptions(InstanceId, headers, runtime);
}

async function describeLogstashWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeLogstashResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeLogstash', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes/${InstanceId}`, 'json', req, runtime);
}

model DescribePipelineResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    batchDelay?: int32(name='batchDelay'),
    batchSize?: int32(name='batchSize'),
    config?: string(name='config'),
    description?: string(name='description'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    pipelineId?: string(name='pipelineId'),
    pipelineStatus?: string(name='pipelineStatus'),
    queueCheckPointWrites?: int32(name='queueCheckPointWrites'),
    queueMaxBytes?: int32(name='queueMaxBytes'),
    queueType?: string(name='queueType'),
    workers?: int32(name='workers'),
  }(name='Result'),
}

model DescribePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePipelineResponseBody(name='body'),
}

async function describePipeline(InstanceId: string, PipelineId: string): DescribePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePipelineWithOptions(InstanceId, PipelineId, headers, runtime);
}

async function describePipelineWithOptions(InstanceId: string, PipelineId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePipelineResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  PipelineId = OpenApiUtil.getEncodeParam(PipelineId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribePipeline', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes/${InstanceId}/pipelines/${PipelineId}`, 'json', req, runtime);
}

model DescribePipelineManagementConfigRequest {
  clientToken?: string(name='clientToken'),
}

model DescribePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    endpoints?: string(name='endpoints'),
    esInstanceId?: string(name='esInstanceId'),
    pipelineIds?: [ string ](name='pipelineIds'),
    pipelineManagementType?: string(name='pipelineManagementType'),
    userName?: string(name='userName'),
  }(name='Result'),
}

model DescribePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePipelineManagementConfigResponseBody(name='body'),
}

async function describePipelineManagementConfig(InstanceId: string, request: DescribePipelineManagementConfigRequest): DescribePipelineManagementConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime);
}

async function describePipelineManagementConfigWithOptions(InstanceId: string, request: DescribePipelineManagementConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePipelineManagementConfigResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DescribePipelineManagementConfig', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes/${InstanceId}/pipeline-management-config`, 'json', req, runtime);
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      consoleEndpoint?: string(name='consoleEndpoint'),
      localName?: string(name='localName'),
      regionEndpoint?: string(name='regionEndpoint'),
      regionId?: string(name='regionId'),
      status?: string(name='status'),
    }
  ](name='Result'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeRegions', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/regions`, 'json', req, runtime);
}

model DescribeSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='Enable'),
    quartzRegex?: string(name='QuartzRegex'),
  }(name='Result'),
}

model DescribeSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotSettingResponseBody(name='body'),
}

async function describeSnapshotSetting(InstanceId: string): DescribeSnapshotSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSnapshotSettingWithOptions(InstanceId, headers, runtime);
}

async function describeSnapshotSettingWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSnapshotSettingResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeSnapshotSetting', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/snapshot-setting`, 'json', req, runtime);
}

model DescribeTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      templateName?: string(name='templateName'),
    }
  ](name='Result'),
}

model DescribeTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTemplatesResponseBody(name='body'),
}

async function describeTemplates(InstanceId: string): DescribeTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeTemplatesWithOptions(InstanceId, headers, runtime);
}

async function describeTemplatesWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeTemplatesResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeTemplates', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/templates`, 'json', req, runtime);
}

model DescribeXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='enable'),
    endpoints?: [ string ](name='endpoints'),
    esInstanceId?: string(name='esInstanceId'),
    pipelineIds?: [ string ](name='pipelineIds'),
    userName?: string(name='userName'),
  }(name='Result'),
}

model DescribeXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeXpackMonitorConfigResponseBody(name='body'),
}

async function describeXpackMonitorConfig(InstanceId: string): DescribeXpackMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeXpackMonitorConfigWithOptions(InstanceId, headers, runtime);
}

async function describeXpackMonitorConfigWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeXpackMonitorConfigResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DescribeXpackMonitorConfig', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes/${InstanceId}/xpack-monitor-config`, 'json', req, runtime);
}

model DiagnoseInstanceRequest {
  clientToken?: string(name='ClientToken'),
  lang?: string(name='lang'),
}

model DiagnoseInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createTime?: long(name='createTime'),
    diagnoseItems?: [ 
      {
        item?: string(name='item'),
      }
    ](name='diagnoseItems'),
    instanceId?: string(name='instanceId'),
    reportId?: string(name='reportId'),
    state?: string(name='state'),
  }(name='Result'),
}

model DiagnoseInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DiagnoseInstanceResponseBody(name='body'),
}

async function diagnoseInstance(InstanceId: string, request: DiagnoseInstanceRequest): DiagnoseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return diagnoseInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function diagnoseInstanceWithOptions(InstanceId: string, request: DiagnoseInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DiagnoseInstanceResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query.lang = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DiagnoseInstance', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/diagnosis/instances/${InstanceId}/actions/diagnose`, 'json', req, runtime);
}

model EstimatedLogstashRestartTimeRequest {
  force?: boolean(name='force'),
}

model EstimatedLogstashRestartTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    unit?: string(name='unit'),
    value?: long(name='value'),
  }(name='Result'),
}

model EstimatedLogstashRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  body: EstimatedLogstashRestartTimeResponseBody(name='body'),
}

async function estimatedLogstashRestartTime(InstanceId: string, request: EstimatedLogstashRestartTimeRequest): EstimatedLogstashRestartTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return estimatedLogstashRestartTimeWithOptions(InstanceId, request, headers, runtime);
}

async function estimatedLogstashRestartTimeWithOptions(InstanceId: string, request: EstimatedLogstashRestartTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EstimatedLogstashRestartTimeResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.force)) {
    query.force = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('EstimatedLogstashRestartTime', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/estimated-time/restart-time`, 'json', req, runtime);
}

model EstimatedRestartTimeRequest {
  force?: boolean(name='force'),
}

model EstimatedRestartTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    unit?: string(name='unit'),
    value?: long(name='value'),
  }(name='Result'),
}

model EstimatedRestartTimeResponse = {
  headers: map[string]string(name='headers'),
  body: EstimatedRestartTimeResponseBody(name='body'),
}

async function estimatedRestartTime(InstanceId: string, request: EstimatedRestartTimeRequest): EstimatedRestartTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return estimatedRestartTimeWithOptions(InstanceId, request, headers, runtime);
}

async function estimatedRestartTimeWithOptions(InstanceId: string, request: EstimatedRestartTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EstimatedRestartTimeResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.force)) {
    query.force = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('EstimatedRestartTime', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/estimated-time/restart-time`, 'json', req, runtime);
}

model GetClusterDataInformationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    connectable?: boolean(name='connectable'),
    metaInfo?: {
      fields?: [ string ](name='fields'),
      indices?: [ string ](name='indices'),
      mapping?: string(name='mapping'),
      settings?: string(name='settings'),
      typeName?: [ string ](name='typeName'),
    }(name='metaInfo'),
  }(name='Result'),
}

model GetClusterDataInformationResponse = {
  headers: map[string]string(name='headers'),
  body: GetClusterDataInformationResponseBody(name='body'),
}

async function getClusterDataInformation(): GetClusterDataInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getClusterDataInformationWithOptions(headers, runtime);
}

async function getClusterDataInformationWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetClusterDataInformationResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetClusterDataInformation', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/cluster/data-information`, 'json', req, runtime);
}

model GetElastictaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model GetElastictaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetElastictaskResponseBody(name='body'),
}

async function getElastictask(InstanceId: string): GetElastictaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getElastictaskWithOptions(InstanceId, headers, runtime);
}

async function getElastictaskWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetElastictaskResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetElastictask', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/elastic-task`, 'json', req, runtime);
}

model GetEmonGrafanaAlertsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEmonGrafanaAlertsResponse = {
  headers: map[string]string(name='headers'),
  body: GetEmonGrafanaAlertsResponseBody(name='body'),
}

async function getEmonGrafanaAlerts(ProjectId: string): GetEmonGrafanaAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonGrafanaAlertsWithOptions(ProjectId, headers, runtime);
}

async function getEmonGrafanaAlertsWithOptions(ProjectId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonGrafanaAlertsResponse {
  ProjectId = OpenApiUtil.getEncodeParam(ProjectId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetEmonGrafanaAlerts', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/emon/projects/${ProjectId}/grafana/proxy/api/alerts`, 'json', req, runtime);
}

model GetEmonGrafanaDashboardsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetEmonGrafanaDashboardsResponse = {
  headers: map[string]string(name='headers'),
  body: GetEmonGrafanaDashboardsResponseBody(name='body'),
}

async function getEmonGrafanaDashboards(ProjectId: string): GetEmonGrafanaDashboardsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonGrafanaDashboardsWithOptions(ProjectId, headers, runtime);
}

async function getEmonGrafanaDashboardsWithOptions(ProjectId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonGrafanaDashboardsResponse {
  ProjectId = OpenApiUtil.getEncodeParam(ProjectId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetEmonGrafanaDashboards', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/emon/projects/${ProjectId}/grafana/proxy/api/search`, 'json', req, runtime);
}

model GetEmonMonitorDataResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      dps?: map[string]any(name='dps'),
      integrity?: float(name='integrity'),
      messageWatermark?: long(name='messageWatermark'),
      metric?: string(name='metric'),
      summary?: float(name='summary'),
      tags?: map[string]any(name='tags'),
    }
  ](name='Result'),
  success?: boolean(name='Success'),
}

model GetEmonMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: GetEmonMonitorDataResponseBody(name='body'),
}

async function getEmonMonitorData(ProjectId: string): GetEmonMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmonMonitorDataWithOptions(ProjectId, headers, runtime);
}

async function getEmonMonitorDataWithOptions(ProjectId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEmonMonitorDataResponse {
  ProjectId = OpenApiUtil.getEncodeParam(ProjectId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetEmonMonitorData', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/emon/projects/${ProjectId}/metrics/query`, 'json', req, runtime);
}

model GetOpenStoreUsageResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  result?: {
    currentUsage?: long(name='currentUsage', description='当前使用量'),
    lastDayUsage?: long(name='lastDayUsage', description='昨日使用容量'),
  }(name='Result'),
}

model GetOpenStoreUsageResponse = {
  headers: map[string]string(name='headers'),
  body: GetOpenStoreUsageResponseBody(name='body'),
}

async function getOpenStoreUsage(InstanceId: string): GetOpenStoreUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOpenStoreUsageWithOptions(InstanceId, headers, runtime);
}

async function getOpenStoreUsageWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOpenStoreUsageResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetOpenStoreUsage', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/openstore/usage`, 'json', req, runtime);
}

model GetRegionConfigurationRequest {
  zoneId?: string(name='zoneId'),
}

model GetRegionConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    clientNodeAmountRange?: {
      maxAmount?: int32(name='maxAmount'),
      minAmount?: int32(name='minAmount'),
    }(name='clientNodeAmountRange'),
    clientNodeDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
      }
    ](name='clientNodeDiskList'),
    clientNodeSpec?: [ string ](name='clientNodeSpec'),
    createUrl?: string(name='createUrl'),
    dataDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
        valueLimitSet?: [ string ](name='valueLimitSet'),
      }
    ](name='dataDiskList'),
    elasticNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount'),
        minAmount?: int32(name='minAmount'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption'),
          diskType?: string(name='diskType'),
          maxSize?: int32(name='maxSize'),
          minSize?: int32(name='minSize'),
          scaleLimit?: int32(name='scaleLimit'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='elasticNodeProperties'),
    env?: string(name='env'),
    esVersions?: [ string ](name='esVersions'),
    esVersionsLatestList?: [ 
      {
        key?: string(name='key'),
        value?: string(name='value'),
      }
    ](name='esVersionsLatestList'),
    instanceSupportNodes?: [ string ](name='instanceSupportNodes'),
    jvmConfine?: {
      memory?: int32(name='memory'),
      supportEsVersions?: [ string ](name='supportEsVersions'),
      supportGcs?: [ string ](name='supportGcs'),
    }(name='jvmConfine'),
    kibanaNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount'),
        minAmount?: int32(name='minAmount'),
      }(name='amountRange'),
      spec?: [ string ](name='spec'),
    }(name='kibanaNodeProperties'),
    masterDiskList?: [ 
      {
        diskType?: string(name='diskType'),
        maxSize?: int32(name='maxSize'),
        minSize?: int32(name='minSize'),
        scaleLimit?: int32(name='scaleLimit'),
      }
    ](name='masterDiskList'),
    masterSpec?: [ string ](name='masterSpec'),
    node?: {
      maxAmount?: int32(name='maxAmount'),
      minAmount?: int32(name='minAmount'),
    }(name='node'),
    nodeSpecList?: [ 
      {
        cpuCount?: int32(name='cpuCount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        enable?: boolean(name='enable'),
        memorySize?: int32(name='memorySize'),
        spec?: string(name='spec'),
        specGroupType?: string(name='specGroupType'),
      }
    ](name='nodeSpecList'),
    regionId?: string(name='regionId'),
    supportVersions?: [ 
      {
        instanceCategory?: string(name='instanceCategory'),
        supportVersionList?: [ 
          {
            key?: string(name='key'),
            value?: string(name='value'),
          }
        ](name='supportVersionList'),
      }
    ](name='supportVersions'),
    warmNodeProperties?: {
      amountRange?: {
        maxAmount?: int32(name='maxAmount'),
        minAmount?: int32(name='minAmount'),
      }(name='amountRange'),
      diskList?: [ 
        {
          diskEncryption?: boolean(name='diskEncryption'),
          diskType?: string(name='diskType'),
          maxSize?: int32(name='maxSize'),
          minSize?: int32(name='minSize'),
          scaleLimit?: int32(name='scaleLimit'),
          valueLimitSet?: [ string ](name='valueLimitSet'),
        }
      ](name='diskList'),
      spec?: [ string ](name='spec'),
    }(name='warmNodeProperties'),
    zones?: [ string ](name='zones'),
  }(name='Result'),
}

model GetRegionConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: GetRegionConfigurationResponseBody(name='body'),
}

async function getRegionConfiguration(request: GetRegionConfigurationRequest): GetRegionConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRegionConfigurationWithOptions(request, headers, runtime);
}

async function getRegionConfigurationWithOptions(request: GetRegionConfigurationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRegionConfigurationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.zoneId)) {
    query.zoneId = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetRegionConfiguration', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/region`, 'json', req, runtime);
}

model GetSuggestShrinkableNodesRequest {
  count?: int32(name='count'),
  ignoreStatus?: boolean(name='ignoreStatus'),
  nodeType?: string(name='nodeType'),
}

model GetSuggestShrinkableNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
    }
  ](name='Result'),
}

model GetSuggestShrinkableNodesResponse = {
  headers: map[string]string(name='headers'),
  body: GetSuggestShrinkableNodesResponseBody(name='body'),
}

async function getSuggestShrinkableNodes(InstanceId: string, request: GetSuggestShrinkableNodesRequest): GetSuggestShrinkableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSuggestShrinkableNodesWithOptions(InstanceId, request, headers, runtime);
}

async function getSuggestShrinkableNodesWithOptions(InstanceId: string, request: GetSuggestShrinkableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSuggestShrinkableNodesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.count)) {
    query.count = request.count;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query.ignoreStatus = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query.nodeType = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetSuggestShrinkableNodes', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/suggest-shrinkable-nodes`, 'json', req, runtime);
}

model GetTransferableNodesRequest {
  count?: int32(name='count'),
  nodeType?: string(name='nodeType'),
}

model GetTransferableNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      host?: string(name='host'),
      port?: int32(name='port'),
    }
  ](name='Result'),
}

model GetTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  body: GetTransferableNodesResponseBody(name='body'),
}

async function getTransferableNodes(InstanceId: string, request: GetTransferableNodesRequest): GetTransferableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTransferableNodesWithOptions(InstanceId, request, headers, runtime);
}

async function getTransferableNodesWithOptions(InstanceId: string, request: GetTransferableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTransferableNodesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.count)) {
    query.count = request.count;
  }
  if (!Util.isUnset(request.nodeType)) {
    query.nodeType = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetTransferableNodes', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/transferable-nodes`, 'json', req, runtime);
}

model InitializeOperationRoleRequest {
  clientToken?: string(name='ClientToken'),
}

model InitializeOperationRoleResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InitializeOperationRoleResponse = {
  headers: map[string]string(name='headers'),
  body: InitializeOperationRoleResponseBody(name='body'),
}

async function initializeOperationRole(request: InitializeOperationRoleRequest): InitializeOperationRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initializeOperationRoleWithOptions(request, headers, runtime);
}

async function initializeOperationRoleWithOptions(request: InitializeOperationRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InitializeOperationRoleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InitializeOperationRole', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/user/slr`, 'json', req, runtime);
}

model InstallAckOperatorRequest {
  clientToken?: string(name='ClientToken'),
}

model InstallAckOperatorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InstallAckOperatorResponse = {
  headers: map[string]string(name='headers'),
  body: InstallAckOperatorResponseBody(name='body'),
}

async function installAckOperator(ClusterId: string, request: InstallAckOperatorRequest): InstallAckOperatorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installAckOperatorWithOptions(ClusterId, request, headers, runtime);
}

async function installAckOperatorWithOptions(ClusterId: string, request: InstallAckOperatorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallAckOperatorResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InstallAckOperator', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/ack-clusters/${ClusterId}/operator`, 'json', req, runtime);
}

model InstallKibanaSystemPluginRequest {
  clientToken?: string(name='clientToken'),
}

model InstallKibanaSystemPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallKibanaSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  body: InstallKibanaSystemPluginResponseBody(name='body'),
}

async function installKibanaSystemPlugin(InstanceId: string, request: InstallKibanaSystemPluginRequest): InstallKibanaSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installKibanaSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

async function installKibanaSystemPluginWithOptions(InstanceId: string, request: InstallKibanaSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallKibanaSystemPluginResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InstallKibanaSystemPlugin', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/kibana-plugins/system/actions/install`, 'json', req, runtime);
}

model InstallLogstashSystemPluginRequest {
  clientToken?: string(name='clientToken'),
}

model InstallLogstashSystemPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallLogstashSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  body: InstallLogstashSystemPluginResponseBody(name='body'),
}

async function installLogstashSystemPlugin(InstanceId: string, request: InstallLogstashSystemPluginRequest): InstallLogstashSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installLogstashSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

async function installLogstashSystemPluginWithOptions(InstanceId: string, request: InstallLogstashSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallLogstashSystemPluginResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InstallLogstashSystemPlugin', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/plugins/system/actions/install`, 'json', req, runtime);
}

model InstallSystemPluginRequest {
  clientToken?: string(name='clientToken'),
}

model InstallSystemPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallSystemPluginResponse = {
  headers: map[string]string(name='headers'),
  body: InstallSystemPluginResponseBody(name='body'),
}

async function installSystemPlugin(InstanceId: string, request: InstallSystemPluginRequest): InstallSystemPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installSystemPluginWithOptions(InstanceId, request, headers, runtime);
}

async function installSystemPluginWithOptions(InstanceId: string, request: InstallSystemPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InstallSystemPluginResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InstallSystemPlugin', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/plugins/system/actions/install`, 'json', req, runtime);
}

model InstallUserPluginsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model InstallUserPluginsResponse = {
  headers: map[string]string(name='headers'),
  body: InstallUserPluginsResponseBody(name='body'),
}

async function installUserPlugins(InstanceId: string): InstallUserPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return installUserPluginsWithOptions(InstanceId, headers, runtime);
}

async function installUserPluginsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): InstallUserPluginsResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('InstallUserPlugins', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/plugins/user/actions/install`, 'json', req, runtime);
}

model InterruptElasticsearchTaskRequest {
  clientToken?: string(name='clientToken'),
}

model InterruptElasticsearchTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InterruptElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: InterruptElasticsearchTaskResponseBody(name='body'),
}

async function interruptElasticsearchTask(InstanceId: string, request: InterruptElasticsearchTaskRequest): InterruptElasticsearchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return interruptElasticsearchTaskWithOptions(InstanceId, request, headers, runtime);
}

async function interruptElasticsearchTaskWithOptions(InstanceId: string, request: InterruptElasticsearchTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InterruptElasticsearchTaskResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InterruptElasticsearchTask', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/interrupt`, 'json', req, runtime);
}

model InterruptLogstashTaskRequest {
  clientToken?: string(name='clientToken'),
}

model InterruptLogstashTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model InterruptLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  body: InterruptLogstashTaskResponseBody(name='body'),
}

async function interruptLogstashTask(InstanceId: string, request: InterruptLogstashTaskRequest): InterruptLogstashTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return interruptLogstashTaskWithOptions(InstanceId, request, headers, runtime);
}

async function interruptLogstashTaskWithOptions(InstanceId: string, request: InterruptLogstashTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InterruptLogstashTaskResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('InterruptLogstashTask', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/actions/interrupt`, 'json', req, runtime);
}

model ListAckClustersRequest {
  page?: int32(name='page'),
  size?: int32(name='size'),
  vpcId?: string(name='vpcId'),
}

model ListAckClustersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      clusterId?: string(name='clusterId'),
      clusterType?: string(name='clusterType'),
      name?: string(name='name'),
      vpcId?: string(name='vpcId'),
    }
  ](name='Result'),
}

model ListAckClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListAckClustersResponseBody(name='body'),
}

async function listAckClusters(request: ListAckClustersRequest): ListAckClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAckClustersWithOptions(request, headers, runtime);
}

async function listAckClustersWithOptions(request: ListAckClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAckClustersResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.vpcId)) {
    query.vpcId = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListAckClusters', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/ack-clusters`, 'json', req, runtime);
}

model ListAckNamespacesRequest {
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListAckNamespacesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      namespace?: string(name='namespace'),
      status?: string(name='status'),
    }
  ](name='Result'),
}

model ListAckNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAckNamespacesResponseBody(name='body'),
}

async function listAckNamespaces(ClusterId: string, request: ListAckNamespacesRequest): ListAckNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAckNamespacesWithOptions(ClusterId, request, headers, runtime);
}

async function listAckNamespacesWithOptions(ClusterId: string, request: ListAckNamespacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAckNamespacesResponse {
  Util.validateModel(request);
  ClusterId = OpenApiUtil.getEncodeParam(ClusterId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListAckNamespaces', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/ack-clusters/${ClusterId}/namespaces`, 'json', req, runtime);
}

model ListAllNodeRequest {
  extended?: boolean(name='extended'),
}

model ListAllNodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      cpuPercent?: string(name='cpuPercent'),
      diskUsedPercent?: string(name='diskUsedPercent'),
      health?: string(name='health'),
      heapPercent?: string(name='heapPercent'),
      host?: string(name='host'),
      loadOneM?: string(name='loadOneM'),
      nodeType?: string(name='nodeType'),
      port?: int32(name='port'),
      zoneId?: string(name='zoneId'),
    }
  ](name='Result'),
}

model ListAllNodeResponse = {
  headers: map[string]string(name='headers'),
  body: ListAllNodeResponseBody(name='body'),
}

async function listAllNode(InstanceId: string, request: ListAllNodeRequest): ListAllNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAllNodeWithOptions(InstanceId, request, headers, runtime);
}

async function listAllNodeWithOptions(InstanceId: string, request: ListAllNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAllNodeResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.extended)) {
    query.extended = request.extended;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListAllNode', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/nodes`, 'json', req, runtime);
}

model ListAlternativeSnapshotReposRequest {
  alreadySetItems?: boolean(name='alreadySetItems'),
}

model ListAlternativeSnapshotReposResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      instanceId?: string(name='instanceId'),
      repoPath?: string(name='repoPath'),
    }
  ](name='Result'),
}

model ListAlternativeSnapshotReposResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlternativeSnapshotReposResponseBody(name='body'),
}

async function listAlternativeSnapshotRepos(InstanceId: string, request: ListAlternativeSnapshotReposRequest): ListAlternativeSnapshotReposResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlternativeSnapshotReposWithOptions(InstanceId, request, headers, runtime);
}

async function listAlternativeSnapshotReposWithOptions(InstanceId: string, request: ListAlternativeSnapshotReposRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAlternativeSnapshotReposResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.alreadySetItems)) {
    query.alreadySetItems = request.alreadySetItems;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListAlternativeSnapshotRepos', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/alternative-snapshot-repos`, 'json', req, runtime);
}

model ListApmRequest {
  description?: string(name='description'),
  instanceId?: string(name='instanceId'),
  output?: string(name='output'),
  page?: long(name='page'),
  size?: long(name='size'),
}

model ListApmResponseBody = {
  headers?: {
    xTotalCount?: long(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createdAt?: string(name='createdAt'),
      deployedReplica?: long(name='deployedReplica'),
      description?: string(name='description'),
      instanceId?: string(name='instanceId'),
      nodeAmount?: long(name='nodeAmount'),
      outputES?: string(name='outputES'),
      outputESUserName?: string(name='outputESUserName'),
      ownerId?: string(name='ownerId'),
      paymentType?: string(name='paymentType'),
      region?: string(name='region'),
      replica?: long(name='replica'),
      resourceSpec?: string(name='resourceSpec'),
      status?: string(name='status'),
      version?: string(name='version'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }
  ](name='Result'),
}

model ListApmResponse = {
  headers: map[string]string(name='headers'),
  body: ListApmResponseBody(name='body'),
}

async function listApm(request: ListApmRequest): ListApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listApmWithOptions(request, headers, runtime);
}

async function listApmWithOptions(request: ListApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListApmResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    query.description = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query.instanceId = request.instanceId;
  }
  if (!Util.isUnset(request.output)) {
    query.output = request.output;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListApm', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/apm`, 'json', req, runtime);
}

model ListAvailableEsInstanceIdsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      endpoint?: string(name='endpoint'),
      esInstanceId?: string(name='esInstanceId'),
      kibanaEndpoint?: string(name='kibanaEndpoint'),
    }
  ](name='Result'),
}

model ListAvailableEsInstanceIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableEsInstanceIdsResponseBody(name='body'),
}

async function listAvailableEsInstanceIds(InstanceId: string): ListAvailableEsInstanceIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAvailableEsInstanceIdsWithOptions(InstanceId, headers, runtime);
}

async function listAvailableEsInstanceIdsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListAvailableEsInstanceIdsResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListAvailableEsInstanceIds', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes/${InstanceId}/available-elasticsearch-for-centralized-management`, 'json', req, runtime);
}

model ListCollectorsRequest {
  instanceId?: string(name='instanceId'),
  name?: string(name='name'),
  page?: int32(name='page'),
  resId?: string(name='resId'),
  size?: int32(name='size'),
  sourceType?: string(name='sourceType'),
}

model ListCollectorsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      collectorPaths?: [ string ](name='collectorPaths'),
      configs?: [ 
        {
          content?: string(name='content'),
          fileName?: string(name='fileName'),
        }
      ](name='configs'),
      dryRun?: boolean(name='dryRun'),
      extendConfigs?: [ 
        {
          configType?: string(name='configType'),
          enableMonitoring?: boolean(name='enableMonitoring'),
          groupId?: string(name='groupId'),
          host?: string(name='host'),
          hosts?: [ string ](name='hosts'),
          instanceId?: string(name='instanceId'),
          instanceType?: string(name='instanceType'),
          kibanaHost?: string(name='kibanaHost'),
          machines?: [ 
            {
              agentStatus?: string(name='agentStatus'),
              instanceId?: string(name='instanceId'),
            }
          ](name='machines'),
          protocol?: string(name='protocol'),
          successPodsCount?: string(name='successPodsCount'),
          totalPodsCount?: string(name='totalPodsCount'),
          type?: string(name='type'),
          userName?: string(name='userName'),
        }
      ](name='extendConfigs'),
      gmtCreatedTime?: string(name='gmtCreatedTime'),
      gmtUpdateTime?: string(name='gmtUpdateTime'),
      name?: string(name='name'),
      ownerId?: string(name='ownerId'),
      resId?: string(name='resId'),
      resType?: string(name='resType'),
      resVersion?: string(name='resVersion'),
      status?: string(name='status'),
      vpcId?: string(name='vpcId'),
    }
  ](name='Result'),
}

model ListCollectorsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCollectorsResponseBody(name='body'),
}

async function listCollectors(request: ListCollectorsRequest): ListCollectorsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCollectorsWithOptions(request, headers, runtime);
}

async function listCollectorsWithOptions(request: ListCollectorsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCollectorsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceId)) {
    query.instanceId = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.resId)) {
    query.resId = request.resId;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.sourceType)) {
    query.sourceType = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListCollectors', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/collectors`, 'json', req, runtime);
}

model ListConnectedClustersResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    result?: [ 
    {
      instances?: string(name='instances'),
      networkType?: string(name='networkType'),
    }
  ](name='Result')
  }(name='Result'),
}

model ListConnectedClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListConnectedClustersResponseBody(name='body'),
}

async function listConnectedClusters(InstanceId: string): ListConnectedClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConnectedClustersWithOptions(InstanceId, headers, runtime);
}

async function listConnectedClustersWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListConnectedClustersResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListConnectedClusters', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/connected-clusters`, 'json', req, runtime);
}

model ListDataStreamsRequest {
  isManaged?: boolean(name='isManaged'),
  name?: string(name='name'),
}

model ListDataStreamsResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      health?: string(name='health'),
      ilmPolicyName?: string(name='ilmPolicyName'),
      indexTemplateName?: string(name='indexTemplateName'),
      indices?: [ 
        {
          createTime?: string(name='createTime'),
          health?: string(name='health'),
          isManaged?: boolean(name='isManaged'),
          managedStatus?: string(name='managedStatus'),
          name?: string(name='name'),
          size?: long(name='size'),
        }
      ](name='indices'),
      managedStorageSize?: long(name='managedStorageSize'),
      name?: string(name='name'),
      totalStorageSize?: long(name='totalStorageSize'),
    }
  ](name='Result'),
}

model ListDataStreamsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataStreamsResponseBody(name='body'),
}

async function listDataStreams(InstanceId: string, request: ListDataStreamsRequest): ListDataStreamsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataStreamsWithOptions(InstanceId, request, headers, runtime);
}

async function listDataStreamsWithOptions(InstanceId: string, request: ListDataStreamsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataStreamsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.isManaged)) {
    query.isManaged = request.isManaged;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDataStreams', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/data-streams`, 'json', req, runtime);
}

model ListDataTasksResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='createTime'),
      sinkCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        endpoint?: string(name='endpoint'),
        index?: string(name='index'),
        type?: string(name='type'),
        vpcId?: string(name='vpcId'),
        vpcInstanceId?: string(name='vpcInstanceId'),
        vpcInstancePort?: string(name='vpcInstancePort'),
      }(name='sinkCluster'),
      sourceCluster?: {
        dataSourceType?: string(name='dataSourceType'),
        index?: string(name='index'),
        mapping?: string(name='mapping'),
        routing?: string(name='routing'),
        settings?: string(name='settings'),
        type?: string(name='type'),
      }(name='sourceCluster'),
      status?: string(name='status'),
      taskId?: string(name='taskId'),
    }
  ](name='Result'),
}

model ListDataTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataTasksResponseBody(name='body'),
}

async function listDataTasks(InstanceId: string): ListDataTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataTasksWithOptions(InstanceId, headers, runtime);
}

async function listDataTasksWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataTasksResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListDataTasks', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/data-task`, 'json', req, runtime);
}

model ListDefaultCollectorConfigurationsRequest {
  resType?: string(name='resType'),
  resVersion?: string(name='resVersion'),
  sourceType?: string(name='sourceType'),
}

model ListDefaultCollectorConfigurationsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      fileName?: string(name='fileName'),
    }
  ](name='Result'),
}

model ListDefaultCollectorConfigurationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDefaultCollectorConfigurationsResponseBody(name='body'),
}

async function listDefaultCollectorConfigurations(request: ListDefaultCollectorConfigurationsRequest): ListDefaultCollectorConfigurationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDefaultCollectorConfigurationsWithOptions(request, headers, runtime);
}

async function listDefaultCollectorConfigurationsWithOptions(request: ListDefaultCollectorConfigurationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDefaultCollectorConfigurationsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resType)) {
    query.resType = request.resType;
  }
  if (!Util.isUnset(request.resVersion)) {
    query.resVersion = request.resVersion;
  }
  if (!Util.isUnset(request.sourceType)) {
    query.sourceType = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDefaultCollectorConfigurations', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/beats/default-configurations`, 'json', req, runtime);
}

model ListDiagnoseIndicesRequest {
  lang?: string(name='lang'),
}

model ListDiagnoseIndicesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseIndicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDiagnoseIndicesResponseBody(name='body'),
}

async function listDiagnoseIndices(InstanceId: string, request: ListDiagnoseIndicesRequest): ListDiagnoseIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseIndicesWithOptions(InstanceId, request, headers, runtime);
}

async function listDiagnoseIndicesWithOptions(InstanceId: string, request: ListDiagnoseIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseIndicesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.lang)) {
    query.lang = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDiagnoseIndices', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/diagnosis/instances/${InstanceId}/indices`, 'json', req, runtime);
}

model ListDiagnoseReportRequest {
  detail?: boolean(name='detail'),
  endTime?: long(name='endTime'),
  lang?: string(name='lang'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  startTime?: long(name='startTime'),
  trigger?: string(name='trigger'),
}

model ListDiagnoseReportResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: long(name='createTime'),
      diagnoseItems?: [ 
        {
          detail?: {
            desc?: string(name='desc'),
            name?: string(name='name'),
            result?: string(name='result'),
            suggest?: string(name='suggest'),
            type?: string(name='type'),
          }(name='detail'),
          health?: string(name='health'),
          item?: string(name='item'),
        }
      ](name='diagnoseItems'),
      health?: string(name='health'),
      instanceId?: string(name='instanceId'),
      reportId?: string(name='reportId'),
      state?: string(name='state'),
      trigger?: string(name='trigger'),
    }
  ](name='Result'),
}

model ListDiagnoseReportResponse = {
  headers: map[string]string(name='headers'),
  body: ListDiagnoseReportResponseBody(name='body'),
}

async function listDiagnoseReport(InstanceId: string, request: ListDiagnoseReportRequest): ListDiagnoseReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseReportWithOptions(InstanceId, request, headers, runtime);
}

async function listDiagnoseReportWithOptions(InstanceId: string, request: ListDiagnoseReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseReportResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.detail)) {
    query.detail = request.detail;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query.lang = request.lang;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.trigger)) {
    query.trigger = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDiagnoseReport', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/diagnosis/instances/${InstanceId}/reports`, 'json', req, runtime);
}

model ListDiagnoseReportIdsRequest {
  endTime?: long(name='endTime'),
  lang?: string(name='lang'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  startTime?: long(name='startTime'),
  trigger?: string(name='trigger'),
}

model ListDiagnoseReportIdsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model ListDiagnoseReportIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDiagnoseReportIdsResponseBody(name='body'),
}

async function listDiagnoseReportIds(InstanceId: string, request: ListDiagnoseReportIdsRequest): ListDiagnoseReportIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDiagnoseReportIdsWithOptions(InstanceId, request, headers, runtime);
}

async function listDiagnoseReportIdsWithOptions(InstanceId: string, request: ListDiagnoseReportIdsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDiagnoseReportIdsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query.lang = request.lang;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.trigger)) {
    query.trigger = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDiagnoseReportIds', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/diagnosis/instances/${InstanceId}/report-ids`, 'json', req, runtime);
}

model ListDictInformationRequest {
  analyzerType?: string(name='analyzerType'),
  bucketName?: string(name='bucketName'),
  key?: string(name='key'),
}

model ListDictInformationResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    fileSize?: long(name='fileSize'),
    ossObject?: {
      bucketName?: string(name='bucketName'),
      etag?: string(name='etag'),
      key?: string(name='key'),
    }(name='ossObject'),
    type?: string(name='type'),
  }(name='Result'),
}

model ListDictInformationResponse = {
  headers: map[string]string(name='headers'),
  body: ListDictInformationResponseBody(name='body'),
}

async function listDictInformation(InstanceId: string, request: ListDictInformationRequest): ListDictInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDictInformationWithOptions(InstanceId, request, headers, runtime);
}

async function listDictInformationWithOptions(InstanceId: string, request: ListDictInformationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDictInformationResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.analyzerType)) {
    query.analyzerType = request.analyzerType;
  }
  if (!Util.isUnset(request.bucketName)) {
    query.bucketName = request.bucketName;
  }
  if (!Util.isUnset(request.key)) {
    query.key = request.key;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDictInformation', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/dict/_info`, 'json', req, runtime);
}

model ListDictsRequest {
  analyzerType?: string(name='analyzerType'),
  name?: string(name='name'),
}

model ListDictsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      downloadUrl?: string(name='downloadUrl'),
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model ListDictsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDictsResponseBody(name='body'),
}

async function listDicts(InstanceId: string, request: ListDictsRequest): ListDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDictsWithOptions(InstanceId, request, headers, runtime);
}

async function listDictsWithOptions(InstanceId: string, request: ListDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDictsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.analyzerType)) {
    query.analyzerType = request.analyzerType;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListDicts', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/dicts`, 'json', req, runtime);
}

model ListEcsInstancesRequest {
  ecsInstanceIds?: string(name='ecsInstanceIds'),
  ecsInstanceName?: string(name='ecsInstanceName'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  tags?: string(name='tags'),
  vpcId?: string(name='vpcId'),
}

model ListEcsInstancesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      cloudAssistantStatus?: string(name='cloudAssistantStatus'),
      collectors?: [ 
        {
          collectorPaths?: [ string ](name='collectorPaths'),
          configs?: [ 
            {
              content?: string(name='content'),
              fileName?: string(name='fileName'),
            }
          ](name='configs'),
          dryRun?: boolean(name='dryRun'),
          extendConfigs?: [ 
            {
              configType?: string(name='configType'),
              enableMonitoring?: boolean(name='enableMonitoring'),
              groupId?: string(name='groupId'),
              hosts?: [ string ](name='hosts'),
              instanceId?: string(name='instanceId'),
              instanceType?: string(name='instanceType'),
              machines?: [ 
                {
                  agentStatus?: string(name='agentStatus'),
                  instanceId?: string(name='instanceId'),
                }
              ](name='machines'),
              protocol?: string(name='protocol'),
              type?: string(name='type'),
              userName?: string(name='userName'),
            }
          ](name='extendConfigs'),
          gmtCreatedTime?: string(name='gmtCreatedTime'),
          gmtUpdateTime?: string(name='gmtUpdateTime'),
          name?: string(name='name'),
          ownerId?: string(name='ownerId'),
          resId?: string(name='resId'),
          resType?: string(name='resType'),
          resVersion?: string(name='resVersion'),
          status?: string(name='status'),
          vpcId?: string(name='vpcId'),
        }
      ](name='collectors'),
      ecsInstanceId?: string(name='ecsInstanceId'),
      ecsInstanceName?: string(name='ecsInstanceName'),
      ipAddress?: [ 
        {
          host?: string(name='host'),
          ipType?: string(name='ipType'),
        }
      ](name='ipAddress'),
      osType?: string(name='osType'),
      status?: string(name='status'),
      tags?: string(name='tags'),
    }
  ](name='Result'),
}

model ListEcsInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEcsInstancesResponseBody(name='body'),
}

async function listEcsInstances(request: ListEcsInstancesRequest): ListEcsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEcsInstancesWithOptions(request, headers, runtime);
}

async function listEcsInstancesWithOptions(request: ListEcsInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEcsInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.ecsInstanceIds)) {
    query.ecsInstanceIds = request.ecsInstanceIds;
  }
  if (!Util.isUnset(request.ecsInstanceName)) {
    query.ecsInstanceName = request.ecsInstanceName;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query.tags = request.tags;
  }
  if (!Util.isUnset(request.vpcId)) {
    query.vpcId = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListEcsInstances', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/ecs`, 'json', req, runtime);
}

model ListExtendfilesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      filePath?: string(name='filePath'),
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
    }
  ](name='Result'),
}

model ListExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListExtendfilesResponseBody(name='body'),
}

async function listExtendfiles(InstanceId: string): ListExtendfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExtendfilesWithOptions(InstanceId, headers, runtime);
}

async function listExtendfilesWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListExtendfilesResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListExtendfiles', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes/${InstanceId}/extendfiles`, 'json', req, runtime);
}

model ListILMPoliciesRequest {
  policyName?: string(name='policyName'),
}

model ListILMPoliciesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      name?: string(name='name'),
      phases?: map[string]any(name='phases'),
    }
  ](name='Result'),
}

model ListILMPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: ListILMPoliciesResponseBody(name='body'),
}

async function listILMPolicies(InstanceId: string, request: ListILMPoliciesRequest): ListILMPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listILMPoliciesWithOptions(InstanceId, request, headers, runtime);
}

async function listILMPoliciesWithOptions(InstanceId: string, request: ListILMPoliciesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListILMPoliciesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.policyName)) {
    query.policyName = request.policyName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListILMPolicies', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/ilm-policies`, 'json', req, runtime);
}

model ListIndexTemplatesRequest {
  indexTemplate?: string(name='indexTemplate'),
}

model ListIndexTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      dataStream?: boolean(name='dataStream'),
      ilmPolicy?: string(name='ilmPolicy'),
      indexPatterns?: [ string ](name='indexPatterns'),
      indexTemplate?: string(name='indexTemplate'),
      priority?: int32(name='priority'),
      template?: {
        aliases?: string(name='aliases'),
        mappings?: string(name='mappings'),
        settings?: string(name='settings'),
      }(name='template'),
    }
  ](name='Result'),
}

model ListIndexTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListIndexTemplatesResponseBody(name='body'),
}

async function listIndexTemplates(InstanceId: string, request: ListIndexTemplatesRequest): ListIndexTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIndexTemplatesWithOptions(InstanceId, request, headers, runtime);
}

async function listIndexTemplatesWithOptions(InstanceId: string, request: ListIndexTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIndexTemplatesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.indexTemplate)) {
    query.indexTemplate = request.indexTemplate;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListIndexTemplates', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/index-templates`, 'json', req, runtime);
}

model ListInstanceRequest {
  description?: string(name='description'),
  esVersion?: string(name='esVersion'),
  instanceCategory?: string(name='instanceCategory'),
  instanceId?: string(name='instanceId'),
  page?: int32(name='page'),
  paymentType?: string(name='paymentType'),
  resourceGroupId?: string(name='resourceGroupId'),
  size?: int32(name='size'),
  tags?: string(name='tags'),
  vpcId?: string(name='vpcId'),
  zoneId?: string(name='zoneId'),
}

model ListInstanceResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      advancedDedicateMaster?: boolean(name='advancedDedicateMaster'),
      clientNodeConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='clientNodeConfiguration'),
      createdAt?: string(name='createdAt'),
      dedicateMaster?: boolean(name='dedicateMaster'),
      description?: string(name='description'),
      elasticDataNodeConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskEncryption?: boolean(name='diskEncryption'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='elasticDataNodeConfiguration'),
      esVersion?: string(name='esVersion'),
      extendConfigs?: [  map[string]any ](name='extendConfigs'),
      instanceId?: string(name='instanceId'),
      isNewDeployment?: string(name='isNewDeployment'),
      kibanaConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='kibanaConfiguration'),
      masterConfiguration?: {
        amount?: int32(name='amount'),
        disk?: int32(name='disk'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='masterConfiguration'),
      networkConfig?: {
        type?: string(name='type'),
        vpcId?: string(name='vpcId'),
        vsArea?: string(name='vsArea'),
        vswitchId?: string(name='vswitchId'),
      }(name='networkConfig'),
      nodeAmount?: int32(name='nodeAmount'),
      nodeSpec?: {
        disk?: int32(name='disk'),
        diskEncryption?: boolean(name='diskEncryption'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='nodeSpec'),
      paymentType?: string(name='paymentType'),
      postpaidServiceStatus?: string(name='postpaidServiceStatus'),
      resourceGroupId?: string(name='resourceGroupId'),
      serviceVpc?: boolean(name='serviceVpc'),
      status?: string(name='status'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey'),
          tagValue?: string(name='tagValue'),
        }
      ](name='tags'),
      updatedAt?: string(name='updatedAt'),
    }
  ](name='Result'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceWithOptions(request, headers, runtime);
}

async function listInstanceWithOptions(request: ListInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    query.description = request.description;
  }
  if (!Util.isUnset(request.esVersion)) {
    query.esVersion = request.esVersion;
  }
  if (!Util.isUnset(request.instanceCategory)) {
    query.instanceCategory = request.instanceCategory;
  }
  if (!Util.isUnset(request.instanceId)) {
    query.instanceId = request.instanceId;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.paymentType)) {
    query.paymentType = request.paymentType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query.resourceGroupId = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query.tags = request.tags;
  }
  if (!Util.isUnset(request.vpcId)) {
    query.vpcId = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query.zoneId = request.zoneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListInstance', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances`, 'json', req, runtime);
}

model ListInstanceIndicesRequest {
  all?: boolean(name='all'),
  isManaged?: boolean(name='isManaged'),
  isOpenstore?: boolean(name='isOpenstore'),
  name?: string(name='name'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListInstanceIndicesResponseBody = {
  headers?: {
    xManagedCount?: int32(name='X-Managed-Count'),
    xManagedStorageSize?: long(name='X-Managed-StorageSize'),
    xOSSCount?: int32(name='X-OSS-Count'),
    xOSSStorageSize?: long(name='X-OSS-StorageSize'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      createTime?: string(name='createTime'),
      health?: string(name='health'),
      ilmExplain?: string(name='ilmExplain'),
      isManaged?: string(name='isManaged'),
      managedStatus?: string(name='managedStatus'),
      name?: string(name='name'),
      phase?: string(name='phase'),
      size?: long(name='size'),
    }
  ](name='Result'),
}

model ListInstanceIndicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceIndicesResponseBody(name='body'),
}

async function listInstanceIndices(InstanceId: string, request: ListInstanceIndicesRequest): ListInstanceIndicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceIndicesWithOptions(InstanceId, request, headers, runtime);
}

async function listInstanceIndicesWithOptions(InstanceId: string, request: ListInstanceIndicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceIndicesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.all)) {
    query.all = request.all;
  }
  if (!Util.isUnset(request.isManaged)) {
    query.isManaged = request.isManaged;
  }
  if (!Util.isUnset(request.isOpenstore)) {
    query.isOpenstore = request.isOpenstore;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListInstanceIndices', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/indices`, 'json', req, runtime);
}

model ListKibanaPluginsRequest {
  page?: string(name='page'),
  size?: int32(name='size'),
}

model ListKibanaPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      source?: string(name='source'),
      specificationUrl?: string(name='specificationUrl'),
      state?: string(name='state'),
    }
  ](name='Result'),
}

model ListKibanaPluginsResponse = {
  headers: map[string]string(name='headers'),
  body: ListKibanaPluginsResponseBody(name='body'),
}

async function listKibanaPlugins(InstanceId: string, request: ListKibanaPluginsRequest): ListKibanaPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listKibanaPluginsWithOptions(InstanceId, request, headers, runtime);
}

async function listKibanaPluginsWithOptions(InstanceId: string, request: ListKibanaPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListKibanaPluginsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListKibanaPlugins', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/kibana-plugins`, 'json', req, runtime);
}

model ListLogstashRequest {
  description?: string(name='description'),
  instanceId?: string(name='instanceId'),
  ownerId?: string(name='ownerId'),
  page?: int32(name='page'),
  resourceGroupId?: string(name='resourceGroupId'),
  size?: int32(name='size'),
  version?: string(name='version'),
}

model ListLogstashResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tags?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tags'),
      createdAt?: string(name='createdAt'),
      description?: string(name='description'),
      instanceId?: string(name='instanceId'),
      networkConfig?: {
        type?: string(name='type'),
        vpcId?: string(name='vpcId'),
        vsArea?: string(name='vsArea'),
        vswitchId?: string(name='vswitchId'),
      }(name='networkConfig'),
      nodeAmount?: int32(name='nodeAmount'),
      nodeSpec?: {
        disk?: int32(name='disk'),
        diskEncryption?: boolean(name='diskEncryption'),
        diskType?: string(name='diskType'),
        spec?: string(name='spec'),
      }(name='nodeSpec'),
      paymentType?: string(name='paymentType'),
      status?: string(name='status'),
      updatedAt?: string(name='updatedAt'),
      version?: string(name='version'),
    }
  ](name='Result'),
}

model ListLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogstashResponseBody(name='body'),
}

async function listLogstash(request: ListLogstashRequest): ListLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashWithOptions(request, headers, runtime);
}

async function listLogstashWithOptions(request: ListLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    query.description = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query.instanceId = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query.ownerId = request.ownerId;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query.resourceGroupId = request.resourceGroupId;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.version)) {
    query.version = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListLogstash', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes`, 'json', req, runtime);
}

model ListLogstashLogRequest {
  beginTime?: long(name='beginTime'),
  endTime?: long(name='endTime'),
  page?: int32(name='page'),
  query?: string(name='query'),
  size?: int32(name='size'),
  type?: string(name='type'),
}

model ListLogstashLogResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      host?: string(name='host'),
      instanceId?: string(name='instanceId'),
      level?: string(name='level'),
      timestamp?: long(name='timestamp'),
    }
  ](name='Result'),
}

model ListLogstashLogResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogstashLogResponseBody(name='body'),
}

async function listLogstashLog(InstanceId: string, request: ListLogstashLogRequest): ListLogstashLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashLogWithOptions(InstanceId, request, headers, runtime);
}

async function listLogstashLogWithOptions(InstanceId: string, request: ListLogstashLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashLogResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.beginTime)) {
    query.beginTime = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.query)) {
    query.query = request.query;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.type)) {
    query.type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListLogstashLog', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes/${InstanceId}/search-log`, 'json', req, runtime);
}

model ListLogstashPluginsRequest {
  name?: string(name='name'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  source?: string(name='source'),
}

model ListLogstashPluginsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      source?: string(name='source'),
      specificationUrl?: string(name='specificationUrl'),
      state?: string(name='state'),
    }
  ](name='Result'),
}

model ListLogstashPluginsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogstashPluginsResponseBody(name='body'),
}

async function listLogstashPlugins(InstanceId: string, request: ListLogstashPluginsRequest): ListLogstashPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogstashPluginsWithOptions(InstanceId, request, headers, runtime);
}

async function listLogstashPluginsWithOptions(InstanceId: string, request: ListLogstashPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogstashPluginsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query.source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListLogstashPlugins', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes/${InstanceId}/plugins`, 'json', req, runtime);
}

model ListNodesRequest {
  ecsInstanceIds?: string(name='ecsInstanceIds'),
  ecsInstanceName?: string(name='ecsInstanceName'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  tags?: string(name='tags'),
}

model ListNodesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      agentStatus?: string(name='agentStatus'),
      cloudAssistantStatus?: string(name='cloudAssistantStatus'),
      ecsInstanceId?: string(name='ecsInstanceId'),
      ecsInstanceName?: string(name='ecsInstanceName'),
      ipAddress?: [ 
        {
          host?: string(name='host'),
          ipType?: string(name='ipType'),
        }
      ](name='ipAddress'),
      osType?: string(name='osType'),
      status?: string(name='status'),
      tags?: [ 
        {
          tagKey?: string(name='tagKey'),
          tagValue?: string(name='tagValue'),
        }
      ](name='tags'),
    }
  ](name='Result'),
}

model ListNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNodesResponseBody(name='body'),
}

async function listNodes(ResId: string, request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNodesWithOptions(ResId, request, headers, runtime);
}

async function listNodesWithOptions(ResId: string, request: ListNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(request);
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.ecsInstanceIds)) {
    query.ecsInstanceIds = request.ecsInstanceIds;
  }
  if (!Util.isUnset(request.ecsInstanceName)) {
    query.ecsInstanceName = request.ecsInstanceName;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query.tags = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListNodes', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/collectors/${ResId}/nodes`, 'json', req, runtime);
}

model ListPipelineRequest {
  page?: int32(name='page'),
  pipelineId?: string(name='pipelineId'),
  size?: int32(name='size'),
}

model ListPipelineResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      gmtCreatedTime?: string(name='gmtCreatedTime'),
      gmtUpdateTime?: string(name='gmtUpdateTime'),
      pipelineId?: string(name='pipelineId'),
      pipelineStatus?: string(name='pipelineStatus'),
    }
  ](name='Result'),
}

model ListPipelineResponse = {
  headers: map[string]string(name='headers'),
  body: ListPipelineResponseBody(name='body'),
}

async function listPipeline(InstanceId: string, request: ListPipelineRequest): ListPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineWithOptions(InstanceId, request, headers, runtime);
}

async function listPipelineWithOptions(InstanceId: string, request: ListPipelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query.pipelineId = request.pipelineId;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListPipeline', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/logstashes/${InstanceId}/pipelines`, 'json', req, runtime);
}

model ListPipelineIdsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      available?: boolean(name='available'),
      code?: string(name='code'),
      message?: string(name='message'),
      pipelineId?: string(name='pipelineId'),
    }
  ](name='Result'),
}

model ListPipelineIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPipelineIdsResponseBody(name='body'),
}

async function listPipelineIds(InstanceId: string): ListPipelineIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelineIdsWithOptions(InstanceId, headers, runtime);
}

async function listPipelineIdsWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelineIdsResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListPipelineIds', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/pipeline-ids`, 'json', req, runtime);
}

model ListPluginsRequest {
  name?: string(name='name'),
  page?: string(name='page'),
  size?: int32(name='size'),
  source?: string(name='source'),
}

model ListPluginsResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      description?: string(name='description'),
      name?: string(name='name'),
      source?: string(name='source'),
      specificationUrl?: string(name='specificationUrl'),
      state?: string(name='state'),
    }
  ](name='Result'),
}

model ListPluginsResponse = {
  headers: map[string]string(name='headers'),
  body: ListPluginsResponseBody(name='body'),
}

async function listPlugins(InstanceId: string, request: ListPluginsRequest): ListPluginsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPluginsWithOptions(InstanceId, request, headers, runtime);
}

async function listPluginsWithOptions(InstanceId: string, request: ListPluginsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPluginsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.source)) {
    query.source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListPlugins', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/plugins`, 'json', req, runtime);
}

model ListSearchLogRequest {
  beginTime?: long(name='beginTime'),
  endTime?: long(name='endTime'),
  page?: int32(name='page'),
  query?: string(name='query'),
  size?: int32(name='size'),
  type?: string(name='type'),
}

model ListSearchLogResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      contentCollection?: map[string]any(name='contentCollection'),
      host?: string(name='host'),
      instanceId?: string(name='instanceId'),
      level?: string(name='level'),
      timestamp?: long(name='timestamp'),
    }
  ](name='Result'),
}

model ListSearchLogResponse = {
  headers: map[string]string(name='headers'),
  body: ListSearchLogResponseBody(name='body'),
}

async function listSearchLog(InstanceId: string, request: ListSearchLogRequest): ListSearchLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSearchLogWithOptions(InstanceId, request, headers, runtime);
}

async function listSearchLogWithOptions(InstanceId: string, request: ListSearchLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSearchLogResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.beginTime)) {
    query.beginTime = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.query)) {
    query.query = request.query;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.type)) {
    query.type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListSearchLog', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/search-log`, 'json', req, runtime);
}

model ListShardRecoveriesRequest {
  activeOnly?: boolean(name='activeOnly'),
}

model ListShardRecoveriesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      bytesPercent?: string(name='bytesPercent'),
      bytesTotal?: long(name='bytesTotal'),
      filesPercent?: string(name='filesPercent'),
      filesTotal?: long(name='filesTotal'),
      index?: string(name='index'),
      sourceHost?: string(name='sourceHost'),
      sourceNode?: string(name='sourceNode'),
      stage?: string(name='stage'),
      targetHost?: string(name='targetHost'),
      targetNode?: string(name='targetNode'),
      translogOps?: long(name='translogOps'),
      translogOpsPercent?: string(name='translogOpsPercent'),
    }
  ](name='Result'),
}

model ListShardRecoveriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListShardRecoveriesResponseBody(name='body'),
}

async function listShardRecoveries(InstanceId: string, request: ListShardRecoveriesRequest): ListShardRecoveriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShardRecoveriesWithOptions(InstanceId, request, headers, runtime);
}

async function listShardRecoveriesWithOptions(InstanceId: string, request: ListShardRecoveriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListShardRecoveriesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.activeOnly)) {
    query.activeOnly = request.activeOnly;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListShardRecoveries', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/cat-recovery`, 'json', req, runtime);
}

model ListSnapshotReposByInstanceIdResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      instanceId?: string(name='instanceId'),
      repoPath?: string(name='repoPath'),
      snapWarehouse?: string(name='snapWarehouse'),
      status?: string(name='status'),
    }
  ](name='Result'),
}

model ListSnapshotReposByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  body: ListSnapshotReposByInstanceIdResponseBody(name='body'),
}

async function listSnapshotReposByInstanceId(InstanceId: string): ListSnapshotReposByInstanceIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSnapshotReposByInstanceIdWithOptions(InstanceId, headers, runtime);
}

async function listSnapshotReposByInstanceIdWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSnapshotReposByInstanceIdResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListSnapshotReposByInstanceId', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/snapshot-repos`, 'json', req, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  page?: int32(name='Page'),
  resourceIds?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  size?: int32(name='Size'),
  tags?: string(name='Tags'),
}

model ListTagResourcesResponseBody = {
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='Headers'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        tagKey?: string(name='TagKey'),
        tagValue?: string(name='TagValue'),
      }
    ](name='TagResource'),
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.nextToken)) {
    query.NextToken = request.nextToken;
  }
  if (!Util.isUnset(request.page)) {
    query.Page = request.page;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query.ResourceIds = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query.ResourceType = request.resourceType;
  }
  if (!Util.isUnset(request.size)) {
    query.Size = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    query.Tags = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTagResources', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/tags`, 'json', req, runtime);
}

model ListTagsRequest {
  pageSize?: int32(name='pageSize'),
  resourceType?: string(name='resourceType'),
}

model ListTagsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Result'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagsResponseBody(name='body'),
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagsWithOptions(request, headers, runtime);
}

async function listTagsWithOptions(request: ListTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageSize)) {
    query.pageSize = request.pageSize;
  }
  if (!Util.isUnset(request.resourceType)) {
    query.resourceType = request.resourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTags', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/tags/all-tags`, 'json', req, runtime);
}

model ListVpcEndpointsRequest {
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListVpcEndpointsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      connectionStatus?: string(name='connectionStatus'),
      createTime?: string(name='createTime'),
      endpointBusinessStatus?: string(name='endpointBusinessStatus'),
      endpointDomain?: string(name='endpointDomain'),
      endpointId?: string(name='endpointId'),
      endpointName?: string(name='endpointName'),
      endpointStatus?: string(name='endpointStatus'),
      serviceId?: string(name='serviceId'),
      serviceName?: string(name='serviceName'),
    }
  ](name='Result'),
}

model ListVpcEndpointsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcEndpointsResponseBody(name='body'),
}

async function listVpcEndpoints(InstanceId: string, request: ListVpcEndpointsRequest): ListVpcEndpointsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcEndpointsWithOptions(InstanceId, request, headers, runtime);
}

async function listVpcEndpointsWithOptions(InstanceId: string, request: ListVpcEndpointsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcEndpointsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListVpcEndpoints', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/vpc-endpoints`, 'json', req, runtime);
}

model MigrateToOtherZoneRequest {
  dryRun?: boolean(name='dryRun'),
}

model MigrateToOtherZoneResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model MigrateToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  body: MigrateToOtherZoneResponseBody(name='body'),
}

async function migrateToOtherZone(InstanceId: string, request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return migrateToOtherZoneWithOptions(InstanceId, request, headers, runtime);
}

async function migrateToOtherZoneWithOptions(InstanceId: string, request: MigrateToOtherZoneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MigrateToOtherZoneResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dryRun)) {
    query.dryRun = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('MigrateToOtherZone', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/migrate-zones`, 'json', req, runtime);
}

model ModifyDeployMachineRequest {
  clientToken?: string(name='ClientToken'),
}

model ModifyDeployMachineResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyDeployMachineResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDeployMachineResponseBody(name='body'),
}

async function modifyDeployMachine(ResId: string, request: ModifyDeployMachineRequest): ModifyDeployMachineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyDeployMachineWithOptions(ResId, request, headers, runtime);
}

async function modifyDeployMachineWithOptions(ResId: string, request: ModifyDeployMachineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyDeployMachineResponse {
  Util.validateModel(request);
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ModifyDeployMachine', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/collectors/${ResId}/actions/modify-deploy-machines`, 'json', req, runtime);
}

model ModifyElastictaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    elasticExpansionTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticExpansionTask'),
    elasticShrinkTask?: {
      cronExpression?: string(name='cronExpression'),
      elasticNodeCount?: int32(name='elasticNodeCount'),
      replicaCount?: int32(name='replicaCount'),
      targetIndices?: [ string ](name='targetIndices'),
      triggerType?: string(name='triggerType'),
    }(name='elasticShrinkTask'),
  }(name='Result'),
}

model ModifyElastictaskResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyElastictaskResponseBody(name='body'),
}

async function modifyElastictask(InstanceId: string): ModifyElastictaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyElastictaskWithOptions(InstanceId, headers, runtime);
}

async function modifyElastictaskWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyElastictaskResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ModifyElastictask', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/elastic-task`, 'json', req, runtime);
}

model ModifyInstanceMaintainTimeRequest {
  clientToken?: string(name='ClientToken'),
}

model ModifyInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyInstanceMaintainTime(InstanceId: string, request: ModifyInstanceMaintainTimeRequest): ModifyInstanceMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyInstanceMaintainTimeWithOptions(InstanceId, request, headers, runtime);
}

async function modifyInstanceMaintainTimeWithOptions(InstanceId: string, request: ModifyInstanceMaintainTimeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyInstanceMaintainTimeResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ModifyInstanceMaintainTime', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/modify-maintaintime`, 'json', req, runtime);
}

model ModifyWhiteIpsRequest {
  clientToken?: string(name='clientToken'),
  modifyMode?: string(name='modifyMode'),
  networkType?: string(name='networkType'),
  nodeType?: string(name='nodeType'),
  whiteIpGroup?: {
    groupName?: string(name='groupName'),
    ips?: [ string ](name='ips'),
  }(name='whiteIpGroup'),
  whiteIpList?: [ string ](name='whiteIpList'),
}

model ModifyWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ModifyWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWhiteIpsResponseBody(name='body'),
}

async function modifyWhiteIps(InstanceId: string, request: ModifyWhiteIpsRequest): ModifyWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function modifyWhiteIpsWithOptions(InstanceId: string, request: ModifyWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyWhiteIpsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.modifyMode)) {
    body.modifyMode = request.modifyMode;
  }
  if (!Util.isUnset(request.networkType)) {
    body.networkType = request.networkType;
  }
  if (!Util.isUnset(request.nodeType)) {
    body.nodeType = request.nodeType;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body.whiteIpGroup = request.whiteIpGroup;
  }
  if (!Util.isUnset(request.whiteIpList)) {
    body.whiteIpList = request.whiteIpList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('ModifyWhiteIps', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/modify-white-ips`, 'json', req, runtime);
}

model MoveResourceGroupRequest {
  clientToken?: string(name='clientToken'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    esVersion?: string(name='esVersion'),
    instanceId?: string(name='instanceId'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaPort?: int32(name='kibanaPort'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    publicDomain?: string(name='publicDomain'),
    publicPort?: int32(name='publicPort'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    updatedAt?: string(name='updatedAt'),
  }(name='Result'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroup(InstanceId: string, request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return moveResourceGroupWithOptions(InstanceId, request, headers, runtime);
}

async function moveResourceGroupWithOptions(InstanceId: string, request: MoveResourceGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('MoveResourceGroup', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/resourcegroup`, 'json', req, runtime);
}

model OpenDiagnosisRequest {
  clientToken?: string(name='ClientToken'),
  lang?: string(name='lang'),
}

model OpenDiagnosisResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model OpenDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: OpenDiagnosisResponseBody(name='body'),
}

async function openDiagnosis(InstanceId: string, request: OpenDiagnosisRequest): OpenDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openDiagnosisWithOptions(InstanceId, request, headers, runtime);
}

async function openDiagnosisWithOptions(InstanceId: string, request: OpenDiagnosisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenDiagnosisResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query.lang = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('OpenDiagnosis', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/diagnosis/instances/${InstanceId}/actions/open-diagnosis`, 'json', req, runtime);
}

model OpenHttpsRequest {
  clientToken?: string(name='clientToken'),
}

model OpenHttpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model OpenHttpsResponse = {
  headers: map[string]string(name='headers'),
  body: OpenHttpsResponseBody(name='body'),
}

async function openHttps(InstanceId: string, request: OpenHttpsRequest): OpenHttpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openHttpsWithOptions(InstanceId, request, headers, runtime);
}

async function openHttpsWithOptions(InstanceId: string, request: OpenHttpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenHttpsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('OpenHttps', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/open-https`, 'json', req, runtime);
}

model PostEmonTryAlarmRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PostEmonTryAlarmRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PostEmonTryAlarmRuleResponseBody(name='body'),
}

async function postEmonTryAlarmRule(ProjectId: string, AlarmGroupId: string): PostEmonTryAlarmRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return postEmonTryAlarmRuleWithOptions(ProjectId, AlarmGroupId, headers, runtime);
}

async function postEmonTryAlarmRuleWithOptions(ProjectId: string, AlarmGroupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): PostEmonTryAlarmRuleResponse {
  ProjectId = OpenApiUtil.getEncodeParam(ProjectId);
  AlarmGroupId = OpenApiUtil.getEncodeParam(AlarmGroupId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('PostEmonTryAlarmRule', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/emon/projects/${ProjectId}/alarm-groups/${AlarmGroupId}/alarm-rules/_test`, 'json', req, runtime);
}

model RecommendTemplatesRequest {
  usageScenario?: string(name='usageScenario'),
}

model RecommendTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      content?: string(name='content'),
      templateName?: string(name='templateName'),
    }
  ](name='Result'),
}

model RecommendTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: RecommendTemplatesResponseBody(name='body'),
}

async function recommendTemplates(InstanceId: string, request: RecommendTemplatesRequest): RecommendTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return recommendTemplatesWithOptions(InstanceId, request, headers, runtime);
}

async function recommendTemplatesWithOptions(InstanceId: string, request: RecommendTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RecommendTemplatesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.usageScenario)) {
    query.usageScenario = request.usageScenario;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RecommendTemplates', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/instances/${InstanceId}/recommended-templates`, 'json', req, runtime);
}

model ReinstallCollectorRequest {
  clientToken?: string(name='ClientToken'),
}

model ReinstallCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ReinstallCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: ReinstallCollectorResponseBody(name='body'),
}

async function reinstallCollector(ResId: string, request: ReinstallCollectorRequest): ReinstallCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return reinstallCollectorWithOptions(ResId, request, headers, runtime);
}

async function reinstallCollectorWithOptions(ResId: string, request: ReinstallCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReinstallCollectorResponse {
  Util.validateModel(request);
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ReinstallCollector', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/collectors/${ResId}/actions/reinstall`, 'json', req, runtime);
}

model RemoveApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RemoveApmResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveApmResponseBody(name='body'),
}

async function removeApm(instanceId: string): RemoveApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeApmWithOptions(instanceId, headers, runtime);
}

async function removeApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveApmResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('RemoveApm', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/apm/${instanceId}`, 'json', req, runtime);
}

model RenewInstanceRequest {
  clientToken?: string(name='clientToken'),
}

model RenewInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(InstanceId: string, request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function renewInstanceWithOptions(InstanceId: string, request: RenewInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RenewInstance', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/renew`, 'json', req, runtime);
}

model RenewLogstashRequest {
  clientToken?: string(name='clientToken'),
}

model RenewLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RenewLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: RenewLogstashResponseBody(name='body'),
}

async function renewLogstash(InstanceId: string, request: RenewLogstashRequest): RenewLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renewLogstashWithOptions(InstanceId, request, headers, runtime);
}

async function renewLogstashWithOptions(InstanceId: string, request: RenewLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenewLogstashResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RenewLogstash', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/actions/renew`, 'json', req, runtime);
}

model RestartCollectorRequest {
  clientToken?: string(name='ClientToken'),
}

model RestartCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RestartCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: RestartCollectorResponseBody(name='body'),
}

async function restartCollector(ResId: string, request: RestartCollectorRequest): RestartCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartCollectorWithOptions(ResId, request, headers, runtime);
}

async function restartCollectorWithOptions(ResId: string, request: RestartCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartCollectorResponse {
  Util.validateModel(request);
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RestartCollector', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/collectors/${ResId}/actions/restart`, 'json', req, runtime);
}

model RestartInstanceRequest {
  clientToken?: string(name='clientToken'),
  force?: boolean(name='force'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    esVersion?: string(name='esVersion'),
    instanceId?: string(name='instanceId'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaPort?: int32(name='kibanaPort'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    publicDomain?: string(name='publicDomain'),
    publicPort?: int32(name='publicPort'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    updatedAt?: string(name='updatedAt'),
  }(name='Result'),
}

model RestartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartInstanceResponseBody(name='body'),
}

async function restartInstance(InstanceId: string, request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function restartInstanceWithOptions(InstanceId: string, request: RestartInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query.force = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RestartInstance', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/restart`, 'json', req, runtime);
}

model RestartLogstashRequest {
  clientToken?: string(name='clientToken'),
  force?: boolean(name='force'),
}

model RestartLogstashResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: RestartLogstashResponseBody(name='body'),
}

async function restartLogstash(InstanceId: string, request: RestartLogstashRequest): RestartLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartLogstashWithOptions(InstanceId, request, headers, runtime);
}

async function restartLogstashWithOptions(InstanceId: string, request: RestartLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartLogstashResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.force)) {
    query.force = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RestartLogstash', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/actions/restart`, 'json', req, runtime);
}

model ResumeElasticsearchTaskRequest {
  clientToken?: string(name='clientToken'),
}

model ResumeElasticsearchTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ResumeElasticsearchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeElasticsearchTaskResponseBody(name='body'),
}

async function resumeElasticsearchTask(InstanceId: string, request: ResumeElasticsearchTaskRequest): ResumeElasticsearchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeElasticsearchTaskWithOptions(InstanceId, request, headers, runtime);
}

async function resumeElasticsearchTaskWithOptions(InstanceId: string, request: ResumeElasticsearchTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeElasticsearchTaskResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ResumeElasticsearchTask', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/resume`, 'json', req, runtime);
}

model ResumeLogstashTaskRequest {
  clientToken?: string(name='clientToken'),
}

model ResumeLogstashTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ResumeLogstashTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeLogstashTaskResponseBody(name='body'),
}

async function resumeLogstashTask(InstanceId: string, request: ResumeLogstashTaskRequest): ResumeLogstashTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeLogstashTaskWithOptions(InstanceId, request, headers, runtime);
}

async function resumeLogstashTaskWithOptions(InstanceId: string, request: ResumeLogstashTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeLogstashTaskResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ResumeLogstashTask', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/actions/resume`, 'json', req, runtime);
}

model RolloverDataStreamRequest {
  clientToken?: string(name='ClientToken'),
}

model RolloverDataStreamResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RolloverDataStreamResponse = {
  headers: map[string]string(name='headers'),
  body: RolloverDataStreamResponseBody(name='body'),
}

async function rolloverDataStream(InstanceId: string, DataStream: string, request: RolloverDataStreamRequest): RolloverDataStreamResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rolloverDataStreamWithOptions(InstanceId, DataStream, request, headers, runtime);
}

async function rolloverDataStreamWithOptions(InstanceId: string, DataStream: string, request: RolloverDataStreamRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RolloverDataStreamResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  DataStream = OpenApiUtil.getEncodeParam(DataStream);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RolloverDataStream', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/data-streams/${DataStream}/rollover`, 'json', req, runtime);
}

model RunPipelinesRequest {
  clientToken?: string(name='ClientToken'),
}

model RunPipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RunPipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: RunPipelinesResponseBody(name='body'),
}

async function runPipelines(InstanceId: string, request: RunPipelinesRequest): RunPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runPipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function runPipelinesWithOptions(InstanceId: string, request: RunPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RunPipelinesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('RunPipelines', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/pipelines/action/run`, 'json', req, runtime);
}

model ShrinkNodeRequest {
  clientToken?: string(name='clientToken'),
  ignoreStatus?: boolean(name='ignoreStatus'),
  nodeType?: string(name='nodeType'),
}

model ShrinkNodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ShrinkNodeResponse = {
  headers: map[string]string(name='headers'),
  body: ShrinkNodeResponseBody(name='body'),
}

async function shrinkNode(InstanceId: string, request: ShrinkNodeRequest): ShrinkNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return shrinkNodeWithOptions(InstanceId, request, headers, runtime);
}

async function shrinkNodeWithOptions(InstanceId: string, request: ShrinkNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ShrinkNodeResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query.ignoreStatus = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query.nodeType = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ShrinkNode', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/shrink`, 'json', req, runtime);
}

model StartApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StartApmResponse = {
  headers: map[string]string(name='headers'),
  body: StartApmResponseBody(name='body'),
}

async function startApm(instanceId: string): StartApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startApmWithOptions(instanceId, headers, runtime);
}

async function startApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartApmResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('StartApm', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/apm/${instanceId}/actions/start`, 'json', req, runtime);
}

model StartCollectorRequest {
  clientToken?: string(name='ClientToken'),
}

model StartCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StartCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: StartCollectorResponseBody(name='body'),
}

async function startCollector(ResId: string, request: StartCollectorRequest): StartCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startCollectorWithOptions(ResId, request, headers, runtime);
}

async function startCollectorWithOptions(ResId: string, request: StartCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartCollectorResponse {
  Util.validateModel(request);
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('StartCollector', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/collectors/${ResId}/actions/start`, 'json', req, runtime);
}

model StopApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StopApmResponse = {
  headers: map[string]string(name='headers'),
  body: StopApmResponseBody(name='body'),
}

async function stopApm(instanceId: string): StopApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopApmWithOptions(instanceId, headers, runtime);
}

async function stopApmWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopApmResponse {
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('StopApm', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/apm/${instanceId}/actions/stop`, 'json', req, runtime);
}

model StopCollectorRequest {
  clientToken?: string(name='ClientToken'),
}

model StopCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StopCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: StopCollectorResponseBody(name='body'),
}

async function stopCollector(ResId: string, request: StopCollectorRequest): StopCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopCollectorWithOptions(ResId, request, headers, runtime);
}

async function stopCollectorWithOptions(ResId: string, request: StopCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopCollectorResponse {
  Util.validateModel(request);
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('StopCollector', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/collectors/${ResId}/actions/stop`, 'json', req, runtime);
}

model StopPipelinesRequest {
  clientToken?: string(name='ClientToken'),
}

model StopPipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model StopPipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: StopPipelinesResponseBody(name='body'),
}

async function stopPipelines(InstanceId: string, request: StopPipelinesRequest): StopPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopPipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function stopPipelinesWithOptions(InstanceId: string, request: StopPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopPipelinesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('StopPipelines', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/pipelines/action/stop`, 'json', req, runtime);
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(headers, runtime);
}

async function tagResourcesWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('TagResources', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/tags`, 'json', req, runtime);
}

model TransferNodeRequest {
  clientToken?: string(name='clientToken'),
  nodeType?: string(name='nodeType'),
}

model TransferNodeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model TransferNodeResponse = {
  headers: map[string]string(name='headers'),
  body: TransferNodeResponseBody(name='body'),
}

async function transferNode(InstanceId: string, request: TransferNodeRequest): TransferNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return transferNodeWithOptions(InstanceId, request, headers, runtime);
}

async function transferNodeWithOptions(InstanceId: string, request: TransferNodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TransferNodeResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.nodeType)) {
    query.nodeType = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('TransferNode', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/transfer`, 'json', req, runtime);
}

model TriggerNetworkRequest {
  actionType?: string(name='actionType'),
  clientToken?: string(name='clientToken'),
  networkType?: string(name='networkType'),
  nodeType?: string(name='nodeType'),
}

model TriggerNetworkResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model TriggerNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: TriggerNetworkResponseBody(name='body'),
}

async function triggerNetwork(InstanceId: string, request: TriggerNetworkRequest): TriggerNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return triggerNetworkWithOptions(InstanceId, request, headers, runtime);
}

async function triggerNetworkWithOptions(InstanceId: string, request: TriggerNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TriggerNetworkResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.actionType)) {
    body.actionType = request.actionType;
  }
  if (!Util.isUnset(request.networkType)) {
    body.networkType = request.networkType;
  }
  if (!Util.isUnset(request.nodeType)) {
    body.nodeType = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('TriggerNetwork', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/network-trigger`, 'json', req, runtime);
}

model UninstallKibanaPluginRequest {
  clientToken?: string(name='clientToken'),
}

model UninstallKibanaPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model UninstallKibanaPluginResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallKibanaPluginResponseBody(name='body'),
}

async function uninstallKibanaPlugin(InstanceId: string, request: UninstallKibanaPluginRequest): UninstallKibanaPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallKibanaPluginWithOptions(InstanceId, request, headers, runtime);
}

async function uninstallKibanaPluginWithOptions(InstanceId: string, request: UninstallKibanaPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallKibanaPluginResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UninstallKibanaPlugin', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/kibana-plugins/actions/uninstall`, 'json', req, runtime);
}

model UninstallLogstashPluginRequest {
  clientToken?: string(name='clientToken'),
}

model UninstallLogstashPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model UninstallLogstashPluginResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallLogstashPluginResponseBody(name='body'),
}

async function uninstallLogstashPlugin(InstanceId: string, request: UninstallLogstashPluginRequest): UninstallLogstashPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallLogstashPluginWithOptions(InstanceId, request, headers, runtime);
}

async function uninstallLogstashPluginWithOptions(InstanceId: string, request: UninstallLogstashPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallLogstashPluginResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UninstallLogstashPlugin', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/plugins/actions/uninstall`, 'json', req, runtime);
}

model UninstallPluginRequest {
  clientToken?: string(name='clientToken'),
}

model UninstallPluginResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ string ](name='Result'),
}

model UninstallPluginResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallPluginResponseBody(name='body'),
}

async function uninstallPlugin(InstanceId: string, request: UninstallPluginRequest): UninstallPluginResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uninstallPluginWithOptions(InstanceId, request, headers, runtime);
}

async function uninstallPluginWithOptions(InstanceId: string, request: UninstallPluginRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UninstallPluginResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UninstallPlugin', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/plugins/actions/uninstall`, 'json', req, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  resourceIds?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKeys?: string(name='TagKeys'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.all)) {
    query.All = request.all;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query.ResourceIds = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query.ResourceType = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query.TagKeys = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UntagResources', '2017-06-13', 'HTTPS', 'DELETE', 'AK', `/openapi/tags`, 'json', req, runtime);
}

model UpdateAdminPasswordRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateAdminPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAdminPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAdminPasswordResponseBody(name='body'),
}

async function updateAdminPassword(InstanceId: string, request: UpdateAdminPasswordRequest): UpdateAdminPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAdminPasswordWithOptions(InstanceId, request, headers, runtime);
}

async function updateAdminPasswordWithOptions(InstanceId: string, request: UpdateAdminPasswordRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAdminPasswordResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateAdminPassword', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/admin-pwd`, 'json', req, runtime);
}

model UpdateAdvancedSettingRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateAdvancedSettingResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateAdvancedSettingResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAdvancedSettingResponseBody(name='body'),
}

async function updateAdvancedSetting(InstanceId: string, request: UpdateAdvancedSettingRequest): UpdateAdvancedSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAdvancedSettingWithOptions(InstanceId, request, headers, runtime);
}

async function updateAdvancedSettingWithOptions(InstanceId: string, request: UpdateAdvancedSettingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAdvancedSettingResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateAdvancedSetting', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/update-advanced-setting`, 'json', req, runtime);
}

model UpdateAliwsDictRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateAliwsDictResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateAliwsDictResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAliwsDictResponseBody(name='body'),
}

async function updateAliwsDict(InstanceId: string, request: UpdateAliwsDictRequest): UpdateAliwsDictResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAliwsDictWithOptions(InstanceId, request, headers, runtime);
}

async function updateAliwsDictWithOptions(InstanceId: string, request: UpdateAliwsDictRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAliwsDictResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateAliwsDict', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/instances/${InstanceId}/aliws-dict`, 'json', req, runtime);
}

model UpdateApmRequest {
  description?: string(name='description', description='apm实例名'),
  outputES?: string(name='outputES', description='es实例id'),
  outputESPassword?: string(name='outputESPassword', description='es实例密码'),
  outputESUserName?: string(name='outputESUserName', description='es实例用户名'),
  token?: string(name='token', description='apm server密码'),
}

model UpdateApmResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateApmResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApmResponseBody(name='body'),
}

async function updateApm(instanceId: string, request: UpdateApmRequest): UpdateApmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApmWithOptions(instanceId, request, headers, runtime);
}

async function updateApmWithOptions(instanceId: string, request: UpdateApmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApmResponse {
  Util.validateModel(request);
  instanceId = OpenApiUtil.getEncodeParam(instanceId);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.outputES)) {
    body.outputES = request.outputES;
  }
  if (!Util.isUnset(request.outputESPassword)) {
    body.outputESPassword = request.outputESPassword;
  }
  if (!Util.isUnset(request.outputESUserName)) {
    body.outputESUserName = request.outputESUserName;
  }
  if (!Util.isUnset(request.token)) {
    body.token = request.token;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateApm', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/apm/${instanceId}`, 'json', req, runtime);
}

model UpdateBlackIpsRequest {
  clientToken?: string(name='clientToken'),
  esIPBlacklist?: [ string ](name='esIPBlacklist'),
}

model UpdateBlackIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    esIPBlacklist?: [ string ](name='esIPBlacklist'),
  }(name='Result'),
}

model UpdateBlackIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBlackIpsResponseBody(name='body'),
}

async function updateBlackIps(InstanceId: string, request: UpdateBlackIpsRequest): UpdateBlackIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateBlackIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updateBlackIpsWithOptions(InstanceId: string, request: UpdateBlackIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateBlackIpsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.esIPBlacklist)) {
    body.esIPBlacklist = request.esIPBlacklist;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('UpdateBlackIps', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/black-ips`, 'json', req, runtime);
}

model UpdateCollectorRequest {
  clientToken?: string(name='ClientToken'),
}

model UpdateCollectorResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content'),
        fileName?: string(name='fileName'),
      }
    ](name='configs'),
    dryRun?: boolean(name='dryRun'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType'),
        enableMonitoring?: boolean(name='enableMonitoring'),
        groupId?: string(name='groupId'),
        host?: string(name='host'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId'),
        instanceType?: string(name='instanceType'),
        kibanaHost?: string(name='kibanaHost'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus'),
            instanceId?: string(name='instanceId'),
          }
        ](name='machines'),
        protocol?: string(name='protocol'),
        successPodsCount?: string(name='successPodsCount'),
        totalPodsCount?: string(name='totalPodsCount'),
        type?: string(name='type'),
        userName?: string(name='userName'),
      }
    ](name='extendConfigs'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    name?: string(name='name'),
    ownerId?: string(name='ownerId'),
    resId?: string(name='resId'),
    resType?: string(name='resType'),
    resVersion?: string(name='resVersion'),
    status?: string(name='status'),
    vpcId?: string(name='vpcId'),
  }(name='Result'),
}

model UpdateCollectorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCollectorResponseBody(name='body'),
}

async function updateCollector(ResId: string, request: UpdateCollectorRequest): UpdateCollectorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCollectorWithOptions(ResId, request, headers, runtime);
}

async function updateCollectorWithOptions(ResId: string, request: UpdateCollectorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCollectorResponse {
  Util.validateModel(request);
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateCollector', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/collectors/${ResId}`, 'json', req, runtime);
}

model UpdateCollectorNameRequest {
  clientToken?: string(name='ClientToken'),
}

model UpdateCollectorNameResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    collectorPaths?: [ string ](name='collectorPaths'),
    configs?: [ 
      {
        content?: string(name='content'),
        fileName?: string(name='fileName'),
      }
    ](name='configs'),
    dryRun?: boolean(name='dryRun'),
    extendConfigs?: [ 
      {
        configType?: string(name='configType'),
        enableMonitoring?: boolean(name='enableMonitoring'),
        groupId?: string(name='groupId'),
        host?: string(name='host'),
        hosts?: [ string ](name='hosts'),
        instanceId?: string(name='instanceId'),
        instanceType?: string(name='instanceType'),
        kibanaHost?: string(name='kibanaHost'),
        machines?: [ 
          {
            agentStatus?: string(name='agentStatus'),
            instanceId?: string(name='instanceId'),
          }
        ](name='machines'),
        protocol?: string(name='protocol'),
        successPodsCount?: string(name='successPodsCount'),
        totalPodsCount?: string(name='totalPodsCount'),
        type?: string(name='type'),
        userName?: string(name='userName'),
      }
    ](name='extendConfigs'),
    gmtCreatedTime?: string(name='gmtCreatedTime'),
    gmtUpdateTime?: string(name='gmtUpdateTime'),
    name?: string(name='name'),
    ownerId?: string(name='ownerId'),
    resId?: string(name='resId'),
    resType?: string(name='resType'),
    resVersion?: string(name='resVersion'),
    status?: string(name='status'),
    vpcId?: string(name='vpcId'),
  }(name='Result'),
}

model UpdateCollectorNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCollectorNameResponseBody(name='body'),
}

async function updateCollectorName(ResId: string, request: UpdateCollectorNameRequest): UpdateCollectorNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCollectorNameWithOptions(ResId, request, headers, runtime);
}

async function updateCollectorNameWithOptions(ResId: string, request: UpdateCollectorNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCollectorNameResponse {
  Util.validateModel(request);
  ResId = OpenApiUtil.getEncodeParam(ResId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateCollectorName', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/collectors/${ResId}/actions/rename`, 'json', req, runtime);
}

model UpdateDescriptionRequest {
  description?: string(name='description'),
  clientToken?: string(name='clientToken'),
}

model UpdateDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    description?: string(name='description'),
  }(name='Result'),
}

model UpdateDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDescriptionResponseBody(name='body'),
}

async function updateDescription(InstanceId: string, request: UpdateDescriptionRequest): UpdateDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDescriptionWithOptions(InstanceId, request, headers, runtime);
}

async function updateDescriptionWithOptions(InstanceId: string, request: UpdateDescriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDescriptionResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateDescription', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/description`, 'json', req, runtime);
}

model UpdateDiagnosisSettingsRequest {
  clientToken?: string(name='ClientToken'),
  lang?: string(name='lang'),
}

model UpdateDiagnosisSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateDiagnosisSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDiagnosisSettingsResponseBody(name='body'),
}

async function updateDiagnosisSettings(InstanceId: string, request: UpdateDiagnosisSettingsRequest): UpdateDiagnosisSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDiagnosisSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function updateDiagnosisSettingsWithOptions(InstanceId: string, request: UpdateDiagnosisSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDiagnosisSettingsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.lang)) {
    query.lang = request.lang;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateDiagnosisSettings', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/diagnosis/instances/${InstanceId}/settings`, 'json', req, runtime);
}

model UpdateDictRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateDictResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateDictResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDictResponseBody(name='body'),
}

async function updateDict(InstanceId: string, request: UpdateDictRequest): UpdateDictResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDictWithOptions(InstanceId, request, headers, runtime);
}

async function updateDictWithOptions(InstanceId: string, request: UpdateDictRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDictResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateDict', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/instances/${InstanceId}/dict`, 'json', req, runtime);
}

model UpdateExtendConfigRequest {
  clientToken?: string(name='ClientToken'),
}

model UpdateExtendConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateExtendConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExtendConfigResponseBody(name='body'),
}

async function updateExtendConfig(InstanceId: string, request: UpdateExtendConfigRequest): UpdateExtendConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExtendConfigWithOptions(InstanceId, request, headers, runtime);
}

async function updateExtendConfigWithOptions(InstanceId: string, request: UpdateExtendConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExtendConfigResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateExtendConfig', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/extend-configs/actions/update`, 'json', req, runtime);
}

model UpdateExtendfilesRequest {
  clientToken?: string(name='ClientToken'),
}

model UpdateExtendfilesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
    }
  ](name='Result'),
}

model UpdateExtendfilesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExtendfilesResponseBody(name='body'),
}

async function updateExtendfiles(InstanceId: string, request: UpdateExtendfilesRequest): UpdateExtendfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExtendfilesWithOptions(InstanceId, request, headers, runtime);
}

async function updateExtendfilesWithOptions(InstanceId: string, request: UpdateExtendfilesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExtendfilesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateExtendfiles', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/logstashes/${InstanceId}/extendfiles`, 'json', req, runtime);
}

model UpdateHotIkDictsRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateHotIkDictsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateHotIkDictsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateHotIkDictsResponseBody(name='body'),
}

async function updateHotIkDicts(InstanceId: string, request: UpdateHotIkDictsRequest): UpdateHotIkDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateHotIkDictsWithOptions(InstanceId, request, headers, runtime);
}

async function updateHotIkDictsWithOptions(InstanceId: string, request: UpdateHotIkDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateHotIkDictsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateHotIkDicts', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/instances/${InstanceId}/ik-hot-dict`, 'json', req, runtime);
}

model UpdateILMPolicyRequest {
  clientToken?: string(name='ClientToken'),
}

model UpdateILMPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateILMPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateILMPolicyResponseBody(name='body'),
}

async function updateILMPolicy(InstanceId: string, PolicyName: string, request: UpdateILMPolicyRequest): UpdateILMPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateILMPolicyWithOptions(InstanceId, PolicyName, request, headers, runtime);
}

async function updateILMPolicyWithOptions(InstanceId: string, PolicyName: string, request: UpdateILMPolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateILMPolicyResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  PolicyName = OpenApiUtil.getEncodeParam(PolicyName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateILMPolicy', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/instances/${InstanceId}/ilm-policies/${PolicyName}`, 'json', req, runtime);
}

model UpdateIndexTemplateRequest {
  clientToken?: string(name='ClientToken'),
}

model UpdateIndexTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model UpdateIndexTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIndexTemplateResponseBody(name='body'),
}

async function updateIndexTemplate(InstanceId: string, IndexTemplate: string, request: UpdateIndexTemplateRequest): UpdateIndexTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIndexTemplateWithOptions(InstanceId, IndexTemplate, request, headers, runtime);
}

async function updateIndexTemplateWithOptions(InstanceId: string, IndexTemplate: string, request: UpdateIndexTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIndexTemplateResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  IndexTemplate = OpenApiUtil.getEncodeParam(IndexTemplate);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateIndexTemplate', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/instances/${InstanceId}/index-templates/${IndexTemplate}`, 'json', req, runtime);
}

model UpdateInstanceRequest {
  clientToken?: string(name='clientToken'),
  ignoreStatus?: boolean(name='ignoreStatus'),
  orderActionType?: string(name='orderActionType'),
}

model UpdateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createdAt?: string(name='createdAt'),
    description?: string(name='description'),
    dictList?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='dictList'),
    domain?: string(name='domain'),
    esVersion?: string(name='esVersion'),
    instanceId?: string(name='instanceId'),
    kibanaConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='kibanaConfiguration'),
    kibanaDomain?: string(name='kibanaDomain'),
    kibanaPort?: int32(name='kibanaPort'),
    masterConfiguration?: {
      amount?: int32(name='amount'),
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='masterConfiguration'),
    networkConfig?: {
      type?: string(name='type'),
      vpcId?: string(name='vpcId'),
      vsArea?: string(name='vsArea'),
      vswitchId?: string(name='vswitchId'),
    }(name='networkConfig'),
    nodeAmount?: int32(name='nodeAmount'),
    nodeSpec?: {
      disk?: int32(name='disk'),
      diskType?: string(name='diskType'),
      spec?: string(name='spec'),
    }(name='nodeSpec'),
    paymentType?: string(name='paymentType'),
    publicDomain?: string(name='publicDomain'),
    publicPort?: int32(name='publicPort'),
    status?: string(name='status'),
    synonymsDicts?: [ 
      {
        fileSize?: long(name='fileSize'),
        name?: string(name='name'),
        sourceType?: string(name='sourceType'),
        type?: string(name='type'),
      }
    ](name='synonymsDicts'),
    updatedAt?: string(name='updatedAt'),
  }(name='Result'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstance(InstanceId: string, request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceWithOptions(InstanceId, request, headers, runtime);
}

async function updateInstanceWithOptions(InstanceId: string, request: UpdateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.ignoreStatus)) {
    query.ignoreStatus = request.ignoreStatus;
  }
  if (!Util.isUnset(request.orderActionType)) {
    query.orderActionType = request.orderActionType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateInstance', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/instances/${InstanceId}`, 'json', req, runtime);
}

model UpdateInstanceChargeTypeRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateInstanceChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateInstanceChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceChargeTypeResponseBody(name='body'),
}

async function updateInstanceChargeType(InstanceId: string, request: UpdateInstanceChargeTypeRequest): UpdateInstanceChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceChargeTypeWithOptions(InstanceId, request, headers, runtime);
}

async function updateInstanceChargeTypeWithOptions(InstanceId: string, request: UpdateInstanceChargeTypeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceChargeTypeResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateInstanceChargeType', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/convert-pay-type`, 'json', req, runtime);
}

model UpdateInstanceSettingsRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateInstanceSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceSettingsResponseBody(name='body'),
}

async function updateInstanceSettings(InstanceId: string, request: UpdateInstanceSettingsRequest): UpdateInstanceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function updateInstanceSettingsWithOptions(InstanceId: string, request: UpdateInstanceSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceSettingsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateInstanceSettings', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/instance-settings`, 'json', req, runtime);
}

model UpdateKibanaSettingsRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateKibanaSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateKibanaSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateKibanaSettingsResponseBody(name='body'),
}

async function updateKibanaSettings(InstanceId: string, request: UpdateKibanaSettingsRequest): UpdateKibanaSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateKibanaSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function updateKibanaSettingsWithOptions(InstanceId: string, request: UpdateKibanaSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateKibanaSettingsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateKibanaSettings', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/update-kibana-settings`, 'json', req, runtime);
}

model UpdateKibanaWhiteIpsRequest {
  clientToken?: string(name='clientToken'),
  modifyMode?: string(name='modifyMode'),
}

model UpdateKibanaWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    kibanaIPWhitelist?: [ string ](name='kibanaIPWhitelist'),
    kibanaPrivateIPWhitelist?: [ string ](name='kibanaPrivateIPWhitelist'),
  }(name='Result'),
}

model UpdateKibanaWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateKibanaWhiteIpsResponseBody(name='body'),
}

async function updateKibanaWhiteIps(InstanceId: string, request: UpdateKibanaWhiteIpsRequest): UpdateKibanaWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateKibanaWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updateKibanaWhiteIpsWithOptions(InstanceId: string, request: UpdateKibanaWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateKibanaWhiteIpsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query.modifyMode = request.modifyMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateKibanaWhiteIps', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/kibana-white-ips`, 'json', req, runtime);
}

model UpdateLogstashRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateLogstashResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateLogstashResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLogstashResponseBody(name='body'),
}

async function updateLogstash(InstanceId: string, request: UpdateLogstashRequest): UpdateLogstashResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashWithOptions(InstanceId, request, headers, runtime);
}

async function updateLogstashWithOptions(InstanceId: string, request: UpdateLogstashRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateLogstash', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/logstashes/${InstanceId}`, 'json', req, runtime);
}

model UpdateLogstashChargeTypeRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateLogstashChargeTypeResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateLogstashChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLogstashChargeTypeResponseBody(name='body'),
}

async function updateLogstashChargeType(InstanceId: string, request: UpdateLogstashChargeTypeRequest): UpdateLogstashChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashChargeTypeWithOptions(InstanceId, request, headers, runtime);
}

async function updateLogstashChargeTypeWithOptions(InstanceId: string, request: UpdateLogstashChargeTypeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashChargeTypeResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateLogstashChargeType', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/actions/convert-pay-type`, 'json', req, runtime);
}

model UpdateLogstashDescriptionRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateLogstashDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    description?: string(name='description'),
  }(name='Result'),
}

model UpdateLogstashDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLogstashDescriptionResponseBody(name='body'),
}

async function updateLogstashDescription(InstanceId: string, request: UpdateLogstashDescriptionRequest): UpdateLogstashDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashDescriptionWithOptions(InstanceId, request, headers, runtime);
}

async function updateLogstashDescriptionWithOptions(InstanceId: string, request: UpdateLogstashDescriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashDescriptionResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateLogstashDescription', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/description`, 'json', req, runtime);
}

model UpdateLogstashSettingsRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateLogstashSettingsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLogstashSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLogstashSettingsResponseBody(name='body'),
}

async function updateLogstashSettings(InstanceId: string, request: UpdateLogstashSettingsRequest): UpdateLogstashSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLogstashSettingsWithOptions(InstanceId, request, headers, runtime);
}

async function updateLogstashSettingsWithOptions(InstanceId: string, request: UpdateLogstashSettingsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLogstashSettingsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateLogstashSettings', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/instance-settings`, 'json', req, runtime);
}

model UpdatePipelineManagementConfigRequest {
  clientToken?: string(name='clientToken'),
}

model UpdatePipelineManagementConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdatePipelineManagementConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePipelineManagementConfigResponseBody(name='body'),
}

async function updatePipelineManagementConfig(InstanceId: string, request: UpdatePipelineManagementConfigRequest): UpdatePipelineManagementConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePipelineManagementConfigWithOptions(InstanceId, request, headers, runtime);
}

async function updatePipelineManagementConfigWithOptions(InstanceId: string, request: UpdatePipelineManagementConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePipelineManagementConfigResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdatePipelineManagementConfig', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/pipeline-management-config`, 'json', req, runtime);
}

model UpdatePipelinesRequest {
  clientToken?: string(name='clientToken'),
  trigger?: boolean(name='trigger'),
}

model UpdatePipelinesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdatePipelinesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePipelinesResponseBody(name='body'),
}

async function updatePipelines(InstanceId: string, request: UpdatePipelinesRequest): UpdatePipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePipelinesWithOptions(InstanceId, request, headers, runtime);
}

async function updatePipelinesWithOptions(InstanceId: string, request: UpdatePipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePipelinesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.trigger)) {
    query.trigger = request.trigger;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdatePipelines', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/logstashes/${InstanceId}/pipelines`, 'json', req, runtime);
}

model UpdatePrivateNetworkWhiteIpsRequest {
  clientToken?: string(name='clientToken'),
  modifyMode?: string(name='modifyMode'),
}

model UpdatePrivateNetworkWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    privateNetworkIpWhiteList?: [ string ](name='privateNetworkIpWhiteList'),
  }(name='Result'),
}

model UpdatePrivateNetworkWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePrivateNetworkWhiteIpsResponseBody(name='body'),
}

async function updatePrivateNetworkWhiteIps(InstanceId: string, request: UpdatePrivateNetworkWhiteIpsRequest): UpdatePrivateNetworkWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePrivateNetworkWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updatePrivateNetworkWhiteIpsWithOptions(InstanceId: string, request: UpdatePrivateNetworkWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePrivateNetworkWhiteIpsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query.modifyMode = request.modifyMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdatePrivateNetworkWhiteIps', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/private-network-white-ips`, 'json', req, runtime);
}

model UpdatePublicNetworkRequest {
  clientToken?: string(name='clientToken'),
}

model UpdatePublicNetworkResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enablePublic?: boolean(name='enablePublic'),
  }(name='Result'),
}

model UpdatePublicNetworkResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePublicNetworkResponseBody(name='body'),
}

async function updatePublicNetwork(InstanceId: string, request: UpdatePublicNetworkRequest): UpdatePublicNetworkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePublicNetworkWithOptions(InstanceId, request, headers, runtime);
}

async function updatePublicNetworkWithOptions(InstanceId: string, request: UpdatePublicNetworkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePublicNetworkResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdatePublicNetwork', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/public-network`, 'json', req, runtime);
}

model UpdatePublicWhiteIpsRequest {
  clientToken?: string(name='clientToken'),
  modifyMode?: string(name='modifyMode'),
}

model UpdatePublicWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    publicIpWhitelist?: [ string ](name='publicIpWhitelist'),
  }(name='Result'),
}

model UpdatePublicWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdatePublicWhiteIpsResponseBody(name='body'),
}

async function updatePublicWhiteIps(InstanceId: string, request: UpdatePublicWhiteIpsRequest): UpdatePublicWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePublicWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updatePublicWhiteIpsWithOptions(InstanceId: string, request: UpdatePublicWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePublicWhiteIpsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query.modifyMode = request.modifyMode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdatePublicWhiteIps', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/public-white-ips`, 'json', req, runtime);
}

model UpdateReadWritePolicyRequest {
  clientToken?: string(name='ClientToken'),
}

model UpdateReadWritePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateReadWritePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateReadWritePolicyResponseBody(name='body'),
}

async function updateReadWritePolicy(InstanceId: string, request: UpdateReadWritePolicyRequest): UpdateReadWritePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateReadWritePolicyWithOptions(InstanceId, request, headers, runtime);
}

async function updateReadWritePolicyWithOptions(InstanceId: string, request: UpdateReadWritePolicyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateReadWritePolicyResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateReadWritePolicy', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/update-read-write-policy`, 'json', req, runtime);
}

model UpdateSnapshotSettingResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    enable?: boolean(name='enable'),
    quartzRegex?: string(name='quartzRegex'),
  }(name='Result'),
}

model UpdateSnapshotSettingResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSnapshotSettingResponseBody(name='body'),
}

async function updateSnapshotSetting(InstanceId: string): UpdateSnapshotSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSnapshotSettingWithOptions(InstanceId, headers, runtime);
}

async function updateSnapshotSettingWithOptions(InstanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSnapshotSettingResponse {
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('UpdateSnapshotSetting', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/snapshot-setting`, 'json', req, runtime);
}

model UpdateSynonymsDictsRequest {
  clientToken?: string(name='clientToken'),
}

model UpdateSynonymsDictsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: [ 
    {
      fileSize?: long(name='fileSize'),
      name?: string(name='name'),
      sourceType?: string(name='sourceType'),
      type?: string(name='type'),
    }
  ](name='Result'),
}

model UpdateSynonymsDictsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSynonymsDictsResponseBody(name='body'),
}

async function updateSynonymsDicts(InstanceId: string, request: UpdateSynonymsDictsRequest): UpdateSynonymsDictsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSynonymsDictsWithOptions(InstanceId, request, headers, runtime);
}

async function updateSynonymsDictsWithOptions(InstanceId: string, request: UpdateSynonymsDictsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSynonymsDictsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateSynonymsDicts', '2017-06-13', 'HTTPS', 'PUT', 'AK', `/openapi/instances/${InstanceId}/synonymsDict`, 'json', req, runtime);
}

model UpdateTemplateRequest {
  clientToken?: string(name='ClientToken'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplate(InstanceId: string, TemplateName: string, request: UpdateTemplateRequest): UpdateTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateTemplateWithOptions(InstanceId, TemplateName, request, headers, runtime);
}

async function updateTemplateWithOptions(InstanceId: string, TemplateName: string, request: UpdateTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateTemplateResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  TemplateName = OpenApiUtil.getEncodeParam(TemplateName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateTemplate', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/templates/${TemplateName}`, 'json', req, runtime);
}

model UpdateWhiteIpsRequest {
  clientToken?: string(name='clientToken'),
  esIPWhitelist?: [ string ](name='esIPWhitelist'),
  modifyMode?: string(name='modifyMode'),
  whiteIpGroup?: {
    groupName?: string(name='groupName'),
    ips?: [ string ](name='ips'),
    whiteIpType?: string(name='whiteIpType'),
  }(name='whiteIpGroup'),
}

model UpdateWhiteIpsResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    esIPWhitelist?: [ string ](name='esIPWhitelist'),
  }(name='Result'),
}

model UpdateWhiteIpsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWhiteIpsResponseBody(name='body'),
}

async function updateWhiteIps(InstanceId: string, request: UpdateWhiteIpsRequest): UpdateWhiteIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateWhiteIpsWithOptions(InstanceId, request, headers, runtime);
}

async function updateWhiteIpsWithOptions(InstanceId: string, request: UpdateWhiteIpsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateWhiteIpsResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query.modifyMode = request.modifyMode;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.esIPWhitelist)) {
    body.esIPWhitelist = request.esIPWhitelist;
  }
  if (!Util.isUnset(request.whiteIpGroup)) {
    body.whiteIpGroup = request.whiteIpGroup;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('UpdateWhiteIps', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/white-ips`, 'json', req, runtime);
}

model UpdateXpackMonitorConfigRequest {
  clientToken?: string(name='ClientToken'),
}

model UpdateXpackMonitorConfigResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model UpdateXpackMonitorConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateXpackMonitorConfigResponseBody(name='body'),
}

async function updateXpackMonitorConfig(InstanceId: string, request: UpdateXpackMonitorConfigRequest): UpdateXpackMonitorConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateXpackMonitorConfigWithOptions(InstanceId, request, headers, runtime);
}

async function updateXpackMonitorConfigWithOptions(InstanceId: string, request: UpdateXpackMonitorConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateXpackMonitorConfigResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('UpdateXpackMonitorConfig', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/xpack-monitor-config`, 'json', req, runtime);
}

model UpgradeEngineVersionRequest {
  clientToken?: string(name='clientToken'),
  dryRun?: boolean(name='dryRun'),
  type?: string(name='type'),
  version?: string(name='version'),
}

model UpgradeEngineVersionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    status?: string(name='status'),
    validateResult?: {
      errorCode?: string(name='errorCode'),
      errorMsg?: string(name='errorMsg'),
      errorType?: string(name='errorType'),
    }(name='validateResult'),
    validateType?: string(name='validateType'),
  }(name='Result'),
}

model UpgradeEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeEngineVersionResponseBody(name='body'),
}

async function upgradeEngineVersion(InstanceId: string, request: UpgradeEngineVersionRequest): UpgradeEngineVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeEngineVersionWithOptions(InstanceId, request, headers, runtime);
}

async function upgradeEngineVersionWithOptions(InstanceId: string, request: UpgradeEngineVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpgradeEngineVersionResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query.dryRun = request.dryRun;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.type)) {
    body.type = request.type;
  }
  if (!Util.isUnset(request.version)) {
    body.version = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('UpgradeEngineVersion', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/actions/upgrade-version`, 'json', req, runtime);
}

model ValidateConnectionRequest {
  clientToken?: string(name='ClientToken'),
}

model ValidateConnectionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateConnectionResponseBody(name='body'),
}

async function validateConnection(InstanceId: string, request: ValidateConnectionRequest): ValidateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateConnectionWithOptions(InstanceId, request, headers, runtime);
}

async function validateConnectionWithOptions(InstanceId: string, request: ValidateConnectionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateConnectionResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ValidateConnection', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/logstashes/${InstanceId}/validate-connection`, 'json', req, runtime);
}

model ValidateShrinkNodesRequest {
  ignoreStatus?: boolean(name='ignoreStatus'),
  nodeType?: string(name='nodeType'),
}

model ValidateShrinkNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateShrinkNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateShrinkNodesResponseBody(name='body'),
}

async function validateShrinkNodes(InstanceId: string, request: ValidateShrinkNodesRequest): ValidateShrinkNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateShrinkNodesWithOptions(InstanceId, request, headers, runtime);
}

async function validateShrinkNodesWithOptions(InstanceId: string, request: ValidateShrinkNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateShrinkNodesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.ignoreStatus)) {
    query.ignoreStatus = request.ignoreStatus;
  }
  if (!Util.isUnset(request.nodeType)) {
    query.nodeType = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ValidateShrinkNodes', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/validate-shrink-nodes`, 'json', req, runtime);
}

model ValidateSlrPermissionRequest {
  clientToken?: string(name='ClientToken'),
  rolename?: string(name='rolename'),
}

model ValidateSlrPermissionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateSlrPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateSlrPermissionResponseBody(name='body'),
}

async function validateSlrPermission(request: ValidateSlrPermissionRequest): ValidateSlrPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateSlrPermissionWithOptions(request, headers, runtime);
}

async function validateSlrPermissionWithOptions(request: ValidateSlrPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateSlrPermissionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }
  if (!Util.isUnset(request.rolename)) {
    query.rolename = request.rolename;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ValidateSlrPermission', '2017-06-13', 'HTTPS', 'GET', 'AK', `/openapi/user/servicerolepermission`, 'json', req, runtime);
}

model ValidateTransferableNodesRequest {
  nodeType?: string(name='nodeType'),
}

model ValidateTransferableNodesResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model ValidateTransferableNodesResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateTransferableNodesResponseBody(name='body'),
}

async function validateTransferableNodes(InstanceId: string, request: ValidateTransferableNodesRequest): ValidateTransferableNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateTransferableNodesWithOptions(InstanceId, request, headers, runtime);
}

async function validateTransferableNodesWithOptions(InstanceId: string, request: ValidateTransferableNodesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateTransferableNodesResponse {
  Util.validateModel(request);
  InstanceId = OpenApiUtil.getEncodeParam(InstanceId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.nodeType)) {
    query.nodeType = request.nodeType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ValidateTransferableNodes', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances/${InstanceId}/validate-transfer-nodes`, 'json', req, runtime);
}

model CreateInstanceRequest {
  clientToken?: string(name='clientToken'),
}

model CreateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    instanceId?: string(name='instanceId'),
  }(name='Result'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createInstanceWithOptions(request, headers, runtime);
}

async function createInstanceWithOptions(request: CreateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.clientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('createInstance', '2017-06-13', 'HTTPS', 'POST', 'AK', `/openapi/instances`, 'json', req, runtime);
}

