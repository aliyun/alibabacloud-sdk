/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Ga';
  @version = '2019-11-20';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddEntriesToAclRequest {
  aclEntries: [ 
    {
      entry?: string(name='Entry'),
      entryDescription?: string(name='EntryDescription'),
    }
  ](name='AclEntries', position='Query'),
  aclId: string(name='AclId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddEntriesToAclResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddEntriesToAclResponse = {
  headers: map[string]string(name='headers'),
  body: AddEntriesToAclResponseBody(name='body'),
}

async function addEntriesToAcl(request: AddEntriesToAclRequest): AddEntriesToAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddEntriesToAcl', 'POST', '/', 'json', false, 'json', request);
}

model AssociateAclsWithListenerRequest {
  aclIds: [ string ](name='AclIds', position='Query'),
  aclType: string(name='AclType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AssociateAclsWithListenerResponseBody = {
  aclIds?: [ string ](name='AclIds'),
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AssociateAclsWithListenerResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateAclsWithListenerResponseBody(name='body'),
}

async function associateAclsWithListener(request: AssociateAclsWithListenerRequest): AssociateAclsWithListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateAclsWithListener', 'POST', '/', 'json', false, 'json', request);
}

model AssociateAdditionalCertificatesWithListenerRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  certificates: [ 
    {
      domain: string(name='Domain'),
      id: string(name='Id'),
    }
  ](name='Certificates', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AssociateAdditionalCertificatesWithListenerResponseBody = {
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId'),
}

model AssociateAdditionalCertificatesWithListenerResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateAdditionalCertificatesWithListenerResponseBody(name='body'),
}

async function associateAdditionalCertificatesWithListener(request: AssociateAdditionalCertificatesWithListenerRequest): AssociateAdditionalCertificatesWithListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateAdditionalCertificatesWithListener', 'POST', '/', 'json', false, 'json', request);
}

model AttachDdosToAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  ddosId: string(name='DdosId', position='Query'),
  ddosRegionId: string(name='DdosRegionId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model AttachDdosToAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  gaId?: string(name='GaId'),
  requestId?: string(name='RequestId'),
}

model AttachDdosToAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDdosToAcceleratorResponseBody(name='body'),
}

async function attachDdosToAccelerator(request: AttachDdosToAcceleratorRequest): AttachDdosToAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachDdosToAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model AttachLogStoreToEndpointGroupRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  endpointGroupIds: [ string ](name='EndpointGroupIds', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  slsLogStoreName: string(name='SlsLogStoreName', position='Query'),
  slsProjectName: string(name='SlsProjectName', position='Query'),
  slsRegionId: string(name='SlsRegionId', position='Query'),
}

model AttachLogStoreToEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AttachLogStoreToEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AttachLogStoreToEndpointGroupResponseBody(name='body'),
}

async function attachLogStoreToEndpointGroup(request: AttachLogStoreToEndpointGroupRequest): AttachLogStoreToEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachLogStoreToEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model BandwidthPackageAddAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model BandwidthPackageAddAcceleratorResponseBody = {
  accelerators?: [ string ](name='Accelerators'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  requestId?: string(name='RequestId'),
}

model BandwidthPackageAddAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: BandwidthPackageAddAcceleratorResponseBody(name='body'),
}

async function bandwidthPackageAddAccelerator(request: BandwidthPackageAddAcceleratorRequest): BandwidthPackageAddAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BandwidthPackageAddAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model BandwidthPackageRemoveAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model BandwidthPackageRemoveAcceleratorResponseBody = {
  accelerators?: [ string ](name='Accelerators'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  requestId?: string(name='RequestId'),
}

model BandwidthPackageRemoveAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: BandwidthPackageRemoveAcceleratorResponseBody(name='body'),
}

async function bandwidthPackageRemoveAccelerator(request: BandwidthPackageRemoveAcceleratorRequest): BandwidthPackageRemoveAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BandwidthPackageRemoveAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model ConfigEndpointProbeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  enable: string(name='Enable', position='Query'),
  endpoint: string(name='Endpoint', position='Query'),
  endpointGroupId: string(name='EndpointGroupId', position='Query'),
  endpointType: string(name='EndpointType', position='Query'),
  probePort?: string(name='ProbePort', position='Query'),
  probeProtocol?: string(name='ProbeProtocol', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ConfigEndpointProbeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigEndpointProbeResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigEndpointProbeResponseBody(name='body'),
}

async function configEndpointProbe(request: ConfigEndpointProbeRequest): ConfigEndpointProbeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigEndpointProbe', 'POST', '/', 'json', false, 'json', request);
}

model CreateAcceleratorRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  autoRenewDuration?: int32(name='AutoRenewDuration', position='Query'),
  autoUseCoupon?: string(name='AutoUseCoupon', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  duration: int32(name='Duration', position='Query'),
  name?: string(name='Name', position='Query'),
  pricingCycle: string(name='PricingCycle', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  spec: string(name='Spec', position='Query'),
}

model CreateAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAcceleratorResponseBody(name='body'),
}

async function createAccelerator(request: CreateAcceleratorRequest): CreateAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model CreateAclRequest {
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
      entryDescription?: string(name='EntryDescription'),
    }
  ](name='AclEntries', position='Query'),
  aclName?: string(name='AclName', position='Query'),
  addressIPVersion: string(name='AddressIPVersion', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateAclResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateAclResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAclResponseBody(name='body'),
}

async function createAcl(request: CreateAclRequest): CreateAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAcl', 'POST', '/', 'json', false, 'json', request);
}

model CreateApplicationMonitorRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  address: string(name='Address', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  detectThreshold?: int32(name='DetectThreshold', minimum=0, maximum=100, position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  optionsJson?: string(name='OptionsJson', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  taskName: string(name='TaskName', position='Query'),
}

model CreateApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId'),
}

model CreateApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationMonitorResponseBody(name='body'),
}

async function createApplicationMonitor(request: CreateApplicationMonitorRequest): CreateApplicationMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateApplicationMonitor', 'POST', '/', 'json', false, 'json', request);
}

model CreateBandwidthPackageRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  autoUseCoupon?: string(name='AutoUseCoupon', position='Query'),
  bandwidth: int32(name='Bandwidth', position='Query'),
  bandwidthType?: string(name='BandwidthType', position='Query'),
  billingType?: string(name='BillingType', position='Query'),
  cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA', position='Query'),
  cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  duration?: string(name='Duration', position='Query'),
  pricingCycle?: string(name='PricingCycle', position='Query'),
  ratio?: int32(name='Ratio', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  type: string(name='Type', position='Query'),
}

model CreateBandwidthPackageResponseBody = {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBandwidthPackageResponseBody(name='body'),
}

async function createBandwidthPackage(request: CreateBandwidthPackageRequest): CreateBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBandwidthPackage', 'POST', '/', 'json', false, 'json', request);
}

model CreateBasicAcceleratorRequest {
  autoPay?: boolean(name='AutoPay', description='自动续费', position='Query'),
  autoRenew?: boolean(name='AutoRenew', description='自动续费', position='Query'),
  autoRenewDuration?: int32(name='AutoRenewDuration', description='续费周期', position='Query'),
  autoUseCoupon?: string(name='AutoUseCoupon', description='自动使用优惠券', position='Query'),
  clientToken?: string(name='ClientToken', description='客户端Token', position='Query'),
  duration: int32(name='Duration', description='购买时长', position='Query'),
  pricingCycle: string(name='PricingCycle', description='时长单位', position='Query'),
  regionId: string(name='RegionId', description='RegionId', position='Query'),
}

model CreateBasicAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例ID'),
  orderId?: string(name='OrderId', description='订单Id'),
  requestId?: string(name='RequestId', description='请求Id'),
}

model CreateBasicAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBasicAcceleratorResponseBody(name='body'),
}

async function createBasicAccelerator(request: CreateBasicAcceleratorRequest): CreateBasicAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBasicAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model CreateBasicEndpointGroupRequest {
  acceleratorId: string(name='AcceleratorId', description='全球加速实例Id', position='Query'),
  clientToken?: string(name='ClientToken', description='客户端Token', position='Query'),
  description?: string(name='Description', description='终端节点组描述', position='Query'),
  endpointAddress: string(name='EndpointAddress', description='终端节点地址', position='Query'),
  endpointGroupRegion: string(name='EndpointGroupRegion', description='终端节点组所在地域', position='Query'),
  endpointType: string(name='EndpointType', description='终端节点类型', position='Query'),
  name?: string(name='Name', description='终端节点组名称', position='Query'),
  regionId: string(name='RegionId', description='Regionid', position='Query'),
}

model CreateBasicEndpointGroupResponseBody = {
  endpointGroupId?: string(name='EndpointGroupId', description='终端节点组Id'),
  requestId?: string(name='RequestId', description='请求Id'),
}

model CreateBasicEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBasicEndpointGroupResponseBody(name='body'),
}

async function createBasicEndpointGroup(request: CreateBasicEndpointGroupRequest): CreateBasicEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBasicEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateBasicIpSetRequest {
  accelerateRegionId: string(name='AccelerateRegionId', description='加速地域Id', position='Query'),
  acceleratorId: string(name='AcceleratorId', description='基础版全球加速实例Id', position='Query'),
  clientToken?: string(name='ClientToken', description='客户端Token', position='Query'),
  regionId: string(name='RegionId', description='RegionId', position='Query'),
}

model CreateBasicIpSetResponseBody = {
  ipSetId?: string(name='IpSetId', description='加速地域接入点Id'),
  requestId?: string(name='RequestId', description='请求Id'),
}

model CreateBasicIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBasicIpSetResponseBody(name='body'),
}

async function createBasicIpSet(request: CreateBasicIpSetRequest): CreateBasicIpSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBasicIpSet', 'POST', '/', 'json', false, 'json', request);
}

model CreateEndpointGroupRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  endpointConfigurations: [ 
    {
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      endpoint: string(name='Endpoint'),
      type: string(name='Type'),
      weight: int32(name='Weight'),
    }
  ](name='EndpointConfigurations', position='Query'),
  endpointGroupRegion: string(name='EndpointGroupRegion', position='Query'),
  endpointGroupType?: string(name='EndpointGroupType', position='Query'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol', position='Query'),
  healthCheckEnabled?: boolean(name='HealthCheckEnabled', position='Query'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds', position='Query'),
  healthCheckPath?: string(name='HealthCheckPath', position='Query'),
  healthCheckPort?: int32(name='HealthCheckPort', position='Query'),
  healthCheckProtocol?: string(name='HealthCheckProtocol', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  name?: string(name='Name', position='Query'),
  portOverrides?: [ 
    {
      endpointPort?: int32(name='EndpointPort'),
      listenerPort?: int32(name='ListenerPort'),
    }
  ](name='PortOverrides', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  thresholdCount?: int32(name='ThresholdCount', position='Query'),
  trafficPercentage?: int32(name='TrafficPercentage', position='Query'),
}

model CreateEndpointGroupResponseBody = {
  endpointGroupId?: string(name='EndpointGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEndpointGroupResponseBody(name='body'),
}

async function createEndpointGroup(request: CreateEndpointGroupRequest): CreateEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateEndpointGroupsRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  endpointGroupConfigurations: [ 
    {
      enableClientIPPreservationProxyProtocol?: boolean(name='EnableClientIPPreservationProxyProtocol'),
      enableClientIPPreservationToa?: boolean(name='EnableClientIPPreservationToa'),
      endpointConfigurations?: [ 
        {
          endpoint?: string(name='Endpoint'),
          type?: string(name='Type'),
          weight?: long(name='Weight'),
        }
      ](name='EndpointConfigurations'),
      endpointGroupDescription?: string(name='EndpointGroupDescription'),
      endpointGroupName?: string(name='EndpointGroupName'),
      endpointGroupRegion: string(name='EndpointGroupRegion'),
      endpointGroupType?: string(name='EndpointGroupType'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
      healthCheckIntervalSeconds?: long(name='HealthCheckIntervalSeconds'),
      healthCheckPath?: string(name='HealthCheckPath'),
      healthCheckPort?: long(name='HealthCheckPort'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      portOverrides?: [ 
        {
          endpointPort?: long(name='EndpointPort'),
          listenerPort?: long(name='ListenerPort'),
        }
      ](name='PortOverrides'),
      thresholdCount?: long(name='ThresholdCount'),
      trafficPercentage?: long(name='TrafficPercentage'),
    }
  ](name='EndpointGroupConfigurations', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateEndpointGroupsResponseBody = {
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEndpointGroupsResponseBody(name='body'),
}

async function createEndpointGroups(request: CreateEndpointGroupsRequest): CreateEndpointGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEndpointGroups', 'POST', '/', 'json', false, 'json', request);
}

model CreateForwardingRulesRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  forwardingRules: [ 
    {
      forwardingRuleName?: string(name='ForwardingRuleName'),
      priority?: int32(name='Priority'),
      ruleActions: [ 
        {
          forwardGroupConfig: {
            serverGroupTuples: [ 
              {
                endpointGroupId: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          order: int32(name='Order'),
          ruleActionType: string(name='RuleActionType'),
        }
      ](name='RuleActions'),
      ruleConditions: [ 
        {
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          ruleConditionType?: string(name='RuleConditionType'),
        }
      ](name='RuleConditions'),
    }
  ](name='ForwardingRules', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model CreateForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardingRulesResponseBody(name='body'),
}

async function createForwardingRules(request: CreateForwardingRulesRequest): CreateForwardingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateForwardingRules', 'POST', '/', 'json', false, 'json', request);
}

model CreateIpSetsRequest {
  accelerateRegion: [ 
    {
      accelerateRegionId: string(name='AccelerateRegionId'),
      bandwidth?: int32(name='Bandwidth'),
      ipVersion?: string(name='IpVersion'),
    }
  ](name='AccelerateRegion', position='Query'),
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model CreateIpSetsResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  ipSets?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      bandwidth?: int32(name='Bandwidth'),
      ipSetId?: string(name='IpSetId'),
    }
  ](name='IpSets'),
  requestId?: string(name='RequestId'),
}

model CreateIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpSetsResponseBody(name='body'),
}

async function createIpSets(request: CreateIpSetsRequest): CreateIpSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateIpSets', 'POST', '/', 'json', false, 'json', request);
}

model CreateListenerRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  certificates?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Certificates', position='Query'),
  clientAffinity?: string(name='ClientAffinity', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  portRanges: [ 
    {
      fromPort: int32(name='FromPort'),
      toPort: int32(name='ToPort'),
    }
  ](name='PortRanges', position='Query'),
  protocol?: string(name='Protocol', position='Query'),
  proxyProtocol?: boolean(name='ProxyProtocol', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  securityPolicyId?: string(name='SecurityPolicyId', position='Query'),
  XForwardedForConfig?: {
    XForwardedForGaApEnabled?: boolean(name='XForwardedForGaApEnabled'),
    XForwardedForGaIdEnabled?: boolean(name='XForwardedForGaIdEnabled'),
    XForwardedForPortEnabled?: boolean(name='XForwardedForPortEnabled'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
    XRealIpEnabled?: boolean(name='XRealIpEnabled'),
  }(name='XForwardedForConfig', position='Query'),
}

model CreateListenerResponseBody = {
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId'),
}

model CreateListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateListenerResponseBody(name='body'),
}

async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateListener', 'POST', '/', 'json', false, 'json', request);
}

model CreateSpareIpRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  spareIps: [ string ](name='SpareIps', position='Query'),
}

model CreateSpareIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateSpareIpResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSpareIpResponseBody(name='body'),
}

async function createSpareIp(request: CreateSpareIpRequest): CreateSpareIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSpareIp', 'POST', '/', 'json', false, 'json', request);
}

model CreateSpareIpsRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  spareIps: [ string ](name='SpareIps', position='Query'),
}

model CreateSpareIpsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateSpareIpsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSpareIpsResponseBody(name='body'),
}

async function createSpareIps(request: CreateSpareIpsRequest): CreateSpareIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSpareIps', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  requestId?: string(name='RequestId'),
}

model DeleteAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAcceleratorResponseBody(name='body'),
}

async function deleteAccelerator(request: DeleteAcceleratorRequest): DeleteAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAclRequest {
  aclId: string(name='AclId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteAclResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteAclResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAclResponseBody(name='body'),
}

async function deleteAcl(request: DeleteAclRequest): DeleteAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAcl', 'POST', '/', 'json', false, 'json', request);
}

model DeleteApplicationMonitorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model DeleteApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationMonitorResponseBody(name='body'),
}

async function deleteApplicationMonitor(request: DeleteApplicationMonitorRequest): DeleteApplicationMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteApplicationMonitor', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBandwidthPackageRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteBandwidthPackageResponseBody = {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  requestId?: string(name='RequestId'),
}

model DeleteBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBandwidthPackageResponseBody(name='body'),
}

async function deleteBandwidthPackage(request: DeleteBandwidthPackageRequest): DeleteBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBandwidthPackage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBasicAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', description='全球加速实例Id', position='Query'),
  regionId: string(name='RegionId', description='RegionId', position='Query'),
}

model DeleteBasicAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  requestId?: string(name='RequestId', description='请求Id'),
}

model DeleteBasicAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBasicAcceleratorResponseBody(name='body'),
}

async function deleteBasicAccelerator(request: DeleteBasicAcceleratorRequest): DeleteBasicAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBasicAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBasicEndpointGroupRequest {
  clientToken?: string(name='ClientToken', description='客户端Token', position='Query'),
  endpointGroupId: string(name='EndpointGroupId', description='终端节点组Id', position='Query'),
}

model DeleteBasicEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='请求Id'),
}

model DeleteBasicEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBasicEndpointGroupResponseBody(name='body'),
}

async function deleteBasicEndpointGroup(request: DeleteBasicEndpointGroupRequest): DeleteBasicEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBasicEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBasicIpSetRequest {
  clientToken?: string(name='ClientToken', description='客户端Token', position='Query'),
  ipSetId: string(name='IpSetId', description='加速接入点Id', position='Query'),
  regionId?: string(name='RegionId', description='RegionId', position='Query'),
}

model DeleteBasicIpSetResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteBasicIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBasicIpSetResponseBody(name='body'),
}

async function deleteBasicIpSet(request: DeleteBasicIpSetRequest): DeleteBasicIpSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBasicIpSet', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEndpointGroupRequest {
  acceleratorId?: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  endpointGroupId: string(name='EndpointGroupId', position='Query'),
}

model DeleteEndpointGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEndpointGroupResponseBody(name='body'),
}

async function deleteEndpointGroup(request: DeleteEndpointGroupRequest): DeleteEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEndpointGroupsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  endpointGroupIds: [ string ](name='EndpointGroupIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteEndpointGroupsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEndpointGroupsResponseBody(name='body'),
}

async function deleteEndpointGroups(request: DeleteEndpointGroupsRequest): DeleteEndpointGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEndpointGroups', 'POST', '/', 'json', false, 'json', request);
}

model DeleteForwardingRuleRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  forwardingRuleId: string(name='ForwardingRuleId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteForwardingRuleResponseBody = {
  forwardingRuleId?: string(name='ForwardingRuleId'),
  requestId?: string(name='RequestId'),
}

model DeleteForwardingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardingRuleResponseBody(name='body'),
}

async function deleteForwardingRule(request: DeleteForwardingRuleRequest): DeleteForwardingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteForwardingRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteForwardingRulesRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  forwardingRuleIds: [ string ](name='ForwardingRuleIds', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model DeleteForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardingRulesResponseBody(name='body'),
}

async function deleteForwardingRules(request: DeleteForwardingRulesRequest): DeleteForwardingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteForwardingRules', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIpSetRequest {
  acceleratorId?: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ipSetId: string(name='IpSetId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteIpSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpSetResponseBody(name='body'),
}

async function deleteIpSet(request: DeleteIpSetRequest): DeleteIpSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIpSet', 'POST', '/', 'json', false, 'json', request);
}

model DeleteIpSetsRequest {
  ipSetIds: [ string ](name='IpSetIds', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpSetsResponseBody(name='body'),
}

async function deleteIpSets(request: DeleteIpSetsRequest): DeleteIpSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteIpSets', 'POST', '/', 'json', false, 'json', request);
}

model DeleteListenerRequest {
  acceleratorId?: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
}

model DeleteListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteListenerResponseBody(name='body'),
}

async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteListener', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSpareIpRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  spareIps: [ string ](name='SpareIps', position='Query'),
}

model DeleteSpareIpResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSpareIpResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSpareIpResponseBody(name='body'),
}

async function deleteSpareIp(request: DeleteSpareIpRequest): DeleteSpareIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSpareIp', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSpareIpsRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  spareIps: [ string ](name='SpareIps', position='Query'),
}

model DeleteSpareIpsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteSpareIpsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSpareIpsResponseBody(name='body'),
}

async function deleteSpareIps(request: DeleteSpareIpsRequest): DeleteSpareIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSpareIps', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  basicBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth'),
    bandwidthType?: string(name='BandwidthType'),
    instanceId?: string(name='InstanceId'),
  }(name='BasicBandwidthPackage'),
  cenId?: string(name='CenId'),
  createTime?: long(name='CreateTime'),
  crossDomainBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth'),
    instanceId?: string(name='InstanceId'),
  }(name='CrossDomainBandwidthPackage'),
  ddosId?: string(name='DdosId'),
  description?: string(name='Description'),
  dnsName?: string(name='DnsName'),
  expiredTime?: long(name='ExpiredTime'),
  instanceChargeType?: string(name='InstanceChargeType'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  secondDnsName?: string(name='SecondDnsName'),
  spec?: string(name='Spec'),
  state?: string(name='State'),
}

model DescribeAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAcceleratorResponseBody(name='body'),
}

async function describeAccelerator(request: DescribeAcceleratorRequest): DescribeAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAcceleratorAutoRenewAttributeRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeAcceleratorAutoRenewAttributeResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewDuration?: int32(name='AutoRenewDuration'),
  renewalStatus?: string(name='RenewalStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeAcceleratorAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAcceleratorAutoRenewAttributeResponseBody(name='body'),
}

async function describeAcceleratorAutoRenewAttribute(request: DescribeAcceleratorAutoRenewAttributeRequest): DescribeAcceleratorAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAcceleratorAutoRenewAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeApplicationMonitorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model DescribeApplicationMonitorResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  address?: string(name='Address'),
  detectThreshold?: string(name='DetectThreshold'),
  ispCityList?: [ 
    {
      city?: string(name='City'),
      cityName?: string(name='CityName'),
      isp?: string(name='Isp'),
      ispName?: string(name='IspName'),
    }
  ](name='IspCityList'),
  listenerId?: string(name='ListenerId'),
  optionsJson?: string(name='OptionsJson'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model DescribeApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationMonitorResponseBody(name='body'),
}

async function describeApplicationMonitor(request: DescribeApplicationMonitorRequest): DescribeApplicationMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeApplicationMonitor', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBandwidthPackageRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeBandwidthPackageResponseBody = {
  accelerators?: [ string ](name='Accelerators'),
  bandwidth?: int32(name='Bandwidth'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  bandwidthType?: string(name='BandwidthType'),
  billingType?: string(name='BillingType'),
  cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
  cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
  chargeType?: string(name='ChargeType'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  expiredTime?: string(name='ExpiredTime'),
  name?: string(name='Name'),
  ratio?: int32(name='Ratio'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
  type?: string(name='Type'),
}

model DescribeBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandwidthPackageResponseBody(name='body'),
}

async function describeBandwidthPackage(request: DescribeBandwidthPackageRequest): DescribeBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBandwidthPackage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEndpointGroupRequest {
  endpointGroupId: string(name='EndpointGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeEndpointGroupResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  accessLogSwitch?: string(name='AccessLogSwitch'),
  description?: string(name='Description'),
  enableAccessLog?: boolean(name='EnableAccessLog'),
  endpointConfigurations?: [ 
    {
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      endpoint?: string(name='Endpoint'),
      probePort?: int32(name='ProbePort'),
      probeProtocol?: string(name='ProbeProtocol'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='EndpointConfigurations'),
  endpointGroupId?: string(name='EndpointGroupId'),
  endpointGroupIpList?: [ string ](name='EndpointGroupIpList'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  endpointGroupType?: string(name='EndpointGroupType'),
  endpointGroupUnconfirmedIpList?: [ string ](name='EndpointGroupUnconfirmedIpList'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
  healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  listenerId?: string(name='ListenerId'),
  name?: string(name='Name'),
  portOverrides?: [ 
    {
      endpointPort?: int32(name='EndpointPort'),
      listenerPort?: int32(name='ListenerPort'),
    }
  ](name='PortOverrides'),
  requestId?: string(name='RequestId'),
  slsLogStoreName?: string(name='SlsLogStoreName'),
  slsProjectName?: string(name='SlsProjectName'),
  slsRegion?: string(name='SlsRegion'),
  state?: string(name='State'),
  thresholdCount?: int32(name='ThresholdCount'),
  totalCount?: int32(name='TotalCount'),
  trafficPercentage?: int32(name='TrafficPercentage'),
}

model DescribeEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEndpointGroupResponseBody(name='body'),
}

async function describeEndpointGroup(request: DescribeEndpointGroupRequest): DescribeEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeIpSetRequest {
  ipSetId: string(name='IpSetId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeIpSetResponseBody = {
  accelerateRegionId?: string(name='AccelerateRegionId'),
  acceleratorId?: string(name='AcceleratorId'),
  bandwidth?: int32(name='Bandwidth'),
  ipAddressList?: [ string ](name='IpAddressList'),
  ipSetId?: string(name='IpSetId'),
  ipVersion?: string(name='IpVersion'),
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
}

model DescribeIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpSetResponseBody(name='body'),
}

async function describeIpSet(request: DescribeIpSetRequest): DescribeIpSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeIpSet', 'POST', '/', 'json', false, 'json', request);
}

model DescribeListenerRequest {
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeListenerResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  aclType?: string(name='AclType'),
  backendPorts?: [ 
    {
      fromPort?: string(name='FromPort'),
      toPort?: string(name='ToPort'),
    }
  ](name='BackendPorts'),
  certificates?: [ 
    {
      id?: string(name='Id'),
      type?: string(name='Type'),
    }
  ](name='Certificates'),
  clientAffinity?: string(name='ClientAffinity'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  listenerId?: string(name='ListenerId'),
  name?: string(name='Name'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  protocol?: string(name='Protocol'),
  proxyProtocol?: boolean(name='ProxyProtocol'),
  relatedAcls?: [ 
    {
      aclId?: string(name='AclId'),
      status?: string(name='Status'),
    }
  ](name='RelatedAcls'),
  requestId?: string(name='RequestId'),
  securityPolicyId?: string(name='SecurityPolicyId'),
  state?: string(name='State'),
  XForwardedForConfig?: {
    XForwardedForGaApEnabled?: boolean(name='XForwardedForGaApEnabled'),
    XForwardedForGaIdEnabled?: boolean(name='XForwardedForGaIdEnabled'),
    XForwardedForPortEnabled?: boolean(name='XForwardedForPortEnabled'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
    XRealIpEnabled?: boolean(name='XRealIpEnabled'),
  }(name='XForwardedForConfig'),
}

model DescribeListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeListenerResponseBody(name='body'),
}

async function describeListener(request: DescribeListenerRequest): DescribeListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeListener', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  regionId: string(name='RegionId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSpareIpRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  spareIp: string(name='SpareIp', position='Query'),
}

model DescribeSpareIpResponseBody = {
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
}

model DescribeSpareIpResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSpareIpResponseBody(name='body'),
}

async function describeSpareIp(request: DescribeSpareIpRequest): DescribeSpareIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSpareIp', 'POST', '/', 'json', false, 'json', request);
}

model DetachDdosFromAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DetachDdosFromAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  requestId?: string(name='RequestId'),
}

model DetachDdosFromAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDdosFromAcceleratorResponseBody(name='body'),
}

async function detachDdosFromAccelerator(request: DetachDdosFromAcceleratorRequest): DetachDdosFromAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachDdosFromAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model DetachLogStoreFromEndpointGroupRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  endpointGroupIds: [ string ](name='EndpointGroupIds', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DetachLogStoreFromEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DetachLogStoreFromEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DetachLogStoreFromEndpointGroupResponseBody(name='body'),
}

async function detachLogStoreFromEndpointGroup(request: DetachLogStoreFromEndpointGroupRequest): DetachLogStoreFromEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachLogStoreFromEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model DetectApplicationMonitorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model DetectApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetectApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: DetectApplicationMonitorResponseBody(name='body'),
}

async function detectApplicationMonitor(request: DetectApplicationMonitorRequest): DetectApplicationMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectApplicationMonitor', 'POST', '/', 'json', false, 'json', request);
}

model DisableApplicationMonitorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model DisableApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: DisableApplicationMonitorResponseBody(name='body'),
}

async function disableApplicationMonitor(request: DisableApplicationMonitorRequest): DisableApplicationMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableApplicationMonitor', 'POST', '/', 'json', false, 'json', request);
}

model DissociateAclsFromListenerRequest {
  aclIds: [ string ](name='AclIds', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DissociateAclsFromListenerResponseBody = {
  aclIds?: [ string ](name='AclIds'),
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DissociateAclsFromListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateAclsFromListenerResponseBody(name='body'),
}

async function dissociateAclsFromListener(request: DissociateAclsFromListenerRequest): DissociateAclsFromListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DissociateAclsFromListener', 'POST', '/', 'json', false, 'json', request);
}

model DissociateAdditionalCertificatesFromListenerRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  domains: [ string ](name='Domains', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DissociateAdditionalCertificatesFromListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DissociateAdditionalCertificatesFromListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateAdditionalCertificatesFromListenerResponseBody(name='body'),
}

async function dissociateAdditionalCertificatesFromListener(request: DissociateAdditionalCertificatesFromListenerRequest): DissociateAdditionalCertificatesFromListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DissociateAdditionalCertificatesFromListener', 'POST', '/', 'json', false, 'json', request);
}

model DissociateAdditionalCertificatesWithListenerRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  domains?: [ string ](name='Domains', position='Query'),
  listenerId?: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DissociateAdditionalCertificatesWithListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DissociateAdditionalCertificatesWithListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateAdditionalCertificatesWithListenerResponseBody(name='body'),
}

async function dissociateAdditionalCertificatesWithListener(request: DissociateAdditionalCertificatesWithListenerRequest): DissociateAdditionalCertificatesWithListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DissociateAdditionalCertificatesWithListener', 'POST', '/', 'json', false, 'json', request);
}

model EnableApplicationMonitorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model EnableApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: EnableApplicationMonitorResponseBody(name='body'),
}

async function enableApplicationMonitor(request: EnableApplicationMonitorRequest): EnableApplicationMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableApplicationMonitor', 'POST', '/', 'json', false, 'json', request);
}

model GetAclRequest {
  aclId: string(name='AclId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetAclResponseBody = {
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
      entryDescription?: string(name='EntryDescription'),
    }
  ](name='AclEntries'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  aclStatus?: string(name='AclStatus'),
  addressIPVersion?: string(name='AddressIPVersion'),
  relatedListeners?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      aclType?: string(name='AclType'),
      listenerId?: string(name='ListenerId'),
    }
  ](name='RelatedListeners'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetAclResponse = {
  headers: map[string]string(name='headers'),
  body: GetAclResponseBody(name='body'),
}

async function getAcl(request: GetAclRequest): GetAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAcl', 'POST', '/', 'json', false, 'json', request);
}

model GetBasicAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', description='全球加速实例Id', position='Query'),
  regionId: string(name='RegionId', description='RegionId', position='Query'),
}

model GetBasicAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  basicBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth', description='基础带宽包带宽'),
    bandwidthType?: string(name='BandwidthType', description='基础带宽包类型'),
    instanceId?: string(name='InstanceId', description='基础带宽包Id'),
  }(name='BasicBandwidthPackage', description='绑定的基础带宽包'),
  basicEndpointGroupId?: string(name='BasicEndpointGroupId', description='全球加速实例下车点Id'),
  basicIpSetId?: string(name='BasicIpSetId', description='全球加速实例上车点Id'),
  cenId?: string(name='CenId', description='使用的云企业网Id'),
  createTime?: long(name='CreateTime', description='全球加速实例创建时间'),
  crossDomainBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth', description='跨境带宽包带宽'),
    instanceId?: string(name='InstanceId', description='跨境带宽包Id'),
  }(name='CrossDomainBandwidthPackage', description='绑定的跨境带宽包'),
  description?: string(name='Description', description='全球加速实例描述'),
  expiredTime?: long(name='ExpiredTime', description='到期时间'),
  instanceChargeType?: string(name='InstanceChargeType', description='全球加速实例收费类型'),
  name?: string(name='Name', description='全球加速实例名称'),
  regionId?: string(name='RegionId', description='RegionId'),
  requestId?: string(name='RequestId', description='请求Id'),
  state?: string(name='State', description='实例状态'),
}

model GetBasicAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: GetBasicAcceleratorResponseBody(name='body'),
}

async function getBasicAccelerator(request: GetBasicAcceleratorRequest): GetBasicAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBasicAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model GetBasicEndpointGroupRequest {
  clientToken?: string(name='ClientToken', description='客户端Token', position='Query'),
  endpointGroupId: string(name='EndpointGroupId', description='终端节点组Id', position='Query'),
  regionId: string(name='RegionId', description='RegionId', position='Query'),
}

model GetBasicEndpointGroupResponseBody = {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  description?: string(name='Description', description='终端节点组描述'),
  endpointAddress?: string(name='EndpointAddress', description='终端节点组地址'),
  endpointGroupId?: string(name='EndpointGroupId', description='终端节点组Id'),
  endpointGroupRegion?: string(name='EndpointGroupRegion', description='终端节点组所在地域'),
  endpointType?: string(name='EndpointType', description='终端节点类型'),
  name?: string(name='Name', description='终端节点组名称'),
  requestId?: string(name='RequestId', description='请求Id'),
  state?: string(name='State', description='终端节点组状态'),
}

model GetBasicEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetBasicEndpointGroupResponseBody(name='body'),
}

async function getBasicEndpointGroup(request: GetBasicEndpointGroupRequest): GetBasicEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBasicEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model GetBasicIpSetRequest {
  clientToken?: string(name='ClientToken', description='客户端Token', position='Query'),
  ipSetId: string(name='IpSetId', description='加速接入点Id', position='Query'),
  regionId: string(name='RegionId', description='RegionId', position='Query'),
}

model GetBasicIpSetResponseBody = {
  accelerateRegionId?: string(name='AccelerateRegionId', description='加速地域Id'),
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  bandwidth?: int32(name='Bandwidth', description='加速地域带宽'),
  ipAddress?: string(name='IpAddress', description='加速接入点IP地址'),
  ipSetId?: string(name='IpSetId', description='加速接入点id'),
  ipVersion?: string(name='IpVersion', description='加速接入点地址类型'),
  requestId?: string(name='RequestId', description='请求Id'),
  state?: string(name='State', description='加速接入点状态'),
}

model GetBasicIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: GetBasicIpSetResponseBody(name='body'),
}

async function getBasicIpSet(request: GetBasicIpSetRequest): GetBasicIpSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBasicIpSet', 'POST', '/', 'json', false, 'json', request);
}

model GetHealthStatusRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetHealthStatusResponseBody = {
  endpointGroups?: [ 
    {
      endpointGroupId?: string(name='EndpointGroupId'),
      endpointGroupType?: string(name='EndpointGroupType'),
      endpoints?: [ 
        {
          address?: string(name='Address'),
          endpointId?: string(name='EndpointId'),
          healthDetail?: string(name='HealthDetail'),
          healthStatus?: string(name='HealthStatus'),
          port?: long(name='Port'),
          type?: string(name='Type'),
        }
      ](name='Endpoints'),
      forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
      healthStatus?: string(name='HealthStatus'),
    }
  ](name='EndpointGroups'),
  healthStatus?: string(name='HealthStatus'),
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetHealthStatusResponseBody(name='body'),
}

async function getHealthStatus(request: GetHealthStatusRequest): GetHealthStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetHealthStatus', 'POST', '/', 'json', false, 'json', request);
}

model GetSpareIpRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  spareIp: string(name='SpareIp', position='Query'),
}

model GetSpareIpResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  state?: string(name='State'),
}

model GetSpareIpResponse = {
  headers: map[string]string(name='headers'),
  body: GetSpareIpResponseBody(name='body'),
}

async function getSpareIp(request: GetSpareIpRequest): GetSpareIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSpareIp', 'POST', '/', 'json', false, 'json', request);
}

model ListAccelerateAreasRequest {
  regionId: string(name='RegionId', position='Query'),
}

model ListAccelerateAreasResponseBody = {
  areas?: [ 
    {
      areaId?: string(name='AreaId'),
      localName?: string(name='LocalName'),
      regionList?: [ 
        {
          localName?: string(name='LocalName'),
          regionId?: string(name='RegionId'),
        }
      ](name='RegionList'),
    }
  ](name='Areas'),
  requestId?: string(name='RequestId'),
}

model ListAccelerateAreasResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccelerateAreasResponseBody(name='body'),
}

async function listAccelerateAreas(request: ListAccelerateAreasRequest): ListAccelerateAreasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAccelerateAreas', 'POST', '/', 'json', false, 'json', request);
}

model ListAcceleratorsRequest {
  acceleratorId?: string(name='AcceleratorId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  state?: string(name='State', position='Query'),
}

model ListAcceleratorsResponseBody = {
  accelerators?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      bandwidth?: int32(name='Bandwidth'),
      basicBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth'),
        bandwidthType?: string(name='BandwidthType'),
        instanceId?: string(name='InstanceId'),
      }(name='BasicBandwidthPackage'),
      cenId?: string(name='CenId'),
      createTime?: long(name='CreateTime'),
      crossDomainBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth'),
        instanceId?: string(name='InstanceId'),
      }(name='CrossDomainBandwidthPackage'),
      ddosId?: string(name='DdosId'),
      description?: string(name='Description'),
      dnsName?: string(name='DnsName'),
      expiredTime?: long(name='ExpiredTime'),
      instanceChargeType?: string(name='InstanceChargeType'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      secondDnsName?: string(name='SecondDnsName'),
      spec?: string(name='Spec'),
      state?: string(name='State'),
      type?: string(name='Type'),
    }
  ](name='Accelerators'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAcceleratorsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAcceleratorsResponseBody(name='body'),
}

async function listAccelerators(request: ListAcceleratorsRequest): ListAcceleratorsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAccelerators', 'POST', '/', 'json', false, 'json', request);
}

model ListAclsRequest {
  aclIds?: [ string ](name='AclIds', position='Query'),
  aclName?: string(name='AclName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListAclsResponseBody = {
  acls?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
      aclStatus?: string(name='AclStatus'),
      addressIPVersion?: string(name='AddressIPVersion'),
    }
  ](name='Acls'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAclsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAclsResponseBody(name='body'),
}

async function listAcls(request: ListAclsRequest): ListAclsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAcls', 'POST', '/', 'json', false, 'json', request);
}

model ListApplicationMonitorRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  searchValue?: string(name='SearchValue', position='Query'),
}

model ListApplicationMonitorResponseBody = {
  applicationMonitors?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      address?: string(name='Address'),
      detectThreshold?: int32(name='DetectThreshold'),
      listenerId?: string(name='ListenerId'),
      optionsJson?: string(name='OptionsJson'),
      state?: string(name='State'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='ApplicationMonitors'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationMonitorResponseBody(name='body'),
}

async function listApplicationMonitor(request: ListApplicationMonitorRequest): ListApplicationMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListApplicationMonitor', 'POST', '/', 'json', false, 'json', request);
}

model ListApplicationMonitorDetectResultRequest {
  beginTime: long(name='BeginTime', position='Query'),
  endTime: long(name='EndTime', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId?: string(name='TaskId', position='Query'),
}

model ListApplicationMonitorDetectResultResponseBody = {
  applicationMonitorDetectResultList?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      detail?: string(name='Detail'),
      diagStatus?: string(name='DiagStatus'),
      listenerId?: string(name='ListenerId'),
      port?: string(name='Port'),
      protocol?: string(name='Protocol'),
      taskId?: string(name='TaskId'),
    }
  ](name='ApplicationMonitorDetectResultList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListApplicationMonitorDetectResultResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationMonitorDetectResultResponseBody(name='body'),
}

async function listApplicationMonitorDetectResult(request: ListApplicationMonitorDetectResultRequest): ListApplicationMonitorDetectResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListApplicationMonitorDetectResult', 'POST', '/', 'json', false, 'json', request);
}

model ListAvailableAccelerateAreasRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListAvailableAccelerateAreasResponseBody = {
  areas?: [ 
    {
      areaId?: string(name='AreaId'),
      localName?: string(name='LocalName'),
      regionList?: [ 
        {
          localName?: string(name='LocalName'),
          regionId?: string(name='RegionId'),
        }
      ](name='RegionList'),
    }
  ](name='Areas'),
  requestId?: string(name='RequestId'),
}

model ListAvailableAccelerateAreasResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableAccelerateAreasResponseBody(name='body'),
}

async function listAvailableAccelerateAreas(request: ListAvailableAccelerateAreasRequest): ListAvailableAccelerateAreasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAvailableAccelerateAreas', 'POST', '/', 'json', false, 'json', request);
}

model ListAvailableBusiRegionsRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListAvailableBusiRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      pop?: boolean(name='Pop'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListAvailableBusiRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableBusiRegionsResponseBody(name='body'),
}

async function listAvailableBusiRegions(request: ListAvailableBusiRegionsRequest): ListAvailableBusiRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAvailableBusiRegions', 'POST', '/', 'json', false, 'json', request);
}

model ListBandwidthPackagesRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  state?: string(name='State', position='Query'),
  type?: string(name='Type', position='Query'),
}

model ListBandwidthPackagesResponseBody = {
  bandwidthPackages?: [ 
    {
      accelerators?: [ string ](name='Accelerators'),
      bandwidth?: int32(name='Bandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidthType?: string(name='BandwidthType'),
      billingType?: string(name='BillingType'),
      cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
      cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
      chargeType?: string(name='ChargeType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      name?: string(name='Name'),
      ratio?: int32(name='Ratio'),
      regionId?: string(name='RegionId'),
      state?: string(name='State'),
      type?: string(name='Type'),
    }
  ](name='BandwidthPackages'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBandwidthPackagesResponseBody(name='body'),
}

async function listBandwidthPackages(request: ListBandwidthPackagesRequest): ListBandwidthPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBandwidthPackages', 'POST', '/', 'json', false, 'json', request);
}

model ListBandwidthackagesRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListBandwidthackagesResponseBody = {
  bandwidthPackages?: [ 
    {
      accelerators?: [ string ](name='Accelerators'),
      bandwidth?: int32(name='Bandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      chargeType?: string(name='ChargeType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      state?: string(name='State'),
    }
  ](name='BandwidthPackages'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListBandwidthackagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBandwidthackagesResponseBody(name='body'),
}

async function listBandwidthackages(request: ListBandwidthackagesRequest): ListBandwidthackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBandwidthackages', 'POST', '/', 'json', false, 'json', request);
}

model ListBasicAcceleratorsRequest {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id', position='Query'),
  pageNumber?: int32(name='PageNumber', description='分页页码', position='Query'),
  pageSize?: int32(name='PageSize', description='分页大小', position='Query'),
  regionId: string(name='RegionId', description='RegionId', position='Query'),
  state?: string(name='State', description='全球加速实例状态', position='Query'),
}

model ListBasicAcceleratorsResponseBody = {
  accelerators?: [ 
    {
      acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
      basicBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth', description='基础带宽包带宽'),
        bandwidthType?: string(name='BandwidthType', description='基础带宽包类型'),
        instanceId?: string(name='InstanceId', description='基础带宽包Id'),
      }(name='BasicBandwidthPackage', description='绑定的基础带宽包'),
      basicEndpointGroupId?: string(name='BasicEndpointGroupId', description='全球加速实例下车点Id'),
      basicIpSetId?: string(name='BasicIpSetId', description='全球加速实例上车点Id'),
      createTime?: long(name='CreateTime', description='创建时间'),
      crossDomainBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth', description='跨境带宽包带宽'),
        instanceId?: string(name='InstanceId', description='跨境带宽包Id'),
      }(name='CrossDomainBandwidthPackage', description='绑定的跨境带宽包'),
      description?: string(name='Description', description='全球加速实例描述'),
      expiredTime?: long(name='ExpiredTime', description='到期时间'),
      instanceChargeType?: string(name='InstanceChargeType', description='全球加速实例计费类型'),
      name?: string(name='Name', description='全球加速实例名称'),
      regionId?: string(name='RegionId', description='RegionId'),
      state?: string(name='State', description='全球加速实例状态'),
      type?: string(name='Type', description='全球加速实例类型'),
    }
  ](name='Accelerators', description='全球加速实例列表'),
  pageNumber?: int32(name='PageNumber', description='页码'),
  pageSize?: int32(name='PageSize', description='页大小'),
  requestId?: string(name='RequestId', description='请求Id'),
  totalCount?: int32(name='TotalCount', description='全球加速实例总数'),
}

model ListBasicAcceleratorsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBasicAcceleratorsResponseBody(name='body'),
}

async function listBasicAccelerators(request: ListBasicAcceleratorsRequest): ListBasicAcceleratorsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBasicAccelerators', 'POST', '/', 'json', false, 'json', request);
}

model ListBusiRegionsRequest {
  regionId: string(name='RegionId', position='Query'),
}

model ListBusiRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListBusiRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBusiRegionsResponseBody(name='body'),
}

async function listBusiRegions(request: ListBusiRegionsRequest): ListBusiRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBusiRegions', 'POST', '/', 'json', false, 'json', request);
}

model ListEndpointGroupsRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  accessLogSwitch?: string(name='AccessLogSwitch', position='Query'),
  endpointGroupId?: string(name='EndpointGroupId', position='Query'),
  endpointGroupType?: string(name='EndpointGroupType', position='Query'),
  listenerId?: string(name='ListenerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListEndpointGroupsResponseBody = {
  endpointGroups?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      description?: string(name='Description'),
      endpointConfigurations?: [ 
        {
          enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
          endpoint?: string(name='Endpoint'),
          endpointId?: string(name='EndpointId'),
          probePort?: int32(name='ProbePort'),
          probeProtocol?: string(name='ProbeProtocol'),
          type?: string(name='Type'),
          weight?: int32(name='Weight'),
        }
      ](name='EndpointConfigurations'),
      endpointGroupId?: string(name='EndpointGroupId'),
      endpointGroupIpList?: [ string ](name='EndpointGroupIpList'),
      endpointGroupRegion?: string(name='EndpointGroupRegion'),
      endpointGroupType?: string(name='EndpointGroupType'),
      endpointGroupUnconfirmedIpList?: [ string ](name='EndpointGroupUnconfirmedIpList'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
      healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
      healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
      healthCheckPath?: string(name='HealthCheckPath'),
      healthCheckPort?: int32(name='HealthCheckPort'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      listenerId?: string(name='ListenerId'),
      name?: string(name='Name'),
      portOverrides?: [ 
        {
          endpointPort?: int32(name='EndpointPort'),
          listenerPort?: int32(name='ListenerPort'),
        }
      ](name='PortOverrides'),
      state?: string(name='State'),
      thresholdCount?: int32(name='ThresholdCount'),
      trafficPercentage?: int32(name='TrafficPercentage'),
    }
  ](name='EndpointGroups'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListEndpointGroupsResponseBody(name='body'),
}

async function listEndpointGroups(request: ListEndpointGroupsRequest): ListEndpointGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEndpointGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListForwardingRulesRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  forwardingRuleId?: string(name='ForwardingRuleId', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  maxResults: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
      forwardingRuleStatus?: string(name='ForwardingRuleStatus'),
      listenerId?: string(name='ListenerId'),
      priority?: int32(name='Priority'),
      ruleActions?: [ 
        {
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
        }
      ](name='RuleActions'),
      ruleConditions?: [ 
        {
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          ruleConditionType?: string(name='RuleConditionType'),
        }
      ](name='RuleConditions'),
    }
  ](name='ForwardingRules'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListForwardingRulesResponseBody(name='body'),
}

async function listForwardingRules(request: ListForwardingRulesRequest): ListForwardingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListForwardingRules', 'POST', '/', 'json', false, 'json', request);
}

model ListIpSetsRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListIpSetsResponseBody = {
  ipSets?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      bandwidth?: int32(name='Bandwidth'),
      ipAddressList?: [ string ](name='IpAddressList'),
      ipSetId?: string(name='IpSetId'),
      ipVersion?: string(name='IpVersion'),
      state?: string(name='State'),
    }
  ](name='IpSets'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpSetsResponseBody(name='body'),
}

async function listIpSets(request: ListIpSetsRequest): ListIpSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListIpSets', 'POST', '/', 'json', false, 'json', request);
}

model ListListenerCertificatesRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=50, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  role?: string(name='Role', position='Query'),
}

model ListListenerCertificatesResponseBody = {
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
      domain?: string(name='Domain'),
      isDefault?: boolean(name='IsDefault'),
    }
  ](name='Certificates'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenerCertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenerCertificatesResponseBody(name='body'),
}

async function listListenerCertificates(request: ListListenerCertificatesRequest): ListListenerCertificatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListListenerCertificates', 'POST', '/', 'json', false, 'json', request);
}

model ListListenersRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListListenersResponseBody = {
  listeners?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      backendPorts?: [ 
        {
          fromPort?: string(name='FromPort'),
          toPort?: string(name='ToPort'),
        }
      ](name='BackendPorts'),
      certificates?: [ 
        {
          id?: string(name='Id'),
          type?: string(name='Type'),
        }
      ](name='Certificates'),
      clientAffinity?: string(name='ClientAffinity'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      listenerId?: string(name='ListenerId'),
      name?: string(name='Name'),
      portRanges?: [ 
        {
          fromPort?: int32(name='FromPort'),
          toPort?: int32(name='ToPort'),
        }
      ](name='PortRanges'),
      protocol?: string(name='Protocol'),
      proxyProtocol?: boolean(name='ProxyProtocol'),
      securityPolicyId?: string(name='SecurityPolicyId'),
      state?: string(name='State'),
      XForwardedForConfig?: {
        XForwardedForGaApEnabled?: boolean(name='XForwardedForGaApEnabled'),
        XForwardedForGaIdEnabled?: boolean(name='XForwardedForGaIdEnabled'),
        XForwardedForPortEnabled?: boolean(name='XForwardedForPortEnabled'),
        XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
        XRealIpEnabled?: boolean(name='XRealIpEnabled'),
      }(name='XForwardedForConfig'),
    }
  ](name='Listeners'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersResponseBody(name='body'),
}

async function listListeners(request: ListListenersRequest): ListListenersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListListeners', 'POST', '/', 'json', false, 'json', request);
}

model ListSpareIpsRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListSpareIpsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  spareIps?: [ 
    {
      spareIp?: string(name='SpareIp'),
      state?: string(name='State'),
    }
  ](name='SpareIps'),
}

model ListSpareIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSpareIpsResponseBody(name='body'),
}

async function listSpareIps(request: ListSpareIpsRequest): ListSpareIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSpareIps', 'POST', '/', 'json', false, 'json', request);
}

model ListSystemSecurityPoliciesRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListSystemSecurityPoliciesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  securityPolicies?: [ 
    {
      ciphers?: [ string ](name='Ciphers'),
      securityPolicyId?: string(name='SecurityPolicyId'),
      tlsVersions?: [ string ](name='TlsVersions'),
    }
  ](name='SecurityPolicies'),
  totalCount?: int32(name='TotalCount'),
}

model ListSystemSecurityPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: ListSystemSecurityPoliciesResponseBody(name='body'),
}

async function listSystemSecurityPolicies(request: ListSystemSecurityPoliciesRequest): ListSystemSecurityPoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSystemSecurityPolicies', 'POST', '/', 'json', false, 'json', request);
}

model RemoveEntriesFromAclRequest {
  aclEntries: [ 
    {
      entry?: string(name='Entry'),
    }
  ](name='AclEntries', position='Query'),
  aclId: string(name='AclId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RemoveEntriesFromAclResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RemoveEntriesFromAclResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveEntriesFromAclResponseBody(name='body'),
}

async function removeEntriesFromAcl(request: RemoveEntriesFromAclRequest): RemoveEntriesFromAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveEntriesFromAcl', 'POST', '/', 'json', false, 'json', request);
}

model ReplaceBandwidthPackageRequest {
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  targetBandwidthPackageId: string(name='TargetBandwidthPackageId', position='Query'),
}

model ReplaceBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReplaceBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: ReplaceBandwidthPackageResponseBody(name='body'),
}

async function replaceBandwidthPackage(request: ReplaceBandwidthPackageRequest): ReplaceBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReplaceBandwidthPackage', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  autoPay?: boolean(name='AutoPay', position='Query'),
  autoUseCoupon?: boolean(name='AutoUseCoupon', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  spec?: string(name='Spec', position='Query'),
}

model UpdateAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAcceleratorResponseBody(name='body'),
}

async function updateAccelerator(request: UpdateAcceleratorRequest): UpdateAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAcceleratorAutoRenewAttributeRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  autoRenew?: boolean(name='AutoRenew', position='Query'),
  autoRenewDuration?: int32(name='AutoRenewDuration', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  renewalStatus?: string(name='RenewalStatus', position='Query'),
}

model UpdateAcceleratorAutoRenewAttributeResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  requestId?: string(name='RequestId'),
}

model UpdateAcceleratorAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAcceleratorAutoRenewAttributeResponseBody(name='body'),
}

async function updateAcceleratorAutoRenewAttribute(request: UpdateAcceleratorAutoRenewAttributeRequest): UpdateAcceleratorAutoRenewAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAcceleratorAutoRenewAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAcceleratorConfirmRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateAcceleratorConfirmResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAcceleratorConfirmResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAcceleratorConfirmResponseBody(name='body'),
}

async function updateAcceleratorConfirm(request: UpdateAcceleratorConfirmRequest): UpdateAcceleratorConfirmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAcceleratorConfirm', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAclAttributeRequest {
  aclId: string(name='AclId', position='Query'),
  aclName: string(name='AclName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateAclAttributeResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateAclAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAclAttributeResponseBody(name='body'),
}

async function updateAclAttribute(request: UpdateAclAttributeRequest): UpdateAclAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAclAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateApplicationMonitorRequest {
  address?: string(name='Address', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  detectThreshold?: int32(name='DetectThreshold', position='Query'),
  listenerId?: string(name='ListenerId', position='Query'),
  optionsJson?: string(name='OptionsJson', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
}

model UpdateApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationMonitorResponseBody(name='body'),
}

async function updateApplicationMonitor(request: UpdateApplicationMonitorRequest): UpdateApplicationMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateApplicationMonitor', 'POST', '/', 'json', false, 'json', request);
}

model UpdateBandwidthPackageRequest {
  autoPay?: boolean(name='AutoPay', position='Query'),
  autoUseCoupon?: boolean(name='AutoUseCoupon', position='Query'),
  bandwidth?: int32(name='Bandwidth', position='Query'),
  bandwidthPackageId: string(name='BandwidthPackageId', position='Query'),
  bandwidthType?: string(name='BandwidthType', position='Query'),
  description?: string(name='Description', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateBandwidthPackageResponseBody = {
  bandwidthPackage?: string(name='BandwidthPackage'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model UpdateBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBandwidthPackageResponseBody(name='body'),
}

async function updateBandwidthPackage(request: UpdateBandwidthPackageRequest): UpdateBandwidthPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateBandwidthPackage', 'POST', '/', 'json', false, 'json', request);
}

model UpdateBasicAcceleratorRequest {
  acceleratorId: string(name='AcceleratorId', description='全球加速实例Id', position='Query'),
  clientToken?: string(name='ClientToken', description='客户端Token', position='Query'),
  description?: string(name='Description', description='全球加速实例描述', position='Query'),
  name?: string(name='Name', description='全球加速实例名称', position='Query'),
  regionId?: string(name='RegionId', description='RegionId', position='Query'),
}

model UpdateBasicAcceleratorResponseBody = {
  requestId?: string(name='RequestId', description='请求Id'),
}

model UpdateBasicAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBasicAcceleratorResponseBody(name='body'),
}

async function updateBasicAccelerator(request: UpdateBasicAcceleratorRequest): UpdateBasicAcceleratorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateBasicAccelerator', 'POST', '/', 'json', false, 'json', request);
}

model UpdateBasicEndpointGroupRequest {
  clientToken?: string(name='ClientToken', description='客户端Token', position='Query'),
  description?: string(name='Description', description='终端节点组描述', position='Query'),
  endpointAddress: string(name='EndpointAddress', description='终端节点地址', position='Query'),
  endpointGroupId: string(name='EndpointGroupId', description='终端节点组Id', position='Query'),
  endpointType: string(name='EndpointType', description='终端节点类型', position='Query'),
  name?: string(name='Name', description='终端节点组名称', position='Query'),
  regionId: string(name='RegionId', description='Regionid', position='Query'),
}

model UpdateBasicEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='请求Id'),
}

model UpdateBasicEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBasicEndpointGroupResponseBody(name='body'),
}

async function updateBasicEndpointGroup(request: UpdateBasicEndpointGroupRequest): UpdateBasicEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateBasicEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateEndpointGroupRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  endpointConfigurations: [ 
    {
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      endpoint: string(name='Endpoint'),
      type: string(name='Type'),
      weight: int32(name='Weight'),
    }
  ](name='EndpointConfigurations', position='Query'),
  endpointGroupId: string(name='EndpointGroupId', position='Query'),
  endpointGroupRegion: string(name='EndpointGroupRegion', position='Query'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol', position='Query'),
  healthCheckEnabled?: boolean(name='HealthCheckEnabled', position='Query'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds', position='Query'),
  healthCheckPath?: string(name='HealthCheckPath', position='Query'),
  healthCheckPort?: int32(name='HealthCheckPort', position='Query'),
  healthCheckProtocol?: string(name='HealthCheckProtocol', position='Query'),
  name?: string(name='Name', position='Query'),
  portOverrides?: [ 
    {
      endpointPort?: int32(name='EndpointPort'),
      listenerPort?: int32(name='ListenerPort'),
    }
  ](name='PortOverrides', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  thresholdCount?: int32(name='ThresholdCount', position='Query'),
  trafficPercentage?: int32(name='TrafficPercentage', position='Query'),
}

model UpdateEndpointGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEndpointGroupResponseBody(name='body'),
}

async function updateEndpointGroup(request: UpdateEndpointGroupRequest): UpdateEndpointGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateEndpointGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateEndpointGroupAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  endpointGroupId: string(name='EndpointGroupId', position='Query'),
  name?: string(name='Name', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateEndpointGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEndpointGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEndpointGroupAttributeResponseBody(name='body'),
}

async function updateEndpointGroupAttribute(request: UpdateEndpointGroupAttributeRequest): UpdateEndpointGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateEndpointGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateEndpointGroupsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  endpointGroupConfigurations: [ 
    {
      enableClientIPPreservationProxyProtocol?: boolean(name='EnableClientIPPreservationProxyProtocol'),
      enableClientIPPreservationToa?: boolean(name='EnableClientIPPreservationToa'),
      endpointConfigurations?: [ 
        {
          endpoint?: string(name='Endpoint'),
          type?: string(name='Type'),
          weight?: long(name='Weight'),
        }
      ](name='EndpointConfigurations'),
      endpointGroupDescription?: string(name='EndpointGroupDescription'),
      endpointGroupId: string(name='EndpointGroupId'),
      endpointGroupName?: string(name='EndpointGroupName'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
      healthCheckIntervalSeconds?: long(name='HealthCheckIntervalSeconds'),
      healthCheckPath?: string(name='HealthCheckPath'),
      healthCheckPort?: long(name='HealthCheckPort'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      portOverrides?: [ 
        {
          endpointPort?: long(name='EndpointPort'),
          listenerPort?: long(name='ListenerPort'),
        }
      ](name='PortOverrides'),
      thresholdCount?: long(name='ThresholdCount'),
      trafficPercentage?: long(name='TrafficPercentage'),
    }
  ](name='EndpointGroupConfigurations', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateEndpointGroupsResponseBody = {
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEndpointGroupsResponseBody(name='body'),
}

async function updateEndpointGroups(request: UpdateEndpointGroupsRequest): UpdateEndpointGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateEndpointGroups', 'POST', '/', 'json', false, 'json', request);
}

model UpdateForwardingRuleAttributeRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  forwardingRule: map[string]any(name='ForwardingRule', position='Query'),
  forwardingRuleDescription?: string(name='ForwardingRuleDescription', position='Query'),
  forwardingRuleName?: string(name='ForwardingRuleName', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateForwardingRuleAttributeResponseBody = {
  endpointGroupId?: string(name='EndpointGroupId'),
  requestId?: string(name='RequestId'),
}

model UpdateForwardingRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateForwardingRuleAttributeResponseBody(name='body'),
}

async function updateForwardingRuleAttribute(request: UpdateForwardingRuleAttributeRequest): UpdateForwardingRuleAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateForwardingRuleAttribute', 'POST', '/', 'json', false, 'json', request);
}

model UpdateForwardingRulesRequest {
  acceleratorId: string(name='AcceleratorId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  forwardingRules: [ 
    {
      forwardingRuleId: string(name='ForwardingRuleId'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
      priority: int32(name='Priority'),
      ruleActions: [ 
        {
          forwardGroupConfig: {
            serverGroupTuples: [ 
              {
                endpointGroupId: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          order: int32(name='Order'),
          ruleActionType: string(name='RuleActionType'),
        }
      ](name='RuleActions'),
      ruleConditions: [ 
        {
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          ruleConditionType: string(name='RuleConditionType'),
        }
      ](name='RuleConditions'),
    }
  ](name='ForwardingRules', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model UpdateForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateForwardingRulesResponseBody(name='body'),
}

async function updateForwardingRules(request: UpdateForwardingRulesRequest): UpdateForwardingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateForwardingRules', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIpSetRequest {
  bandwidth: int32(name='Bandwidth', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  ipSetId: string(name='IpSetId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateIpSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpSetResponseBody(name='body'),
}

async function updateIpSet(request: UpdateIpSetRequest): UpdateIpSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIpSet', 'POST', '/', 'json', false, 'json', request);
}

model UpdateIpSetsRequest {
  ipSets: [ 
    {
      bandwidth: int32(name='Bandwidth'),
      ipSetId: string(name='IpSetId'),
    }
  ](name='IpSets', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model UpdateIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpSetsResponseBody(name='body'),
}

async function updateIpSets(request: UpdateIpSetsRequest): UpdateIpSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateIpSets', 'POST', '/', 'json', false, 'json', request);
}

model UpdateListenerRequest {
  backendPorts?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='BackendPorts', position='Query'),
  certificates?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Certificates', position='Query'),
  clientAffinity?: string(name='ClientAffinity', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  listenerId: string(name='ListenerId', position='Query'),
  name?: string(name='Name', position='Query'),
  portRanges?: [ 
    {
      fromPort: int32(name='FromPort'),
      toPort: int32(name='ToPort'),
    }
  ](name='PortRanges', position='Query'),
  protocol?: string(name='Protocol', position='Query'),
  proxyProtocol?: string(name='ProxyProtocol', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  securityPolicyId?: string(name='SecurityPolicyId', position='Query'),
  XForwardedForConfig?: {
    XForwardedForGaApEnabled?: boolean(name='XForwardedForGaApEnabled'),
    XForwardedForGaIdEnabled?: boolean(name='XForwardedForGaIdEnabled'),
    XForwardedForPortEnabled?: boolean(name='XForwardedForPortEnabled'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
    XRealIpEnabled?: boolean(name='XRealIpEnabled'),
  }(name='XForwardedForConfig', position='Query'),
}

model UpdateListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateListenerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateListenerResponseBody(name='body'),
}

async function updateListener(request: UpdateListenerRequest): UpdateListenerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateListener', 'POST', '/', 'json', false, 'json', request);
}

