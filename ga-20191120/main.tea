/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ga', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddEntriesToAclRequest {
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
      entryDescription?: string(name='EntryDescription'),
    }
  ](name='AclEntries'),
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
}

model AddEntriesToAclResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddEntriesToAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddEntriesToAclResponseBody(name='body'),
}

async function addEntriesToAclWithOptions(request: AddEntriesToAclRequest, runtime: Util.RuntimeOptions): AddEntriesToAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntries)) {
    query['AclEntries'] = request.aclEntries;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddEntriesToAcl',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addEntriesToAcl(request: AddEntriesToAclRequest): AddEntriesToAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEntriesToAclWithOptions(request, runtime);
}

model AssociateAclsWithListenerRequest {
  aclIds?: [ string ](name='AclIds'),
  aclType?: string(name='AclType'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model AssociateAclsWithListenerResponseBody = {
  aclIds?: [ string ](name='AclIds'),
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AssociateAclsWithListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateAclsWithListenerResponseBody(name='body'),
}

async function associateAclsWithListenerWithOptions(request: AssociateAclsWithListenerRequest, runtime: Util.RuntimeOptions): AssociateAclsWithListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateAclsWithListener',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateAclsWithListener(request: AssociateAclsWithListenerRequest): AssociateAclsWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateAclsWithListenerWithOptions(request, runtime);
}

model AssociateAdditionalCertificatesWithListenerRequest {
  acceleratorId?: string(name='AcceleratorId'),
  certificates?: [ 
    {
      domain?: string(name='Domain'),
      id?: string(name='Id'),
    }
  ](name='Certificates'),
  clientToken?: string(name='ClientToken'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model AssociateAdditionalCertificatesWithListenerResponseBody = {
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId'),
}

model AssociateAdditionalCertificatesWithListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateAdditionalCertificatesWithListenerResponseBody(name='body'),
}

async function associateAdditionalCertificatesWithListenerWithOptions(request: AssociateAdditionalCertificatesWithListenerRequest, runtime: Util.RuntimeOptions): AssociateAdditionalCertificatesWithListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateAdditionalCertificatesWithListener',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateAdditionalCertificatesWithListener(request: AssociateAdditionalCertificatesWithListenerRequest): AssociateAdditionalCertificatesWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateAdditionalCertificatesWithListenerWithOptions(request, runtime);
}

model AttachDdosToAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  ddosId?: string(name='DdosId'),
  ddosRegionId?: string(name='DdosRegionId'),
  regionId?: string(name='RegionId'),
}

model AttachDdosToAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  gaId?: string(name='GaId'),
  requestId?: string(name='RequestId'),
}

model AttachDdosToAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachDdosToAcceleratorResponseBody(name='body'),
}

async function attachDdosToAcceleratorWithOptions(request: AttachDdosToAcceleratorRequest, runtime: Util.RuntimeOptions): AttachDdosToAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.ddosId)) {
    query['DdosId'] = request.ddosId;
  }
  if (!Util.isUnset(request.ddosRegionId)) {
    query['DdosRegionId'] = request.ddosRegionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachDdosToAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachDdosToAccelerator(request: AttachDdosToAcceleratorRequest): AttachDdosToAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDdosToAcceleratorWithOptions(request, runtime);
}

model AttachLogStoreToEndpointGroupRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
  slsLogStoreName?: string(name='SlsLogStoreName'),
  slsProjectName?: string(name='SlsProjectName'),
  slsRegionId?: string(name='SlsRegionId'),
}

model AttachLogStoreToEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AttachLogStoreToEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachLogStoreToEndpointGroupResponseBody(name='body'),
}

async function attachLogStoreToEndpointGroupWithOptions(request: AttachLogStoreToEndpointGroupRequest, runtime: Util.RuntimeOptions): AttachLogStoreToEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endpointGroupIds)) {
    query['EndpointGroupIds'] = request.endpointGroupIds;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.slsLogStoreName)) {
    query['SlsLogStoreName'] = request.slsLogStoreName;
  }
  if (!Util.isUnset(request.slsProjectName)) {
    query['SlsProjectName'] = request.slsProjectName;
  }
  if (!Util.isUnset(request.slsRegionId)) {
    query['SlsRegionId'] = request.slsRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachLogStoreToEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachLogStoreToEndpointGroup(request: AttachLogStoreToEndpointGroupRequest): AttachLogStoreToEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachLogStoreToEndpointGroupWithOptions(request, runtime);
}

model BandwidthPackageAddAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  regionId?: string(name='RegionId'),
}

model BandwidthPackageAddAcceleratorResponseBody = {
  accelerators?: [ string ](name='Accelerators'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  requestId?: string(name='RequestId'),
}

model BandwidthPackageAddAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BandwidthPackageAddAcceleratorResponseBody(name='body'),
}

async function bandwidthPackageAddAcceleratorWithOptions(request: BandwidthPackageAddAcceleratorRequest, runtime: Util.RuntimeOptions): BandwidthPackageAddAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BandwidthPackageAddAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bandwidthPackageAddAccelerator(request: BandwidthPackageAddAcceleratorRequest): BandwidthPackageAddAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return bandwidthPackageAddAcceleratorWithOptions(request, runtime);
}

model BandwidthPackageRemoveAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  regionId?: string(name='RegionId'),
}

model BandwidthPackageRemoveAcceleratorResponseBody = {
  accelerators?: [ string ](name='Accelerators'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  requestId?: string(name='RequestId'),
}

model BandwidthPackageRemoveAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BandwidthPackageRemoveAcceleratorResponseBody(name='body'),
}

async function bandwidthPackageRemoveAcceleratorWithOptions(request: BandwidthPackageRemoveAcceleratorRequest, runtime: Util.RuntimeOptions): BandwidthPackageRemoveAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BandwidthPackageRemoveAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bandwidthPackageRemoveAccelerator(request: BandwidthPackageRemoveAcceleratorRequest): BandwidthPackageRemoveAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return bandwidthPackageRemoveAcceleratorWithOptions(request, runtime);
}

model ConfigEndpointProbeRequest {
  clientToken?: string(name='ClientToken'),
  enable?: string(name='Enable'),
  endpoint?: string(name='Endpoint'),
  endpointGroupId?: string(name='EndpointGroupId'),
  endpointType?: string(name='EndpointType'),
  probePort?: string(name='ProbePort'),
  probeProtocol?: string(name='ProbeProtocol'),
  regionId?: string(name='RegionId'),
}

model ConfigEndpointProbeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigEndpointProbeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigEndpointProbeResponseBody(name='body'),
}

async function configEndpointProbeWithOptions(request: ConfigEndpointProbeRequest, runtime: Util.RuntimeOptions): ConfigEndpointProbeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.endpoint)) {
    query['Endpoint'] = request.endpoint;
  }
  if (!Util.isUnset(request.endpointGroupId)) {
    query['EndpointGroupId'] = request.endpointGroupId;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.probePort)) {
    query['ProbePort'] = request.probePort;
  }
  if (!Util.isUnset(request.probeProtocol)) {
    query['ProbeProtocol'] = request.probeProtocol;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigEndpointProbe',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configEndpointProbe(request: ConfigEndpointProbeRequest): ConfigEndpointProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return configEndpointProbeWithOptions(request, runtime);
}

model CreateAcceleratorRequest {
  autoPay?: boolean(name='AutoPay'),
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewDuration?: int32(name='AutoRenewDuration'),
  autoUseCoupon?: string(name='AutoUseCoupon'),
  clientToken?: string(name='ClientToken'),
  duration?: int32(name='Duration'),
  ipSetConfig?: {
    accessMode?: string(name='AccessMode'),
  }(name='IpSetConfig'),
  name?: string(name='Name'),
  pricingCycle?: string(name='PricingCycle'),
  regionId?: string(name='RegionId'),
  spec?: string(name='Spec'),
}

model CreateAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAcceleratorResponseBody(name='body'),
}

async function createAcceleratorWithOptions(request: CreateAcceleratorRequest, runtime: Util.RuntimeOptions): CreateAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewDuration)) {
    query['AutoRenewDuration'] = request.autoRenewDuration;
  }
  if (!Util.isUnset(request.autoUseCoupon)) {
    query['AutoUseCoupon'] = request.autoUseCoupon;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.ipSetConfig)) {
    query['IpSetConfig'] = request.ipSetConfig;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccelerator(request: CreateAcceleratorRequest): CreateAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAcceleratorWithOptions(request, runtime);
}

model CreateAclRequest {
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
      entryDescription?: string(name='EntryDescription'),
    }
  ](name='AclEntries'),
  aclName?: string(name='AclName'),
  addressIPVersion?: string(name='AddressIPVersion'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
}

model CreateAclResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAclResponseBody(name='body'),
}

async function createAclWithOptions(request: CreateAclRequest, runtime: Util.RuntimeOptions): CreateAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntries)) {
    query['AclEntries'] = request.aclEntries;
  }
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.addressIPVersion)) {
    query['AddressIPVersion'] = request.addressIPVersion;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAcl',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAcl(request: CreateAclRequest): CreateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAclWithOptions(request, runtime);
}

model CreateApplicationMonitorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  address?: string(name='Address'),
  clientToken?: string(name='ClientToken'),
  detectEnable?: boolean(name='DetectEnable'),
  detectThreshold?: int32(name='DetectThreshold'),
  detectTimes?: int32(name='DetectTimes'),
  listenerId?: string(name='ListenerId'),
  optionsJson?: string(name='OptionsJson'),
  regionId?: string(name='RegionId'),
  silenceTime?: int32(name='SilenceTime'),
  taskName?: string(name='TaskName'),
}

model CreateApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId'),
}

model CreateApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateApplicationMonitorResponseBody(name='body'),
}

async function createApplicationMonitorWithOptions(request: CreateApplicationMonitorRequest, runtime: Util.RuntimeOptions): CreateApplicationMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.detectEnable)) {
    query['DetectEnable'] = request.detectEnable;
  }
  if (!Util.isUnset(request.detectThreshold)) {
    query['DetectThreshold'] = request.detectThreshold;
  }
  if (!Util.isUnset(request.detectTimes)) {
    query['DetectTimes'] = request.detectTimes;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.optionsJson)) {
    query['OptionsJson'] = request.optionsJson;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplicationMonitor',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApplicationMonitor(request: CreateApplicationMonitorRequest): CreateApplicationMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationMonitorWithOptions(request, runtime);
}

model CreateBandwidthPackageRequest {
  autoPay?: boolean(name='AutoPay'),
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewDuration?: int32(name='AutoRenewDuration'),
  autoUseCoupon?: string(name='AutoUseCoupon'),
  bandwidth?: int32(name='Bandwidth'),
  bandwidthType?: string(name='BandwidthType'),
  billingType?: string(name='BillingType'),
  cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
  cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
  chargeType?: string(name='ChargeType'),
  clientToken?: string(name='ClientToken'),
  duration?: string(name='Duration'),
  pricingCycle?: string(name='PricingCycle'),
  ratio?: int32(name='Ratio'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model CreateBandwidthPackageResponseBody = {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBandwidthPackageResponseBody(name='body'),
}

async function createBandwidthPackageWithOptions(request: CreateBandwidthPackageRequest, runtime: Util.RuntimeOptions): CreateBandwidthPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewDuration)) {
    query['AutoRenewDuration'] = request.autoRenewDuration;
  }
  if (!Util.isUnset(request.autoUseCoupon)) {
    query['AutoUseCoupon'] = request.autoUseCoupon;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.bandwidthType)) {
    query['BandwidthType'] = request.bandwidthType;
  }
  if (!Util.isUnset(request.billingType)) {
    query['BillingType'] = request.billingType;
  }
  if (!Util.isUnset(request.cbnGeographicRegionIdA)) {
    query['CbnGeographicRegionIdA'] = request.cbnGeographicRegionIdA;
  }
  if (!Util.isUnset(request.cbnGeographicRegionIdB)) {
    query['CbnGeographicRegionIdB'] = request.cbnGeographicRegionIdB;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.ratio)) {
    query['Ratio'] = request.ratio;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBandwidthPackage',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBandwidthPackage(request: CreateBandwidthPackageRequest): CreateBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBandwidthPackageWithOptions(request, runtime);
}

model CreateBasicAcceleratorRequest {
  autoPay?: boolean(name='AutoPay', description='自动续费'),
  autoRenew?: boolean(name='AutoRenew', description='自动续费'),
  autoRenewDuration?: int32(name='AutoRenewDuration', description='续费周期'),
  autoUseCoupon?: string(name='AutoUseCoupon', description='自动使用优惠券'),
  clientToken?: string(name='ClientToken', description='客户端Token'),
  duration?: int32(name='Duration', description='购买时长'),
  pricingCycle?: string(name='PricingCycle', description='时长单位'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model CreateBasicAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例ID'),
  orderId?: string(name='OrderId', description='订单Id'),
  requestId?: string(name='RequestId', description='请求Id'),
}

model CreateBasicAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBasicAcceleratorResponseBody(name='body'),
}

async function createBasicAcceleratorWithOptions(request: CreateBasicAcceleratorRequest, runtime: Util.RuntimeOptions): CreateBasicAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewDuration)) {
    query['AutoRenewDuration'] = request.autoRenewDuration;
  }
  if (!Util.isUnset(request.autoUseCoupon)) {
    query['AutoUseCoupon'] = request.autoUseCoupon;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBasicAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBasicAccelerator(request: CreateBasicAcceleratorRequest): CreateBasicAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBasicAcceleratorWithOptions(request, runtime);
}

model CreateBasicEndpointGroupRequest {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  clientToken?: string(name='ClientToken', description='客户端Token'),
  description?: string(name='Description', description='终端节点组描述'),
  endpointAddress?: string(name='EndpointAddress', description='终端节点地址'),
  endpointGroupRegion?: string(name='EndpointGroupRegion', description='终端节点组所在地域'),
  endpointType?: string(name='EndpointType', description='终端节点类型'),
  name?: string(name='Name', description='终端节点组名称'),
  regionId?: string(name='RegionId', description='Regionid'),
}

model CreateBasicEndpointGroupResponseBody = {
  endpointGroupId?: string(name='EndpointGroupId', description='终端节点组Id'),
  requestId?: string(name='RequestId', description='请求Id'),
}

model CreateBasicEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBasicEndpointGroupResponseBody(name='body'),
}

async function createBasicEndpointGroupWithOptions(request: CreateBasicEndpointGroupRequest, runtime: Util.RuntimeOptions): CreateBasicEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endpointAddress)) {
    query['EndpointAddress'] = request.endpointAddress;
  }
  if (!Util.isUnset(request.endpointGroupRegion)) {
    query['EndpointGroupRegion'] = request.endpointGroupRegion;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBasicEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBasicEndpointGroup(request: CreateBasicEndpointGroupRequest): CreateBasicEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBasicEndpointGroupWithOptions(request, runtime);
}

model CreateBasicIpSetRequest {
  accelerateRegionId?: string(name='AccelerateRegionId', description='加速地域Id'),
  acceleratorId?: string(name='AcceleratorId', description='基础版全球加速实例Id'),
  clientToken?: string(name='ClientToken', description='客户端Token'),
  ispType?: string(name='IspType', description='公网质量类型'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model CreateBasicIpSetResponseBody = {
  ipSetId?: string(name='IpSetId', description='加速地域接入点Id'),
  requestId?: string(name='RequestId', description='请求Id'),
}

model CreateBasicIpSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBasicIpSetResponseBody(name='body'),
}

async function createBasicIpSetWithOptions(request: CreateBasicIpSetRequest, runtime: Util.RuntimeOptions): CreateBasicIpSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accelerateRegionId)) {
    query['AccelerateRegionId'] = request.accelerateRegionId;
  }
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ispType)) {
    query['IspType'] = request.ispType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBasicIpSet',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBasicIpSet(request: CreateBasicIpSetRequest): CreateBasicIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBasicIpSetWithOptions(request, runtime);
}

model CreateEndpointGroupRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  endpointConfigurations?: [ 
    {
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      endpoint?: string(name='Endpoint'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='EndpointConfigurations'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  endpointGroupType?: string(name='EndpointGroupType'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  listenerId?: string(name='ListenerId'),
  name?: string(name='Name'),
  portOverrides?: [ 
    {
      endpointPort?: int32(name='EndpointPort'),
      listenerPort?: int32(name='ListenerPort'),
    }
  ](name='PortOverrides'),
  regionId?: string(name='RegionId'),
  thresholdCount?: int32(name='ThresholdCount'),
  trafficPercentage?: int32(name='TrafficPercentage'),
}

model CreateEndpointGroupResponseBody = {
  endpointGroupId?: string(name='EndpointGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEndpointGroupResponseBody(name='body'),
}

async function createEndpointGroupWithOptions(request: CreateEndpointGroupRequest, runtime: Util.RuntimeOptions): CreateEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endpointConfigurations)) {
    query['EndpointConfigurations'] = request.endpointConfigurations;
  }
  if (!Util.isUnset(request.endpointGroupRegion)) {
    query['EndpointGroupRegion'] = request.endpointGroupRegion;
  }
  if (!Util.isUnset(request.endpointGroupType)) {
    query['EndpointGroupType'] = request.endpointGroupType;
  }
  if (!Util.isUnset(request.endpointRequestProtocol)) {
    query['EndpointRequestProtocol'] = request.endpointRequestProtocol;
  }
  if (!Util.isUnset(request.healthCheckEnabled)) {
    query['HealthCheckEnabled'] = request.healthCheckEnabled;
  }
  if (!Util.isUnset(request.healthCheckIntervalSeconds)) {
    query['HealthCheckIntervalSeconds'] = request.healthCheckIntervalSeconds;
  }
  if (!Util.isUnset(request.healthCheckPath)) {
    query['HealthCheckPath'] = request.healthCheckPath;
  }
  if (!Util.isUnset(request.healthCheckPort)) {
    query['HealthCheckPort'] = request.healthCheckPort;
  }
  if (!Util.isUnset(request.healthCheckProtocol)) {
    query['HealthCheckProtocol'] = request.healthCheckProtocol;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.portOverrides)) {
    query['PortOverrides'] = request.portOverrides;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.thresholdCount)) {
    query['ThresholdCount'] = request.thresholdCount;
  }
  if (!Util.isUnset(request.trafficPercentage)) {
    query['TrafficPercentage'] = request.trafficPercentage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEndpointGroup(request: CreateEndpointGroupRequest): CreateEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEndpointGroupWithOptions(request, runtime);
}

model CreateEndpointGroupsRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointGroupConfigurations?: [ 
    {
      enableClientIPPreservationProxyProtocol?: boolean(name='EnableClientIPPreservationProxyProtocol'),
      enableClientIPPreservationToa?: boolean(name='EnableClientIPPreservationToa'),
      endpointConfigurations?: [ 
        {
          endpoint?: string(name='Endpoint'),
          type?: string(name='Type'),
          weight?: long(name='Weight'),
        }
      ](name='EndpointConfigurations'),
      endpointGroupDescription?: string(name='EndpointGroupDescription'),
      endpointGroupName?: string(name='EndpointGroupName'),
      endpointGroupRegion?: string(name='EndpointGroupRegion'),
      endpointGroupType?: string(name='EndpointGroupType'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
      healthCheckIntervalSeconds?: long(name='HealthCheckIntervalSeconds'),
      healthCheckPath?: string(name='HealthCheckPath'),
      healthCheckPort?: long(name='HealthCheckPort'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      portOverrides?: [ 
        {
          endpointPort?: long(name='EndpointPort'),
          listenerPort?: long(name='ListenerPort'),
        }
      ](name='PortOverrides'),
      thresholdCount?: long(name='ThresholdCount'),
      trafficPercentage?: long(name='TrafficPercentage'),
    }
  ](name='EndpointGroupConfigurations'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model CreateEndpointGroupsResponseBody = {
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEndpointGroupsResponseBody(name='body'),
}

async function createEndpointGroupsWithOptions(request: CreateEndpointGroupsRequest, runtime: Util.RuntimeOptions): CreateEndpointGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endpointGroupConfigurations)) {
    query['EndpointGroupConfigurations'] = request.endpointGroupConfigurations;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateEndpointGroups',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEndpointGroups(request: CreateEndpointGroupsRequest): CreateEndpointGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEndpointGroupsWithOptions(request, runtime);
}

model CreateForwardingRulesRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  forwardingRules?: [ 
    {
      forwardingRuleName?: string(name='ForwardingRuleName'),
      priority?: int32(name='Priority'),
      ruleActions?: [ 
        {
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
          ruleActionValue?: string(name='RuleActionValue'),
        }
      ](name='RuleActions'),
      ruleConditions?: [ 
        {
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          ruleConditionType?: string(name='RuleConditionType'),
          ruleConditionValue?: string(name='RuleConditionValue'),
        }
      ](name='RuleConditions'),
      ruleDirection?: string(name='RuleDirection'),
    }
  ](name='ForwardingRules'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model CreateForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model CreateForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateForwardingRulesResponseBody(name='body'),
}

async function createForwardingRulesWithOptions(request: CreateForwardingRulesRequest, runtime: Util.RuntimeOptions): CreateForwardingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forwardingRules)) {
    query['ForwardingRules'] = request.forwardingRules;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateForwardingRules',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createForwardingRules(request: CreateForwardingRulesRequest): CreateForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createForwardingRulesWithOptions(request, runtime);
}

model CreateIpSetsRequest {
  accelerateRegion?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      bandwidth?: int32(name='Bandwidth'),
      ipVersion?: string(name='IpVersion'),
    }
  ](name='AccelerateRegion'),
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
}

model CreateIpSetsResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  ipSets?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      bandwidth?: int32(name='Bandwidth'),
      ipSetId?: string(name='IpSetId'),
    }
  ](name='IpSets'),
  requestId?: string(name='RequestId'),
}

model CreateIpSetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIpSetsResponseBody(name='body'),
}

async function createIpSetsWithOptions(request: CreateIpSetsRequest, runtime: Util.RuntimeOptions): CreateIpSetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accelerateRegion)) {
    query['AccelerateRegion'] = request.accelerateRegion;
  }
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIpSets',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIpSets(request: CreateIpSetsRequest): CreateIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpSetsWithOptions(request, runtime);
}

model CreateListenerRequest {
  acceleratorId?: string(name='AcceleratorId'),
  certificates?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Certificates'),
  clientAffinity?: string(name='ClientAffinity'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  protocol?: string(name='Protocol'),
  proxyProtocol?: boolean(name='ProxyProtocol'),
  regionId?: string(name='RegionId'),
  securityPolicyId?: string(name='SecurityPolicyId'),
  XForwardedForConfig?: {
    XForwardedForGaApEnabled?: boolean(name='XForwardedForGaApEnabled'),
    XForwardedForGaIdEnabled?: boolean(name='XForwardedForGaIdEnabled'),
    XForwardedForPortEnabled?: boolean(name='XForwardedForPortEnabled'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
    XRealIpEnabled?: boolean(name='XRealIpEnabled'),
  }(name='XForwardedForConfig'),
}

model CreateListenerResponseBody = {
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId'),
}

model CreateListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateListenerResponseBody(name='body'),
}

async function createListenerWithOptions(request: CreateListenerRequest, runtime: Util.RuntimeOptions): CreateListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientAffinity)) {
    query['ClientAffinity'] = request.clientAffinity;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.portRanges)) {
    query['PortRanges'] = request.portRanges;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.proxyProtocol)) {
    query['ProxyProtocol'] = request.proxyProtocol;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.XForwardedForConfig)) {
    query['XForwardedForConfig'] = request.XForwardedForConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateListener',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createListenerWithOptions(request, runtime);
}

model CreateSpareIpsRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  spareIps?: [ string ](name='SpareIps'),
}

model CreateSpareIpsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateSpareIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSpareIpsResponseBody(name='body'),
}

async function createSpareIpsWithOptions(request: CreateSpareIpsRequest, runtime: Util.RuntimeOptions): CreateSpareIpsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.spareIps)) {
    query['SpareIps'] = request.spareIps;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSpareIps',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSpareIps(request: CreateSpareIpsRequest): CreateSpareIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSpareIpsWithOptions(request, runtime);
}

model DeleteAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  regionId?: string(name='RegionId'),
}

model DeleteAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  requestId?: string(name='RequestId'),
}

model DeleteAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAcceleratorResponseBody(name='body'),
}

async function deleteAcceleratorWithOptions(request: DeleteAcceleratorRequest, runtime: Util.RuntimeOptions): DeleteAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccelerator(request: DeleteAcceleratorRequest): DeleteAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAcceleratorWithOptions(request, runtime);
}

model DeleteAclRequest {
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
}

model DeleteAclResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAclResponseBody(name='body'),
}

async function deleteAclWithOptions(request: DeleteAclRequest, runtime: Util.RuntimeOptions): DeleteAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAcl',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAcl(request: DeleteAclRequest): DeleteAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAclWithOptions(request, runtime);
}

model DeleteApplicationMonitorRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
}

model DeleteApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteApplicationMonitorResponseBody(name='body'),
}

async function deleteApplicationMonitorWithOptions(request: DeleteApplicationMonitorRequest, runtime: Util.RuntimeOptions): DeleteApplicationMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplicationMonitor',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteApplicationMonitor(request: DeleteApplicationMonitorRequest): DeleteApplicationMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationMonitorWithOptions(request, runtime);
}

model DeleteBandwidthPackageRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
}

model DeleteBandwidthPackageResponseBody = {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  requestId?: string(name='RequestId'),
}

model DeleteBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBandwidthPackageResponseBody(name='body'),
}

async function deleteBandwidthPackageWithOptions(request: DeleteBandwidthPackageRequest, runtime: Util.RuntimeOptions): DeleteBandwidthPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBandwidthPackage',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBandwidthPackage(request: DeleteBandwidthPackageRequest): DeleteBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBandwidthPackageWithOptions(request, runtime);
}

model DeleteBasicAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model DeleteBasicAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  requestId?: string(name='RequestId', description='请求Id'),
}

model DeleteBasicAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBasicAcceleratorResponseBody(name='body'),
}

async function deleteBasicAcceleratorWithOptions(request: DeleteBasicAcceleratorRequest, runtime: Util.RuntimeOptions): DeleteBasicAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBasicAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBasicAccelerator(request: DeleteBasicAcceleratorRequest): DeleteBasicAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBasicAcceleratorWithOptions(request, runtime);
}

model DeleteBasicEndpointGroupRequest {
  clientToken?: string(name='ClientToken', description='客户端Token'),
  endpointGroupId?: string(name='EndpointGroupId', description='终端节点组Id'),
}

model DeleteBasicEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='请求Id'),
}

model DeleteBasicEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBasicEndpointGroupResponseBody(name='body'),
}

async function deleteBasicEndpointGroupWithOptions(request: DeleteBasicEndpointGroupRequest, runtime: Util.RuntimeOptions): DeleteBasicEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endpointGroupId)) {
    query['EndpointGroupId'] = request.endpointGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBasicEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBasicEndpointGroup(request: DeleteBasicEndpointGroupRequest): DeleteBasicEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBasicEndpointGroupWithOptions(request, runtime);
}

model DeleteBasicIpSetRequest {
  clientToken?: string(name='ClientToken', description='客户端Token'),
  ipSetId?: string(name='IpSetId', description='加速接入点Id'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model DeleteBasicIpSetResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteBasicIpSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBasicIpSetResponseBody(name='body'),
}

async function deleteBasicIpSetWithOptions(request: DeleteBasicIpSetRequest, runtime: Util.RuntimeOptions): DeleteBasicIpSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipSetId)) {
    query['IpSetId'] = request.ipSetId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBasicIpSet',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBasicIpSet(request: DeleteBasicIpSetRequest): DeleteBasicIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBasicIpSetWithOptions(request, runtime);
}

model DeleteEndpointGroupRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  endpointGroupId?: string(name='EndpointGroupId'),
}

model DeleteEndpointGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEndpointGroupResponseBody(name='body'),
}

async function deleteEndpointGroupWithOptions(request: DeleteEndpointGroupRequest, runtime: Util.RuntimeOptions): DeleteEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endpointGroupId)) {
    query['EndpointGroupId'] = request.endpointGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEndpointGroup(request: DeleteEndpointGroupRequest): DeleteEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEndpointGroupWithOptions(request, runtime);
}

model DeleteEndpointGroupsRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
  regionId?: string(name='RegionId'),
}

model DeleteEndpointGroupsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEndpointGroupsResponseBody(name='body'),
}

async function deleteEndpointGroupsWithOptions(request: DeleteEndpointGroupsRequest, runtime: Util.RuntimeOptions): DeleteEndpointGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endpointGroupIds)) {
    query['EndpointGroupIds'] = request.endpointGroupIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEndpointGroups',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEndpointGroups(request: DeleteEndpointGroupsRequest): DeleteEndpointGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEndpointGroupsWithOptions(request, runtime);
}

model DeleteForwardingRulesRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model DeleteForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model DeleteForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteForwardingRulesResponseBody(name='body'),
}

async function deleteForwardingRulesWithOptions(request: DeleteForwardingRulesRequest, runtime: Util.RuntimeOptions): DeleteForwardingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forwardingRuleIds)) {
    query['ForwardingRuleIds'] = request.forwardingRuleIds;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteForwardingRules',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteForwardingRules(request: DeleteForwardingRulesRequest): DeleteForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteForwardingRulesWithOptions(request, runtime);
}

model DeleteIpSetRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  ipSetId?: string(name='IpSetId'),
  regionId?: string(name='RegionId'),
}

model DeleteIpSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIpSetResponseBody(name='body'),
}

async function deleteIpSetWithOptions(request: DeleteIpSetRequest, runtime: Util.RuntimeOptions): DeleteIpSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipSetId)) {
    query['IpSetId'] = request.ipSetId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIpSet',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIpSet(request: DeleteIpSetRequest): DeleteIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpSetWithOptions(request, runtime);
}

model DeleteIpSetsRequest {
  ipSetIds?: [ string ](name='IpSetIds'),
  regionId?: string(name='RegionId'),
}

model DeleteIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpSetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIpSetsResponseBody(name='body'),
}

async function deleteIpSetsWithOptions(request: DeleteIpSetsRequest, runtime: Util.RuntimeOptions): DeleteIpSetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipSetIds)) {
    query['IpSetIds'] = request.ipSetIds;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIpSets',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIpSets(request: DeleteIpSetsRequest): DeleteIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpSetsWithOptions(request, runtime);
}

model DeleteListenerRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  listenerId?: string(name='ListenerId'),
}

model DeleteListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteListenerResponseBody(name='body'),
}

async function deleteListenerWithOptions(request: DeleteListenerRequest, runtime: Util.RuntimeOptions): DeleteListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteListener',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteListenerWithOptions(request, runtime);
}

model DeleteSpareIpsRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  spareIps?: [ string ](name='SpareIps'),
}

model DeleteSpareIpsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteSpareIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSpareIpsResponseBody(name='body'),
}

async function deleteSpareIpsWithOptions(request: DeleteSpareIpsRequest, runtime: Util.RuntimeOptions): DeleteSpareIpsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.spareIps)) {
    query['SpareIps'] = request.spareIps;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSpareIps',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSpareIps(request: DeleteSpareIpsRequest): DeleteSpareIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSpareIpsWithOptions(request, runtime);
}

model DescribeAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  regionId?: string(name='RegionId'),
}

model DescribeAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  basicBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth'),
    bandwidthType?: string(name='BandwidthType'),
    instanceId?: string(name='InstanceId'),
  }(name='BasicBandwidthPackage'),
  cenId?: string(name='CenId'),
  createTime?: long(name='CreateTime'),
  crossDomainBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth'),
    instanceId?: string(name='InstanceId'),
  }(name='CrossDomainBandwidthPackage'),
  ddosId?: string(name='DdosId'),
  description?: string(name='Description'),
  dnsName?: string(name='DnsName'),
  expiredTime?: long(name='ExpiredTime'),
  instanceChargeType?: string(name='InstanceChargeType'),
  ipSetConfig?: {
    accessMode?: string(name='AccessMode'),
  }(name='IpSetConfig'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  secondDnsName?: string(name='SecondDnsName'),
  spec?: string(name='Spec'),
  state?: string(name='State'),
}

model DescribeAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAcceleratorResponseBody(name='body'),
}

async function describeAcceleratorWithOptions(request: DescribeAcceleratorRequest, runtime: Util.RuntimeOptions): DescribeAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccelerator(request: DescribeAcceleratorRequest): DescribeAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAcceleratorWithOptions(request, runtime);
}

model DescribeAcceleratorAutoRenewAttributeRequest {
  acceleratorId?: string(name='AcceleratorId'),
  regionId?: string(name='RegionId'),
}

model DescribeAcceleratorAutoRenewAttributeResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewDuration?: int32(name='AutoRenewDuration'),
  renewalStatus?: string(name='RenewalStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeAcceleratorAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAcceleratorAutoRenewAttributeResponseBody(name='body'),
}

async function describeAcceleratorAutoRenewAttributeWithOptions(request: DescribeAcceleratorAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): DescribeAcceleratorAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAcceleratorAutoRenewAttribute',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAcceleratorAutoRenewAttribute(request: DescribeAcceleratorAutoRenewAttributeRequest): DescribeAcceleratorAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAcceleratorAutoRenewAttributeWithOptions(request, runtime);
}

model DescribeApplicationMonitorRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
}

model DescribeApplicationMonitorResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  address?: string(name='Address'),
  detectEnable?: boolean(name='DetectEnable'),
  detectThreshold?: int32(name='DetectThreshold'),
  detectTimes?: int32(name='DetectTimes'),
  ispCityList?: [ 
    {
      city?: string(name='City'),
      cityName?: string(name='CityName'),
      isp?: string(name='Isp'),
      ispName?: string(name='IspName'),
    }
  ](name='IspCityList'),
  listenerId?: string(name='ListenerId'),
  optionsJson?: string(name='OptionsJson'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  silenceTime?: int32(name='SilenceTime'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model DescribeApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationMonitorResponseBody(name='body'),
}

async function describeApplicationMonitorWithOptions(request: DescribeApplicationMonitorRequest, runtime: Util.RuntimeOptions): DescribeApplicationMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationMonitor',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeApplicationMonitor(request: DescribeApplicationMonitorRequest): DescribeApplicationMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeApplicationMonitorWithOptions(request, runtime);
}

model DescribeBandwidthPackageRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  regionId?: string(name='RegionId'),
}

model DescribeBandwidthPackageResponseBody = {
  accelerators?: [ string ](name='Accelerators'),
  bandwidth?: int32(name='Bandwidth'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  bandwidthType?: string(name='BandwidthType'),
  billingType?: string(name='BillingType'),
  cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
  cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
  chargeType?: string(name='ChargeType'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  expiredTime?: string(name='ExpiredTime'),
  name?: string(name='Name'),
  ratio?: int32(name='Ratio'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
  type?: string(name='Type'),
}

model DescribeBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBandwidthPackageResponseBody(name='body'),
}

async function describeBandwidthPackageWithOptions(request: DescribeBandwidthPackageRequest, runtime: Util.RuntimeOptions): DescribeBandwidthPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBandwidthPackage',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBandwidthPackage(request: DescribeBandwidthPackageRequest): DescribeBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBandwidthPackageWithOptions(request, runtime);
}

model DescribeBandwidthPackageAutoRenewAttributeRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DescribeBandwidthPackageAutoRenewAttributeResponseBody = {
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewDuration?: int32(name='AutoRenewDuration'),
  instanceId?: string(name='InstanceId'),
  renewalStatus?: string(name='RenewalStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeBandwidthPackageAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBandwidthPackageAutoRenewAttributeResponseBody(name='body'),
}

async function describeBandwidthPackageAutoRenewAttributeWithOptions(request: DescribeBandwidthPackageAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): DescribeBandwidthPackageAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBandwidthPackageAutoRenewAttribute',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBandwidthPackageAutoRenewAttribute(request: DescribeBandwidthPackageAutoRenewAttributeRequest): DescribeBandwidthPackageAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBandwidthPackageAutoRenewAttributeWithOptions(request, runtime);
}

model DescribeEndpointGroupRequest {
  endpointGroupId?: string(name='EndpointGroupId'),
  regionId?: string(name='RegionId'),
}

model DescribeEndpointGroupResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  accessLogSwitch?: string(name='AccessLogSwitch'),
  description?: string(name='Description'),
  enableAccessLog?: boolean(name='EnableAccessLog'),
  endpointConfigurations?: [ 
    {
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      endpoint?: string(name='Endpoint'),
      probePort?: int32(name='ProbePort'),
      probeProtocol?: string(name='ProbeProtocol'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='EndpointConfigurations'),
  endpointGroupId?: string(name='EndpointGroupId'),
  endpointGroupIpList?: [ string ](name='EndpointGroupIpList'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  endpointGroupType?: string(name='EndpointGroupType'),
  endpointGroupUnconfirmedIpList?: [ string ](name='EndpointGroupUnconfirmedIpList'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
  healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  listenerId?: string(name='ListenerId'),
  name?: string(name='Name'),
  portOverrides?: [ 
    {
      endpointPort?: int32(name='EndpointPort'),
      listenerPort?: int32(name='ListenerPort'),
    }
  ](name='PortOverrides'),
  requestId?: string(name='RequestId'),
  slsLogStoreName?: string(name='SlsLogStoreName'),
  slsProjectName?: string(name='SlsProjectName'),
  slsRegion?: string(name='SlsRegion'),
  state?: string(name='State'),
  thresholdCount?: int32(name='ThresholdCount'),
  totalCount?: int32(name='TotalCount'),
  trafficPercentage?: int32(name='TrafficPercentage'),
}

model DescribeEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEndpointGroupResponseBody(name='body'),
}

async function describeEndpointGroupWithOptions(request: DescribeEndpointGroupRequest, runtime: Util.RuntimeOptions): DescribeEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endpointGroupId)) {
    query['EndpointGroupId'] = request.endpointGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEndpointGroup(request: DescribeEndpointGroupRequest): DescribeEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEndpointGroupWithOptions(request, runtime);
}

model DescribeIpSetRequest {
  ipSetId?: string(name='IpSetId'),
  regionId?: string(name='RegionId'),
}

model DescribeIpSetResponseBody = {
  accelerateRegionId?: string(name='AccelerateRegionId'),
  acceleratorId?: string(name='AcceleratorId'),
  bandwidth?: int32(name='Bandwidth'),
  ipAddressList?: [ string ](name='IpAddressList'),
  ipSetId?: string(name='IpSetId'),
  ipVersion?: string(name='IpVersion'),
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
}

model DescribeIpSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIpSetResponseBody(name='body'),
}

async function describeIpSetWithOptions(request: DescribeIpSetRequest, runtime: Util.RuntimeOptions): DescribeIpSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipSetId)) {
    query['IpSetId'] = request.ipSetId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIpSet',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIpSet(request: DescribeIpSetRequest): DescribeIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpSetWithOptions(request, runtime);
}

model DescribeListenerRequest {
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model DescribeListenerResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  aclType?: string(name='AclType'),
  backendPorts?: [ 
    {
      fromPort?: string(name='FromPort'),
      toPort?: string(name='ToPort'),
    }
  ](name='BackendPorts'),
  certificates?: [ 
    {
      id?: string(name='Id'),
      type?: string(name='Type'),
    }
  ](name='Certificates'),
  clientAffinity?: string(name='ClientAffinity'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  listenerId?: string(name='ListenerId'),
  name?: string(name='Name'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  protocol?: string(name='Protocol'),
  proxyProtocol?: boolean(name='ProxyProtocol'),
  relatedAcls?: [ 
    {
      aclId?: string(name='AclId'),
      status?: string(name='Status'),
    }
  ](name='RelatedAcls'),
  requestId?: string(name='RequestId'),
  securityPolicyId?: string(name='SecurityPolicyId'),
  state?: string(name='State'),
  XForwardedForConfig?: {
    XForwardedForGaApEnabled?: boolean(name='XForwardedForGaApEnabled'),
    XForwardedForGaIdEnabled?: boolean(name='XForwardedForGaIdEnabled'),
    XForwardedForPortEnabled?: boolean(name='XForwardedForPortEnabled'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
    XRealIpEnabled?: boolean(name='XRealIpEnabled'),
  }(name='XForwardedForConfig'),
}

model DescribeListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeListenerResponseBody(name='body'),
}

async function describeListenerWithOptions(request: DescribeListenerRequest, runtime: Util.RuntimeOptions): DescribeListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeListener',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeListener(request: DescribeListenerRequest): DescribeListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeListenerWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DetachDdosFromAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  regionId?: string(name='RegionId'),
}

model DetachDdosFromAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  requestId?: string(name='RequestId'),
}

model DetachDdosFromAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachDdosFromAcceleratorResponseBody(name='body'),
}

async function detachDdosFromAcceleratorWithOptions(request: DetachDdosFromAcceleratorRequest, runtime: Util.RuntimeOptions): DetachDdosFromAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachDdosFromAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachDdosFromAccelerator(request: DetachDdosFromAcceleratorRequest): DetachDdosFromAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDdosFromAcceleratorWithOptions(request, runtime);
}

model DetachLogStoreFromEndpointGroupRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model DetachLogStoreFromEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DetachLogStoreFromEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachLogStoreFromEndpointGroupResponseBody(name='body'),
}

async function detachLogStoreFromEndpointGroupWithOptions(request: DetachLogStoreFromEndpointGroupRequest, runtime: Util.RuntimeOptions): DetachLogStoreFromEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endpointGroupIds)) {
    query['EndpointGroupIds'] = request.endpointGroupIds;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachLogStoreFromEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachLogStoreFromEndpointGroup(request: DetachLogStoreFromEndpointGroupRequest): DetachLogStoreFromEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachLogStoreFromEndpointGroupWithOptions(request, runtime);
}

model DetectApplicationMonitorRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
}

model DetectApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetectApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectApplicationMonitorResponseBody(name='body'),
}

async function detectApplicationMonitorWithOptions(request: DetectApplicationMonitorRequest, runtime: Util.RuntimeOptions): DetectApplicationMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectApplicationMonitor',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectApplicationMonitor(request: DetectApplicationMonitorRequest): DetectApplicationMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectApplicationMonitorWithOptions(request, runtime);
}

model DisableApplicationMonitorRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
}

model DisableApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableApplicationMonitorResponseBody(name='body'),
}

async function disableApplicationMonitorWithOptions(request: DisableApplicationMonitorRequest, runtime: Util.RuntimeOptions): DisableApplicationMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableApplicationMonitor',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableApplicationMonitor(request: DisableApplicationMonitorRequest): DisableApplicationMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableApplicationMonitorWithOptions(request, runtime);
}

model DissociateAclsFromListenerRequest {
  aclIds?: [ string ](name='AclIds'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model DissociateAclsFromListenerResponseBody = {
  aclIds?: [ string ](name='AclIds'),
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DissociateAclsFromListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateAclsFromListenerResponseBody(name='body'),
}

async function dissociateAclsFromListenerWithOptions(request: DissociateAclsFromListenerRequest, runtime: Util.RuntimeOptions): DissociateAclsFromListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateAclsFromListener',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dissociateAclsFromListener(request: DissociateAclsFromListenerRequest): DissociateAclsFromListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateAclsFromListenerWithOptions(request, runtime);
}

model DissociateAdditionalCertificatesFromListenerRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  domains?: [ string ](name='Domains'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model DissociateAdditionalCertificatesFromListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DissociateAdditionalCertificatesFromListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateAdditionalCertificatesFromListenerResponseBody(name='body'),
}

async function dissociateAdditionalCertificatesFromListenerWithOptions(request: DissociateAdditionalCertificatesFromListenerRequest, runtime: Util.RuntimeOptions): DissociateAdditionalCertificatesFromListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateAdditionalCertificatesFromListener',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dissociateAdditionalCertificatesFromListener(request: DissociateAdditionalCertificatesFromListenerRequest): DissociateAdditionalCertificatesFromListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateAdditionalCertificatesFromListenerWithOptions(request, runtime);
}

model EnableApplicationMonitorRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
}

model EnableApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableApplicationMonitorResponseBody(name='body'),
}

async function enableApplicationMonitorWithOptions(request: EnableApplicationMonitorRequest, runtime: Util.RuntimeOptions): EnableApplicationMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableApplicationMonitor',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableApplicationMonitor(request: EnableApplicationMonitorRequest): EnableApplicationMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableApplicationMonitorWithOptions(request, runtime);
}

model GetAclRequest {
  aclId?: string(name='AclId'),
  regionId?: string(name='RegionId'),
}

model GetAclResponseBody = {
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
      entryDescription?: string(name='EntryDescription'),
    }
  ](name='AclEntries'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  aclStatus?: string(name='AclStatus'),
  addressIPVersion?: string(name='AddressIPVersion'),
  relatedListeners?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      aclType?: string(name='AclType'),
      listenerId?: string(name='ListenerId'),
    }
  ](name='RelatedListeners'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAclResponseBody(name='body'),
}

async function getAclWithOptions(request: GetAclRequest, runtime: Util.RuntimeOptions): GetAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAcl',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAcl(request: GetAclRequest): GetAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAclWithOptions(request, runtime);
}

model GetBasicAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model GetBasicAcceleratorResponseBody = {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  basicBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth', description='基础带宽包带宽'),
    bandwidthType?: string(name='BandwidthType', description='基础带宽包类型'),
    instanceId?: string(name='InstanceId', description='基础带宽包Id'),
  }(name='BasicBandwidthPackage', description='绑定的基础带宽包'),
  basicEndpointGroupId?: string(name='BasicEndpointGroupId', description='全球加速实例下车点Id'),
  basicIpSetId?: string(name='BasicIpSetId', description='全球加速实例上车点Id'),
  cenId?: string(name='CenId', description='使用的云企业网Id'),
  createTime?: long(name='CreateTime', description='全球加速实例创建时间'),
  crossDomainBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth', description='跨境带宽包带宽'),
    instanceId?: string(name='InstanceId', description='跨境带宽包Id'),
  }(name='CrossDomainBandwidthPackage', description='绑定的跨境带宽包'),
  description?: string(name='Description', description='全球加速实例描述'),
  expiredTime?: long(name='ExpiredTime', description='到期时间'),
  instanceChargeType?: string(name='InstanceChargeType', description='全球加速实例收费类型'),
  name?: string(name='Name', description='全球加速实例名称'),
  regionId?: string(name='RegionId', description='RegionId'),
  requestId?: string(name='RequestId', description='请求Id'),
  state?: string(name='State', description='实例状态'),
}

model GetBasicAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBasicAcceleratorResponseBody(name='body'),
}

async function getBasicAcceleratorWithOptions(request: GetBasicAcceleratorRequest, runtime: Util.RuntimeOptions): GetBasicAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBasicAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBasicAccelerator(request: GetBasicAcceleratorRequest): GetBasicAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBasicAcceleratorWithOptions(request, runtime);
}

model GetBasicEndpointGroupRequest {
  clientToken?: string(name='ClientToken', description='客户端Token'),
  endpointGroupId?: string(name='EndpointGroupId', description='终端节点组Id'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model GetBasicEndpointGroupResponseBody = {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  description?: string(name='Description', description='终端节点组描述'),
  endpointAddress?: string(name='EndpointAddress', description='终端节点组地址'),
  endpointGroupId?: string(name='EndpointGroupId', description='终端节点组Id'),
  endpointGroupRegion?: string(name='EndpointGroupRegion', description='终端节点组所在地域'),
  endpointType?: string(name='EndpointType', description='终端节点类型'),
  name?: string(name='Name', description='终端节点组名称'),
  requestId?: string(name='RequestId', description='请求Id'),
  state?: string(name='State', description='终端节点组状态'),
}

model GetBasicEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBasicEndpointGroupResponseBody(name='body'),
}

async function getBasicEndpointGroupWithOptions(request: GetBasicEndpointGroupRequest, runtime: Util.RuntimeOptions): GetBasicEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.endpointGroupId)) {
    query['EndpointGroupId'] = request.endpointGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBasicEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBasicEndpointGroup(request: GetBasicEndpointGroupRequest): GetBasicEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBasicEndpointGroupWithOptions(request, runtime);
}

model GetBasicIpSetRequest {
  clientToken?: string(name='ClientToken', description='客户端Token'),
  ipSetId?: string(name='IpSetId', description='加速接入点Id'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model GetBasicIpSetResponseBody = {
  accelerateRegionId?: string(name='AccelerateRegionId', description='加速地域Id'),
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  bandwidth?: int32(name='Bandwidth', description='加速地域带宽'),
  ipAddress?: string(name='IpAddress', description='加速接入点IP地址'),
  ipSetId?: string(name='IpSetId', description='加速接入点id'),
  ipVersion?: string(name='IpVersion', description='加速接入点地址类型'),
  ispType?: string(name='IspType', description='公网质量类型'),
  requestId?: string(name='RequestId', description='请求Id'),
  state?: string(name='State', description='加速接入点状态'),
}

model GetBasicIpSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBasicIpSetResponseBody(name='body'),
}

async function getBasicIpSetWithOptions(request: GetBasicIpSetRequest, runtime: Util.RuntimeOptions): GetBasicIpSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipSetId)) {
    query['IpSetId'] = request.ipSetId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBasicIpSet',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBasicIpSet(request: GetBasicIpSetRequest): GetBasicIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBasicIpSetWithOptions(request, runtime);
}

model GetHealthStatusRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model GetHealthStatusResponseBody = {
  endpointGroups?: [ 
    {
      endpointGroupId?: string(name='EndpointGroupId'),
      endpointGroupType?: string(name='EndpointGroupType'),
      endpoints?: [ 
        {
          address?: string(name='Address'),
          endpointId?: string(name='EndpointId'),
          healthDetail?: string(name='HealthDetail'),
          healthStatus?: string(name='HealthStatus'),
          port?: long(name='Port'),
          type?: string(name='Type'),
        }
      ](name='Endpoints'),
      forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
      healthStatus?: string(name='HealthStatus'),
    }
  ](name='EndpointGroups'),
  healthStatus?: string(name='HealthStatus'),
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHealthStatusResponseBody(name='body'),
}

async function getHealthStatusWithOptions(request: GetHealthStatusRequest, runtime: Util.RuntimeOptions): GetHealthStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHealthStatus',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHealthStatus(request: GetHealthStatusRequest): GetHealthStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHealthStatusWithOptions(request, runtime);
}

model GetSpareIpRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  spareIp?: string(name='SpareIp'),
}

model GetSpareIpResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  state?: string(name='State'),
}

model GetSpareIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSpareIpResponseBody(name='body'),
}

async function getSpareIpWithOptions(request: GetSpareIpRequest, runtime: Util.RuntimeOptions): GetSpareIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.spareIp)) {
    query['SpareIp'] = request.spareIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSpareIp',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSpareIp(request: GetSpareIpRequest): GetSpareIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSpareIpWithOptions(request, runtime);
}

model ListAccelerateAreasRequest {
  regionId?: string(name='RegionId'),
}

model ListAccelerateAreasResponseBody = {
  areas?: [ 
    {
      areaId?: string(name='AreaId'),
      localName?: string(name='LocalName'),
      regionList?: [ 
        {
          localName?: string(name='LocalName'),
          regionId?: string(name='RegionId'),
        }
      ](name='RegionList'),
    }
  ](name='Areas'),
  requestId?: string(name='RequestId'),
}

model ListAccelerateAreasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccelerateAreasResponseBody(name='body'),
}

async function listAccelerateAreasWithOptions(request: ListAccelerateAreasRequest, runtime: Util.RuntimeOptions): ListAccelerateAreasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccelerateAreas',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccelerateAreas(request: ListAccelerateAreasRequest): ListAccelerateAreasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccelerateAreasWithOptions(request, runtime);
}

model ListAcceleratorsRequest {
  acceleratorId?: string(name='AcceleratorId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  state?: string(name='State'),
}

model ListAcceleratorsResponseBody = {
  accelerators?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      bandwidth?: int32(name='Bandwidth'),
      basicBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth'),
        bandwidthType?: string(name='BandwidthType'),
        instanceId?: string(name='InstanceId'),
      }(name='BasicBandwidthPackage'),
      cenId?: string(name='CenId'),
      createTime?: long(name='CreateTime'),
      crossDomainBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth'),
        instanceId?: string(name='InstanceId'),
      }(name='CrossDomainBandwidthPackage'),
      ddosId?: string(name='DdosId'),
      description?: string(name='Description'),
      dnsName?: string(name='DnsName'),
      expiredTime?: long(name='ExpiredTime'),
      instanceChargeType?: string(name='InstanceChargeType'),
      ipSetConfig?: {
        accessMode?: string(name='AccessMode', description='加速区接入方式'),
      }(name='IpSetConfig', description='加速区配置'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      secondDnsName?: string(name='SecondDnsName'),
      spec?: string(name='Spec'),
      state?: string(name='State'),
      type?: string(name='Type'),
    }
  ](name='Accelerators'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAcceleratorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAcceleratorsResponseBody(name='body'),
}

async function listAcceleratorsWithOptions(request: ListAcceleratorsRequest, runtime: Util.RuntimeOptions): ListAcceleratorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccelerators',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccelerators(request: ListAcceleratorsRequest): ListAcceleratorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAcceleratorsWithOptions(request, runtime);
}

model ListAclsRequest {
  aclIds?: [ string ](name='AclIds'),
  aclName?: string(name='AclName'),
  clientToken?: string(name='ClientToken'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model ListAclsResponseBody = {
  acls?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
      aclStatus?: string(name='AclStatus'),
      addressIPVersion?: string(name='AddressIPVersion'),
    }
  ](name='Acls'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAclsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAclsResponseBody(name='body'),
}

async function listAclsWithOptions(request: ListAclsRequest, runtime: Util.RuntimeOptions): ListAclsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAcls',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAcls(request: ListAclsRequest): ListAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAclsWithOptions(request, runtime);
}

model ListApplicationMonitorRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  searchValue?: string(name='SearchValue'),
}

model ListApplicationMonitorResponseBody = {
  applicationMonitors?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      address?: string(name='Address'),
      detectEnable?: boolean(name='DetectEnable'),
      detectThreshold?: int32(name='DetectThreshold'),
      detectTimes?: int32(name='DetectTimes'),
      listenerId?: string(name='ListenerId'),
      optionsJson?: string(name='OptionsJson'),
      silenceTime?: int32(name='SilenceTime'),
      state?: string(name='State'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='ApplicationMonitors'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplicationMonitorResponseBody(name='body'),
}

async function listApplicationMonitorWithOptions(request: ListApplicationMonitorRequest, runtime: Util.RuntimeOptions): ListApplicationMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.searchValue)) {
    query['SearchValue'] = request.searchValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApplicationMonitor',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApplicationMonitor(request: ListApplicationMonitorRequest): ListApplicationMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationMonitorWithOptions(request, runtime);
}

model ListApplicationMonitorDetectResultRequest {
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
}

model ListApplicationMonitorDetectResultResponseBody = {
  applicationMonitorDetectResultList?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      content?: string(name='Content'),
      detail?: string(name='Detail'),
      detectTime?: string(name='DetectTime'),
      diagStatus?: string(name='DiagStatus'),
      listenerId?: string(name='ListenerId'),
      port?: string(name='Port'),
      protocol?: string(name='Protocol'),
      statusCode?: string(name='StatusCode'),
      taskId?: string(name='TaskId'),
    }
  ](name='ApplicationMonitorDetectResultList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListApplicationMonitorDetectResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplicationMonitorDetectResultResponseBody(name='body'),
}

async function listApplicationMonitorDetectResultWithOptions(request: ListApplicationMonitorDetectResultRequest, runtime: Util.RuntimeOptions): ListApplicationMonitorDetectResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApplicationMonitorDetectResult',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApplicationMonitorDetectResult(request: ListApplicationMonitorDetectResultRequest): ListApplicationMonitorDetectResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationMonitorDetectResultWithOptions(request, runtime);
}

model ListAvailableAccelerateAreasRequest {
  acceleratorId?: string(name='AcceleratorId'),
  regionId?: string(name='RegionId'),
}

model ListAvailableAccelerateAreasResponseBody = {
  areas?: [ 
    {
      areaId?: string(name='AreaId'),
      localName?: string(name='LocalName'),
      regionList?: [ 
        {
          localName?: string(name='LocalName'),
          regionId?: string(name='RegionId'),
        }
      ](name='RegionList'),
    }
  ](name='Areas'),
  requestId?: string(name='RequestId'),
}

model ListAvailableAccelerateAreasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAvailableAccelerateAreasResponseBody(name='body'),
}

async function listAvailableAccelerateAreasWithOptions(request: ListAvailableAccelerateAreasRequest, runtime: Util.RuntimeOptions): ListAvailableAccelerateAreasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableAccelerateAreas',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAvailableAccelerateAreas(request: ListAvailableAccelerateAreasRequest): ListAvailableAccelerateAreasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableAccelerateAreasWithOptions(request, runtime);
}

model ListAvailableBusiRegionsRequest {
  acceleratorId?: string(name='AcceleratorId'),
  regionId?: string(name='RegionId'),
}

model ListAvailableBusiRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      pop?: boolean(name='Pop'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListAvailableBusiRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAvailableBusiRegionsResponseBody(name='body'),
}

async function listAvailableBusiRegionsWithOptions(request: ListAvailableBusiRegionsRequest, runtime: Util.RuntimeOptions): ListAvailableBusiRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableBusiRegions',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAvailableBusiRegions(request: ListAvailableBusiRegionsRequest): ListAvailableBusiRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableBusiRegionsWithOptions(request, runtime);
}

model ListBandwidthPackagesRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  state?: string(name='State'),
  type?: string(name='Type'),
}

model ListBandwidthPackagesResponseBody = {
  bandwidthPackages?: [ 
    {
      accelerators?: [ string ](name='Accelerators'),
      bandwidth?: int32(name='Bandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidthType?: string(name='BandwidthType'),
      billingType?: string(name='BillingType'),
      cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
      cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
      chargeType?: string(name='ChargeType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      name?: string(name='Name'),
      ratio?: int32(name='Ratio'),
      regionId?: string(name='RegionId'),
      state?: string(name='State'),
      type?: string(name='Type'),
    }
  ](name='BandwidthPackages'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBandwidthPackagesResponseBody(name='body'),
}

async function listBandwidthPackagesWithOptions(request: ListBandwidthPackagesRequest, runtime: Util.RuntimeOptions): ListBandwidthPackagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBandwidthPackages',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBandwidthPackages(request: ListBandwidthPackagesRequest): ListBandwidthPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBandwidthPackagesWithOptions(request, runtime);
}

model ListBandwidthackagesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListBandwidthackagesResponseBody = {
  bandwidthPackages?: [ 
    {
      accelerators?: [ string ](name='Accelerators'),
      bandwidth?: int32(name='Bandwidth'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      chargeType?: string(name='ChargeType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
      state?: string(name='State'),
    }
  ](name='BandwidthPackages'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListBandwidthackagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBandwidthackagesResponseBody(name='body'),
}

async function listBandwidthackagesWithOptions(request: ListBandwidthackagesRequest, runtime: Util.RuntimeOptions): ListBandwidthackagesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBandwidthackages',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBandwidthackages(request: ListBandwidthackagesRequest): ListBandwidthackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBandwidthackagesWithOptions(request, runtime);
}

model ListBasicAcceleratorsRequest {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  pageNumber?: int32(name='PageNumber', description='分页页码'),
  pageSize?: int32(name='PageSize', description='分页大小'),
  regionId?: string(name='RegionId', description='RegionId'),
  state?: string(name='State', description='全球加速实例状态'),
}

model ListBasicAcceleratorsResponseBody = {
  accelerators?: [ 
    {
      acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
      basicBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth', description='基础带宽包带宽'),
        bandwidthType?: string(name='BandwidthType', description='基础带宽包类型'),
        instanceId?: string(name='InstanceId', description='基础带宽包Id'),
      }(name='BasicBandwidthPackage', description='绑定的基础带宽包'),
      basicEndpointGroupId?: string(name='BasicEndpointGroupId', description='全球加速实例下车点Id'),
      basicIpSetId?: string(name='BasicIpSetId', description='全球加速实例上车点Id'),
      createTime?: long(name='CreateTime', description='创建时间'),
      crossDomainBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth', description='跨境带宽包带宽'),
        instanceId?: string(name='InstanceId', description='跨境带宽包Id'),
      }(name='CrossDomainBandwidthPackage', description='绑定的跨境带宽包'),
      description?: string(name='Description', description='全球加速实例描述'),
      expiredTime?: long(name='ExpiredTime', description='到期时间'),
      instanceChargeType?: string(name='InstanceChargeType', description='全球加速实例计费类型'),
      name?: string(name='Name', description='全球加速实例名称'),
      regionId?: string(name='RegionId', description='RegionId'),
      state?: string(name='State', description='全球加速实例状态'),
      type?: string(name='Type', description='全球加速实例类型'),
    }
  ](name='Accelerators', description='全球加速实例列表'),
  pageNumber?: int32(name='PageNumber', description='页码'),
  pageSize?: int32(name='PageSize', description='页大小'),
  requestId?: string(name='RequestId', description='请求Id'),
  totalCount?: int32(name='TotalCount', description='全球加速实例总数'),
}

model ListBasicAcceleratorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBasicAcceleratorsResponseBody(name='body'),
}

async function listBasicAcceleratorsWithOptions(request: ListBasicAcceleratorsRequest, runtime: Util.RuntimeOptions): ListBasicAcceleratorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBasicAccelerators',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBasicAccelerators(request: ListBasicAcceleratorsRequest): ListBasicAcceleratorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBasicAcceleratorsWithOptions(request, runtime);
}

model ListBusiRegionsRequest {
  regionId?: string(name='RegionId'),
}

model ListBusiRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListBusiRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBusiRegionsResponseBody(name='body'),
}

async function listBusiRegionsWithOptions(request: ListBusiRegionsRequest, runtime: Util.RuntimeOptions): ListBusiRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBusiRegions',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBusiRegions(request: ListBusiRegionsRequest): ListBusiRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBusiRegionsWithOptions(request, runtime);
}

model ListEndpointGroupsRequest {
  acceleratorId?: string(name='AcceleratorId'),
  accessLogSwitch?: string(name='AccessLogSwitch'),
  endpointGroupId?: string(name='EndpointGroupId'),
  endpointGroupType?: string(name='EndpointGroupType'),
  listenerId?: string(name='ListenerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListEndpointGroupsResponseBody = {
  endpointGroups?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      description?: string(name='Description'),
      endpointConfigurations?: [ 
        {
          enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
          endpoint?: string(name='Endpoint'),
          endpointId?: string(name='EndpointId'),
          probePort?: int32(name='ProbePort'),
          probeProtocol?: string(name='ProbeProtocol'),
          type?: string(name='Type'),
          weight?: int32(name='Weight'),
        }
      ](name='EndpointConfigurations'),
      endpointGroupId?: string(name='EndpointGroupId'),
      endpointGroupIpList?: [ string ](name='EndpointGroupIpList'),
      endpointGroupRegion?: string(name='EndpointGroupRegion'),
      endpointGroupType?: string(name='EndpointGroupType'),
      endpointGroupUnconfirmedIpList?: [ string ](name='EndpointGroupUnconfirmedIpList'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
      healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
      healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
      healthCheckPath?: string(name='HealthCheckPath'),
      healthCheckPort?: int32(name='HealthCheckPort'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      listenerId?: string(name='ListenerId'),
      name?: string(name='Name'),
      portOverrides?: [ 
        {
          endpointPort?: int32(name='EndpointPort'),
          listenerPort?: int32(name='ListenerPort'),
        }
      ](name='PortOverrides'),
      state?: string(name='State'),
      thresholdCount?: int32(name='ThresholdCount'),
      trafficPercentage?: int32(name='TrafficPercentage'),
    }
  ](name='EndpointGroups'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEndpointGroupsResponseBody(name='body'),
}

async function listEndpointGroupsWithOptions(request: ListEndpointGroupsRequest, runtime: Util.RuntimeOptions): ListEndpointGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.accessLogSwitch)) {
    query['AccessLogSwitch'] = request.accessLogSwitch;
  }
  if (!Util.isUnset(request.endpointGroupId)) {
    query['EndpointGroupId'] = request.endpointGroupId;
  }
  if (!Util.isUnset(request.endpointGroupType)) {
    query['EndpointGroupType'] = request.endpointGroupType;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEndpointGroups',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEndpointGroups(request: ListEndpointGroupsRequest): ListEndpointGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEndpointGroupsWithOptions(request, runtime);
}

model ListForwardingRulesRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  forwardingRuleId?: string(name='ForwardingRuleId'),
  listenerId?: string(name='ListenerId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model ListForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleDirection?: string(name='ForwardingRuleDirection'),
      forwardingRuleId?: string(name='ForwardingRuleId'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
      forwardingRuleStatus?: string(name='ForwardingRuleStatus'),
      listenerId?: string(name='ListenerId'),
      priority?: int32(name='Priority'),
      ruleActions?: [ 
        {
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
          ruleActionValue?: string(name='RuleActionValue'),
        }
      ](name='RuleActions'),
      ruleConditions?: [ 
        {
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          ruleConditionType?: string(name='RuleConditionType'),
          ruleConditionValue?: string(name='RuleConditionValue'),
        }
      ](name='RuleConditions'),
    }
  ](name='ForwardingRules'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListForwardingRulesResponseBody(name='body'),
}

async function listForwardingRulesWithOptions(request: ListForwardingRulesRequest, runtime: Util.RuntimeOptions): ListForwardingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forwardingRuleId)) {
    query['ForwardingRuleId'] = request.forwardingRuleId;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListForwardingRules',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listForwardingRules(request: ListForwardingRulesRequest): ListForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listForwardingRulesWithOptions(request, runtime);
}

model ListIpSetsRequest {
  acceleratorId?: string(name='AcceleratorId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListIpSetsResponseBody = {
  ipSets?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      bandwidth?: int32(name='Bandwidth'),
      ipAddressList?: [ string ](name='IpAddressList'),
      ipSetId?: string(name='IpSetId'),
      ipVersion?: string(name='IpVersion'),
      state?: string(name='State'),
    }
  ](name='IpSets'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIpSetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIpSetsResponseBody(name='body'),
}

async function listIpSetsWithOptions(request: ListIpSetsRequest, runtime: Util.RuntimeOptions): ListIpSetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIpSets',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIpSets(request: ListIpSetsRequest): ListIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpSetsWithOptions(request, runtime);
}

model ListListenerCertificatesRequest {
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  role?: string(name='Role'),
}

model ListListenerCertificatesResponseBody = {
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
      domain?: string(name='Domain'),
      isDefault?: boolean(name='IsDefault'),
    }
  ](name='Certificates'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenerCertificatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenerCertificatesResponseBody(name='body'),
}

async function listListenerCertificatesWithOptions(request: ListListenerCertificatesRequest, runtime: Util.RuntimeOptions): ListListenerCertificatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListenerCertificates',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListenerCertificates(request: ListListenerCertificatesRequest): ListListenerCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenerCertificatesWithOptions(request, runtime);
}

model ListListenersRequest {
  acceleratorId?: string(name='AcceleratorId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListListenersResponseBody = {
  listeners?: [ 
    {
      acceleratorId?: string(name='AcceleratorId'),
      backendPorts?: [ 
        {
          fromPort?: string(name='FromPort'),
          toPort?: string(name='ToPort'),
        }
      ](name='BackendPorts'),
      certificates?: [ 
        {
          id?: string(name='Id'),
          type?: string(name='Type'),
        }
      ](name='Certificates'),
      clientAffinity?: string(name='ClientAffinity'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      listenerId?: string(name='ListenerId'),
      name?: string(name='Name'),
      portRanges?: [ 
        {
          fromPort?: int32(name='FromPort'),
          toPort?: int32(name='ToPort'),
        }
      ](name='PortRanges'),
      protocol?: string(name='Protocol'),
      proxyProtocol?: boolean(name='ProxyProtocol'),
      securityPolicyId?: string(name='SecurityPolicyId'),
      state?: string(name='State'),
      XForwardedForConfig?: {
        XForwardedForGaApEnabled?: boolean(name='XForwardedForGaApEnabled'),
        XForwardedForGaIdEnabled?: boolean(name='XForwardedForGaIdEnabled'),
        XForwardedForPortEnabled?: boolean(name='XForwardedForPortEnabled'),
        XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
        XRealIpEnabled?: boolean(name='XRealIpEnabled'),
      }(name='XForwardedForConfig'),
    }
  ](name='Listeners'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenersResponseBody(name='body'),
}

async function listListenersWithOptions(request: ListListenersRequest, runtime: Util.RuntimeOptions): ListListenersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListeners',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListeners(request: ListListenersRequest): ListListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersWithOptions(request, runtime);
}

model ListSpareIpsRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
}

model ListSpareIpsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  spareIps?: [ 
    {
      spareIp?: string(name='SpareIp'),
      state?: string(name='State'),
    }
  ](name='SpareIps'),
}

model ListSpareIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSpareIpsResponseBody(name='body'),
}

async function listSpareIpsWithOptions(request: ListSpareIpsRequest, runtime: Util.RuntimeOptions): ListSpareIpsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSpareIps',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSpareIps(request: ListSpareIpsRequest): ListSpareIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSpareIpsWithOptions(request, runtime);
}

model ListSystemSecurityPoliciesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListSystemSecurityPoliciesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  securityPolicies?: [ 
    {
      ciphers?: [ string ](name='Ciphers'),
      securityPolicyId?: string(name='SecurityPolicyId'),
      tlsVersions?: [ string ](name='TlsVersions'),
    }
  ](name='SecurityPolicies'),
  totalCount?: int32(name='TotalCount'),
}

model ListSystemSecurityPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemSecurityPoliciesResponseBody(name='body'),
}

async function listSystemSecurityPoliciesWithOptions(request: ListSystemSecurityPoliciesRequest, runtime: Util.RuntimeOptions): ListSystemSecurityPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSystemSecurityPolicies',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemSecurityPolicies(request: ListSystemSecurityPoliciesRequest): ListSystemSecurityPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemSecurityPoliciesWithOptions(request, runtime);
}

model RemoveEntriesFromAclRequest {
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
    }
  ](name='AclEntries'),
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
}

model RemoveEntriesFromAclResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RemoveEntriesFromAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveEntriesFromAclResponseBody(name='body'),
}

async function removeEntriesFromAclWithOptions(request: RemoveEntriesFromAclRequest, runtime: Util.RuntimeOptions): RemoveEntriesFromAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntries)) {
    query['AclEntries'] = request.aclEntries;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveEntriesFromAcl',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeEntriesFromAcl(request: RemoveEntriesFromAclRequest): RemoveEntriesFromAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeEntriesFromAclWithOptions(request, runtime);
}

model ReplaceBandwidthPackageRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  regionId?: string(name='RegionId'),
  targetBandwidthPackageId?: string(name='TargetBandwidthPackageId'),
}

model ReplaceBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReplaceBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReplaceBandwidthPackageResponseBody(name='body'),
}

async function replaceBandwidthPackageWithOptions(request: ReplaceBandwidthPackageRequest, runtime: Util.RuntimeOptions): ReplaceBandwidthPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.targetBandwidthPackageId)) {
    query['TargetBandwidthPackageId'] = request.targetBandwidthPackageId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReplaceBandwidthPackage',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function replaceBandwidthPackage(request: ReplaceBandwidthPackageRequest): ReplaceBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceBandwidthPackageWithOptions(request, runtime);
}

model UpdateAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  spec?: string(name='Spec'),
}

model UpdateAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAcceleratorResponseBody(name='body'),
}

async function updateAcceleratorWithOptions(request: UpdateAcceleratorRequest, runtime: Util.RuntimeOptions): UpdateAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoUseCoupon)) {
    query['AutoUseCoupon'] = request.autoUseCoupon;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAccelerator(request: UpdateAcceleratorRequest): UpdateAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAcceleratorWithOptions(request, runtime);
}

model UpdateAcceleratorAutoRenewAttributeRequest {
  acceleratorId?: string(name='AcceleratorId'),
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewDuration?: int32(name='AutoRenewDuration'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  renewalStatus?: string(name='RenewalStatus'),
}

model UpdateAcceleratorAutoRenewAttributeResponseBody = {
  acceleratorId?: string(name='AcceleratorId'),
  requestId?: string(name='RequestId'),
}

model UpdateAcceleratorAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAcceleratorAutoRenewAttributeResponseBody(name='body'),
}

async function updateAcceleratorAutoRenewAttributeWithOptions(request: UpdateAcceleratorAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): UpdateAcceleratorAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewDuration)) {
    query['AutoRenewDuration'] = request.autoRenewDuration;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.renewalStatus)) {
    query['RenewalStatus'] = request.renewalStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAcceleratorAutoRenewAttribute',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAcceleratorAutoRenewAttribute(request: UpdateAcceleratorAutoRenewAttributeRequest): UpdateAcceleratorAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAcceleratorAutoRenewAttributeWithOptions(request, runtime);
}

model UpdateAcceleratorConfirmRequest {
  acceleratorId?: string(name='AcceleratorId'),
  regionId?: string(name='RegionId'),
}

model UpdateAcceleratorConfirmResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAcceleratorConfirmResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAcceleratorConfirmResponseBody(name='body'),
}

async function updateAcceleratorConfirmWithOptions(request: UpdateAcceleratorConfirmRequest, runtime: Util.RuntimeOptions): UpdateAcceleratorConfirmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAcceleratorConfirm',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAcceleratorConfirm(request: UpdateAcceleratorConfirmRequest): UpdateAcceleratorConfirmResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAcceleratorConfirmWithOptions(request, runtime);
}

model UpdateAclAttributeRequest {
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
}

model UpdateAclAttributeResponseBody = {
  aclId?: string(name='AclId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateAclAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAclAttributeResponseBody(name='body'),
}

async function updateAclAttributeWithOptions(request: UpdateAclAttributeRequest, runtime: Util.RuntimeOptions): UpdateAclAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAclAttribute',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAclAttribute(request: UpdateAclAttributeRequest): UpdateAclAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAclAttributeWithOptions(request, runtime);
}

model UpdateApplicationMonitorRequest {
  address?: string(name='Address'),
  clientToken?: string(name='ClientToken'),
  detectEnable?: boolean(name='DetectEnable'),
  detectThreshold?: int32(name='DetectThreshold'),
  detectTimes?: int32(name='DetectTimes'),
  listenerId?: string(name='ListenerId'),
  optionsJson?: string(name='OptionsJson'),
  regionId?: string(name='RegionId'),
  silenceTime?: int32(name='SilenceTime'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model UpdateApplicationMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateApplicationMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicationMonitorResponseBody(name='body'),
}

async function updateApplicationMonitorWithOptions(request: UpdateApplicationMonitorRequest, runtime: Util.RuntimeOptions): UpdateApplicationMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.detectEnable)) {
    query['DetectEnable'] = request.detectEnable;
  }
  if (!Util.isUnset(request.detectThreshold)) {
    query['DetectThreshold'] = request.detectThreshold;
  }
  if (!Util.isUnset(request.detectTimes)) {
    query['DetectTimes'] = request.detectTimes;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.optionsJson)) {
    query['OptionsJson'] = request.optionsJson;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplicationMonitor',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApplicationMonitor(request: UpdateApplicationMonitorRequest): UpdateApplicationMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicationMonitorWithOptions(request, runtime);
}

model UpdateBandwidthPackagaAutoRenewAttributeRequest {
  autoRenew?: boolean(name='AutoRenew'),
  autoRenewDuration?: int32(name='AutoRenewDuration'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  renewalStatus?: string(name='RenewalStatus'),
}

model UpdateBandwidthPackagaAutoRenewAttributeResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model UpdateBandwidthPackagaAutoRenewAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBandwidthPackagaAutoRenewAttributeResponseBody(name='body'),
}

async function updateBandwidthPackagaAutoRenewAttributeWithOptions(request: UpdateBandwidthPackagaAutoRenewAttributeRequest, runtime: Util.RuntimeOptions): UpdateBandwidthPackagaAutoRenewAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.autoRenewDuration)) {
    query['AutoRenewDuration'] = request.autoRenewDuration;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.renewalStatus)) {
    query['RenewalStatus'] = request.renewalStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBandwidthPackagaAutoRenewAttribute',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBandwidthPackagaAutoRenewAttribute(request: UpdateBandwidthPackagaAutoRenewAttributeRequest): UpdateBandwidthPackagaAutoRenewAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBandwidthPackagaAutoRenewAttributeWithOptions(request, runtime);
}

model UpdateBandwidthPackageRequest {
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  bandwidth?: int32(name='Bandwidth'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  bandwidthType?: string(name='BandwidthType'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model UpdateBandwidthPackageResponseBody = {
  bandwidthPackage?: string(name='BandwidthPackage'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
}

model UpdateBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBandwidthPackageResponseBody(name='body'),
}

async function updateBandwidthPackageWithOptions(request: UpdateBandwidthPackageRequest, runtime: Util.RuntimeOptions): UpdateBandwidthPackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoUseCoupon)) {
    query['AutoUseCoupon'] = request.autoUseCoupon;
  }
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.bandwidthType)) {
    query['BandwidthType'] = request.bandwidthType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBandwidthPackage',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBandwidthPackage(request: UpdateBandwidthPackageRequest): UpdateBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBandwidthPackageWithOptions(request, runtime);
}

model UpdateBasicAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId', description='全球加速实例Id'),
  clientToken?: string(name='ClientToken', description='客户端Token'),
  description?: string(name='Description', description='全球加速实例描述'),
  name?: string(name='Name', description='全球加速实例名称'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model UpdateBasicAcceleratorResponseBody = {
  requestId?: string(name='RequestId', description='请求Id'),
}

model UpdateBasicAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBasicAcceleratorResponseBody(name='body'),
}

async function updateBasicAcceleratorWithOptions(request: UpdateBasicAcceleratorRequest, runtime: Util.RuntimeOptions): UpdateBasicAcceleratorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBasicAccelerator',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBasicAccelerator(request: UpdateBasicAcceleratorRequest): UpdateBasicAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBasicAcceleratorWithOptions(request, runtime);
}

model UpdateBasicEndpointGroupRequest {
  clientToken?: string(name='ClientToken', description='客户端Token'),
  description?: string(name='Description', description='终端节点组描述'),
  endpointAddress?: string(name='EndpointAddress', description='终端节点地址'),
  endpointGroupId?: string(name='EndpointGroupId', description='终端节点组Id'),
  endpointType?: string(name='EndpointType', description='终端节点类型'),
  name?: string(name='Name', description='终端节点组名称'),
  regionId?: string(name='RegionId', description='Regionid'),
}

model UpdateBasicEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='请求Id'),
}

model UpdateBasicEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBasicEndpointGroupResponseBody(name='body'),
}

async function updateBasicEndpointGroupWithOptions(request: UpdateBasicEndpointGroupRequest, runtime: Util.RuntimeOptions): UpdateBasicEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endpointAddress)) {
    query['EndpointAddress'] = request.endpointAddress;
  }
  if (!Util.isUnset(request.endpointGroupId)) {
    query['EndpointGroupId'] = request.endpointGroupId;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBasicEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBasicEndpointGroup(request: UpdateBasicEndpointGroupRequest): UpdateBasicEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBasicEndpointGroupWithOptions(request, runtime);
}

model UpdateEndpointGroupRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  endpointConfigurations?: [ 
    {
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      endpoint?: string(name='Endpoint'),
      type?: string(name='Type'),
      weight?: int32(name='Weight'),
    }
  ](name='EndpointConfigurations'),
  endpointGroupId?: string(name='EndpointGroupId'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  name?: string(name='Name'),
  portOverrides?: [ 
    {
      endpointPort?: int32(name='EndpointPort'),
      listenerPort?: int32(name='ListenerPort'),
    }
  ](name='PortOverrides'),
  regionId?: string(name='RegionId'),
  thresholdCount?: int32(name='ThresholdCount'),
  trafficPercentage?: int32(name='TrafficPercentage'),
}

model UpdateEndpointGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEndpointGroupResponseBody(name='body'),
}

async function updateEndpointGroupWithOptions(request: UpdateEndpointGroupRequest, runtime: Util.RuntimeOptions): UpdateEndpointGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endpointConfigurations)) {
    query['EndpointConfigurations'] = request.endpointConfigurations;
  }
  if (!Util.isUnset(request.endpointGroupId)) {
    query['EndpointGroupId'] = request.endpointGroupId;
  }
  if (!Util.isUnset(request.endpointGroupRegion)) {
    query['EndpointGroupRegion'] = request.endpointGroupRegion;
  }
  if (!Util.isUnset(request.endpointRequestProtocol)) {
    query['EndpointRequestProtocol'] = request.endpointRequestProtocol;
  }
  if (!Util.isUnset(request.healthCheckEnabled)) {
    query['HealthCheckEnabled'] = request.healthCheckEnabled;
  }
  if (!Util.isUnset(request.healthCheckIntervalSeconds)) {
    query['HealthCheckIntervalSeconds'] = request.healthCheckIntervalSeconds;
  }
  if (!Util.isUnset(request.healthCheckPath)) {
    query['HealthCheckPath'] = request.healthCheckPath;
  }
  if (!Util.isUnset(request.healthCheckPort)) {
    query['HealthCheckPort'] = request.healthCheckPort;
  }
  if (!Util.isUnset(request.healthCheckProtocol)) {
    query['HealthCheckProtocol'] = request.healthCheckProtocol;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.portOverrides)) {
    query['PortOverrides'] = request.portOverrides;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.thresholdCount)) {
    query['ThresholdCount'] = request.thresholdCount;
  }
  if (!Util.isUnset(request.trafficPercentage)) {
    query['TrafficPercentage'] = request.trafficPercentage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEndpointGroup',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEndpointGroup(request: UpdateEndpointGroupRequest): UpdateEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEndpointGroupWithOptions(request, runtime);
}

model UpdateEndpointGroupAttributeRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  endpointGroupId?: string(name='EndpointGroupId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model UpdateEndpointGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEndpointGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEndpointGroupAttributeResponseBody(name='body'),
}

async function updateEndpointGroupAttributeWithOptions(request: UpdateEndpointGroupAttributeRequest, runtime: Util.RuntimeOptions): UpdateEndpointGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endpointGroupId)) {
    query['EndpointGroupId'] = request.endpointGroupId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEndpointGroupAttribute',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEndpointGroupAttribute(request: UpdateEndpointGroupAttributeRequest): UpdateEndpointGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEndpointGroupAttributeWithOptions(request, runtime);
}

model UpdateEndpointGroupsRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointGroupConfigurations?: [ 
    {
      enableClientIPPreservationProxyProtocol?: boolean(name='EnableClientIPPreservationProxyProtocol'),
      enableClientIPPreservationToa?: boolean(name='EnableClientIPPreservationToa'),
      endpointConfigurations?: [ 
        {
          endpoint?: string(name='Endpoint'),
          type?: string(name='Type'),
          weight?: long(name='Weight'),
        }
      ](name='EndpointConfigurations'),
      endpointGroupDescription?: string(name='EndpointGroupDescription'),
      endpointGroupId?: string(name='EndpointGroupId'),
      endpointGroupName?: string(name='EndpointGroupName'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
      healthCheckIntervalSeconds?: long(name='HealthCheckIntervalSeconds'),
      healthCheckPath?: string(name='HealthCheckPath'),
      healthCheckPort?: long(name='HealthCheckPort'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      portOverrides?: [ 
        {
          endpointPort?: long(name='EndpointPort'),
          listenerPort?: long(name='ListenerPort'),
        }
      ](name='PortOverrides'),
      thresholdCount?: long(name='ThresholdCount'),
      trafficPercentage?: long(name='TrafficPercentage'),
    }
  ](name='EndpointGroupConfigurations'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model UpdateEndpointGroupsResponseBody = {
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEndpointGroupsResponseBody(name='body'),
}

async function updateEndpointGroupsWithOptions(request: UpdateEndpointGroupsRequest, runtime: Util.RuntimeOptions): UpdateEndpointGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.endpointGroupConfigurations)) {
    query['EndpointGroupConfigurations'] = request.endpointGroupConfigurations;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEndpointGroups',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEndpointGroups(request: UpdateEndpointGroupsRequest): UpdateEndpointGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEndpointGroupsWithOptions(request, runtime);
}

model UpdateForwardingRulesRequest {
  acceleratorId?: string(name='AcceleratorId'),
  clientToken?: string(name='ClientToken'),
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
      priority?: int32(name='Priority'),
      ruleActions?: [ 
        {
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
          ruleActionValue?: string(name='RuleActionValue'),
        }
      ](name='RuleActions'),
      ruleConditions?: [ 
        {
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          ruleConditionType?: string(name='RuleConditionType'),
          ruleConditionValue?: string(name='RuleConditionValue'),
        }
      ](name='RuleConditions'),
      ruleDirection?: string(name='RuleDirection'),
    }
  ](name='ForwardingRules'),
  listenerId?: string(name='ListenerId'),
  regionId?: string(name='RegionId'),
}

model UpdateForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model UpdateForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateForwardingRulesResponseBody(name='body'),
}

async function updateForwardingRulesWithOptions(request: UpdateForwardingRulesRequest, runtime: Util.RuntimeOptions): UpdateForwardingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceleratorId)) {
    query['AcceleratorId'] = request.acceleratorId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.forwardingRules)) {
    query['ForwardingRules'] = request.forwardingRules;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateForwardingRules',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateForwardingRules(request: UpdateForwardingRulesRequest): UpdateForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateForwardingRulesWithOptions(request, runtime);
}

model UpdateIpSetRequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  ipSetId?: string(name='IpSetId'),
  regionId?: string(name='RegionId'),
}

model UpdateIpSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIpSetResponseBody(name='body'),
}

async function updateIpSetWithOptions(request: UpdateIpSetRequest, runtime: Util.RuntimeOptions): UpdateIpSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ipSetId)) {
    query['IpSetId'] = request.ipSetId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIpSet',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIpSet(request: UpdateIpSetRequest): UpdateIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpSetWithOptions(request, runtime);
}

model UpdateIpSetsRequest {
  ipSets?: [ 
    {
      bandwidth?: int32(name='Bandwidth'),
      ipSetId?: string(name='IpSetId'),
    }
  ](name='IpSets'),
  regionId?: string(name='RegionId'),
}

model UpdateIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpSetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIpSetsResponseBody(name='body'),
}

async function updateIpSetsWithOptions(request: UpdateIpSetsRequest, runtime: Util.RuntimeOptions): UpdateIpSetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ipSets)) {
    query['IpSets'] = request.ipSets;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIpSets',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIpSets(request: UpdateIpSetsRequest): UpdateIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpSetsWithOptions(request, runtime);
}

model UpdateListenerRequest {
  backendPorts?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='BackendPorts'),
  certificates?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Certificates'),
  clientAffinity?: string(name='ClientAffinity'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  listenerId?: string(name='ListenerId'),
  name?: string(name='Name'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  protocol?: string(name='Protocol'),
  proxyProtocol?: string(name='ProxyProtocol'),
  regionId?: string(name='RegionId'),
  securityPolicyId?: string(name='SecurityPolicyId'),
  XForwardedForConfig?: {
    XForwardedForGaApEnabled?: boolean(name='XForwardedForGaApEnabled'),
    XForwardedForGaIdEnabled?: boolean(name='XForwardedForGaIdEnabled'),
    XForwardedForPortEnabled?: boolean(name='XForwardedForPortEnabled'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
    XRealIpEnabled?: boolean(name='XRealIpEnabled'),
  }(name='XForwardedForConfig'),
}

model UpdateListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateListenerResponseBody(name='body'),
}

async function updateListenerWithOptions(request: UpdateListenerRequest, runtime: Util.RuntimeOptions): UpdateListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendPorts)) {
    query['BackendPorts'] = request.backendPorts;
  }
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientAffinity)) {
    query['ClientAffinity'] = request.clientAffinity;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.portRanges)) {
    query['PortRanges'] = request.portRanges;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.proxyProtocol)) {
    query['ProxyProtocol'] = request.proxyProtocol;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.XForwardedForConfig)) {
    query['XForwardedForConfig'] = request.XForwardedForConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateListener',
    version = '2019-11-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateListener(request: UpdateListenerRequest): UpdateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerWithOptions(request, runtime);
}

