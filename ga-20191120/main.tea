/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ga', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model DescribeIpSetRequest {
  regionId?: string(name='RegionId'),
  ipSetId?: string(name='IpSetId'),
}

model DescribeIpSetResponseBody = {
  ipSetId?: string(name='IpSetId'),
  requestId?: string(name='RequestId'),
  ipVersion?: string(name='IpVersion'),
  state?: string(name='State'),
  bandwidth?: int32(name='Bandwidth'),
  ipAddressList?: [ string ](name='IpAddressList'),
  accelerateRegionId?: string(name='AccelerateRegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model DescribeIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpSetResponseBody(name='body'),
}

async function describeIpSetWithOptions(request: DescribeIpSetRequest, runtime: Util.RuntimeOptions): DescribeIpSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpSet', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpSet(request: DescribeIpSetRequest): DescribeIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpSetWithOptions(request, runtime);
}

model ListAclsRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  aclIds?: [ string ](name='AclIds'),
  aclName?: string(name='AclName'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListAclsResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  acls?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
      addressIPVersion?: string(name='AddressIPVersion'),
      aclStatus?: string(name='AclStatus'),
    }
  ](name='Acls'),
}

model ListAclsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAclsResponseBody(name='body'),
}

async function listAclsWithOptions(request: ListAclsRequest, runtime: Util.RuntimeOptions): ListAclsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAcls', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAcls(request: ListAclsRequest): ListAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAclsWithOptions(request, runtime);
}

model CreateAcceleratorRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  duration?: int32(name='Duration'),
  pricingCycle?: string(name='PricingCycle'),
  spec?: string(name='Spec'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: string(name='AutoUseCoupon'),
}

model CreateAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model CreateAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAcceleratorResponseBody(name='body'),
}

async function createAcceleratorWithOptions(request: CreateAcceleratorRequest, runtime: Util.RuntimeOptions): CreateAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAccelerator(request: CreateAcceleratorRequest): CreateAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAcceleratorWithOptions(request, runtime);
}

model DescribeListenerRequest {
  regionId?: string(name='RegionId'),
  listenerId?: string(name='ListenerId'),
}

model DescribeListenerResponseBody = {
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
  createTime?: string(name='CreateTime'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  backendPorts?: [ 
    {
      fromPort?: string(name='FromPort'),
      toPort?: string(name='ToPort'),
    }
  ](name='BackendPorts'),
  certificates?: [ 
    {
      type?: string(name='Type'),
      id?: string(name='Id'),
    }
  ](name='Certificates'),
  protocol?: string(name='Protocol'),
  listenerId?: string(name='ListenerId'),
  clientAffinity?: string(name='ClientAffinity'),
  name?: string(name='Name'),
  relatedAcls?: [ 
    {
      aclId?: string(name='AclId'),
      status?: string(name='Status'),
    }
  ](name='RelatedAcls'),
  aclType?: string(name='AclType'),
  acceleratorId?: string(name='AcceleratorId'),
  proxyProtocol?: boolean(name='ProxyProtocol'),
}

model DescribeListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeListenerResponseBody(name='body'),
}

async function describeListenerWithOptions(request: DescribeListenerRequest, runtime: Util.RuntimeOptions): DescribeListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeListener(request: DescribeListenerRequest): DescribeListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeListenerWithOptions(request, runtime);
}

model DeleteSpareIpsRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  acceleratorId?: string(name='AcceleratorId'),
  spareIps?: [ string ](name='SpareIps'),
}

model DeleteSpareIpsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteSpareIpsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSpareIpsResponseBody(name='body'),
}

async function deleteSpareIpsWithOptions(request: DeleteSpareIpsRequest, runtime: Util.RuntimeOptions): DeleteSpareIpsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSpareIps', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSpareIps(request: DeleteSpareIpsRequest): DeleteSpareIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSpareIpsWithOptions(request, runtime);
}

model UpdateIpSetsRequest {
  regionId?: string(name='RegionId'),
  ipSets?: [ 
    {
      bandwidth?: int32(name='Bandwidth'),
      ipSetId?: string(name='IpSetId'),
    }
  ](name='IpSets'),
}

model UpdateIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpSetsResponseBody(name='body'),
}

async function updateIpSetsWithOptions(request: UpdateIpSetsRequest, runtime: Util.RuntimeOptions): UpdateIpSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIpSets', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIpSets(request: UpdateIpSetsRequest): UpdateIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpSetsWithOptions(request, runtime);
}

model ConfigEndpointProbeRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  endpointGroupId?: string(name='EndpointGroupId'),
  endpointType?: string(name='EndpointType'),
  endpoint?: string(name='Endpoint'),
  probeProtocol?: string(name='ProbeProtocol'),
  probePort?: string(name='ProbePort'),
  enable?: string(name='Enable'),
}

model ConfigEndpointProbeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigEndpointProbeResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigEndpointProbeResponseBody(name='body'),
}

async function configEndpointProbeWithOptions(request: ConfigEndpointProbeRequest, runtime: Util.RuntimeOptions): ConfigEndpointProbeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConfigEndpointProbe', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function configEndpointProbe(request: ConfigEndpointProbeRequest): ConfigEndpointProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return configEndpointProbeWithOptions(request, runtime);
}

model RemoveEntriesFromAclRequest {
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
    }
  ](name='AclEntries'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model RemoveEntriesFromAclResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  aclId?: string(name='AclId'),
}

model RemoveEntriesFromAclResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveEntriesFromAclResponseBody(name='body'),
}

async function removeEntriesFromAclWithOptions(request: RemoveEntriesFromAclRequest, runtime: Util.RuntimeOptions): RemoveEntriesFromAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveEntriesFromAcl', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeEntriesFromAcl(request: RemoveEntriesFromAclRequest): RemoveEntriesFromAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeEntriesFromAclWithOptions(request, runtime);
}

model DescribeBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model DescribeBandwidthPackageResponseBody = {
  cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
  cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  name?: string(name='Name'),
  bandwidthType?: string(name='BandwidthType'),
  type?: string(name='Type'),
  accelerators?: [ string ](name='Accelerators'),
  state?: string(name='State'),
  chargeType?: string(name='ChargeType'),
  bandwidth?: int32(name='Bandwidth'),
  expiredTime?: string(name='ExpiredTime'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  regionId?: string(name='RegionId'),
  billingType?: string(name='BillingType'),
  ratio?: int32(name='Ratio'),
}

model DescribeBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandwidthPackageResponseBody(name='body'),
}

async function describeBandwidthPackageWithOptions(request: DescribeBandwidthPackageRequest, runtime: Util.RuntimeOptions): DescribeBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeBandwidthPackage(request: DescribeBandwidthPackageRequest): DescribeBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBandwidthPackageWithOptions(request, runtime);
}

model ListBandwidthPackagesRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  state?: string(name='State'),
  type?: string(name='Type'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model ListBandwidthPackagesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  bandwidthPackages?: [ 
    {
      type?: string(name='Type'),
      bandwidthType?: string(name='BandwidthType'),
      state?: string(name='State'),
      createTime?: string(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      regionId?: string(name='RegionId'),
      cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidth?: int32(name='Bandwidth'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      accelerators?: [ string ](name='Accelerators'),
      cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
      name?: string(name='Name'),
      billingType?: string(name='BillingType'),
      ratio?: int32(name='Ratio'),
    }
  ](name='BandwidthPackages'),
}

model ListBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBandwidthPackagesResponseBody(name='body'),
}

async function listBandwidthPackagesWithOptions(request: ListBandwidthPackagesRequest, runtime: Util.RuntimeOptions): ListBandwidthPackagesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListBandwidthPackages', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listBandwidthPackages(request: ListBandwidthPackagesRequest): ListBandwidthPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBandwidthPackagesWithOptions(request, runtime);
}

model UpdateEndpointGroupRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  endpointGroupId?: string(name='EndpointGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  trafficPercentage?: int32(name='TrafficPercentage'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  thresholdCount?: int32(name='ThresholdCount'),
  endpointConfigurations?: [ 
    {
      type?: string(name='Type'),
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      weight?: int32(name='Weight'),
      endpoint?: string(name='Endpoint'),
    }
  ](name='EndpointConfigurations'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  portOverrides?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      endpointPort?: int32(name='EndpointPort'),
    }
  ](name='PortOverrides'),
  healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
}

model UpdateEndpointGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEndpointGroupResponseBody(name='body'),
}

async function updateEndpointGroupWithOptions(request: UpdateEndpointGroupRequest, runtime: Util.RuntimeOptions): UpdateEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateEndpointGroup(request: UpdateEndpointGroupRequest): UpdateEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEndpointGroupWithOptions(request, runtime);
}

model AttachDdosToAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  ddosId?: string(name='DdosId'),
  ddosRegionId?: string(name='DdosRegionId'),
  regionId?: string(name='RegionId'),
}

model AttachDdosToAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  requestId?: string(name='RequestId'),
  gaId?: string(name='GaId'),
}

model AttachDdosToAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDdosToAcceleratorResponseBody(name='body'),
}

async function attachDdosToAcceleratorWithOptions(request: AttachDdosToAcceleratorRequest, runtime: Util.RuntimeOptions): AttachDdosToAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AttachDdosToAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function attachDdosToAccelerator(request: AttachDdosToAcceleratorRequest): AttachDdosToAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDdosToAcceleratorWithOptions(request, runtime);
}

model GetAclRequest {
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
}

model GetAclResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  aclId?: string(name='AclId'),
  addressIPVersion?: string(name='AddressIPVersion'),
  aclStatus?: string(name='AclStatus'),
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
      entryDescription?: string(name='EntryDescription'),
    }
  ](name='AclEntries'),
  relatedListeners?: [ 
    {
      listenerId?: string(name='ListenerId'),
      aclType?: string(name='AclType'),
      acceleratorId?: string(name='AcceleratorId'),
    }
  ](name='RelatedListeners'),
  aclName?: string(name='AclName'),
}

model GetAclResponse = {
  headers: map[string]string(name='headers'),
  body: GetAclResponseBody(name='body'),
}

async function getAclWithOptions(request: GetAclRequest, runtime: Util.RuntimeOptions): GetAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAcl', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAcl(request: GetAclRequest): GetAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAclWithOptions(request, runtime);
}

model AssociateAclsWithListenerRequest {
  regionId?: string(name='RegionId'),
  aclIds?: [ string ](name='AclIds'),
  listenerId?: string(name='ListenerId'),
  aclType?: string(name='AclType'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model AssociateAclsWithListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  aclIds?: [ string ](name='AclIds'),
  listenerId?: string(name='ListenerId'),
}

model AssociateAclsWithListenerResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateAclsWithListenerResponseBody(name='body'),
}

async function associateAclsWithListenerWithOptions(request: AssociateAclsWithListenerRequest, runtime: Util.RuntimeOptions): AssociateAclsWithListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateAclsWithListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateAclsWithListener(request: AssociateAclsWithListenerRequest): AssociateAclsWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateAclsWithListenerWithOptions(request, runtime);
}

model ListForwardingRulesRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  listenerId?: string(name='ListenerId'),
  acceleratorId?: string(name='AcceleratorId'),
  forwardingRuleId?: string(name='ForwardingRuleId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListForwardingRulesResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  forwardingRules?: [ 
    {
      priority?: int32(name='Priority'),
      forwardingRuleId?: string(name='ForwardingRuleId'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
      forwardingRuleStatus?: string(name='ForwardingRuleStatus'),
      ruleConditions?: [ 
        {
          ruleConditionType?: string(name='RuleConditionType'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
        }
      ](name='RuleConditions'),
      ruleActions?: [ 
        {
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
        }
      ](name='RuleActions'),
      listenerId?: string(name='ListenerId'),
    }
  ](name='ForwardingRules'),
}

model ListForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListForwardingRulesResponseBody(name='body'),
}

async function listForwardingRulesWithOptions(request: ListForwardingRulesRequest, runtime: Util.RuntimeOptions): ListForwardingRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListForwardingRules', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listForwardingRules(request: ListForwardingRulesRequest): ListForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listForwardingRulesWithOptions(request, runtime);
}

model CreateBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidth?: int32(name='Bandwidth'),
  duration?: string(name='Duration'),
  pricingCycle?: string(name='PricingCycle'),
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  type?: string(name='Type'),
  bandwidthType?: string(name='BandwidthType'),
  autoUseCoupon?: string(name='AutoUseCoupon'),
  ratio?: int32(name='Ratio'),
  billingType?: string(name='BillingType'),
  chargeType?: string(name='ChargeType'),
  cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
  cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
}

model CreateBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  orderId?: string(name='OrderId'),
}

model CreateBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBandwidthPackageResponseBody(name='body'),
}

async function createBandwidthPackageWithOptions(request: CreateBandwidthPackageRequest, runtime: Util.RuntimeOptions): CreateBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBandwidthPackage(request: CreateBandwidthPackageRequest): CreateBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBandwidthPackageWithOptions(request, runtime);
}

model ListBandwidthackagesRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListBandwidthackagesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  bandwidthPackages?: [ 
    {
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidth?: int32(name='Bandwidth'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      state?: string(name='State'),
      createTime?: string(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      accelerators?: [ string ](name='Accelerators'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
    }
  ](name='BandwidthPackages'),
}

model ListBandwidthackagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBandwidthackagesResponseBody(name='body'),
}

async function listBandwidthackagesWithOptions(request: ListBandwidthackagesRequest, runtime: Util.RuntimeOptions): ListBandwidthackagesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListBandwidthackages', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listBandwidthackages(request: ListBandwidthackagesRequest): ListBandwidthackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBandwidthackagesWithOptions(request, runtime);
}

model DeleteBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model DeleteBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBandwidthPackageResponseBody(name='body'),
}

async function deleteBandwidthPackageWithOptions(request: DeleteBandwidthPackageRequest, runtime: Util.RuntimeOptions): DeleteBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBandwidthPackage(request: DeleteBandwidthPackageRequest): DeleteBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBandwidthPackageWithOptions(request, runtime);
}

model GetHealthStatusRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
}

model GetHealthStatusResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  listenerId?: string(name='ListenerId'),
  healthStatus?: string(name='HealthStatus'),
  endpointGroups?: [ 
    {
      endpointGroupId?: string(name='EndpointGroupId'),
      endpointGroupType?: string(name='EndpointGroupType'),
      healthStatus?: string(name='HealthStatus'),
      forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
      endpoints?: [ 
        {
          endpointId?: string(name='EndpointId'),
          address?: string(name='Address'),
          healthStatus?: string(name='HealthStatus'),
          healthDetail?: string(name='HealthDetail'),
          port?: long(name='Port'),
          type?: string(name='Type'),
        }
      ](name='Endpoints'),
    }
  ](name='EndpointGroups'),
}

model GetHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetHealthStatusResponseBody(name='body'),
}

async function getHealthStatusWithOptions(request: GetHealthStatusRequest, runtime: Util.RuntimeOptions): GetHealthStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetHealthStatus', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getHealthStatus(request: GetHealthStatusRequest): GetHealthStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHealthStatusWithOptions(request, runtime);
}

model DescribeAcceleratorRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model DescribeAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  dnsName?: string(name='DnsName'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  createTime?: long(name='CreateTime'),
  crossDomainBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth'),
    instanceId?: string(name='InstanceId'),
  }(name='CrossDomainBandwidthPackage'),
  secondDnsName?: string(name='SecondDnsName'),
  name?: string(name='Name'),
  basicBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth'),
    bandwidthType?: string(name='BandwidthType'),
    instanceId?: string(name='InstanceId'),
  }(name='BasicBandwidthPackage'),
  state?: string(name='State'),
  expiredTime?: long(name='ExpiredTime'),
  cenId?: string(name='CenId'),
  regionId?: string(name='RegionId'),
  spec?: string(name='Spec'),
  acceleratorId?: string(name='AcceleratorId'),
}

model DescribeAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAcceleratorResponseBody(name='body'),
}

async function describeAcceleratorWithOptions(request: DescribeAcceleratorRequest, runtime: Util.RuntimeOptions): DescribeAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAccelerator(request: DescribeAcceleratorRequest): DescribeAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAcceleratorWithOptions(request, runtime);
}

model DetachLogStoreFromEndpointGroupRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
  clientToken?: string(name='ClientToken'),
}

model DetachLogStoreFromEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DetachLogStoreFromEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DetachLogStoreFromEndpointGroupResponseBody(name='body'),
}

async function detachLogStoreFromEndpointGroupWithOptions(request: DetachLogStoreFromEndpointGroupRequest, runtime: Util.RuntimeOptions): DetachLogStoreFromEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetachLogStoreFromEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detachLogStoreFromEndpointGroup(request: DetachLogStoreFromEndpointGroupRequest): DetachLogStoreFromEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachLogStoreFromEndpointGroupWithOptions(request, runtime);
}

model CreateIpSetsRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  accelerateRegion?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      ipVersion?: string(name='IpVersion'),
      bandwidth?: int32(name='Bandwidth'),
    }
  ](name='AccelerateRegion'),
}

model CreateIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
  ipSets?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      bandwidth?: int32(name='Bandwidth'),
      ipSetId?: string(name='IpSetId'),
      ipList?: [ string ](name='IpList'),
    }
  ](name='IpSets'),
  acceleratorId?: string(name='AcceleratorId'),
}

model CreateIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpSetsResponseBody(name='body'),
}

async function createIpSetsWithOptions(request: CreateIpSetsRequest, runtime: Util.RuntimeOptions): CreateIpSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIpSets', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIpSets(request: CreateIpSetsRequest): CreateIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpSetsWithOptions(request, runtime);
}

model CreateForwardingRulesRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  forwardingRules?: [ 
    {
      priority?: int32(name='Priority'),
      ruleConditions?: [ 
        {
          ruleConditionType?: string(name='RuleConditionType'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
        }
      ](name='RuleConditions'),
      ruleActions?: [ 
        {
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
        }
      ](name='RuleActions'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
    }
  ](name='ForwardingRules'),
}

model CreateForwardingRulesResponseBody = {
  requestId?: string(name='RequestId'),
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
}

model CreateForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardingRulesResponseBody(name='body'),
}

async function createForwardingRulesWithOptions(request: CreateForwardingRulesRequest, runtime: Util.RuntimeOptions): CreateForwardingRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateForwardingRules', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createForwardingRules(request: CreateForwardingRulesRequest): CreateForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createForwardingRulesWithOptions(request, runtime);
}

model ListAvailableAccelerateAreasRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListAvailableAccelerateAreasResponseBody = {
  requestId?: string(name='RequestId'),
  areas?: [ 
    {
      localName?: string(name='LocalName'),
      areaId?: string(name='AreaId'),
      regionList?: [ 
        {
          localName?: string(name='LocalName'),
          regionId?: string(name='RegionId'),
        }
      ](name='RegionList'),
    }
  ](name='Areas'),
}

model ListAvailableAccelerateAreasResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableAccelerateAreasResponseBody(name='body'),
}

async function listAvailableAccelerateAreasWithOptions(request: ListAvailableAccelerateAreasRequest, runtime: Util.RuntimeOptions): ListAvailableAccelerateAreasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAvailableAccelerateAreas', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAvailableAccelerateAreas(request: ListAvailableAccelerateAreasRequest): ListAvailableAccelerateAreasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableAccelerateAreasWithOptions(request, runtime);
}

model DeleteAclRequest {
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model DeleteAclResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  aclId?: string(name='AclId'),
}

model DeleteAclResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAclResponseBody(name='body'),
}

async function deleteAclWithOptions(request: DeleteAclRequest, runtime: Util.RuntimeOptions): DeleteAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAcl', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAcl(request: DeleteAclRequest): DeleteAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAclWithOptions(request, runtime);
}

model AddEntriesToAclRequest {
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
      entryDescription?: string(name='EntryDescription'),
    }
  ](name='AclEntries'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model AddEntriesToAclResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  aclId?: string(name='AclId'),
}

model AddEntriesToAclResponse = {
  headers: map[string]string(name='headers'),
  body: AddEntriesToAclResponseBody(name='body'),
}

async function addEntriesToAclWithOptions(request: AddEntriesToAclRequest, runtime: Util.RuntimeOptions): AddEntriesToAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddEntriesToAcl', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addEntriesToAcl(request: AddEntriesToAclRequest): AddEntriesToAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEntriesToAclWithOptions(request, runtime);
}

model CreateSpareIpsRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  acceleratorId?: string(name='AcceleratorId'),
  spareIps?: [ string ](name='SpareIps'),
}

model CreateSpareIpsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateSpareIpsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSpareIpsResponseBody(name='body'),
}

async function createSpareIpsWithOptions(request: CreateSpareIpsRequest, runtime: Util.RuntimeOptions): CreateSpareIpsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSpareIps', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSpareIps(request: CreateSpareIpsRequest): CreateSpareIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSpareIpsWithOptions(request, runtime);
}

model DissociateAdditionalCertificatesFromListenerRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  domains?: [ string ](name='Domains'),
}

model DissociateAdditionalCertificatesFromListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DissociateAdditionalCertificatesFromListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateAdditionalCertificatesFromListenerResponseBody(name='body'),
}

async function dissociateAdditionalCertificatesFromListenerWithOptions(request: DissociateAdditionalCertificatesFromListenerRequest, runtime: Util.RuntimeOptions): DissociateAdditionalCertificatesFromListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DissociateAdditionalCertificatesFromListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function dissociateAdditionalCertificatesFromListener(request: DissociateAdditionalCertificatesFromListenerRequest): DissociateAdditionalCertificatesFromListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateAdditionalCertificatesFromListenerWithOptions(request, runtime);
}

model ListEndpointGroupsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  endpointGroupType?: string(name='EndpointGroupType'),
  accessLogSwitch?: string(name='AccessLogSwitch'),
  endpointGroupId?: string(name='EndpointGroupId'),
}

model ListEndpointGroupsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  endpointGroups?: [ 
    {
      endpointGroupId?: string(name='EndpointGroupId'),
      endpointGroupIpList?: [ string ](name='EndpointGroupIpList'),
      endpointGroupUnconfirmedIpList?: [ string ](name='EndpointGroupUnconfirmedIpList'),
      state?: string(name='State'),
      healthCheckPath?: string(name='HealthCheckPath'),
      endpointGroupRegion?: string(name='EndpointGroupRegion'),
      healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
      trafficPercentage?: int32(name='TrafficPercentage'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      thresholdCount?: int32(name='ThresholdCount'),
      listenerId?: string(name='ListenerId'),
      acceleratorId?: string(name='AcceleratorId'),
      endpointConfigurations?: [ 
        {
          type?: string(name='Type'),
          enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
          weight?: int32(name='Weight'),
          probeProtocol?: string(name='ProbeProtocol'),
          endpoint?: string(name='Endpoint'),
          probePort?: int32(name='ProbePort'),
          endpointId?: string(name='EndpointId'),
        }
      ](name='EndpointConfigurations'),
      portOverrides?: [ 
        {
          listenerPort?: int32(name='ListenerPort'),
          endpointPort?: int32(name='EndpointPort'),
        }
      ](name='PortOverrides'),
      forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
      endpointGroupType?: string(name='EndpointGroupType'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      healthCheckPort?: int32(name='HealthCheckPort'),
      healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
    }
  ](name='EndpointGroups'),
}

model ListEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListEndpointGroupsResponseBody(name='body'),
}

async function listEndpointGroupsWithOptions(request: ListEndpointGroupsRequest, runtime: Util.RuntimeOptions): ListEndpointGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListEndpointGroups', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listEndpointGroups(request: ListEndpointGroupsRequest): ListEndpointGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEndpointGroupsWithOptions(request, runtime);
}

model ListBusiRegionsRequest {
  regionId?: string(name='RegionId'),
}

model ListBusiRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
}

model ListBusiRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBusiRegionsResponseBody(name='body'),
}

async function listBusiRegionsWithOptions(request: ListBusiRegionsRequest, runtime: Util.RuntimeOptions): ListBusiRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListBusiRegions', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listBusiRegions(request: ListBusiRegionsRequest): ListBusiRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBusiRegionsWithOptions(request, runtime);
}

model ReplaceBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  targetBandwidthPackageId?: string(name='TargetBandwidthPackageId'),
}

model ReplaceBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReplaceBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: ReplaceBandwidthPackageResponseBody(name='body'),
}

async function replaceBandwidthPackageWithOptions(request: ReplaceBandwidthPackageRequest, runtime: Util.RuntimeOptions): ReplaceBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReplaceBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function replaceBandwidthPackage(request: ReplaceBandwidthPackageRequest): ReplaceBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceBandwidthPackageWithOptions(request, runtime);
}

model UpdateEndpointGroupAttributeRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  endpointGroupId?: string(name='EndpointGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model UpdateEndpointGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEndpointGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEndpointGroupAttributeResponseBody(name='body'),
}

async function updateEndpointGroupAttributeWithOptions(request: UpdateEndpointGroupAttributeRequest, runtime: Util.RuntimeOptions): UpdateEndpointGroupAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateEndpointGroupAttribute', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateEndpointGroupAttribute(request: UpdateEndpointGroupAttributeRequest): UpdateEndpointGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEndpointGroupAttributeWithOptions(request, runtime);
}

model UpdateForwardingRulesRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  forwardingRules?: [ 
    {
      priority?: int32(name='Priority'),
      ruleConditions?: [ 
        {
          ruleConditionType?: string(name='RuleConditionType'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
        }
      ](name='RuleConditions'),
      ruleActions?: [ 
        {
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
        }
      ](name='RuleActions'),
      forwardingRuleId?: string(name='ForwardingRuleId'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
    }
  ](name='ForwardingRules'),
}

model UpdateForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model UpdateForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateForwardingRulesResponseBody(name='body'),
}

async function updateForwardingRulesWithOptions(request: UpdateForwardingRulesRequest, runtime: Util.RuntimeOptions): UpdateForwardingRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateForwardingRules', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateForwardingRules(request: UpdateForwardingRulesRequest): UpdateForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateForwardingRulesWithOptions(request, runtime);
}

model ListListenersRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListListenersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  listeners?: [ 
    {
      certificates?: [ 
        {
          type?: string(name='Type'),
          id?: string(name='Id'),
        }
      ](name='Certificates'),
      backendPorts?: [ 
        {
          fromPort?: string(name='FromPort'),
          toPort?: string(name='ToPort'),
        }
      ](name='BackendPorts'),
      listenerId?: string(name='ListenerId'),
      description?: string(name='Description'),
      state?: string(name='State'),
      clientAffinity?: string(name='ClientAffinity'),
      protocol?: string(name='Protocol'),
      createTime?: long(name='CreateTime'),
      portRanges?: [ 
        {
          fromPort?: int32(name='FromPort'),
          toPort?: int32(name='ToPort'),
        }
      ](name='PortRanges'),
      name?: string(name='Name'),
      proxyProtocol?: boolean(name='ProxyProtocol'),
      acceleratorId?: string(name='AcceleratorId'),
    }
  ](name='Listeners'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListListenersResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersResponseBody(name='body'),
}

async function listListenersWithOptions(request: ListListenersRequest, runtime: Util.RuntimeOptions): ListListenersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListListeners', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listListeners(request: ListListenersRequest): ListListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersWithOptions(request, runtime);
}

model DescribeEndpointGroupRequest {
  regionId?: string(name='RegionId'),
  endpointGroupId?: string(name='EndpointGroupId'),
}

model DescribeEndpointGroupResponseBody = {
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  trafficPercentage?: int32(name='TrafficPercentage'),
  endpointGroupId?: string(name='EndpointGroupId'),
  description?: string(name='Description'),
  endpointGroupIpList?: [ string ](name='EndpointGroupIpList'),
  endpointGroupUnconfirmedIpList?: [ string ](name='EndpointGroupUnconfirmedIpList'),
  requestId?: string(name='RequestId'),
  healthCheckPath?: string(name='HealthCheckPath'),
  thresholdCount?: int32(name='ThresholdCount'),
  name?: string(name='Name'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  totalCount?: int32(name='TotalCount'),
  state?: string(name='State'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  endpointConfigurations?: [ 
    {
      type?: string(name='Type'),
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      weight?: int32(name='Weight'),
      probeProtocol?: string(name='ProbeProtocol'),
      endpoint?: string(name='Endpoint'),
      probePort?: int32(name='ProbePort'),
    }
  ](name='EndpointConfigurations'),
  portOverrides?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      endpointPort?: int32(name='EndpointPort'),
    }
  ](name='PortOverrides'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  endpointGroupType?: string(name='EndpointGroupType'),
  forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  slsRegion?: string(name='SlsRegion'),
  slsProjectName?: string(name='SlsProjectName'),
  slsLogStoreName?: string(name='SlsLogStoreName'),
  accessLogSwitch?: string(name='AccessLogSwitch'),
  enableAccessLog?: boolean(name='EnableAccessLog'),
  healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
}

model DescribeEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEndpointGroupResponseBody(name='body'),
}

async function describeEndpointGroupWithOptions(request: DescribeEndpointGroupRequest, runtime: Util.RuntimeOptions): DescribeEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEndpointGroup(request: DescribeEndpointGroupRequest): DescribeEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEndpointGroupWithOptions(request, runtime);
}

model DeleteListenerRequest {
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
}

model DeleteListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteListenerResponseBody(name='body'),
}

async function deleteListenerWithOptions(request: DeleteListenerRequest, runtime: Util.RuntimeOptions): DeleteListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteListenerWithOptions(request, runtime);
}

model AssociateAdditionalCertificatesWithListenerRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  certificates?: [ 
    {
      id?: string(name='Id'),
      domain?: string(name='Domain'),
    }
  ](name='Certificates'),
}

model AssociateAdditionalCertificatesWithListenerResponseBody = {
  requestId?: string(name='RequestId'),
  listenerId?: string(name='ListenerId'),
}

model AssociateAdditionalCertificatesWithListenerResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateAdditionalCertificatesWithListenerResponseBody(name='body'),
}

async function associateAdditionalCertificatesWithListenerWithOptions(request: AssociateAdditionalCertificatesWithListenerRequest, runtime: Util.RuntimeOptions): AssociateAdditionalCertificatesWithListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AssociateAdditionalCertificatesWithListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function associateAdditionalCertificatesWithListener(request: AssociateAdditionalCertificatesWithListenerRequest): AssociateAdditionalCertificatesWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateAdditionalCertificatesWithListenerWithOptions(request, runtime);
}

model AttachLogStoreToEndpointGroupRequest {
  regionId?: string(name='RegionId'),
  slsProjectName?: string(name='SlsProjectName'),
  slsLogStoreName?: string(name='SlsLogStoreName'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  slsRegionId?: string(name='SlsRegionId'),
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
  clientToken?: string(name='ClientToken'),
}

model AttachLogStoreToEndpointGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AttachLogStoreToEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AttachLogStoreToEndpointGroupResponseBody(name='body'),
}

async function attachLogStoreToEndpointGroupWithOptions(request: AttachLogStoreToEndpointGroupRequest, runtime: Util.RuntimeOptions): AttachLogStoreToEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AttachLogStoreToEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function attachLogStoreToEndpointGroup(request: AttachLogStoreToEndpointGroupRequest): AttachLogStoreToEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachLogStoreToEndpointGroupWithOptions(request, runtime);
}

model UpdateCrossBorderPackageComplianceStatusRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  complianceStatus?: string(name='ComplianceStatus'),
  instanceId?: string(name='InstanceId'),
  description?: string(name='Description'),
}

model UpdateCrossBorderPackageComplianceStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCrossBorderPackageComplianceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCrossBorderPackageComplianceStatusResponseBody(name='body'),
}

async function updateCrossBorderPackageComplianceStatusWithOptions(request: UpdateCrossBorderPackageComplianceStatusRequest, runtime: Util.RuntimeOptions): UpdateCrossBorderPackageComplianceStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateCrossBorderPackageComplianceStatus', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateCrossBorderPackageComplianceStatus(request: UpdateCrossBorderPackageComplianceStatusRequest): UpdateCrossBorderPackageComplianceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCrossBorderPackageComplianceStatusWithOptions(request, runtime);
}

model UpdateBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  bandwidth?: int32(name='Bandwidth'),
  bandwidthType?: string(name='BandwidthType'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
}

model UpdateBandwidthPackageResponseBody = {
  bandwidthPackage?: string(name='BandwidthPackage'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  name?: string(name='Name'),
}

model UpdateBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBandwidthPackageResponseBody(name='body'),
}

async function updateBandwidthPackageWithOptions(request: UpdateBandwidthPackageRequest, runtime: Util.RuntimeOptions): UpdateBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateBandwidthPackage(request: UpdateBandwidthPackageRequest): UpdateBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBandwidthPackageWithOptions(request, runtime);
}

model DeleteAcceleratorRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model DeleteAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model DeleteAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAcceleratorResponseBody(name='body'),
}

async function deleteAcceleratorWithOptions(request: DeleteAcceleratorRequest, runtime: Util.RuntimeOptions): DeleteAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAccelerator(request: DeleteAcceleratorRequest): DeleteAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAcceleratorWithOptions(request, runtime);
}

model CreateEndpointGroupRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  listenerId?: string(name='ListenerId'),
  trafficPercentage?: int32(name='TrafficPercentage'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  thresholdCount?: int32(name='ThresholdCount'),
  endpointConfigurations?: [ 
    {
      type?: string(name='Type'),
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      weight?: int32(name='Weight'),
      endpoint?: string(name='Endpoint'),
    }
  ](name='EndpointConfigurations'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  endpointGroupType?: string(name='EndpointGroupType'),
  portOverrides?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      endpointPort?: int32(name='EndpointPort'),
    }
  ](name='PortOverrides'),
  healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
}

model CreateEndpointGroupResponseBody = {
  endpointGroupId?: string(name='EndpointGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEndpointGroupResponseBody(name='body'),
}

async function createEndpointGroupWithOptions(request: CreateEndpointGroupRequest, runtime: Util.RuntimeOptions): CreateEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createEndpointGroup(request: CreateEndpointGroupRequest): CreateEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEndpointGroupWithOptions(request, runtime);
}

model DeleteEndpointGroupRequest {
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  endpointGroupId?: string(name='EndpointGroupId'),
}

model DeleteEndpointGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEndpointGroupResponseBody(name='body'),
}

async function deleteEndpointGroupWithOptions(request: DeleteEndpointGroupRequest, runtime: Util.RuntimeOptions): DeleteEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteEndpointGroup(request: DeleteEndpointGroupRequest): DeleteEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEndpointGroupWithOptions(request, runtime);
}

model ListIpSetsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListIpSetsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  ipSets?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      ipVersion?: string(name='IpVersion'),
      bandwidth?: int32(name='Bandwidth'),
      state?: string(name='State'),
      ipSetId?: string(name='IpSetId'),
      ipAddressList?: [ string ](name='IpAddressList'),
    }
  ](name='IpSets'),
}

model ListIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpSetsResponseBody(name='body'),
}

async function listIpSetsWithOptions(request: ListIpSetsRequest, runtime: Util.RuntimeOptions): ListIpSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListIpSets', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listIpSets(request: ListIpSetsRequest): ListIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpSetsWithOptions(request, runtime);
}

model UpdateAcceleratorConfirmRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model UpdateAcceleratorConfirmResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAcceleratorConfirmResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAcceleratorConfirmResponseBody(name='body'),
}

async function updateAcceleratorConfirmWithOptions(request: UpdateAcceleratorConfirmRequest, runtime: Util.RuntimeOptions): UpdateAcceleratorConfirmResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAcceleratorConfirm', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAcceleratorConfirm(request: UpdateAcceleratorConfirmRequest): UpdateAcceleratorConfirmResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAcceleratorConfirmWithOptions(request, runtime);
}

model BandwidthPackageRemoveAcceleratorRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model BandwidthPackageRemoveAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
  accelerators?: [ string ](name='Accelerators'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model BandwidthPackageRemoveAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: BandwidthPackageRemoveAcceleratorResponseBody(name='body'),
}

async function bandwidthPackageRemoveAcceleratorWithOptions(request: BandwidthPackageRemoveAcceleratorRequest, runtime: Util.RuntimeOptions): BandwidthPackageRemoveAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BandwidthPackageRemoveAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function bandwidthPackageRemoveAccelerator(request: BandwidthPackageRemoveAcceleratorRequest): BandwidthPackageRemoveAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return bandwidthPackageRemoveAcceleratorWithOptions(request, runtime);
}

model DeleteForwardingRulesRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
}

model DeleteForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model DeleteForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardingRulesResponseBody(name='body'),
}

async function deleteForwardingRulesWithOptions(request: DeleteForwardingRulesRequest, runtime: Util.RuntimeOptions): DeleteForwardingRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteForwardingRules', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteForwardingRules(request: DeleteForwardingRulesRequest): DeleteForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteForwardingRulesWithOptions(request, runtime);
}

model DissociateAclsFromListenerRequest {
  regionId?: string(name='RegionId'),
  aclIds?: [ string ](name='AclIds'),
  listenerId?: string(name='ListenerId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model DissociateAclsFromListenerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  aclIds?: [ string ](name='AclIds'),
  listenerId?: string(name='ListenerId'),
}

model DissociateAclsFromListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DissociateAclsFromListenerResponseBody(name='body'),
}

async function dissociateAclsFromListenerWithOptions(request: DissociateAclsFromListenerRequest, runtime: Util.RuntimeOptions): DissociateAclsFromListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DissociateAclsFromListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function dissociateAclsFromListener(request: DissociateAclsFromListenerRequest): DissociateAclsFromListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateAclsFromListenerWithOptions(request, runtime);
}

model ListCrossBorderPackageForComplianceRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  resourceUid?: long(name='ResourceUid'),
  isBinded?: boolean(name='IsBinded'),
  nextToken?: string(name='NextToken'),
  maxResult?: int32(name='MaxResult'),
}

model ListCrossBorderPackageForComplianceResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  bandwidthPackages?: [ 
    {
      isBinded?: boolean(name='IsBinded'),
      createTime?: long(name='CreateTime'),
      cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidth?: int32(name='Bandwidth'),
      expiredTime?: long(name='ExpiredTime'),
      cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
      aliUid?: long(name='AliUid'),
      bindTime?: long(name='BindTime'),
    }
  ](name='BandwidthPackages'),
}

model ListCrossBorderPackageForComplianceResponse = {
  headers: map[string]string(name='headers'),
  body: ListCrossBorderPackageForComplianceResponseBody(name='body'),
}

async function listCrossBorderPackageForComplianceWithOptions(request: ListCrossBorderPackageForComplianceRequest, runtime: Util.RuntimeOptions): ListCrossBorderPackageForComplianceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListCrossBorderPackageForCompliance', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listCrossBorderPackageForCompliance(request: ListCrossBorderPackageForComplianceRequest): ListCrossBorderPackageForComplianceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCrossBorderPackageForComplianceWithOptions(request, runtime);
}

model ListAccelerateAreasRequest {
  regionId?: string(name='RegionId'),
}

model ListAccelerateAreasResponseBody = {
  requestId?: string(name='RequestId'),
  areas?: [ 
    {
      localName?: string(name='LocalName'),
      areaId?: string(name='AreaId'),
      regionList?: [ 
        {
          localName?: string(name='LocalName'),
          regionId?: string(name='RegionId'),
        }
      ](name='RegionList'),
    }
  ](name='Areas'),
}

model ListAccelerateAreasResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccelerateAreasResponseBody(name='body'),
}

async function listAccelerateAreasWithOptions(request: ListAccelerateAreasRequest, runtime: Util.RuntimeOptions): ListAccelerateAreasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAccelerateAreas', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAccelerateAreas(request: ListAccelerateAreasRequest): ListAccelerateAreasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccelerateAreasWithOptions(request, runtime);
}

model ListListenerCertificatesRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListListenerCertificatesResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
      type?: string(name='Type'),
      isDefault?: boolean(name='IsDefault'),
      domain?: string(name='Domain'),
    }
  ](name='Certificates'),
}

model ListListenerCertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenerCertificatesResponseBody(name='body'),
}

async function listListenerCertificatesWithOptions(request: ListListenerCertificatesRequest, runtime: Util.RuntimeOptions): ListListenerCertificatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListListenerCertificates', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listListenerCertificates(request: ListListenerCertificatesRequest): ListListenerCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenerCertificatesWithOptions(request, runtime);
}

model UpdateIpSetRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  ipSetId?: string(name='IpSetId'),
  bandwidth?: int32(name='Bandwidth'),
}

model UpdateIpSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpSetResponseBody(name='body'),
}

async function updateIpSetWithOptions(request: UpdateIpSetRequest, runtime: Util.RuntimeOptions): UpdateIpSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIpSet', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIpSet(request: UpdateIpSetRequest): UpdateIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpSetWithOptions(request, runtime);
}

model CreateAclRequest {
  regionId?: string(name='RegionId'),
  aclName?: string(name='AclName'),
  addressIPVersion?: string(name='AddressIPVersion'),
  aclEntries?: [ 
    {
      entry?: string(name='Entry'),
      entryDescription?: string(name='EntryDescription'),
    }
  ](name='AclEntries'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model CreateAclResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  aclId?: string(name='AclId'),
}

model CreateAclResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAclResponseBody(name='body'),
}

async function createAclWithOptions(request: CreateAclRequest, runtime: Util.RuntimeOptions): CreateAclResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAcl', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAcl(request: CreateAclRequest): CreateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAclWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model UpdateListenerRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientAffinity?: string(name='ClientAffinity'),
  protocol?: string(name='Protocol'),
  listenerId?: string(name='ListenerId'),
  proxyProtocol?: string(name='ProxyProtocol'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  certificates?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Certificates'),
  backendPorts?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='BackendPorts'),
}

model UpdateListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateListenerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateListenerResponseBody(name='body'),
}

async function updateListenerWithOptions(request: UpdateListenerRequest, runtime: Util.RuntimeOptions): UpdateListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateListener(request: UpdateListenerRequest): UpdateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerWithOptions(request, runtime);
}

model ListAvailableBusiRegionsRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListAvailableBusiRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
}

model ListAvailableBusiRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableBusiRegionsResponseBody(name='body'),
}

async function listAvailableBusiRegionsWithOptions(request: ListAvailableBusiRegionsRequest, runtime: Util.RuntimeOptions): ListAvailableBusiRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAvailableBusiRegions', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAvailableBusiRegions(request: ListAvailableBusiRegionsRequest): ListAvailableBusiRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableBusiRegionsWithOptions(request, runtime);
}

model UpdateAcceleratorRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  acceleratorId?: string(name='AcceleratorId'),
  spec?: string(name='Spec'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
}

model UpdateAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAcceleratorResponseBody(name='body'),
}

async function updateAcceleratorWithOptions(request: UpdateAcceleratorRequest, runtime: Util.RuntimeOptions): UpdateAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAccelerator(request: UpdateAcceleratorRequest): UpdateAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAcceleratorWithOptions(request, runtime);
}

model DeleteEndpointGroupsRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
}

model DeleteEndpointGroupsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEndpointGroupsResponseBody(name='body'),
}

async function deleteEndpointGroupsWithOptions(request: DeleteEndpointGroupsRequest, runtime: Util.RuntimeOptions): DeleteEndpointGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteEndpointGroups', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteEndpointGroups(request: DeleteEndpointGroupsRequest): DeleteEndpointGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEndpointGroupsWithOptions(request, runtime);
}

model DeleteIpSetRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  ipSetId?: string(name='IpSetId'),
}

model DeleteIpSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpSetResponseBody(name='body'),
}

async function deleteIpSetWithOptions(request: DeleteIpSetRequest, runtime: Util.RuntimeOptions): DeleteIpSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpSet', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpSet(request: DeleteIpSetRequest): DeleteIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpSetWithOptions(request, runtime);
}

model UpdateEndpointGroupsRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  endpointGroupConfigurations?: [ 
    {
      endpointGroupName?: string(name='EndpointGroupName'),
      endpointGroupDescription?: string(name='EndpointGroupDescription'),
      trafficPercentage?: long(name='TrafficPercentage'),
      healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
      healthCheckIntervalSeconds?: long(name='HealthCheckIntervalSeconds'),
      healthCheckPath?: string(name='HealthCheckPath'),
      healthCheckPort?: long(name='HealthCheckPort'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      thresholdCount?: long(name='ThresholdCount'),
      endpointConfigurations?: [ 
        {
          type?: string(name='Type'),
          weight?: long(name='Weight'),
          endpoint?: string(name='Endpoint'),
        }
      ](name='EndpointConfigurations'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      portOverrides?: [ 
        {
          listenerPort?: long(name='ListenerPort'),
          endpointPort?: long(name='EndpointPort'),
        }
      ](name='PortOverrides'),
      enableClientIPPreservationToa?: boolean(name='EnableClientIPPreservationToa'),
      enableClientIPPreservationProxyProtocol?: boolean(name='EnableClientIPPreservationProxyProtocol'),
      endpointGroupId?: string(name='EndpointGroupId'),
    }
  ](name='EndpointGroupConfigurations'),
  listenerId?: string(name='ListenerId'),
}

model UpdateEndpointGroupsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
}

model UpdateEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEndpointGroupsResponseBody(name='body'),
}

async function updateEndpointGroupsWithOptions(request: UpdateEndpointGroupsRequest, runtime: Util.RuntimeOptions): UpdateEndpointGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateEndpointGroups', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateEndpointGroups(request: UpdateEndpointGroupsRequest): UpdateEndpointGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEndpointGroupsWithOptions(request, runtime);
}

model DeleteIpSetsRequest {
  regionId?: string(name='RegionId'),
  ipSetIds?: [ string ](name='IpSetIds'),
}

model DeleteIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpSetsResponseBody(name='body'),
}

async function deleteIpSetsWithOptions(request: DeleteIpSetsRequest, runtime: Util.RuntimeOptions): DeleteIpSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpSets', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpSets(request: DeleteIpSetsRequest): DeleteIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpSetsWithOptions(request, runtime);
}

model BandwidthPackageAddAcceleratorRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model BandwidthPackageAddAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
  accelerators?: [ string ](name='Accelerators'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model BandwidthPackageAddAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: BandwidthPackageAddAcceleratorResponseBody(name='body'),
}

async function bandwidthPackageAddAcceleratorWithOptions(request: BandwidthPackageAddAcceleratorRequest, runtime: Util.RuntimeOptions): BandwidthPackageAddAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BandwidthPackageAddAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function bandwidthPackageAddAccelerator(request: BandwidthPackageAddAcceleratorRequest): BandwidthPackageAddAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return bandwidthPackageAddAcceleratorWithOptions(request, runtime);
}

model UpdateAclAttributeRequest {
  regionId?: string(name='RegionId'),
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model UpdateAclAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  aclId?: string(name='AclId'),
}

model UpdateAclAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAclAttributeResponseBody(name='body'),
}

async function updateAclAttributeWithOptions(request: UpdateAclAttributeRequest, runtime: Util.RuntimeOptions): UpdateAclAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAclAttribute', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAclAttribute(request: UpdateAclAttributeRequest): UpdateAclAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAclAttributeWithOptions(request, runtime);
}

model ListAcceleratorsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  acceleratorId?: string(name='AcceleratorId'),
  state?: string(name='State'),
}

model ListAcceleratorsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  accelerators?: [ 
    {
      dnsName?: string(name='DnsName'),
      type?: string(name='Type'),
      secondDnsName?: string(name='SecondDnsName'),
      spec?: string(name='Spec'),
      state?: string(name='State'),
      createTime?: long(name='CreateTime'),
      cenId?: string(name='CenId'),
      ddosId?: string(name='DdosId'),
      basicBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth'),
        bandwidthType?: string(name='BandwidthType'),
        instanceId?: string(name='InstanceId'),
      }(name='BasicBandwidthPackage'),
      regionId?: string(name='RegionId'),
      instanceChargeType?: string(name='InstanceChargeType'),
      acceleratorId?: string(name='AcceleratorId'),
      description?: string(name='Description'),
      bandwidth?: int32(name='Bandwidth'),
      expiredTime?: long(name='ExpiredTime'),
      name?: string(name='Name'),
      crossDomainBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth'),
        instanceId?: string(name='InstanceId'),
      }(name='CrossDomainBandwidthPackage'),
    }
  ](name='Accelerators'),
  pageNumber?: int32(name='PageNumber'),
}

model ListAcceleratorsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAcceleratorsResponseBody(name='body'),
}

async function listAcceleratorsWithOptions(request: ListAcceleratorsRequest, runtime: Util.RuntimeOptions): ListAcceleratorsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAccelerators', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAccelerators(request: ListAcceleratorsRequest): ListAcceleratorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAcceleratorsWithOptions(request, runtime);
}

model CreateListenerRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientAffinity?: string(name='ClientAffinity'),
  protocol?: string(name='Protocol'),
  proxyProtocol?: boolean(name='ProxyProtocol'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  certificates?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Certificates'),
}

model CreateListenerResponseBody = {
  requestId?: string(name='RequestId'),
  listenerId?: string(name='ListenerId'),
}

model CreateListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateListenerResponseBody(name='body'),
}

async function createListenerWithOptions(request: CreateListenerRequest, runtime: Util.RuntimeOptions): CreateListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createListenerWithOptions(request, runtime);
}

model ListSpareIpsRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListSpareIpsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  spareIps?: [ 
    {
      spareIp?: string(name='SpareIp'),
      state?: string(name='State'),
    }
  ](name='SpareIps'),
}

model ListSpareIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSpareIpsResponseBody(name='body'),
}

async function listSpareIpsWithOptions(request: ListSpareIpsRequest, runtime: Util.RuntimeOptions): ListSpareIpsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSpareIps', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSpareIps(request: ListSpareIpsRequest): ListSpareIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSpareIpsWithOptions(request, runtime);
}

model CreateEndpointGroupsRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  endpointGroupConfigurations?: [ 
    {
      endpointGroupName?: string(name='EndpointGroupName'),
      endpointGroupDescription?: string(name='EndpointGroupDescription'),
      endpointGroupRegion?: string(name='EndpointGroupRegion'),
      trafficPercentage?: long(name='TrafficPercentage'),
      healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
      healthCheckIntervalSeconds?: long(name='HealthCheckIntervalSeconds'),
      healthCheckPath?: string(name='HealthCheckPath'),
      healthCheckPort?: long(name='HealthCheckPort'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      thresholdCount?: long(name='ThresholdCount'),
      endpointConfigurations?: [ 
        {
          type?: string(name='Type'),
          weight?: long(name='Weight'),
          endpoint?: string(name='Endpoint'),
        }
      ](name='EndpointConfigurations'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      endpointGroupType?: string(name='EndpointGroupType'),
      portOverrides?: [ 
        {
          listenerPort?: long(name='ListenerPort'),
          endpointPort?: long(name='EndpointPort'),
        }
      ](name='PortOverrides'),
      enableClientIPPreservationToa?: boolean(name='EnableClientIPPreservationToa'),
      enableClientIPPreservationProxyProtocol?: boolean(name='EnableClientIPPreservationProxyProtocol'),
    }
  ](name='EndpointGroupConfigurations'),
}

model CreateEndpointGroupsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  endpointGroupIds?: [ string ](name='EndpointGroupIds'),
}

model CreateEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEndpointGroupsResponseBody(name='body'),
}

async function createEndpointGroupsWithOptions(request: CreateEndpointGroupsRequest, runtime: Util.RuntimeOptions): CreateEndpointGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateEndpointGroups', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createEndpointGroups(request: CreateEndpointGroupsRequest): CreateEndpointGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEndpointGroupsWithOptions(request, runtime);
}

model DetachDdosFromAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  regionId?: string(name='RegionId'),
}

model DetachDdosFromAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  requestId?: string(name='RequestId'),
}

model DetachDdosFromAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDdosFromAcceleratorResponseBody(name='body'),
}

async function detachDdosFromAcceleratorWithOptions(request: DetachDdosFromAcceleratorRequest, runtime: Util.RuntimeOptions): DetachDdosFromAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetachDdosFromAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detachDdosFromAccelerator(request: DetachDdosFromAcceleratorRequest): DetachDdosFromAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDdosFromAcceleratorWithOptions(request, runtime);
}

model GetSpareIpRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  acceleratorId?: string(name='AcceleratorId'),
  spareIp?: string(name='SpareIp'),
}

model GetSpareIpResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  state?: string(name='State'),
}

model GetSpareIpResponse = {
  headers: map[string]string(name='headers'),
  body: GetSpareIpResponseBody(name='body'),
}

async function getSpareIpWithOptions(request: GetSpareIpRequest, runtime: Util.RuntimeOptions): GetSpareIpResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSpareIp', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSpareIp(request: GetSpareIpRequest): GetSpareIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSpareIpWithOptions(request, runtime);
}

