/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ga', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model DescribeIpSetRequest {
  regionId?: string(name='RegionId'),
  ipSetId?: string(name='IpSetId'),
}

model DescribeIpSetResponseBody = {
  ipSetId?: string(name='IpSetId'),
  requestId?: string(name='RequestId'),
  ipVersion?: string(name='IpVersion'),
  state?: string(name='State'),
  bandwidth?: int32(name='Bandwidth'),
  ipAddressList?: [ string ](name='IpAddressList'),
  accelerateRegionId?: string(name='AccelerateRegionId'),
}

model DescribeIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIpSetResponseBody(name='body'),
}

async function describeIpSetWithOptions(request: DescribeIpSetRequest, runtime: Util.RuntimeOptions): DescribeIpSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeIpSet', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeIpSet(request: DescribeIpSetRequest): DescribeIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpSetWithOptions(request, runtime);
}

model CreateAcceleratorRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  duration?: int32(name='Duration'),
  pricingCycle?: string(name='PricingCycle'),
  spec?: string(name='Spec'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: string(name='AutoUseCoupon'),
  promotionOptionNo?: string(name='PromotionOptionNo'),
}

model CreateAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model CreateAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAcceleratorResponseBody(name='body'),
}

async function createAcceleratorWithOptions(request: CreateAcceleratorRequest, runtime: Util.RuntimeOptions): CreateAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAccelerator(request: CreateAcceleratorRequest): CreateAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAcceleratorWithOptions(request, runtime);
}

model UpdateBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  bandwidth?: int32(name='Bandwidth'),
  bandwidthType?: string(name='BandwidthType'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  promotionOptionNo?: string(name='PromotionOptionNo'),
}

model UpdateBandwidthPackageResponseBody = {
  bandwidthPackage?: string(name='BandwidthPackage'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  name?: string(name='Name'),
}

model UpdateBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBandwidthPackageResponseBody(name='body'),
}

async function updateBandwidthPackageWithOptions(request: UpdateBandwidthPackageRequest, runtime: Util.RuntimeOptions): UpdateBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateBandwidthPackage(request: UpdateBandwidthPackageRequest): UpdateBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBandwidthPackageWithOptions(request, runtime);
}

model DescribeListenerRequest {
  regionId?: string(name='RegionId'),
  listenerId?: string(name='ListenerId'),
}

model DescribeListenerResponseBody = {
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
  createTime?: string(name='CreateTime'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  backendPorts?: [ 
    {
      fromPort?: string(name='FromPort'),
      toPort?: string(name='ToPort'),
    }
  ](name='BackendPorts'),
  certificates?: [ 
    {
      type?: string(name='Type'),
      id?: string(name='Id'),
    }
  ](name='Certificates'),
  protocol?: string(name='Protocol'),
  listenerId?: string(name='ListenerId'),
  clientAffinity?: string(name='ClientAffinity'),
  name?: string(name='Name'),
}

model DescribeListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeListenerResponseBody(name='body'),
}

async function describeListenerWithOptions(request: DescribeListenerRequest, runtime: Util.RuntimeOptions): DescribeListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeListener(request: DescribeListenerRequest): DescribeListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeListenerWithOptions(request, runtime);
}

model DeleteAcceleratorRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model DeleteAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model DeleteAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAcceleratorResponseBody(name='body'),
}

async function deleteAcceleratorWithOptions(request: DeleteAcceleratorRequest, runtime: Util.RuntimeOptions): DeleteAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAccelerator(request: DeleteAcceleratorRequest): DeleteAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAcceleratorWithOptions(request, runtime);
}

model CreateEndpointGroupRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  listenerId?: string(name='ListenerId'),
  trafficPercentage?: int32(name='TrafficPercentage'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  thresholdCount?: int32(name='ThresholdCount'),
  endpointConfigurations?: [ 
    {
      type?: string(name='Type'),
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      weight?: int32(name='Weight'),
      endpoint?: string(name='Endpoint'),
    }
  ](name='EndpointConfigurations'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  endpointGroupType?: string(name='EndpointGroupType'),
  portOverrides?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      endpointPort?: int32(name='EndpointPort'),
    }
  ](name='PortOverrides'),
}

model CreateEndpointGroupResponseBody = {
  endpointGroupId?: string(name='EndpointGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEndpointGroupResponseBody(name='body'),
}

async function createEndpointGroupWithOptions(request: CreateEndpointGroupRequest, runtime: Util.RuntimeOptions): CreateEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createEndpointGroup(request: CreateEndpointGroupRequest): CreateEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEndpointGroupWithOptions(request, runtime);
}

model UpdateIpSetsRequest {
  regionId?: string(name='RegionId'),
  ipSets?: [ 
    {
      bandwidth?: int32(name='Bandwidth'),
      ipSetId?: string(name='IpSetId'),
    }
  ](name='IpSets'),
}

model UpdateIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpSetsResponseBody(name='body'),
}

async function updateIpSetsWithOptions(request: UpdateIpSetsRequest, runtime: Util.RuntimeOptions): UpdateIpSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIpSets', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIpSets(request: UpdateIpSetsRequest): UpdateIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpSetsWithOptions(request, runtime);
}

model ConfigEndpointProbeRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  endpointGroupId?: string(name='EndpointGroupId'),
  endpointType?: string(name='EndpointType'),
  endpoint?: string(name='Endpoint'),
  probeProtocol?: string(name='ProbeProtocol'),
  probePort?: string(name='ProbePort'),
  enable?: string(name='Enable'),
}

model ConfigEndpointProbeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigEndpointProbeResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigEndpointProbeResponseBody(name='body'),
}

async function configEndpointProbeWithOptions(request: ConfigEndpointProbeRequest, runtime: Util.RuntimeOptions): ConfigEndpointProbeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConfigEndpointProbe', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function configEndpointProbe(request: ConfigEndpointProbeRequest): ConfigEndpointProbeResponse {
  var runtime = new Util.RuntimeOptions{};
  return configEndpointProbeWithOptions(request, runtime);
}

model DeleteEndpointGroupRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  endpointGroupId?: string(name='EndpointGroupId'),
}

model DeleteEndpointGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEndpointGroupResponseBody(name='body'),
}

async function deleteEndpointGroupWithOptions(request: DeleteEndpointGroupRequest, runtime: Util.RuntimeOptions): DeleteEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteEndpointGroup(request: DeleteEndpointGroupRequest): DeleteEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEndpointGroupWithOptions(request, runtime);
}

model ListIpSetsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListIpSetsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  ipSets?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      ipVersion?: string(name='IpVersion'),
      bandwidth?: int32(name='Bandwidth'),
      state?: string(name='State'),
      ipSetId?: string(name='IpSetId'),
      ipAddressList?: [ string ](name='IpAddressList'),
    }
  ](name='IpSets'),
}

model ListIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIpSetsResponseBody(name='body'),
}

async function listIpSetsWithOptions(request: ListIpSetsRequest, runtime: Util.RuntimeOptions): ListIpSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListIpSets', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listIpSets(request: ListIpSetsRequest): ListIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpSetsWithOptions(request, runtime);
}

model BandwidthPackageRemoveAcceleratorRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model BandwidthPackageRemoveAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
  accelerators?: [ string ](name='Accelerators'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model BandwidthPackageRemoveAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: BandwidthPackageRemoveAcceleratorResponseBody(name='body'),
}

async function bandwidthPackageRemoveAcceleratorWithOptions(request: BandwidthPackageRemoveAcceleratorRequest, runtime: Util.RuntimeOptions): BandwidthPackageRemoveAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BandwidthPackageRemoveAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function bandwidthPackageRemoveAccelerator(request: BandwidthPackageRemoveAcceleratorRequest): BandwidthPackageRemoveAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return bandwidthPackageRemoveAcceleratorWithOptions(request, runtime);
}

model DescribeBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model DescribeBandwidthPackageResponseBody = {
  cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
  cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  createTime?: string(name='CreateTime'),
  name?: string(name='Name'),
  bandwidthType?: string(name='BandwidthType'),
  type?: string(name='Type'),
  accelerators?: [ string ](name='Accelerators'),
  state?: string(name='State'),
  chargeType?: string(name='ChargeType'),
  bandwidth?: int32(name='Bandwidth'),
  expiredTime?: string(name='ExpiredTime'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  regionId?: string(name='RegionId'),
  billingType?: string(name='BillingType'),
}

model DescribeBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBandwidthPackageResponseBody(name='body'),
}

async function describeBandwidthPackageWithOptions(request: DescribeBandwidthPackageRequest, runtime: Util.RuntimeOptions): DescribeBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeBandwidthPackage(request: DescribeBandwidthPackageRequest): DescribeBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBandwidthPackageWithOptions(request, runtime);
}

model DeleteForwardingRulesRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
}

model DeleteForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model DeleteForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteForwardingRulesResponseBody(name='body'),
}

async function deleteForwardingRulesWithOptions(request: DeleteForwardingRulesRequest, runtime: Util.RuntimeOptions): DeleteForwardingRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteForwardingRules', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteForwardingRules(request: DeleteForwardingRulesRequest): DeleteForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteForwardingRulesWithOptions(request, runtime);
}

model ListAccelerateAreasRequest {
  regionId?: string(name='RegionId'),
}

model ListAccelerateAreasResponseBody = {
  requestId?: string(name='RequestId'),
  areas?: [ 
    {
      localName?: string(name='LocalName'),
      areaId?: string(name='AreaId'),
      regionList?: [ 
        {
          localName?: string(name='LocalName'),
          regionId?: string(name='RegionId'),
        }
      ](name='RegionList'),
    }
  ](name='Areas'),
}

model ListAccelerateAreasResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccelerateAreasResponseBody(name='body'),
}

async function listAccelerateAreasWithOptions(request: ListAccelerateAreasRequest, runtime: Util.RuntimeOptions): ListAccelerateAreasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAccelerateAreas', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAccelerateAreas(request: ListAccelerateAreasRequest): ListAccelerateAreasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccelerateAreasWithOptions(request, runtime);
}

model UpdateIpSetRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  ipSetId?: string(name='IpSetId'),
  bandwidth?: int32(name='Bandwidth'),
}

model UpdateIpSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIpSetResponseBody(name='body'),
}

async function updateIpSetWithOptions(request: UpdateIpSetRequest, runtime: Util.RuntimeOptions): UpdateIpSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateIpSet', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateIpSet(request: UpdateIpSetRequest): UpdateIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIpSetWithOptions(request, runtime);
}

model ListBandwidthPackagesRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  state?: string(name='State'),
  type?: string(name='Type'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model ListBandwidthPackagesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  bandwidthPackages?: [ 
    {
      type?: string(name='Type'),
      bandwidthType?: string(name='BandwidthType'),
      state?: string(name='State'),
      createTime?: string(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      regionId?: string(name='RegionId'),
      cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidth?: int32(name='Bandwidth'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      accelerators?: [ string ](name='Accelerators'),
      cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
      name?: string(name='Name'),
      billingType?: string(name='BillingType'),
    }
  ](name='BandwidthPackages'),
}

model ListBandwidthPackagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBandwidthPackagesResponseBody(name='body'),
}

async function listBandwidthPackagesWithOptions(request: ListBandwidthPackagesRequest, runtime: Util.RuntimeOptions): ListBandwidthPackagesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListBandwidthPackages', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listBandwidthPackages(request: ListBandwidthPackagesRequest): ListBandwidthPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBandwidthPackagesWithOptions(request, runtime);
}

model UpdateEndpointGroupRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  endpointGroupId?: string(name='EndpointGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  trafficPercentage?: int32(name='TrafficPercentage'),
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  thresholdCount?: int32(name='ThresholdCount'),
  endpointConfigurations?: [ 
    {
      type?: string(name='Type'),
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      weight?: int32(name='Weight'),
      endpoint?: string(name='Endpoint'),
    }
  ](name='EndpointConfigurations'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  portOverrides?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      endpointPort?: int32(name='EndpointPort'),
    }
  ](name='PortOverrides'),
}

model UpdateEndpointGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEndpointGroupResponseBody(name='body'),
}

async function updateEndpointGroupWithOptions(request: UpdateEndpointGroupRequest, runtime: Util.RuntimeOptions): UpdateEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateEndpointGroup(request: UpdateEndpointGroupRequest): UpdateEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEndpointGroupWithOptions(request, runtime);
}

model AttachDdosToAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  ddosId?: string(name='DdosId'),
  ddosRegionId?: string(name='DdosRegionId'),
  regionId?: string(name='RegionId'),
}

model AttachDdosToAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  requestId?: string(name='RequestId'),
  gaId?: string(name='GaId'),
}

model AttachDdosToAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDdosToAcceleratorResponseBody(name='body'),
}

async function attachDdosToAcceleratorWithOptions(request: AttachDdosToAcceleratorRequest, runtime: Util.RuntimeOptions): AttachDdosToAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AttachDdosToAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function attachDdosToAccelerator(request: AttachDdosToAcceleratorRequest): AttachDdosToAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDdosToAcceleratorWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model ListForwardingRulesRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  listenerId?: string(name='ListenerId'),
  acceleratorId?: string(name='AcceleratorId'),
  forwardingRuleId?: string(name='ForwardingRuleId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListForwardingRulesResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
  forwardingRules?: [ 
    {
      priority?: int32(name='Priority'),
      forwardingRuleId?: string(name='ForwardingRuleId'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
      forwardingRuleStatus?: string(name='ForwardingRuleStatus'),
      ruleConditions?: [ 
        {
          ruleConditionType?: string(name='RuleConditionType'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
        }
      ](name='RuleConditions'),
      ruleActions?: [ 
        {
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
        }
      ](name='RuleActions'),
      listenerId?: string(name='ListenerId'),
    }
  ](name='ForwardingRules'),
}

model ListForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListForwardingRulesResponseBody(name='body'),
}

async function listForwardingRulesWithOptions(request: ListForwardingRulesRequest, runtime: Util.RuntimeOptions): ListForwardingRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListForwardingRules', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listForwardingRules(request: ListForwardingRulesRequest): ListForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listForwardingRulesWithOptions(request, runtime);
}

model CreateBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidth?: int32(name='Bandwidth'),
  duration?: string(name='Duration'),
  pricingCycle?: string(name='PricingCycle'),
  autoPay?: boolean(name='AutoPay'),
  clientToken?: string(name='ClientToken'),
  type?: string(name='Type'),
  bandwidthType?: string(name='BandwidthType'),
  autoUseCoupon?: string(name='AutoUseCoupon'),
  ratio?: int32(name='Ratio'),
  billingType?: string(name='BillingType'),
  chargeType?: string(name='ChargeType'),
  cbnGeographicRegionIdA?: string(name='CbnGeographicRegionIdA'),
  cbnGeographicRegionIdB?: string(name='CbnGeographicRegionIdB'),
  promotionOptionNo?: string(name='PromotionOptionNo'),
}

model CreateBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  orderId?: string(name='OrderId'),
}

model CreateBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBandwidthPackageResponseBody(name='body'),
}

async function createBandwidthPackageWithOptions(request: CreateBandwidthPackageRequest, runtime: Util.RuntimeOptions): CreateBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBandwidthPackage(request: CreateBandwidthPackageRequest): CreateBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBandwidthPackageWithOptions(request, runtime);
}

model UpdateListenerRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientAffinity?: string(name='ClientAffinity'),
  protocol?: string(name='Protocol'),
  listenerId?: string(name='ListenerId'),
  proxyProtocol?: string(name='ProxyProtocol'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  certificates?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Certificates'),
  backendPorts?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='BackendPorts'),
}

model UpdateListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateListenerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateListenerResponseBody(name='body'),
}

async function updateListenerWithOptions(request: UpdateListenerRequest, runtime: Util.RuntimeOptions): UpdateListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateListener(request: UpdateListenerRequest): UpdateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerWithOptions(request, runtime);
}

model ListBandwidthackagesRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListBandwidthackagesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  bandwidthPackages?: [ 
    {
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      bandwidth?: int32(name='Bandwidth'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      state?: string(name='State'),
      createTime?: string(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      accelerators?: [ string ](name='Accelerators'),
      name?: string(name='Name'),
      regionId?: string(name='RegionId'),
    }
  ](name='BandwidthPackages'),
}

model ListBandwidthackagesResponse = {
  headers: map[string]string(name='headers'),
  body: ListBandwidthackagesResponseBody(name='body'),
}

async function listBandwidthackagesWithOptions(request: ListBandwidthackagesRequest, runtime: Util.RuntimeOptions): ListBandwidthackagesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListBandwidthackages', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listBandwidthackages(request: ListBandwidthackagesRequest): ListBandwidthackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBandwidthackagesWithOptions(request, runtime);
}

model DeleteBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model DeleteBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBandwidthPackageResponseBody(name='body'),
}

async function deleteBandwidthPackageWithOptions(request: DeleteBandwidthPackageRequest, runtime: Util.RuntimeOptions): DeleteBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBandwidthPackage(request: DeleteBandwidthPackageRequest): DeleteBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBandwidthPackageWithOptions(request, runtime);
}

model ListAvailableBusiRegionsRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListAvailableBusiRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
}

model ListAvailableBusiRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableBusiRegionsResponseBody(name='body'),
}

async function listAvailableBusiRegionsWithOptions(request: ListAvailableBusiRegionsRequest, runtime: Util.RuntimeOptions): ListAvailableBusiRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAvailableBusiRegions', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAvailableBusiRegions(request: ListAvailableBusiRegionsRequest): ListAvailableBusiRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableBusiRegionsWithOptions(request, runtime);
}

model UpdateAcceleratorRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  acceleratorId?: string(name='AcceleratorId'),
  spec?: string(name='Spec'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  promotionOptionNo?: string(name='PromotionOptionNo'),
}

model UpdateAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAcceleratorResponseBody(name='body'),
}

async function updateAcceleratorWithOptions(request: UpdateAcceleratorRequest, runtime: Util.RuntimeOptions): UpdateAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAccelerator(request: UpdateAcceleratorRequest): UpdateAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAcceleratorWithOptions(request, runtime);
}

model DeleteIpSetRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  ipSetId?: string(name='IpSetId'),
}

model DeleteIpSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpSetResponseBody(name='body'),
}

async function deleteIpSetWithOptions(request: DeleteIpSetRequest, runtime: Util.RuntimeOptions): DeleteIpSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpSet', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpSet(request: DeleteIpSetRequest): DeleteIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpSetWithOptions(request, runtime);
}

model DeleteIpSetsRequest {
  regionId?: string(name='RegionId'),
  ipSetIds?: [ string ](name='IpSetIds'),
}

model DeleteIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIpSetsResponseBody(name='body'),
}

async function deleteIpSetsWithOptions(request: DeleteIpSetsRequest, runtime: Util.RuntimeOptions): DeleteIpSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteIpSets', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteIpSets(request: DeleteIpSetsRequest): DeleteIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIpSetsWithOptions(request, runtime);
}

model DescribeAcceleratorRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model DescribeAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  dnsName?: string(name='DnsName'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  instanceChargeType?: string(name='InstanceChargeType'),
  createTime?: long(name='CreateTime'),
  crossDomainBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth'),
    instanceId?: string(name='InstanceId'),
  }(name='CrossDomainBandwidthPackage'),
  secondDnsName?: string(name='SecondDnsName'),
  name?: string(name='Name'),
  basicBandwidthPackage?: {
    bandwidth?: int32(name='Bandwidth'),
    bandwidthType?: string(name='BandwidthType'),
    instanceId?: string(name='InstanceId'),
  }(name='BasicBandwidthPackage'),
  state?: string(name='State'),
  expiredTime?: long(name='ExpiredTime'),
  cenId?: string(name='CenId'),
  regionId?: string(name='RegionId'),
  spec?: string(name='Spec'),
  acceleratorId?: string(name='AcceleratorId'),
}

model DescribeAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAcceleratorResponseBody(name='body'),
}

async function describeAcceleratorWithOptions(request: DescribeAcceleratorRequest, runtime: Util.RuntimeOptions): DescribeAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAccelerator(request: DescribeAcceleratorRequest): DescribeAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAcceleratorWithOptions(request, runtime);
}

model BandwidthPackageAddAcceleratorRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model BandwidthPackageAddAcceleratorResponseBody = {
  requestId?: string(name='RequestId'),
  accelerators?: [ string ](name='Accelerators'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
}

model BandwidthPackageAddAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: BandwidthPackageAddAcceleratorResponseBody(name='body'),
}

async function bandwidthPackageAddAcceleratorWithOptions(request: BandwidthPackageAddAcceleratorRequest, runtime: Util.RuntimeOptions): BandwidthPackageAddAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BandwidthPackageAddAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function bandwidthPackageAddAccelerator(request: BandwidthPackageAddAcceleratorRequest): BandwidthPackageAddAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return bandwidthPackageAddAcceleratorWithOptions(request, runtime);
}

model CreateIpSetsRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  accelerateRegion?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      ipVersion?: string(name='IpVersion'),
      bandwidth?: int32(name='Bandwidth'),
    }
  ](name='AccelerateRegion'),
}

model CreateIpSetsResponseBody = {
  requestId?: string(name='RequestId'),
  ipSets?: [ 
    {
      accelerateRegionId?: string(name='AccelerateRegionId'),
      bandwidth?: int32(name='Bandwidth'),
      ipSetId?: string(name='IpSetId'),
      ipList?: [ string ](name='IpList'),
    }
  ](name='IpSets'),
  acceleratorId?: string(name='AcceleratorId'),
}

model CreateIpSetsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIpSetsResponseBody(name='body'),
}

async function createIpSetsWithOptions(request: CreateIpSetsRequest, runtime: Util.RuntimeOptions): CreateIpSetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIpSets', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIpSets(request: CreateIpSetsRequest): CreateIpSetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIpSetsWithOptions(request, runtime);
}

model CreateForwardingRulesRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  forwardingRules?: [ 
    {
      priority?: int32(name='Priority'),
      ruleConditions?: [ 
        {
          ruleConditionType?: string(name='RuleConditionType'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
        }
      ](name='RuleConditions'),
      ruleActions?: [ 
        {
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
        }
      ](name='RuleActions'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
    }
  ](name='ForwardingRules'),
}

model CreateForwardingRulesResponseBody = {
  requestId?: string(name='RequestId'),
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
}

model CreateForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateForwardingRulesResponseBody(name='body'),
}

async function createForwardingRulesWithOptions(request: CreateForwardingRulesRequest, runtime: Util.RuntimeOptions): CreateForwardingRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateForwardingRules', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createForwardingRules(request: CreateForwardingRulesRequest): CreateForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createForwardingRulesWithOptions(request, runtime);
}

model ListAvailableAccelerateAreasRequest {
  regionId?: string(name='RegionId'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListAvailableAccelerateAreasResponseBody = {
  requestId?: string(name='RequestId'),
  areas?: [ 
    {
      localName?: string(name='LocalName'),
      areaId?: string(name='AreaId'),
      regionList?: [ 
        {
          localName?: string(name='LocalName'),
          regionId?: string(name='RegionId'),
        }
      ](name='RegionList'),
    }
  ](name='Areas'),
}

model ListAvailableAccelerateAreasResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableAccelerateAreasResponseBody(name='body'),
}

async function listAvailableAccelerateAreasWithOptions(request: ListAvailableAccelerateAreasRequest, runtime: Util.RuntimeOptions): ListAvailableAccelerateAreasResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAvailableAccelerateAreas', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAvailableAccelerateAreas(request: ListAvailableAccelerateAreasRequest): ListAvailableAccelerateAreasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableAccelerateAreasWithOptions(request, runtime);
}

model ListAcceleratorsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListAcceleratorsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  accelerators?: [ 
    {
      dnsName?: string(name='DnsName'),
      type?: string(name='Type'),
      secondDnsName?: string(name='SecondDnsName'),
      spec?: string(name='Spec'),
      state?: string(name='State'),
      createTime?: long(name='CreateTime'),
      cenId?: string(name='CenId'),
      ddosId?: string(name='DdosId'),
      basicBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth'),
        bandwidthType?: string(name='BandwidthType'),
        instanceId?: string(name='InstanceId'),
      }(name='BasicBandwidthPackage'),
      regionId?: string(name='RegionId'),
      instanceChargeType?: string(name='InstanceChargeType'),
      acceleratorId?: string(name='AcceleratorId'),
      description?: string(name='Description'),
      bandwidth?: int32(name='Bandwidth'),
      expiredTime?: long(name='ExpiredTime'),
      name?: string(name='Name'),
      crossDomainBandwidthPackage?: {
        bandwidth?: int32(name='Bandwidth'),
        instanceId?: string(name='InstanceId'),
      }(name='CrossDomainBandwidthPackage'),
    }
  ](name='Accelerators'),
  pageNumber?: int32(name='PageNumber'),
}

model ListAcceleratorsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAcceleratorsResponseBody(name='body'),
}

async function listAcceleratorsWithOptions(request: ListAcceleratorsRequest, runtime: Util.RuntimeOptions): ListAcceleratorsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAccelerators', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAccelerators(request: ListAcceleratorsRequest): ListAcceleratorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAcceleratorsWithOptions(request, runtime);
}

model CreateListenerRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  clientAffinity?: string(name='ClientAffinity'),
  protocol?: string(name='Protocol'),
  proxyProtocol?: boolean(name='ProxyProtocol'),
  portRanges?: [ 
    {
      fromPort?: int32(name='FromPort'),
      toPort?: int32(name='ToPort'),
    }
  ](name='PortRanges'),
  certificates?: [ 
    {
      id?: string(name='Id'),
    }
  ](name='Certificates'),
  backendPorts?: [ 
    {
    }
  ](name='BackendPorts', description='转发端口迁移至终端节点组portoverride'),
}

model CreateListenerResponseBody = {
  requestId?: string(name='RequestId'),
  listenerId?: string(name='ListenerId'),
}

model CreateListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateListenerResponseBody(name='body'),
}

async function createListenerWithOptions(request: CreateListenerRequest, runtime: Util.RuntimeOptions): CreateListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createListenerWithOptions(request, runtime);
}

model ListEndpointGroupsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  endpointGroupType?: string(name='EndpointGroupType'),
}

model ListEndpointGroupsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  endpointGroups?: [ 
    {
      endpointGroupId?: string(name='EndpointGroupId'),
      endpointGroupIpList?: [ string ](name='EndpointGroupIpList'),
      state?: string(name='State'),
      healthCheckPath?: string(name='HealthCheckPath'),
      endpointGroupRegion?: string(name='EndpointGroupRegion'),
      healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
      trafficPercentage?: int32(name='TrafficPercentage'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      thresholdCount?: int32(name='ThresholdCount'),
      listenerId?: string(name='ListenerId'),
      endpointConfigurations?: [ 
        {
          type?: string(name='Type'),
          enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
          weight?: int32(name='Weight'),
          probeProtocol?: string(name='ProbeProtocol'),
          endpoint?: string(name='Endpoint'),
          probePort?: int32(name='ProbePort'),
        }
      ](name='EndpointConfigurations'),
      portOverrides?: [ 
        {
          listenerPort?: int32(name='ListenerPort'),
          endpointPort?: int32(name='EndpointPort'),
        }
      ](name='PortOverrides'),
      forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
      endpointGroupType?: string(name='EndpointGroupType'),
      endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
      description?: string(name='Description'),
      name?: string(name='Name'),
      healthCheckPort?: int32(name='HealthCheckPort'),
    }
  ](name='EndpointGroups'),
}

model ListEndpointGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListEndpointGroupsResponseBody(name='body'),
}

async function listEndpointGroupsWithOptions(request: ListEndpointGroupsRequest, runtime: Util.RuntimeOptions): ListEndpointGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListEndpointGroups', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listEndpointGroups(request: ListEndpointGroupsRequest): ListEndpointGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEndpointGroupsWithOptions(request, runtime);
}

model ListBusiRegionsRequest {
  regionId?: string(name='RegionId'),
}

model ListBusiRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
}

model ListBusiRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBusiRegionsResponseBody(name='body'),
}

async function listBusiRegionsWithOptions(request: ListBusiRegionsRequest, runtime: Util.RuntimeOptions): ListBusiRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListBusiRegions', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listBusiRegions(request: ListBusiRegionsRequest): ListBusiRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBusiRegionsWithOptions(request, runtime);
}

model ReplaceBandwidthPackageRequest {
  regionId?: string(name='RegionId'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  targetBandwidthPackageId?: string(name='TargetBandwidthPackageId'),
}

model ReplaceBandwidthPackageResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReplaceBandwidthPackageResponse = {
  headers: map[string]string(name='headers'),
  body: ReplaceBandwidthPackageResponseBody(name='body'),
}

async function replaceBandwidthPackageWithOptions(request: ReplaceBandwidthPackageRequest, runtime: Util.RuntimeOptions): ReplaceBandwidthPackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReplaceBandwidthPackage', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function replaceBandwidthPackage(request: ReplaceBandwidthPackageRequest): ReplaceBandwidthPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceBandwidthPackageWithOptions(request, runtime);
}

model UpdateEndpointGroupAttributeRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  endpointGroupId?: string(name='EndpointGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model UpdateEndpointGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEndpointGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateEndpointGroupAttributeResponseBody(name='body'),
}

async function updateEndpointGroupAttributeWithOptions(request: UpdateEndpointGroupAttributeRequest, runtime: Util.RuntimeOptions): UpdateEndpointGroupAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateEndpointGroupAttribute', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateEndpointGroupAttribute(request: UpdateEndpointGroupAttributeRequest): UpdateEndpointGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEndpointGroupAttributeWithOptions(request, runtime);
}

model UpdateForwardingRulesRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
  forwardingRules?: [ 
    {
      priority?: int32(name='Priority'),
      ruleConditions?: [ 
        {
          ruleConditionType?: string(name='RuleConditionType'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
        }
      ](name='RuleConditions'),
      ruleActions?: [ 
        {
          order?: int32(name='Order'),
          ruleActionType?: string(name='RuleActionType'),
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                endpointGroupId?: string(name='EndpointGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
        }
      ](name='RuleActions'),
      forwardingRuleId?: string(name='ForwardingRuleId'),
      forwardingRuleName?: string(name='ForwardingRuleName'),
    }
  ](name='ForwardingRules'),
}

model UpdateForwardingRulesResponseBody = {
  forwardingRules?: [ 
    {
      forwardingRuleId?: string(name='ForwardingRuleId'),
    }
  ](name='ForwardingRules'),
  requestId?: string(name='RequestId'),
}

model UpdateForwardingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateForwardingRulesResponseBody(name='body'),
}

async function updateForwardingRulesWithOptions(request: UpdateForwardingRulesRequest, runtime: Util.RuntimeOptions): UpdateForwardingRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateForwardingRules', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateForwardingRules(request: UpdateForwardingRulesRequest): UpdateForwardingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateForwardingRulesWithOptions(request, runtime);
}

model ListListenersRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  acceleratorId?: string(name='AcceleratorId'),
}

model ListListenersResponseBody = {
  totalCount?: int32(name='TotalCount'),
  listeners?: [ 
    {
      certificates?: [ 
        {
          type?: string(name='Type'),
          id?: string(name='Id'),
        }
      ](name='Certificates'),
      backendPorts?: [ 
        {
          fromPort?: string(name='FromPort'),
          toPort?: string(name='ToPort'),
        }
      ](name='BackendPorts'),
      listenerId?: string(name='ListenerId'),
      description?: string(name='Description'),
      state?: string(name='State'),
      clientAffinity?: string(name='ClientAffinity'),
      protocol?: string(name='Protocol'),
      createTime?: long(name='CreateTime'),
      portRanges?: [ 
        {
          fromPort?: int32(name='FromPort'),
          toPort?: int32(name='ToPort'),
        }
      ](name='PortRanges'),
      name?: string(name='Name'),
      proxyProtocol?: boolean(name='ProxyProtocol'),
    }
  ](name='Listeners'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListListenersResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersResponseBody(name='body'),
}

async function listListenersWithOptions(request: ListListenersRequest, runtime: Util.RuntimeOptions): ListListenersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListListeners', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listListeners(request: ListListenersRequest): ListListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersWithOptions(request, runtime);
}

model DescribeEndpointGroupRequest {
  regionId?: string(name='RegionId'),
  endpointGroupId?: string(name='EndpointGroupId'),
}

model DescribeEndpointGroupResponseBody = {
  healthCheckIntervalSeconds?: int32(name='HealthCheckIntervalSeconds'),
  trafficPercentage?: int32(name='TrafficPercentage'),
  endpointGroupId?: string(name='EndpointGroupId'),
  description?: string(name='Description'),
  requestId?: string(name='RequestId'),
  healthCheckPath?: string(name='HealthCheckPath'),
  thresholdCount?: int32(name='ThresholdCount'),
  name?: string(name='Name'),
  endpointGroupRegion?: string(name='EndpointGroupRegion'),
  totalCount?: int32(name='TotalCount'),
  state?: string(name='State'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  healthCheckPort?: int32(name='HealthCheckPort'),
  endpointConfigurations?: [ 
    {
      type?: string(name='Type'),
      enableClientIPPreservation?: boolean(name='EnableClientIPPreservation'),
      weight?: int32(name='Weight'),
      probeProtocol?: string(name='ProbeProtocol'),
      endpoint?: string(name='Endpoint'),
      probePort?: int32(name='ProbePort'),
    }
  ](name='EndpointConfigurations'),
  portOverrides?: [ 
    {
      listenerPort?: int32(name='ListenerPort'),
      endpointPort?: int32(name='EndpointPort'),
    }
  ](name='PortOverrides'),
  endpointRequestProtocol?: string(name='EndpointRequestProtocol'),
  endpointGroupType?: string(name='EndpointGroupType'),
  forwardingRuleIds?: [ string ](name='ForwardingRuleIds'),
  listenerId?: string(name='ListenerId'),
}

model DescribeEndpointGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEndpointGroupResponseBody(name='body'),
}

async function describeEndpointGroupWithOptions(request: DescribeEndpointGroupRequest, runtime: Util.RuntimeOptions): DescribeEndpointGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEndpointGroup', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEndpointGroup(request: DescribeEndpointGroupRequest): DescribeEndpointGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEndpointGroupWithOptions(request, runtime);
}

model DetachDdosFromAcceleratorRequest {
  acceleratorId?: string(name='AcceleratorId'),
  regionId?: string(name='RegionId'),
}

model DetachDdosFromAcceleratorResponseBody = {
  ddosId?: string(name='DdosId'),
  requestId?: string(name='RequestId'),
}

model DetachDdosFromAcceleratorResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDdosFromAcceleratorResponseBody(name='body'),
}

async function detachDdosFromAcceleratorWithOptions(request: DetachDdosFromAcceleratorRequest, runtime: Util.RuntimeOptions): DetachDdosFromAcceleratorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetachDdosFromAccelerator', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detachDdosFromAccelerator(request: DetachDdosFromAcceleratorRequest): DetachDdosFromAcceleratorResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDdosFromAcceleratorWithOptions(request, runtime);
}

model DeleteListenerRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  acceleratorId?: string(name='AcceleratorId'),
  listenerId?: string(name='ListenerId'),
}

model DeleteListenerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteListenerResponseBody(name='body'),
}

async function deleteListenerWithOptions(request: DeleteListenerRequest, runtime: Util.RuntimeOptions): DeleteListenerResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteListener', '2019-11-20', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteListenerWithOptions(request, runtime);
}

