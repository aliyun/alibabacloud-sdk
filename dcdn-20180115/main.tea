/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'dcdn.aliyuncs.com',
    ap-northeast-2-pop = 'dcdn.aliyuncs.com',
    ap-south-1 = 'dcdn.aliyuncs.com',
    ap-southeast-1 = 'dcdn.aliyuncs.com',
    ap-southeast-2 = 'dcdn.aliyuncs.com',
    ap-southeast-3 = 'dcdn.aliyuncs.com',
    ap-southeast-5 = 'dcdn.aliyuncs.com',
    cn-beijing = 'dcdn.aliyuncs.com',
    cn-beijing-finance-1 = 'dcdn.aliyuncs.com',
    cn-beijing-finance-pop = 'dcdn.aliyuncs.com',
    cn-beijing-gov-1 = 'dcdn.aliyuncs.com',
    cn-beijing-nu16-b01 = 'dcdn.aliyuncs.com',
    cn-chengdu = 'dcdn.aliyuncs.com',
    cn-edge-1 = 'dcdn.aliyuncs.com',
    cn-fujian = 'dcdn.aliyuncs.com',
    cn-haidian-cm12-c01 = 'dcdn.aliyuncs.com',
    cn-hangzhou = 'dcdn.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'dcdn.aliyuncs.com',
    cn-hangzhou-finance = 'dcdn.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'dcdn.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'dcdn.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'dcdn.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'dcdn.aliyuncs.com',
    cn-hangzhou-test-306 = 'dcdn.aliyuncs.com',
    cn-hongkong = 'dcdn.aliyuncs.com',
    cn-hongkong-finance-pop = 'dcdn.aliyuncs.com',
    cn-huhehaote = 'dcdn.aliyuncs.com',
    cn-north-2-gov-1 = 'dcdn.aliyuncs.com',
    cn-qingdao = 'dcdn.aliyuncs.com',
    cn-qingdao-nebula = 'dcdn.aliyuncs.com',
    cn-shanghai = 'dcdn.aliyuncs.com',
    cn-shanghai-et15-b01 = 'dcdn.aliyuncs.com',
    cn-shanghai-et2-b01 = 'dcdn.aliyuncs.com',
    cn-shanghai-finance-1 = 'dcdn.aliyuncs.com',
    cn-shanghai-inner = 'dcdn.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'dcdn.aliyuncs.com',
    cn-shenzhen = 'dcdn.aliyuncs.com',
    cn-shenzhen-finance-1 = 'dcdn.aliyuncs.com',
    cn-shenzhen-inner = 'dcdn.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'dcdn.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'dcdn.aliyuncs.com',
    cn-wuhan = 'dcdn.aliyuncs.com',
    cn-yushanfang = 'dcdn.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'dcdn.aliyuncs.com',
    cn-zhangjiakou = 'dcdn.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'dcdn.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'dcdn.aliyuncs.com',
    eu-central-1 = 'dcdn.aliyuncs.com',
    eu-west-1 = 'dcdn.aliyuncs.com',
    eu-west-1-oxs = 'dcdn.aliyuncs.com',
    me-east-1 = 'dcdn.aliyuncs.com',
    rus-west-1-pop = 'dcdn.aliyuncs.com',
    us-east-1 = 'dcdn.aliyuncs.com',
    us-west-1 = 'dcdn.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('dcdn', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddDcdnDomainRequest {
  checkUrl?: string(name='CheckUrl', description='The URL that is used to check the accessibility of the origin server.', example='example.com'),
  domainName?: string(name='DomainName', description='The domain name that you want to add. You can specify only one domain name in each request.

Wildcard domain names are supported. A wildcard domain name must start with a period (.), such as .example.com.', example='example.com'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. If you do not specify a value for this parameter, the system automatically assigns the ID of the default resource group.', example='rg-acfmyuji4b6r4**'),
  scope?: string(name='Scope', description='The acceleration region. Valid values:

*   **domestic**: Chinese mainland
*   **overseas**: global (excluding the Chinese mainland)
*   **global**: global

Default value: **domestic**.', example='domestic'),
  securityToken?: string(name='SecurityToken'),
  sources?: string(name='Sources', description='The information about the addresses of origin servers.', example='[{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80}]'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of a tag. Valid values of N: **1 to 20**.', example='env'),
      value?: string(name='Value', description='The value of a tag. Valid values of N: **1 to 20**.', example='value'),
    }
  ](name='Tag', description='The information about the tags.'),
  topLevelDomain?: string(name='TopLevelDomain', description='The top-level domain.', example='yourTopLevelDomain'),
}

model AddDcdnDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
}

model AddDcdnDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDcdnDomainResponseBody(name='body'),
}

/**
  * > 
  * *   The Dynamic Route for CDN (DCDN) service is activated.
  * *   Internet content provider (ICP) filing is complete for the accelerated domain name.
  * *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
  * *   You can call this operation up to 30 times per second per account.
  *
  * @param request AddDcdnDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddDcdnDomainResponse
 */
async function addDcdnDomainWithOptions(request: AddDcdnDomainRequest, runtime: Util.RuntimeOptions): AddDcdnDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkUrl)) {
    query['CheckUrl'] = request.checkUrl;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scope)) {
    query['Scope'] = request.scope;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sources)) {
    query['Sources'] = request.sources;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.topLevelDomain)) {
    query['TopLevelDomain'] = request.topLevelDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDcdnDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   The Dynamic Route for CDN (DCDN) service is activated.
  * *   Internet content provider (ICP) filing is complete for the accelerated domain name.
  * *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
  * *   You can call this operation up to 30 times per second per account.
  *
  * @param request AddDcdnDomainRequest
  * @return AddDcdnDomainResponse
 */
async function addDcdnDomain(request: AddDcdnDomainRequest): AddDcdnDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDcdnDomainWithOptions(request, runtime);
}

model AddDcdnIpaDomainRequest {
  checkUrl?: string(name='CheckUrl', description='The URL that is used to check the accessibility of the origin server.', example='example.com/image_01.png'),
  domainName?: string(name='DomainName', description='The domain name to be added to IPA.

A wildcard domain that starts with a period (.) is supported, such as .example.com.', example='example.com'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  protocol?: string(name='Protocol', description='The protocol. Valid values:

*   **udp**
*   **tcp**

>  Example: `{"protocol":"udp"}`.', example='udp'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. If you do not specify a value for this parameter, the system automatically assigns the ID of the default resource group.', example='rg'),
  scope?: string(name='Scope', description='The acceleration region. Valid values:

*   **domestic**: Chinese mainland
*   **overseas**: global (excluding the Chinese mainland)
*   **global**: global', example='domestic'),
  securityToken?: string(name='SecurityToken'),
  sources?: string(name='Sources', description='The information about the addresses of origin servers.', example='[{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80,"weight":"15"}]'),
  topLevelDomain?: string(name='TopLevelDomain', description='The top-level domain name.', example='*.com'),
}

model AddDcdnIpaDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model AddDcdnIpaDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDcdnIpaDomainResponseBody(name='body'),
}

/**
  * > 
  * *   Make sure that the IPA service is activated before you add a domain name to accelerate.
  * *   Make sure that the Internet content provider (ICP) filling is complete for the domain name to accelerate.
  * *   If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed. The review is complete by the end of the next business day after you submit the request.
  * *   You can call this operation up to 10 times per second per account.
  *
  * @param request AddDcdnIpaDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddDcdnIpaDomainResponse
 */
async function addDcdnIpaDomainWithOptions(request: AddDcdnIpaDomainRequest, runtime: Util.RuntimeOptions): AddDcdnIpaDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkUrl)) {
    query['CheckUrl'] = request.checkUrl;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scope)) {
    query['Scope'] = request.scope;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sources)) {
    query['Sources'] = request.sources;
  }
  if (!Util.isUnset(request.topLevelDomain)) {
    query['TopLevelDomain'] = request.topLevelDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddDcdnIpaDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   Make sure that the IPA service is activated before you add a domain name to accelerate.
  * *   Make sure that the Internet content provider (ICP) filling is complete for the domain name to accelerate.
  * *   If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed. The review is complete by the end of the next business day after you submit the request.
  * *   You can call this operation up to 10 times per second per account.
  *
  * @param request AddDcdnIpaDomainRequest
  * @return AddDcdnIpaDomainResponse
 */
async function addDcdnIpaDomain(request: AddDcdnIpaDomainRequest): AddDcdnIpaDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDcdnIpaDomainWithOptions(request, runtime);
}

model BatchAddDcdnDomainRequest {
  checkUrl?: string(name='CheckUrl', description='The URL that is used to check whether the origin server can be accessed.', example='www.example.com/test.html'),
  domainName?: string(name='DomainName', description='You can add up to 50 domain names to DCDN for each of your Alibaba Cloud account. Separate multiple domain names with commas (,).', example='example.com,example.org'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. If you do not specify a value for this parameter, the system automatically assigns the ID of the default resource group.', example='testID'),
  scope?: string(name='Scope', description='The accelerated region. Default value: domestic. Valid values:

*   domestic: Chinese mainland
*   overseas: global (excluding the Chinese mainland)
*   global: global', example='domestic'),
  securityToken?: string(name='SecurityToken'),
  sources?: string(name='Sources', description='The information about the addresses of origin servers.', example='[{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80,"weight":"15"}]'),
  topLevelDomain?: string(name='TopLevelDomain', description='The top-level domain name.', example='example.com'),
}

model BatchAddDcdnDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
}

model BatchAddDcdnDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchAddDcdnDomainResponseBody(name='body'),
}

/**
  * **Prerequisites**:
  * *   The [DCDN service is activated](~~64926~~).
  * *   Internet Content Provider (ICP) filing is complete for the accelerated domain names.
  * > 
  * *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
  * *   The maximum number of domain names configured at a time is 50.
  * *   The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request BatchAddDcdnDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchAddDcdnDomainResponse
 */
async function batchAddDcdnDomainWithOptions(request: BatchAddDcdnDomainRequest, runtime: Util.RuntimeOptions): BatchAddDcdnDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkUrl)) {
    query['CheckUrl'] = request.checkUrl;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scope)) {
    query['Scope'] = request.scope;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sources)) {
    query['Sources'] = request.sources;
  }
  if (!Util.isUnset(request.topLevelDomain)) {
    query['TopLevelDomain'] = request.topLevelDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchAddDcdnDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **Prerequisites**:
  * *   The [DCDN service is activated](~~64926~~).
  * *   Internet Content Provider (ICP) filing is complete for the accelerated domain names.
  * > 
  * *   If the content of the origin server is not stored on Alibaba Cloud, the content must be reviewed. After you submit the request, the review is complete by the end of the following business day.
  * *   The maximum number of domain names configured at a time is 50.
  * *   The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request BatchAddDcdnDomainRequest
  * @return BatchAddDcdnDomainResponse
 */
async function batchAddDcdnDomain(request: BatchAddDcdnDomainRequest): BatchAddDcdnDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchAddDcdnDomainWithOptions(request, runtime);
}

model BatchCreateDcdnWafRulesRequest {
  policyId?: long(name='PolicyId', description='The ID of the protection policy.', example='1000001'),
  ruleConfigs?: string(name='RuleConfigs', description='The configurations of the protection rule.', example='{"name":"ttttt","action":"monitor","conditions":[{"key":"URL","opValue":"match-one","values":"1,2,3,4,5"},{"key":"Header","opValue":"contain-one","subKey":"testheader","values":"6,7,8,9,10"}],"ratelimit":{"target":"header","interval":10,"threshold":5,"ttl":1800,"subKey":"testheadercc","status":{"code":"502","count":5}},"ccStatus":"on","effect":"rule","status":"on"}'),
}

model BatchCreateDcdnWafRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-280B-72F8FD6DA2FE'),
  ruleIds?: {
    ruleId?: [ string ](name='RuleId')
  }(name='RuleIds', description='The IDs of created rules.'),
}

model BatchCreateDcdnWafRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchCreateDcdnWafRulesResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 20 times per second per account.
  *
  * @param request BatchCreateDcdnWafRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchCreateDcdnWafRulesResponse
 */
async function batchCreateDcdnWafRulesWithOptions(request: BatchCreateDcdnWafRulesRequest, runtime: Util.RuntimeOptions): BatchCreateDcdnWafRulesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.ruleConfigs)) {
    body['RuleConfigs'] = request.ruleConfigs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateDcdnWafRules',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 20 times per second per account.
  *
  * @param request BatchCreateDcdnWafRulesRequest
  * @return BatchCreateDcdnWafRulesResponse
 */
async function batchCreateDcdnWafRules(request: BatchCreateDcdnWafRulesRequest): BatchCreateDcdnWafRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCreateDcdnWafRulesWithOptions(request, runtime);
}

model BatchDeleteDcdnDomainConfigsRequest {
  domainNames?: string(name='DomainNames', description='The accelerated domain names whose configurations you want to delete. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  functionNames?: string(name='FunctionNames', description='The names of the features that you want to delete. Separate multiple feature names with commas (,). For more information about feature names, see [Feature settings for a domain name](~~410622~~).', example='referer_white_list_set,https_force'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model BatchDeleteDcdnDomainConfigsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model BatchDeleteDcdnDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteDcdnDomainConfigsResponseBody(name='body'),
}

/**
  * > 
  * *   You can specify up to 50 domain names in each request.
  * *   You can call this operation up to 30 times per second per account.
  *
  * @param request BatchDeleteDcdnDomainConfigsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchDeleteDcdnDomainConfigsResponse
 */
async function batchDeleteDcdnDomainConfigsWithOptions(request: BatchDeleteDcdnDomainConfigsRequest, runtime: Util.RuntimeOptions): BatchDeleteDcdnDomainConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.functionNames)) {
    query['FunctionNames'] = request.functionNames;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteDcdnDomainConfigs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can specify up to 50 domain names in each request.
  * *   You can call this operation up to 30 times per second per account.
  *
  * @param request BatchDeleteDcdnDomainConfigsRequest
  * @return BatchDeleteDcdnDomainConfigsResponse
 */
async function batchDeleteDcdnDomainConfigs(request: BatchDeleteDcdnDomainConfigsRequest): BatchDeleteDcdnDomainConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteDcdnDomainConfigsWithOptions(request, runtime);
}

model BatchDeleteDcdnWafRulesRequest {
  ruleIds?: string(name='RuleIds', description='The IDs of the protection rules that you want to delete. Separate multiple IDs with commas (,).', example='20000001,20000002'),
}

model BatchDeleteDcdnWafRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-802B-72F8FD6DA2FE'),
}

model BatchDeleteDcdnWafRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteDcdnWafRulesResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request BatchDeleteDcdnWafRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchDeleteDcdnWafRulesResponse
 */
async function batchDeleteDcdnWafRulesWithOptions(request: BatchDeleteDcdnWafRulesRequest, runtime: Util.RuntimeOptions): BatchDeleteDcdnWafRulesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ruleIds)) {
    body['RuleIds'] = request.ruleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteDcdnWafRules',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request BatchDeleteDcdnWafRulesRequest
  * @return BatchDeleteDcdnWafRulesResponse
 */
async function batchDeleteDcdnWafRules(request: BatchDeleteDcdnWafRulesRequest): BatchDeleteDcdnWafRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteDcdnWafRulesWithOptions(request, runtime);
}

model BatchModifyDcdnWafRulesRequest {
  policyId?: long(name='PolicyId', description='The ID of the protection policy.', example='10000001'),
  ruleConfigs?: string(name='RuleConfigs', description='The configurations of the protection rule.', example='[{"id":135,"type":"web_sdk","status":"on","config":{"mode":"automatic","crossDomain":"example.com"},"action":""},{"id":149,"type":"intelligence_fake_crawler","status":"on","config":{},"action":"deny"}]'),
}

model BatchModifyDcdnWafRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-XXXX-72F8FD6DA2FE'),
}

model BatchModifyDcdnWafRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchModifyDcdnWafRulesResponseBody(name='body'),
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request BatchModifyDcdnWafRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchModifyDcdnWafRulesResponse
 */
async function batchModifyDcdnWafRulesWithOptions(request: BatchModifyDcdnWafRulesRequest, runtime: Util.RuntimeOptions): BatchModifyDcdnWafRulesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.ruleConfigs)) {
    body['RuleConfigs'] = request.ruleConfigs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchModifyDcdnWafRules',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request BatchModifyDcdnWafRulesRequest
  * @return BatchModifyDcdnWafRulesResponse
 */
async function batchModifyDcdnWafRules(request: BatchModifyDcdnWafRulesRequest): BatchModifyDcdnWafRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchModifyDcdnWafRulesWithOptions(request, runtime);
}

model BatchSetDcdnDomainCertificateRequest {
  certName?: string(name='CertName', description='The name of the certificate.', example='cert-te**.com'),
  certType?: string(name='CertType', description='The type of the certificate. Valid values:

*   **upload**: a custom certificate that you upload.
*   **cas**: a certificate that is purchased from Alibaba Cloud SSL Certificates Service', example='cas'),
  domainName?: string(name='DomainName', description='The name of the accelerated domain for which you want to configure the HTTPS certificate. The accelerated domain must have HTTPS acceleration enabled. You can specify multiple domain names and separate them with commas (,).

>  You can configure up to 10 domain names at a time.', example='**example**.com'),
  ownerId?: long(name='OwnerId'),
  region?: string(name='Region', description='The ID of the region.', example='cn-hangzhou'),
  SSLPri?: string(name='SSLPri', description='The private key. This parameter is required only if you enable the certificate.', example='y****'),
  SSLProtocol?: string(name='SSLProtocol', description='Specifies whether to enable the HTTPS certificate. Valid values:

*   **on:**
*   **off**

The default value is **off**.', example='on'),
  SSLPub?: string(name='SSLPub', description='The content of the certificate. This parameter is required only if you enable the certificate.', example='x****'),
  securityToken?: string(name='SecurityToken'),
}

model BatchSetDcdnDomainCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model BatchSetDcdnDomainCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchSetDcdnDomainCertificateResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 10 times per second per account.
  *
  * @param request BatchSetDcdnDomainCertificateRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchSetDcdnDomainCertificateResponse
 */
async function batchSetDcdnDomainCertificateWithOptions(request: BatchSetDcdnDomainCertificateRequest, runtime: Util.RuntimeOptions): BatchSetDcdnDomainCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certName)) {
    query['CertName'] = request.certName;
  }
  if (!Util.isUnset(request.certType)) {
    query['CertType'] = request.certType;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.SSLPri)) {
    query['SSLPri'] = request.SSLPri;
  }
  if (!Util.isUnset(request.SSLProtocol)) {
    query['SSLProtocol'] = request.SSLProtocol;
  }
  if (!Util.isUnset(request.SSLPub)) {
    query['SSLPub'] = request.SSLPub;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchSetDcdnDomainCertificate',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 10 times per second per account.
  *
  * @param request BatchSetDcdnDomainCertificateRequest
  * @return BatchSetDcdnDomainCertificateResponse
 */
async function batchSetDcdnDomainCertificate(request: BatchSetDcdnDomainCertificateRequest): BatchSetDcdnDomainCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSetDcdnDomainCertificateWithOptions(request, runtime);
}

model BatchSetDcdnDomainConfigsRequest {
  domainNames?: string(name='DomainNames', description='The accelerated domain names. Specify multiple accelerated domain names with commas (,).', example='example.com,example.org'),
  functions?: string(name='Functions', description='The features that you want to configure. Format:

> 
*   **functionName**: The name of the feature. Separate multiple values with commas (,). For more information, see [A list of features](~~410622~~).
*   **argName**: The feature parameters for **functionName**.
*   **argValue**: The parameter values set for **functionName**.

        [
         {
           "functionArgs": [
            {
             "argName": "Parameter A", 
             "argValue": "Parameter value"
            }, 
          {
            "argName": "Parameter B", 
            "argValue": "Parameter value"
             }
         ], 
         "functionName": "Feature name"
            }
        ]', example='[{"functionArgs":[{"argName":"switch","argValue":"on"},{"argName":"region","argValue":"*"}],"functionName":"ipv6"}]'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model BatchSetDcdnDomainConfigsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model BatchSetDcdnDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchSetDcdnDomainConfigsResponseBody(name='body'),
}

/**
  * > 
  * *   You can specify up to 50 domain names in each request. Separate multiple domain names with commas (,)
  * *   You can call this operation up to 30 times per second per account.
  *
  * @param request BatchSetDcdnDomainConfigsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchSetDcdnDomainConfigsResponse
 */
async function batchSetDcdnDomainConfigsWithOptions(request: BatchSetDcdnDomainConfigsRequest, runtime: Util.RuntimeOptions): BatchSetDcdnDomainConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.functions)) {
    query['Functions'] = request.functions;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchSetDcdnDomainConfigs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can specify up to 50 domain names in each request. Separate multiple domain names with commas (,)
  * *   You can call this operation up to 30 times per second per account.
  *
  * @param request BatchSetDcdnDomainConfigsRequest
  * @return BatchSetDcdnDomainConfigsResponse
 */
async function batchSetDcdnDomainConfigs(request: BatchSetDcdnDomainConfigsRequest): BatchSetDcdnDomainConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSetDcdnDomainConfigsWithOptions(request, runtime);
}

model BatchSetDcdnIpaDomainConfigsRequest {
  domainNames?: string(name='DomainNames', description='The domain names accelerated by IPA. Separate multiple domain names with commas (,).', example='example.com'),
  functions?: string(name='Functions', description='The list of features.

    [{"functionArgs":[{"argName":"Parameter name","argValue":"Parameter value"}],"functionName":"Feature name"}]', example='[{"functionArgs":[{"argName":"domain_name","argValue":"api.*com"}],"functionName":"protogw"}]'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model BatchSetDcdnIpaDomainConfigsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model BatchSetDcdnIpaDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchSetDcdnIpaDomainConfigsResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request BatchSetDcdnIpaDomainConfigsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchSetDcdnIpaDomainConfigsResponse
 */
async function batchSetDcdnIpaDomainConfigsWithOptions(request: BatchSetDcdnIpaDomainConfigsRequest, runtime: Util.RuntimeOptions): BatchSetDcdnIpaDomainConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainNames)) {
    query['DomainNames'] = request.domainNames;
  }
  if (!Util.isUnset(request.functions)) {
    query['Functions'] = request.functions;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchSetDcdnIpaDomainConfigs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request BatchSetDcdnIpaDomainConfigsRequest
  * @return BatchSetDcdnIpaDomainConfigsResponse
 */
async function batchSetDcdnIpaDomainConfigs(request: BatchSetDcdnIpaDomainConfigsRequest): BatchSetDcdnIpaDomainConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSetDcdnIpaDomainConfigsWithOptions(request, runtime);
}

model BatchSetDcdnWafDomainConfigsRequest {
  clientIpTag?: string(name='ClientIpTag', description='Specifies the header that records the IP address to be obtained. If the default header is selected, the value of this parameter is empty. If a custom header is selected, the value of this parameter is the value specified by the user. Separate multiple values with commas (,). You can specify a maximum of five values.', example='X-Forwarded-For'),
  defenseStatus?: string(name='DefenseStatus', description='The protection status of the domain name. Valid values: on, off, and empty string.

*   When you add a domain name, the value of this parameter is **on**, and the value of ClientIpTag takes effect.
*   When you delete a domain name, the value of this parameter is **off**, and the value of ClientIpTag does not take effect.
*   When you only modify the value of ClientIpTag, the value of DefenseStatus is an empty string.', example='on'),
  domainNames?: string(name='DomainNames', description='The protected domain names for which you want to change the protection status. You can specify up to 50 domain names. Separate multiple domain names with commas (,).', example='example.com,example2.com'),
}

model BatchSetDcdnWafDomainConfigsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-3C82-72F8FD6DA2FE'),
}

model BatchSetDcdnWafDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchSetDcdnWafDomainConfigsResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request BatchSetDcdnWafDomainConfigsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchSetDcdnWafDomainConfigsResponse
 */
async function batchSetDcdnWafDomainConfigsWithOptions(request: BatchSetDcdnWafDomainConfigsRequest, runtime: Util.RuntimeOptions): BatchSetDcdnWafDomainConfigsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientIpTag)) {
    body['ClientIpTag'] = request.clientIpTag;
  }
  if (!Util.isUnset(request.defenseStatus)) {
    body['DefenseStatus'] = request.defenseStatus;
  }
  if (!Util.isUnset(request.domainNames)) {
    body['DomainNames'] = request.domainNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchSetDcdnWafDomainConfigs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request BatchSetDcdnWafDomainConfigsRequest
  * @return BatchSetDcdnWafDomainConfigsResponse
 */
async function batchSetDcdnWafDomainConfigs(request: BatchSetDcdnWafDomainConfigsRequest): BatchSetDcdnWafDomainConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSetDcdnWafDomainConfigsWithOptions(request, runtime);
}

model CheckDcdnProjectExistRequest {
  projectName?: string(name='ProjectName', description='The name of a real-time log delivery project.', example='example'),
}

model CheckDcdnProjectExistResponseBody = {
  content?: {
    exist?: string(name='Exist', description='Indicates whether the real-time log delivery project exists. Valid values:

*   **false**: The real-time log delivery project does not exist.
*   **true**: The real-time log delivery project exists.', example='false'),
  }(name='Content', description='The returned results.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='b021e538-9dde-46ed-a1f2-9469da8f3e77'),
}

model CheckDcdnProjectExistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckDcdnProjectExistResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request CheckDcdnProjectExistRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CheckDcdnProjectExistResponse
 */
async function checkDcdnProjectExistWithOptions(request: CheckDcdnProjectExistRequest, runtime: Util.RuntimeOptions): CheckDcdnProjectExistResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDcdnProjectExist',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request CheckDcdnProjectExistRequest
  * @return CheckDcdnProjectExistResponse
 */
async function checkDcdnProjectExist(request: CheckDcdnProjectExistRequest): CheckDcdnProjectExistResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDcdnProjectExistWithOptions(request, runtime);
}

model CommitStagingRoutineCodeRequest {
  codeDescription?: string(name='CodeDescription', description='The description of the code version.', example='Hello World'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
}

model CommitStagingRoutineCodeResponseBody = {
  content?: map[string]any(name='Content', description='The version number of the code.', example='1620876959997924701'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5CC228B4-7A67-4016-9C9F-4A4133494A91'),
}

model CommitStagingRoutineCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CommitStagingRoutineCodeResponseBody(name='body'),
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @param request CommitStagingRoutineCodeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CommitStagingRoutineCodeResponse
 */
async function commitStagingRoutineCodeWithOptions(request: CommitStagingRoutineCodeRequest, runtime: Util.RuntimeOptions): CommitStagingRoutineCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.codeDescription)) {
    body['CodeDescription'] = request.codeDescription;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CommitStagingRoutineCode',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @param request CommitStagingRoutineCodeRequest
  * @return CommitStagingRoutineCodeResponse
 */
async function commitStagingRoutineCode(request: CommitStagingRoutineCodeRequest): CommitStagingRoutineCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return commitStagingRoutineCodeWithOptions(request, runtime);
}

model CreateDcdnDeliverTaskRequest {
  deliver?: string(name='Deliver', description='The method that is used to send operations reports. Operations reports are sent to you only by email. The settings must be escaped in JSON.', example='{"email":{"subject":"Subject Name","to":["username@example.com","username@example.org"]}}'),
  domainName?: string(name='DomainName', description='The domain names to be tracked. Separate multiple domain names with commas (,). You can specify up to 500 domain names. If you want to specify more than 500 domain names, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).

>  If you do not specify a domain name, the custom operations reports are created for all domain names that belong to your Alibaba Cloud account.', example='example.com,example.org'),
  name?: string(name='Name', description='The name of the tracking task.', example='Domain Subscription'),
  reports?: string(name='Reports', description='The operations reports that are tracked by the task. The data must be escaped in JSON.', example='[{\\"reportId\\":2,\\"conditions\\":[{\\"field\\":\\"prov\\",\\"op\\":\\"in\\",\\"value\\":[\\ "Heilongjiang\\",\\"Beijing\\"]}]}]'),
  schedule?: string(name='Schedule', description='The parameters of the tracking task. The settings must be escaped in JSON.', example='{"schedName":"subscription task name","description":"description","crontab":"000**?","frequency":"d","status":"enable","effectiveFrom": "2020-09-17T00:00:00Z","effectiveEnd":"2020-11-17T00:00:00Z"}'),
}

model CreateDcdnDeliverTaskResponseBody = {
  deliverId?: string(name='DeliverId', description='The ID of the change tracking task.', example='92'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model CreateDcdnDeliverTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDcdnDeliverTaskResponseBody(name='body'),
}

/**
  * >  You can call this operation up to three times per second per account.
  *
  * @param request CreateDcdnDeliverTaskRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDcdnDeliverTaskResponse
 */
async function createDcdnDeliverTaskWithOptions(request: CreateDcdnDeliverTaskRequest, runtime: Util.RuntimeOptions): CreateDcdnDeliverTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deliver)) {
    body['Deliver'] = request.deliver;
  }
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.reports)) {
    body['Reports'] = request.reports;
  }
  if (!Util.isUnset(request.schedule)) {
    body['Schedule'] = request.schedule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDcdnDeliverTask',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to three times per second per account.
  *
  * @param request CreateDcdnDeliverTaskRequest
  * @return CreateDcdnDeliverTaskResponse
 */
async function createDcdnDeliverTask(request: CreateDcdnDeliverTaskRequest): CreateDcdnDeliverTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDcdnDeliverTaskWithOptions(request, runtime);
}

model CreateDcdnSLSRealTimeLogDeliveryRequest {
  businessType?: string(name='BusinessType', description='The type of the collected logs. Default value: cdn_log_access_l1. Valid values:

*   **cdn_log_access_l1**: access logs of L1 Dynamic Route for CDN (DCDN) points of presence (POPs)
*   **cdn_log_origin**: back-to-origin logs
*   **cdn_log_er**: EdgeRoutine logs', example='cdn_log_access_l1'),
  dataCenter?: string(name='DataCenter', description='The data center. Valid values:

*   cn: China
*   sg: Singapore
*   in: India
*   eu: Europe
*   us: United States', example='cn'),
  domainName?: string(name='DomainName', description='The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).', example='example.com'),
  projectName?: string(name='ProjectName', description='The name of a real-time log delivery project.', example='example'),
  SLSLogStore?: string(name='SLSLogStore', description='The name of the Log Service Logstore.', example='demo'),
  SLSProject?: string(name='SLSProject', description='The name of the Log Service project.', example='aliyundoc'),
  SLSRegion?: string(name='SLSRegion', description='The region to which real-time logs are delivered.', example='cn-hangzhou'),
  samplingRate?: string(name='SamplingRate', description='The sampling rate.', example='1.0'),
}

model CreateDcdnSLSRealTimeLogDeliveryResponseBody = {
  content?: {
    domains?: [ 
    {
      desc?: string(name='Desc', description='The description of the returned result.', example='ok'),
      domainName?: string(name='DomainName', description='The domain name from which real-time logs were collected.', example='example.com'),
      region?: string(name='Region', description='The region to which real-time logs were delivered.', example='cn'),
      status?: string(name='Status', description='The status of real-time logs.', example='success'),
    }
  ](name='Domains')
  }(name='Content', description='The configuration results of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F32C57AA-7BF8-49AE-A2CC-9F42390F5A19'),
}

model CreateDcdnSLSRealTimeLogDeliveryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDcdnSLSRealTimeLogDeliveryResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request CreateDcdnSLSRealTimeLogDeliveryRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDcdnSLSRealTimeLogDeliveryResponse
 */
async function createDcdnSLSRealTimeLogDeliveryWithOptions(request: CreateDcdnSLSRealTimeLogDeliveryRequest, runtime: Util.RuntimeOptions): CreateDcdnSLSRealTimeLogDeliveryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.businessType)) {
    body['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.dataCenter)) {
    body['DataCenter'] = request.dataCenter;
  }
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.SLSLogStore)) {
    body['SLSLogStore'] = request.SLSLogStore;
  }
  if (!Util.isUnset(request.SLSProject)) {
    body['SLSProject'] = request.SLSProject;
  }
  if (!Util.isUnset(request.SLSRegion)) {
    body['SLSRegion'] = request.SLSRegion;
  }
  if (!Util.isUnset(request.samplingRate)) {
    body['SamplingRate'] = request.samplingRate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDcdnSLSRealTimeLogDelivery',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request CreateDcdnSLSRealTimeLogDeliveryRequest
  * @return CreateDcdnSLSRealTimeLogDeliveryResponse
 */
async function createDcdnSLSRealTimeLogDelivery(request: CreateDcdnSLSRealTimeLogDeliveryRequest): CreateDcdnSLSRealTimeLogDeliveryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDcdnSLSRealTimeLogDeliveryWithOptions(request, runtime);
}

model CreateDcdnSubTaskRequest {
  domainName?: string(name='DomainName', description='The domain names for which you want to create a custom operations report. Separate multiple domain names with commas (,). You can specify up to 500 domain names. If you want to specify more than 500 domain names, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.2020520001.aliyun_topbar.18.dbd44bd3e4f845#/ticket/createIndex).

>  If you do not specify a domain name, the custom operations reports are created for all domain names that belong to your Alibaba Cloud account.', example='example.com,example.org'),
  reportIds?: string(name='ReportIds', description='The IDs of the metrics that you want to include in the report. Separate multiple IDs with commas (,). Valid values:

*   **2**: Popular URLs by Request
*   **4**: Popular URLs by Traffic
*   **6**: Popular Referer by Request
*   **8**: Popular Referer by Traffic
*   **10**: Popular Back-to-origin URLs by Request
*   **12**: Popular Back-to-origin URLs by Traffic
*   **14**: Top Client IPs by Request
*   **16**: Top Client IPs by Traffic
*   **18**: Popular Domain Names by Traffic
*   **20**: PV/UV
*   **22**: Visit Distribution by Region
*   **24**: Distribution of ISPs', example='2,4,6'),
}

model CreateDcdnSubTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model CreateDcdnSubTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDcdnSubTaskResponseBody(name='body'),
}

/**
  * > 
  * *   This operation allows you to create a custom operations report for a specific domain name. You can view the statistics about the domain name in the report.
  * *   You can call this operation up to three times per second.
  *
  * @param request CreateDcdnSubTaskRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDcdnSubTaskResponse
 */
async function createDcdnSubTaskWithOptions(request: CreateDcdnSubTaskRequest, runtime: Util.RuntimeOptions): CreateDcdnSubTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.reportIds)) {
    body['ReportIds'] = request.reportIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDcdnSubTask',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   This operation allows you to create a custom operations report for a specific domain name. You can view the statistics about the domain name in the report.
  * *   You can call this operation up to three times per second.
  *
  * @param request CreateDcdnSubTaskRequest
  * @return CreateDcdnSubTaskResponse
 */
async function createDcdnSubTask(request: CreateDcdnSubTaskRequest): CreateDcdnSubTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDcdnSubTaskWithOptions(request, runtime);
}

model CreateDcdnWafPolicyRequest {
  defenseScene?: string(name='DefenseScene', description='The type of the WAF protection policy. Valid values:

*   waf_group: basic web protection
*   custom_acl: custom protection
*   whitelist: IP address whitelist
*   ip_blacklist: IP address blacklist
*   region_block: region blacklist
*   bot: bot management', example='waf_group'),
  policyName?: string(name='PolicyName', description='The name of the protection policy. The name can be up to 64 characters in length and can contain letters, digits, and underscores (\\_).', example='policy_test'),
  policyStatus?: string(name='PolicyStatus', description='The status of the protection policy. Valid values:

*   on: enabled
*   off: disabled', example='on'),
  policyType?: string(name='PolicyType', description='Specifies whether to set the current policy as the default policy. Valid values:

*   default: sets the current policy as the default policy.
*   custom: does not set the current policy as the default policy.', example='default'),
}

model CreateDcdnWafPolicyResponseBody = {
  policyId?: long(name='PolicyId', description='The ID of the protection policy that you created.', example='10000001'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-A198-72F8FD6DA2FE'),
}

model CreateDcdnWafPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDcdnWafPolicyResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request CreateDcdnWafPolicyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDcdnWafPolicyResponse
 */
async function createDcdnWafPolicyWithOptions(request: CreateDcdnWafPolicyRequest, runtime: Util.RuntimeOptions): CreateDcdnWafPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.defenseScene)) {
    body['DefenseScene'] = request.defenseScene;
  }
  if (!Util.isUnset(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyStatus)) {
    body['PolicyStatus'] = request.policyStatus;
  }
  if (!Util.isUnset(request.policyType)) {
    body['PolicyType'] = request.policyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDcdnWafPolicy',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request CreateDcdnWafPolicyRequest
  * @return CreateDcdnWafPolicyResponse
 */
async function createDcdnWafPolicy(request: CreateDcdnWafPolicyRequest): CreateDcdnWafPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDcdnWafPolicyWithOptions(request, runtime);
}

model CreateRoutineRequest {
  description?: string(name='Description', description='The description of the routine.', example='the description of this routine'),
  envConf?: map[string]any(name='EnvConf', description='The configurations of the specified environment.', example='{"staging":{"pecName":"50ms"},"production":{"SpecName":"50ms"}}'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
}

model CreateRoutineShrinkRequest {
  description?: string(name='Description', description='The description of the routine.', example='the description of this routine'),
  envConfShrink?: string(name='EnvConf', description='The configurations of the specified environment.', example='{"staging":{"pecName":"50ms"},"production":{"SpecName":"50ms"}}'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
}

model CreateRoutineResponseBody = {
  content?: map[string]any(name='Content', description='The message returned, such as ""Status": "OK"".', example='"Status": "OK"'),
  requestId?: string(name='RequestId', description='The ID of the region.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model CreateRoutineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRoutineResponseBody(name='body'),
}

/**
  * > 
  * *   The parameters must comply with the rules of EnvConf. The description of a routine cannot exceed 50 characters in length.
  * *   This operation creates a routine that contains only production and staging environments.
  * *   You can call this operation up to 100 times per second.
  *
  * @param tmpReq CreateRoutineRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateRoutineResponse
 */
async function createRoutineWithOptions(tmpReq: CreateRoutineRequest, runtime: Util.RuntimeOptions): CreateRoutineResponse {
  Util.validateModel(tmpReq);
  var request = new CreateRoutineShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.envConf)) {
    request.envConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.envConf, 'EnvConf', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.envConfShrink)) {
    body['EnvConf'] = request.envConfShrink;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRoutine',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   The parameters must comply with the rules of EnvConf. The description of a routine cannot exceed 50 characters in length.
  * *   This operation creates a routine that contains only production and staging environments.
  * *   You can call this operation up to 100 times per second.
  *
  * @param request CreateRoutineRequest
  * @return CreateRoutineResponse
 */
async function createRoutine(request: CreateRoutineRequest): CreateRoutineResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRoutineWithOptions(request, runtime);
}

model CreateSlrAndSlsProjectRequest {
  businessType?: string(name='BusinessType', description='The type of the collected logs. Default value: cdn_log_access_l1. Valid values:

*   **cdn_log_access_l1**: access logs of L1 Dynamic Route for CDN (DCDN) points of presence (POPs)
*   **cdn_log_origin**: back-to-origin logs
*   **cdn_log_er**: EdgeRoutine logs', example='cdn_log_access_l1'),
  region?: string(name='Region', description='The region where Log Service resides. Valid values:

*   **cn-hangzhou**
*   **cn-shanghai**
*   **cn-qingdao**
*   **cn-beijing**
*   **cn-zhangjiakou**
*   **cn-shenzhen**
*   **eu-central-1**
*   **us-west-1**
*   **ap-south-1**
*   **ap-southeast-1**', example='cn-shanghai'),
}

model CreateSlrAndSlsProjectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='fe33a379-5053-4f22-a73c-826e2b44355d'),
  slsInfo?: {
    endPoint?: string(name='EndPoint', description='The endpoint of Log Service.', example='cn-shanghai.log.*.com'),
    logStore?: string(name='LogStore', description='The Logstore of Log Service.', example='dcdn-edge-trlog'),
    project?: string(name='Project', description='The project of Log Service.', example='dcdn-edge-rtlog-cn-cfc7****'),
    region?: string(name='Region', description='The region where Log Service resides.', example='cn-shanghai'),
  }(name='SlsInfo', description='The information about Log Service.'),
}

model CreateSlrAndSlsProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSlrAndSlsProjectResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request CreateSlrAndSlsProjectRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateSlrAndSlsProjectResponse
 */
async function createSlrAndSlsProjectWithOptions(request: CreateSlrAndSlsProjectRequest, runtime: Util.RuntimeOptions): CreateSlrAndSlsProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.businessType)) {
    body['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.region)) {
    body['Region'] = request.region;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSlrAndSlsProject',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request CreateSlrAndSlsProjectRequest
  * @return CreateSlrAndSlsProjectResponse
 */
async function createSlrAndSlsProject(request: CreateSlrAndSlsProjectRequest): CreateSlrAndSlsProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSlrAndSlsProjectWithOptions(request, runtime);
}

model DeleteDcdnDeliverTaskRequest {
  deliverId?: long(name='DeliverId', description='The IDs of the tracking tasks that you want to delete. You can call the [DescribeCdnDeliverList](~~270043~~) operation to query task IDs.', example='92'),
}

model DeleteDcdnDeliverTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteDcdnDeliverTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnDeliverTaskResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 3.
  *
  * @param request DeleteDcdnDeliverTaskRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnDeliverTaskResponse
 */
async function deleteDcdnDeliverTaskWithOptions(request: DeleteDcdnDeliverTaskRequest, runtime: Util.RuntimeOptions): DeleteDcdnDeliverTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deliverId)) {
    query['DeliverId'] = request.deliverId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDcdnDeliverTask',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 3.
  *
  * @param request DeleteDcdnDeliverTaskRequest
  * @return DeleteDcdnDeliverTaskResponse
 */
async function deleteDcdnDeliverTask(request: DeleteDcdnDeliverTaskRequest): DeleteDcdnDeliverTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnDeliverTaskWithOptions(request, runtime);
}

model DeleteDcdnDomainRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name to be deleted. You can specify only one domain name.', example='example.com'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteDcdnDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model DeleteDcdnDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnDomainResponseBody(name='body'),
}

/**
  * > 
  * *   Before you delete your domain name, you must request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
  * *   If you call the **DeleteDcdnDomain** operation, all the information about the accelerated domain name is deleted. If you want to disable an accelerated domain name, call the [StopDcdnDomain](~~130622~~) operation.
  * *   The maximum number of times that each user can call this operation per second is 10.
  *
  * @param request DeleteDcdnDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnDomainResponse
 */
async function deleteDcdnDomainWithOptions(request: DeleteDcdnDomainRequest, runtime: Util.RuntimeOptions): DeleteDcdnDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDcdnDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   Before you delete your domain name, you must request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
  * *   If you call the **DeleteDcdnDomain** operation, all the information about the accelerated domain name is deleted. If you want to disable an accelerated domain name, call the [StopDcdnDomain](~~130622~~) operation.
  * *   The maximum number of times that each user can call this operation per second is 10.
  *
  * @param request DeleteDcdnDomainRequest
  * @return DeleteDcdnDomainResponse
 */
async function deleteDcdnDomain(request: DeleteDcdnDomainRequest): DeleteDcdnDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnDomainWithOptions(request, runtime);
}

model DeleteDcdnIpaDomainRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain name to be deleted. You can specify only one domain name.', example='example.com'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteDcdnIpaDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='94E3559F-7B6A-4A5E-AFFD-44E2A208A249'),
}

model DeleteDcdnIpaDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnIpaDomainResponseBody(name='body'),
}

/**
  * > 
  * *   Before you delete your domain name, we recommend that you request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
  * *   If you call the **DeleteDcdnIpaDomain** operation to delete an accelerated domain name, all the relevant information is deleted. If you want to only disable an accelerated domain name, we recommend that you call the **StopDcdnIpaDomain** operation.
  * *   The maximum number of times that users can call this operation per second is 10.
  *
  * @param request DeleteDcdnIpaDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnIpaDomainResponse
 */
async function deleteDcdnIpaDomainWithOptions(request: DeleteDcdnIpaDomainRequest, runtime: Util.RuntimeOptions): DeleteDcdnIpaDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDcdnIpaDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   Before you delete your domain name, we recommend that you request the Domain Name System (DNS) provider to restore the A record of the domain name. Otherwise, the domain name may become inaccessible after you delete it.
  * *   If you call the **DeleteDcdnIpaDomain** operation to delete an accelerated domain name, all the relevant information is deleted. If you want to only disable an accelerated domain name, we recommend that you call the **StopDcdnIpaDomain** operation.
  * *   The maximum number of times that users can call this operation per second is 10.
  *
  * @param request DeleteDcdnIpaDomainRequest
  * @return DeleteDcdnIpaDomainResponse
 */
async function deleteDcdnIpaDomain(request: DeleteDcdnIpaDomainRequest): DeleteDcdnIpaDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnIpaDomainWithOptions(request, runtime);
}

model DeleteDcdnIpaSpecificConfigRequest {
  configId?: string(name='ConfigId', description='The ID of the configuration. You can call the [DescribeDcdnDomainConfigs](~~130625~~) operation to query configuration IDs.', example='50035**'),
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name in each call.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteDcdnIpaSpecificConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteDcdnIpaSpecificConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnIpaSpecificConfigResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 10.
  *
  * @param request DeleteDcdnIpaSpecificConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnIpaSpecificConfigResponse
 */
async function deleteDcdnIpaSpecificConfigWithOptions(request: DeleteDcdnIpaSpecificConfigRequest, runtime: Util.RuntimeOptions): DeleteDcdnIpaSpecificConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDcdnIpaSpecificConfig',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 10.
  *
  * @param request DeleteDcdnIpaSpecificConfigRequest
  * @return DeleteDcdnIpaSpecificConfigResponse
 */
async function deleteDcdnIpaSpecificConfig(request: DeleteDcdnIpaSpecificConfigRequest): DeleteDcdnIpaSpecificConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnIpaSpecificConfigWithOptions(request, runtime);
}

model DeleteDcdnKvRequest {
  key?: string(name='Key', description='The name of the key that you want to delete.', example='test_key_1'),
  namespace?: string(name='Namespace', description='The namespace that you specify when you call the PutDcdnKvNamespace operation.', example='ns1'),
}

model DeleteDcdnKvResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='D61E4801-EAFF-4A63-AAE1-FBF6CE1CFD1C'),
}

model DeleteDcdnKvResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnKvResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 50 times per second per account.
  *
  * @param request DeleteDcdnKvRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnKvResponse
 */
async function deleteDcdnKvWithOptions(request: DeleteDcdnKvRequest, runtime: Util.RuntimeOptions): DeleteDcdnKvResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDcdnKv',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 50 times per second per account.
  *
  * @param request DeleteDcdnKvRequest
  * @return DeleteDcdnKvResponse
 */
async function deleteDcdnKv(request: DeleteDcdnKvRequest): DeleteDcdnKvResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnKvWithOptions(request, runtime);
}

model DeleteDcdnRealTimeLogProjectRequest {
  projectName?: string(name='ProjectName', description='The name of a real-time log delivery project.', example='example'),
}

model DeleteDcdnRealTimeLogProjectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
}

model DeleteDcdnRealTimeLogProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnRealTimeLogProjectResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DeleteDcdnRealTimeLogProjectRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnRealTimeLogProjectResponse
 */
async function deleteDcdnRealTimeLogProjectWithOptions(request: DeleteDcdnRealTimeLogProjectRequest, runtime: Util.RuntimeOptions): DeleteDcdnRealTimeLogProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDcdnRealTimeLogProject',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DeleteDcdnRealTimeLogProjectRequest
  * @return DeleteDcdnRealTimeLogProjectResponse
 */
async function deleteDcdnRealTimeLogProject(request: DeleteDcdnRealTimeLogProjectRequest): DeleteDcdnRealTimeLogProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnRealTimeLogProjectWithOptions(request, runtime);
}

model DeleteDcdnSpecificConfigRequest {
  configId?: string(name='ConfigId', description='The ID of the configuration. Separate multiple configuration IDs with commas (,). For more information about ConfigId, see [Usage notes on ConfigId](~~410558~~).', example='2117'),
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteDcdnSpecificConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteDcdnSpecificConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnSpecificConfigResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request DeleteDcdnSpecificConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnSpecificConfigResponse
 */
async function deleteDcdnSpecificConfigWithOptions(request: DeleteDcdnSpecificConfigRequest, runtime: Util.RuntimeOptions): DeleteDcdnSpecificConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDcdnSpecificConfig',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request DeleteDcdnSpecificConfigRequest
  * @return DeleteDcdnSpecificConfigResponse
 */
async function deleteDcdnSpecificConfig(request: DeleteDcdnSpecificConfigRequest): DeleteDcdnSpecificConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnSpecificConfigWithOptions(request, runtime);
}

model DeleteDcdnSpecificStagingConfigRequest {
  configId?: string(name='ConfigId', description='The ID of the configuration to be deleted. You can specify multiple configuration IDs and separate them with commas (,).

You can call the DescribeDcdnDomainStagingConfig operation to query the environment configuration.', example='2317'),
  domainName?: string(name='DomainName', description='The name of the accelerated domain. You can specify only one domain name.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteDcdnSpecificStagingConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteDcdnSpecificStagingConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnSpecificStagingConfigResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request DeleteDcdnSpecificStagingConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnSpecificStagingConfigResponse
 */
async function deleteDcdnSpecificStagingConfigWithOptions(request: DeleteDcdnSpecificStagingConfigRequest, runtime: Util.RuntimeOptions): DeleteDcdnSpecificStagingConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDcdnSpecificStagingConfig',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request DeleteDcdnSpecificStagingConfigRequest
  * @return DeleteDcdnSpecificStagingConfigResponse
 */
async function deleteDcdnSpecificStagingConfig(request: DeleteDcdnSpecificStagingConfigRequest): DeleteDcdnSpecificStagingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnSpecificStagingConfigWithOptions(request, runtime);
}

model DeleteDcdnSubTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteDcdnSubTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnSubTaskResponseBody(name='body'),
}

/**
  * >  You can call this operation up to three times per second per account.
  *
  * @param request DeleteDcdnSubTaskRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnSubTaskResponse
 */
async function deleteDcdnSubTaskWithOptions(runtime: Util.RuntimeOptions): DeleteDcdnSubTaskResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DeleteDcdnSubTask',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to three times per second per account.
  *
  * @return DeleteDcdnSubTaskResponse
 */
async function deleteDcdnSubTask(): DeleteDcdnSubTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnSubTaskWithOptions(runtime);
}

model DeleteDcdnWafPolicyRequest {
  policyId?: long(name='PolicyId', description='The ID of the protection policy that you want to delete. You can specify only one ID in each request.', example='1000001'),
}

model DeleteDcdnWafPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-B084-72F8FD6DA2FE'),
}

model DeleteDcdnWafPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDcdnWafPolicyResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request DeleteDcdnWafPolicyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteDcdnWafPolicyResponse
 */
async function deleteDcdnWafPolicyWithOptions(request: DeleteDcdnWafPolicyRequest, runtime: Util.RuntimeOptions): DeleteDcdnWafPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDcdnWafPolicy',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request DeleteDcdnWafPolicyRequest
  * @return DeleteDcdnWafPolicyResponse
 */
async function deleteDcdnWafPolicy(request: DeleteDcdnWafPolicyRequest): DeleteDcdnWafPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDcdnWafPolicyWithOptions(request, runtime);
}

model DeleteRoutineRequest {
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
}

model DeleteRoutineResponseBody = {
  content?: map[string]any(name='Content', description='Returns ""Status": "OK"".', example='"Status": "OK"'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteRoutineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRoutineResponseBody(name='body'),
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @param request DeleteRoutineRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteRoutineResponse
 */
async function deleteRoutineWithOptions(request: DeleteRoutineRequest, runtime: Util.RuntimeOptions): DeleteRoutineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRoutine',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @param request DeleteRoutineRequest
  * @return DeleteRoutineResponse
 */
async function deleteRoutine(request: DeleteRoutineRequest): DeleteRoutineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRoutineWithOptions(request, runtime);
}

model DeleteRoutineCodeRevisionRequest {
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
  selectCodeRevision?: string(name='SelectCodeRevision', description='The number of the version that you want to delete.', example='123456'),
}

model DeleteRoutineCodeRevisionResponseBody = {
  content?: map[string]any(name='Content', description='Returns “"Status": "OK"".', example='"Status": "OK"'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteRoutineCodeRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRoutineCodeRevisionResponseBody(name='body'),
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @param request DeleteRoutineCodeRevisionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteRoutineCodeRevisionResponse
 */
async function deleteRoutineCodeRevisionWithOptions(request: DeleteRoutineCodeRevisionRequest, runtime: Util.RuntimeOptions): DeleteRoutineCodeRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.selectCodeRevision)) {
    body['SelectCodeRevision'] = request.selectCodeRevision;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRoutineCodeRevision',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @param request DeleteRoutineCodeRevisionRequest
  * @return DeleteRoutineCodeRevisionResponse
 */
async function deleteRoutineCodeRevision(request: DeleteRoutineCodeRevisionRequest): DeleteRoutineCodeRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRoutineCodeRevisionWithOptions(request, runtime);
}

model DeleteRoutineConfEnvsRequest {
  envs?: map[string]any(name='Envs', description='The custom canary release environments that you want to delete.', example='["presetCanaryZheJiang"]'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
}

model DeleteRoutineConfEnvsShrinkRequest {
  envsShrink?: string(name='Envs', description='The custom canary release environments that you want to delete.', example='["presetCanaryZheJiang"]'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
}

model DeleteRoutineConfEnvsResponseBody = {
  content?: map[string]any(name='Content', description='The message returned, such as ""Status": "OK"".', example='"Status": "OK"'),
  requestId?: string(name='RequestId', description='The ID of the region.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteRoutineConfEnvsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRoutineConfEnvsResponseBody(name='body'),
}

/**
  * > 
  * *   This operation deletes only custom preset canary release environments. You cannot delete production or staging environments.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param tmpReq DeleteRoutineConfEnvsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteRoutineConfEnvsResponse
 */
async function deleteRoutineConfEnvsWithOptions(tmpReq: DeleteRoutineConfEnvsRequest, runtime: Util.RuntimeOptions): DeleteRoutineConfEnvsResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteRoutineConfEnvsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.envs)) {
    request.envsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.envs, 'Envs', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.envsShrink)) {
    body['Envs'] = request.envsShrink;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRoutineConfEnvs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   This operation deletes only custom preset canary release environments. You cannot delete production or staging environments.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request DeleteRoutineConfEnvsRequest
  * @return DeleteRoutineConfEnvsResponse
 */
async function deleteRoutineConfEnvs(request: DeleteRoutineConfEnvsRequest): DeleteRoutineConfEnvsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRoutineConfEnvsWithOptions(request, runtime);
}

model DescribeDcdnAclFieldsRequest {
  lang?: string(name='Lang', description='The access language. Default value: en. Valid values:

*   **en**: English
*   **zh**: Chinese', example='en'),
}

model DescribeDcdnAclFieldsResponseBody = {
  content?: [ 
    {
      fields?: string(name='Fields', description='The rules and policies that were configured. The JSON string must be decoded.', example='\\"fieldList\\":[{\\"name\\":\\"alert\\",\\"display\\":\\"observe\\",\\"tip\\":\\"mark the request in the log without blocking it\\"},{\\"name\\":\\"bypass\\",\\"display\\":\\"bypass\\",\\"tip\\":\\"bypass security modules\\"}],\\"module\\":[{\\"name\\":\\"cc\\",\\"display\\":\\"Rate Limit\\",\\"tip\\":\\"bypass Rate Limit\\"},{\\"name\\":\\"bot\\",\\"display\\":\\"Bot Traffic Management\\",\\"tip\\":\\"bypass Bot Manager\\"}]'),
    }
  ](name='Content', description='The details about the rules.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='30A3A25A-86B3-4C1D-BAA8-12B8607A5CFD'),
}

model DescribeDcdnAclFieldsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnAclFieldsResponseBody(name='body'),
}

/**
  * >  You can call this operation up to three times per second.
  *
  * @param request DescribeDcdnAclFieldsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnAclFieldsResponse
 */
async function describeDcdnAclFieldsWithOptions(request: DescribeDcdnAclFieldsRequest, runtime: Util.RuntimeOptions): DescribeDcdnAclFieldsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnAclFields',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to three times per second.
  *
  * @param request DescribeDcdnAclFieldsRequest
  * @return DescribeDcdnAclFieldsResponse
 */
async function describeDcdnAclFields(request: DescribeDcdnAclFieldsRequest): DescribeDcdnAclFieldsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnAclFieldsWithOptions(request, runtime);
}

model DescribeDcdnBgpBpsDataRequest {
  deviceName?: string(name='DeviceName', description='The name of the device. If you specify this parameter, the data of the device is returned. Otherwise, the data of all devices is returned.', example='devicename'),
  devicePort?: string(name='DevicePort', description='The port of the device. If you specify this parameter, the data of the port is returned. Otherwise, the data of all ports is returned. This parameter takes effect only when the **DeviceName** parameter is specified.', example='123'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-11-30T00:00:00Z'),
  interval?: string(name='Interval', description='The data collection interval. Unit: seconds. Valid values: 300 and 3600. Default value: 300. The default value of 300 seconds is equal to 5 minutes. The value of this parameter varies based on the time range from the specified start time to the specified end time.', example='300'),
  isp?: string(name='Isp', description='The ISPs. If you need to specify multiple ISPs, separate them with commas (,). If you specify multiple ISPs, the data for the ISPs is aggregated. If you do not specify this parameter, the operation returns the data for all the ISPs.

Valid values:

*   cu: China Unicom
*   cmi: China Mobile
*   ct: China Telecom', example='cu'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The minimum data collection interval is an hour.

If you do not set this parameter, data collected in the last 24 hours is queried.', example='2018-11-29T00:00:00Z'),
}

model DescribeDcdnBgpBpsDataResponseBody = {
  bgpDataInterval?: [ 
    {
      in?: float(name='In', description='The inbound bandwidth. Unit: bit/s.', example='318'),
      out?: float(name='Out', description='The outbound bandwidth. Unit: bit/s.', example='183'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2018-11-29T20:00:00Z'),
    }
  ](name='BgpDataInterval', description='The BGP bandwidth data that is collected for each interval.'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2018-11-30T00:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E9D3257A-1B7C-414C-90C1-8D07AC47BCAC'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried.', example='2018-11-29T00:00:00Z'),
}

model DescribeDcdnBgpBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnBgpBpsDataResponseBody(name='body'),
}

/**
  * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both of them empty.
  * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
  * *   You can query data in the last 90 days.
  * *   The maximum time range from the start time to the end time is 31 days. The start time is specified by the StartTime parameter and the end time is specified by the EndTime parameter.
  * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
  * *   You can call this operation up to five times per second per account.
  *
  * @param request DescribeDcdnBgpBpsDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnBgpBpsDataResponse
 */
async function describeDcdnBgpBpsDataWithOptions(request: DescribeDcdnBgpBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnBgpBpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceName)) {
    query['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.devicePort)) {
    query['DevicePort'] = request.devicePort;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnBgpBpsData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both of them empty.
  * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
  * *   You can query data in the last 90 days.
  * *   The maximum time range from the start time to the end time is 31 days. The start time is specified by the StartTime parameter and the end time is specified by the EndTime parameter.
  * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
  * *   You can call this operation up to five times per second per account.
  *
  * @param request DescribeDcdnBgpBpsDataRequest
  * @return DescribeDcdnBgpBpsDataResponse
 */
async function describeDcdnBgpBpsData(request: DescribeDcdnBgpBpsDataRequest): DescribeDcdnBgpBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnBgpBpsDataWithOptions(request, runtime);
}

model DescribeDcdnBgpTrafficDataRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-11-30T00:00:00Z'),
  interval?: string(name='Interval', description='The data collection interval. Unit: seconds. Valid values: 300 and 3600. Default value: 300. The default value of 300 seconds is equal to 5 minutes. The value of this parameter varies based on the time range from the specified start time to the specified end time.', example='300'),
  isp?: string(name='Isp', description='The ISPs. If you need to specify multiple ISPs, separate them with commas (,). If you specify multiple ISPs, the data for the ISPs is aggregated. If you do not specify this parameter, the operation returns the data for all the ISPs.

Valid values:

*   cu: China Unicom
*   cmi: China Mobile
*   ct: China Telecom', example='cu'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The minimum data collection interval is an hour.

If you do not set this parameter, data collected in the last 24 hours is queried.', example='2018-11-29T00:00:00Z'),
}

model DescribeDcdnBgpTrafficDataResponseBody = {
  bgpDataInterval?: [ 
    {
      in?: long(name='In', description='The inbound traffic. Unit: bytes.', example='318'),
      out?: long(name='Out', description='The outbound traffic. Unit: bytes.', example='183'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2018-11-29T20:00:00Z'),
    }
  ](name='BgpDataInterval', description='The BGP traffic data that is collected for each interval.'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2018-11-30T00:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E9D3257A-1B7C-414C-90C1-8D07AC47BCAC'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried.', example='2018-11-29T00:00:00Z'),
}

model DescribeDcdnBgpTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnBgpTrafficDataResponseBody(name='body'),
}

/**
  * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both of them empty.
  * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
  * *   You can query data in the last 90 days.
  * *   The maximum time range from the start time to the end time is 31 days. The start time is specified by the StartTime parameter and the end time is specified by the EndTime parameter.
  * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
  * *   You can call this operation up to five times per second per account.
  *
  * @param request DescribeDcdnBgpTrafficDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnBgpTrafficDataResponse
 */
async function describeDcdnBgpTrafficDataWithOptions(request: DescribeDcdnBgpTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnBgpTrafficDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnBgpTrafficData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range. You must set both parameters or leave both of them empty.
  * *   If you specify multiple Internet service providers (ISPs), the data for the ISPs is aggregated.
  * *   You can query data in the last 90 days.
  * *   The maximum time range from the start time to the end time is 31 days. The start time is specified by the StartTime parameter and the end time is specified by the EndTime parameter.
  * *   If the time range from the start time to the end time is 72 hours or shorter, you can specify the interval as 5 minutes. If the time range is longer than 72 hours, you must specify the interval as 1 hour.
  * *   You can call this operation up to five times per second per account.
  *
  * @param request DescribeDcdnBgpTrafficDataRequest
  * @return DescribeDcdnBgpTrafficDataResponse
 */
async function describeDcdnBgpTrafficData(request: DescribeDcdnBgpTrafficDataRequest): DescribeDcdnBgpTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnBgpTrafficDataWithOptions(request, runtime);
}

model DescribeDcdnBlockedRegionsRequest {
  language?: string(name='Language', description='The language. Valid values: zh, en, and jp.', example='zh'),
}

model DescribeDcdnBlockedRegionsResponseBody = {
  infoList?: {
    infoItem?: [ 
    {
      continent?: string(name='Continent', description='The district to which the country or region belongs.', example='middle East'),
      countriesAndRegions?: string(name='CountriesAndRegions', description='The abbreviation of the name of the country or region.', example='AE'),
      countriesAndRegionsName?: string(name='CountriesAndRegionsName', description='The name of the country or region.', example='united arab emirates'),
    }
  ](name='InfoItem')
  }(name='InfoList', description='The information about the country or region.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BFFCDFAD-DACC-484E-9BE6-0AF3B3A0DD23'),
}

model DescribeDcdnBlockedRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnBlockedRegionsResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnBlockedRegionsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnBlockedRegionsResponse
 */
async function describeDcdnBlockedRegionsWithOptions(request: DescribeDcdnBlockedRegionsRequest, runtime: Util.RuntimeOptions): DescribeDcdnBlockedRegionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnBlockedRegions',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnBlockedRegionsRequest
  * @return DescribeDcdnBlockedRegionsResponse
 */
async function describeDcdnBlockedRegions(request: DescribeDcdnBlockedRegionsRequest): DescribeDcdnBlockedRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnBlockedRegionsWithOptions(request, runtime);
}

model DescribeDcdnCertificateDetailRequest {
  certName?: string(name='CertName', description='The name of the certificate.', example='123'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnCertificateDetailResponseBody = {
  cert?: string(name='Cert', description='The content of the certificate.', example='-----BEGIN CERTIFICATE-----xxx-----END CERTIFICATE-----'),
  certId?: long(name='CertId', description='The ID of the certificate.', example='123'),
  certName?: string(name='CertName', description='The name of the certificate.', example='123'),
  key?: string(name='Key', description='The key of the certificate.', example='ak1htyxxxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C7C69682-7F88-40DD-A198-10D0309E439B'),
}

model DescribeDcdnCertificateDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnCertificateDetailResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnCertificateDetailRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnCertificateDetailResponse
 */
async function describeDcdnCertificateDetailWithOptions(request: DescribeDcdnCertificateDetailRequest, runtime: Util.RuntimeOptions): DescribeDcdnCertificateDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certName)) {
    query['CertName'] = request.certName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnCertificateDetail',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnCertificateDetailRequest
  * @return DescribeDcdnCertificateDetailResponse
 */
async function describeDcdnCertificateDetail(request: DescribeDcdnCertificateDetailRequest): DescribeDcdnCertificateDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnCertificateDetailWithOptions(request, runtime);
}

model DescribeDcdnCertificateListRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. If you need to specify multiple accelerated domain names, separate them with commas (,).

By default, this operation queries the certificates of all accelerated domain names.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnCertificateListResponseBody = {
  certificateListModel?: {
    certList?: {
      cert?: [ 
      {
        certId?: long(name='CertId', description='The ID of the certificate.', example='123'),
        certName?: string(name='CertName', description='The name of the certificate.', example='Certificate 2'),
        common?: string(name='Common', description='The Common Name (CN) attribute of the certificate. In most cases, the CN is a domain name.', example='example.com'),
        fingerprint?: string(name='Fingerprint', description='The fingerprint of the certificate.', example='0151xxxx'),
        issuer?: string(name='Issuer', description='The certificate authority (CA) that issued the certificate.', example='DigiCert'),
        lastTime?: long(name='LastTime', description='The timestamp.', example='1548065550'),
      }
    ](name='Cert')
    }(name='CertList', description='Details about each certificate.'),
    count?: int32(name='Count', description='The number of certificates.', example='123'),
  }(name='CertificateListModel', description='Details about certificates.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FC0E34AC-0239-44A7-AB0E-800DE522C8DA'),
}

model DescribeDcdnCertificateListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnCertificateListResponseBody(name='body'),
}

/**
  * > You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnCertificateListRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnCertificateListResponse
 */
async function describeDcdnCertificateListWithOptions(request: DescribeDcdnCertificateListRequest, runtime: Util.RuntimeOptions): DescribeDcdnCertificateListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnCertificateList',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnCertificateListRequest
  * @return DescribeDcdnCertificateListResponse
 */
async function describeDcdnCertificateList(request: DescribeDcdnCertificateListRequest): DescribeDcdnCertificateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnCertificateListWithOptions(request, runtime);
}

model DescribeDcdnDeletedDomainsRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of domain names to return per page. Valid values: an integer between **1** and **500**. Default value: **20**.', example='5'),
}

model DescribeDcdnDeletedDomainsResponseBody = {
  domains?: {
    pageData?: [ 
    {
      domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
      gmtModified?: string(name='GmtModified', description='The time when the accelerated domain name was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC+0.', example='2015-10-28T11:05:52Z'),
    }
  ](name='PageData')
  }(name='Domains', description='The list of accelerated domain names and the time each domain name was last modified.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page, which is the same as the **PageNumber** parameter in request parameters.', example='1'),
  pageSize?: long(name='PageSize', description='The number of domain names returned per page, which is the same as the **PageSize** parameter in request parameters.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AA75AADB-5E25-4970-B480-EAA1F5658483'),
  totalCount?: long(name='TotalCount', description='The total number of domain names returned.', example='16'),
}

model DescribeDcdnDeletedDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDeletedDomainsResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 10 times per second per account.
  *
  * @param request DescribeDcdnDeletedDomainsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDeletedDomainsResponse
 */
async function describeDcdnDeletedDomainsWithOptions(request: DescribeDcdnDeletedDomainsRequest, runtime: Util.RuntimeOptions): DescribeDcdnDeletedDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDeletedDomains',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 10 times per second per account.
  *
  * @param request DescribeDcdnDeletedDomainsRequest
  * @return DescribeDcdnDeletedDomainsResponse
 */
async function describeDcdnDeletedDomains(request: DescribeDcdnDeletedDomainsRequest): DescribeDcdnDeletedDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDeletedDomainsWithOptions(request, runtime);
}

model DescribeDcdnDeliverListRequest {
  deliverId?: long(name='DeliverId', description='The ID of the tracking task that you want to query. If you do not specify an ID, all tracking tasks are queried.', example='92'),
}

model DescribeDcdnDeliverListResponseBody = {
  content?: string(name='Content', description='The information about the tracking task.', example='"data": [{"deliverId": 1,"status": "enable","createTime": "2021-06-14T11:19:26Z","crontab": "0 0 0 * * ?"," frequency": "d","name": "Domain Subscription","dmList": ["www.example.com"],"reports": [{"reportId": 1,"conditions": [{"op ": "in","field": "prov","value": ["Heilongjiang","Beijing"]}]},{"reportId": 2}],"deliver": {"email": { "subject": "subject","to": ["username@example.com","username@example.org"],"copy":["username@example.com","username@example.org" ]}}}]}'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DescribeDcdnDeliverListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDeliverListResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 3.
  *
  * @param request DescribeDcdnDeliverListRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDeliverListResponse
 */
async function describeDcdnDeliverListWithOptions(request: DescribeDcdnDeliverListRequest, runtime: Util.RuntimeOptions): DescribeDcdnDeliverListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deliverId)) {
    query['DeliverId'] = request.deliverId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDeliverList',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 3.
  *
  * @param request DescribeDcdnDeliverListRequest
  * @return DescribeDcdnDeliverListResponse
 */
async function describeDcdnDeliverList(request: DescribeDcdnDeliverListRequest): DescribeDcdnDeliverListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDeliverListWithOptions(request, runtime);
}

model DescribeDcdnDomainBpsDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.

Separate multiple domain names with commas (,). If you do not specify a value for this parameter, bandwidth data of all accelerated domain names is queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  interval?: string(name='Interval', description='The time granularity for a query. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='beijing'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='unicom'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainBpsDataResponseBody = {
  bpsDataPerInterval?: {
    dataModule?: [ 
    {
      bps?: float(name='Bps', description='The bandwidth value. Unit: bit/s.', example='11286'),
      dynamicHttpBps?: float(name='DynamicHttpBps', description='The bandwidth that was consumed to deliver dynamic content over HTTP, in bit/s.', example='11286111'),
      dynamicHttpsBps?: float(name='DynamicHttpsBps', description='The bandwidth that was consumed to deliver dynamic content over HTTPS, in bit/s.', example='12312'),
      staticHttpBps?: float(name='StaticHttpBps', description='The bandwidth that was consumed to deliver static content over HTTP, in bit/s.', example='123'),
      staticHttpsBps?: float(name='StaticHttpsBps', description='The bandwidth that was consumed to deliver static content over HTTPS, in bit/s.', example='123'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2017-12-10T20:00:00Z'),
    }
  ](name='DataModule')
  }(name='BpsDataPerInterval', description='The bandwidth data returned at each interval.'),
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2017-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried.', example='2017-12-10T10:00:00Z'),
}

model DescribeDcdnDomainBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainBpsDataResponseBody(name='body'),
}

/**
  * * You can call this operation up to 100 times per second per account.
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainBpsDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainBpsDataResponse
 */
async function describeDcdnDomainBpsDataWithOptions(request: DescribeDcdnDomainBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainBpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainBpsData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * * You can call this operation up to 100 times per second per account.
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainBpsDataRequest
  * @return DescribeDcdnDomainBpsDataResponse
 */
async function describeDcdnDomainBpsData(request: DescribeDcdnDomainBpsDataRequest): DescribeDcdnDomainBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainBpsDataWithOptions(request, runtime);
}

model DescribeDcdnDomainBpsDataByLayerRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify multiple domain names and separate them with commas (,). You can specify up to 500 domain names in each request. The query results of multiple domain names are aggregated.

If you do not specify a domain name, data of all domain names is queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2015-12-10T21:00:00Z'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP). You can call the DescribeDcdnRegionAndIsp operation to query the ISP name. If you do not specify a value for this parameter, all ISPs are queried.', example='telecom'),
  layer?: string(name='Layer', description='The layer at which you want to query the bandwidth data. The network layer supports IPv4 and IPv6. The application layer supports http, https, and quic. You can also set the value to all.

Default value: all.', example='all'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. You can call the DescribeDcdnRegionAndIsp operation to query the region name. If you do not specify a value for this parameter, all regions are queried.', example='hangzhou'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The minimum data granularity is 5 minutes.

If you do not set this parameter, data in the last 24 hours is queried.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainBpsDataByLayerResponseBody = {
  bpsDataInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2015-12-10T21:00:00Z'),
      trafficValue?: string(name='TrafficValue', description='The total amount of network traffic. Unit: bytes.', example='331'),
      value?: string(name='Value', description='The total bandwidth. Unit: bit/s.', example='0.56'),
    }
  ](name='DataModule')
  }(name='BpsDataInterval', description='The bandwidth returned at each time interval.'),
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BEA5625F-8FCF-48F4-851B-CA63946DA664'),
}

model DescribeDcdnDomainBpsDataByLayerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainBpsDataByLayerResponseBody(name='body'),
}

/**
  * - You can call this operation up to 20 times per second.
  * - If you do not set the **StartTime** or **EndTime** parameters, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data is available | Data delay |
  * | ---------------- | ---------------------------- | ---------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainBpsDataByLayerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainBpsDataByLayerResponse
 */
async function describeDcdnDomainBpsDataByLayerWithOptions(request: DescribeDcdnDomainBpsDataByLayerRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainBpsDataByLayerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.layer)) {
    query['Layer'] = request.layer;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainBpsDataByLayer',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 20 times per second.
  * - If you do not set the **StartTime** or **EndTime** parameters, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data is available | Data delay |
  * | ---------------- | ---------------------------- | ---------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainBpsDataByLayerRequest
  * @return DescribeDcdnDomainBpsDataByLayerResponse
 */
async function describeDcdnDomainBpsDataByLayer(request: DescribeDcdnDomainBpsDataByLayerRequest): DescribeDcdnDomainBpsDataByLayerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainBpsDataByLayerWithOptions(request, runtime);
}

model DescribeDcdnDomainByCertificateRequest {
  SSLPub?: string(name='SSLPub', description='The public key of the certificate.

You must use Base64 encoding schemes and then the encodeURIComponent method to encode the public key. PEM files are supported.', example='xxx'),
  SSLStatus?: boolean(name='SSLStatus', description='Indicates the returned domain name list contains only domain names with HTTPS enabled or disabled.

*   true: The list contains only domain names with HTTPS enabled.
*   false: The list contains only domain names with HTTPS disabled..', example='true'),
}

model DescribeDcdnDomainByCertificateResponseBody = {
  certInfos?: {
    certInfo?: [ 
    {
      certCaIsLegacy?: string(name='CertCaIsLegacy', description='Indicates whether the CA certificate has been revoked. Valid values:

*   **yes**: The certificate has been revoked.
*   **no**: The certificate is normal.', example='yes'),
      certExpireTime?: string(name='CertExpireTime', description='The time when the certificate expires.', example='Nov 29 00:00:00 2016 GMT'),
      certExpired?: string(name='CertExpired', description='Indicates whether the certificate is expired. Valid values:

*   **yes**: The certificate is expired.
*   **no**: The certificate is not expired.', example='yes'),
      certStartTime?: string(name='CertStartTime', description='The time at which the certificate started to take effect.', example='Nov 29 23:59:59 2017 GMT'),
      certSubjectCommonName?: string(name='CertSubjectCommonName', description='The name of the SSL certificate owner.', example='example.aliyundoc.com'),
      certType?: string(name='CertType', description='The type of the certificate. **RSA**, **DSA**, and **ECDSA**.', example='RSA'),
      domainList?: string(name='DomainList', description='The list of domain names that use the certificate.

If one or more domain names are returned, the domain names are matched with the specified certificate. Multiple domain names are separated with commas (,).', example='example.com,example.org'),
      domainNames?: string(name='DomainNames', description='The domain names (DNS fields) that match the certificate. Multiple domain names are separated with commas (,).', example='*.example.com,example.org'),
      issuer?: string(name='Issuer', description='The certificate authority CA that issued the certificate.', example='C=US, O=Symantec Corporation, OU=Symantec Trust Network, OU=Domain Validated SSL, CN=Symantec Basic DV SSL CA - G1'),
    }
  ](name='CertInfo')
  }(name='CertInfos', description='The certificate information of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='ASAF2FDS-12SADSA-DDSAE3D-DSADCD4C-CDADS2D'),
}

model DescribeDcdnDomainByCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainByCertificateResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnDomainByCertificateRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainByCertificateResponse
 */
async function describeDcdnDomainByCertificateWithOptions(request: DescribeDcdnDomainByCertificateRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainByCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.SSLPub)) {
    query['SSLPub'] = request.SSLPub;
  }
  if (!Util.isUnset(request.SSLStatus)) {
    query['SSLStatus'] = request.SSLStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainByCertificate',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnDomainByCertificateRequest
  * @return DescribeDcdnDomainByCertificateResponse
 */
async function describeDcdnDomainByCertificate(request: DescribeDcdnDomainByCertificateRequest): DescribeDcdnDomainByCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainByCertificateWithOptions(request, runtime);
}

model DescribeDcdnDomainCcActivityLogRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify one or more domain names. Separate multiple domain names with commas (,).

If you leave this parameter empty, the data of all domain names is queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The end time must be later than the start time.', example='2015-12-10T21:05:00Z'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Default value: **30**.', example='30'),
  ruleName?: string(name='RuleName', description='The name of the rule. Valid values

*   default_normal in normal mode
*   default_attack in emergency mode
*   A custom rule name in custom mode. Example: test2.

If you leave this parameter empty, all events that triggered rate limiting are queried.', example='test2'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The resolution of the queried data is 5 minutes.

If you leave this parameter empty, the data collected over the last 24 hours is queried.', example='2015-12-10T20:00:00Z'),
  triggerObject?: string(name='TriggerObject', description='The object that triggered rate limiting.

If you leave this parameter empty, all events that triggered rate limiting are queried.', example='IP'),
  value?: string(name='Value', description='The value of the object that triggered rate limiting.

If you leave this parameter empty, all events that triggered rate limiting are queried.', example='10.10.10.10'),
}

model DescribeDcdnDomainCcActivityLogResponseBody = {
  activityLog?: [ 
    {
      action?: string(name='Action', description='The action that was triggered.', example='deny'),
      domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
      ruleName?: string(name='RuleName', description='The name of the rule that was triggered.', example='test2'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data.', example='2015-12-10T20:00:00Z'),
      triggerObject?: string(name='TriggerObject', description='The object that triggered rate limiting.', example='IP'),
      ttl?: long(name='Ttl', description='The period of time during which rate limiting remains effective.', example='300'),
      value?: string(name='Value', description='The value of the object that triggered rate limiting.', example='10.10.10.10'),
    }
  ](name='ActivityLog', description='The log data of the event that triggered rate limiting.'),
  pageIndex?: long(name='PageIndex', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F'),
  total?: long(name='Total', description='The total number of entries returned.', example='20'),
}

model DescribeDcdnDomainCcActivityLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainCcActivityLogResponseBody(name='body'),
}

/**
  * > 
  * *   If you do not configure the StartTime or EndTime parameter, data collected over the last 24 hours is queried. If you configure both the StartTime and EndTime parameters, data collected within the specified time range is queried.
  * *   You can query data collected over the last 30 days.
  * *   You can call this operation up to 50 times per second.
  *
  * @param request DescribeDcdnDomainCcActivityLogRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainCcActivityLogResponse
 */
async function describeDcdnDomainCcActivityLogWithOptions(request: DescribeDcdnDomainCcActivityLogRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainCcActivityLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.triggerObject)) {
    query['TriggerObject'] = request.triggerObject;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainCcActivityLog',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   If you do not configure the StartTime or EndTime parameter, data collected over the last 24 hours is queried. If you configure both the StartTime and EndTime parameters, data collected within the specified time range is queried.
  * *   You can query data collected over the last 30 days.
  * *   You can call this operation up to 50 times per second.
  *
  * @param request DescribeDcdnDomainCcActivityLogRequest
  * @return DescribeDcdnDomainCcActivityLogResponse
 */
async function describeDcdnDomainCcActivityLog(request: DescribeDcdnDomainCcActivityLogRequest): DescribeDcdnDomainCcActivityLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainCcActivityLogWithOptions(request, runtime);
}

model DescribeDcdnDomainCertificateInfoRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name in each request.', example='example.com'),
}

model DescribeDcdnDomainCertificateInfoResponseBody = {
  certInfos?: {
    certInfo?: [ 
    {
      certDomainName?: string(name='CertDomainName', description='The domain name that matches the certificate.', example='example.com'),
      certExpireTime?: string(name='CertExpireTime', description='The expiration time of the certificate.', example='2018-06-03T22:03:39Z'),
      certId?: string(name='CertId'),
      certLife?: string(name='CertLife', description='The validity period of the certificate. Unit: **months** or **years**.', example='3 months'),
      certName?: string(name='CertName', description='The name of the certificate.', example='cert-example.com'),
      certOrg?: string(name='CertOrg', description='The certificate authority (CA) that issued the certificate.', example='Let\\"s Encrypt'),
      certRegion?: string(name='CertRegion'),
      certType?: string(name='CertType', description='The type of the certificate. Valid values:

*   **free**: a free certificate
*   **cas**: a certificate that is purchased from Alibaba Cloud SSL Certificates Service
*   **upload**: a certificate that is uploaded by the user', example='cas'),
      domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
      SSLProtocol?: string(name='SSLProtocol', description='The status of HTTPS. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
      SSLPub?: string(name='SSLPub', description='The public key of the certificate.', example='xxxx'),
      status?: string(name='Status', description='The status of the certificate. Valid values:

*   **success**: The certificate has taken effect.
*   **checking**: The system is checking whether the domain name is using Dynamic Route for CDN (DCDN).
*   **cname_error**: The domain name is not using DCDN.
*   **domain_invalid**: The domain name contains invalid characters.
*   **unsupport_wildcard**: The wildcard domain name is not supported.
*   **applying**: Certificate application is in progress.
*   **get_token_timeout**: The certificate application request has timed out.
*   **check_token_timeout**: The verification has timed out.
*   **get_cert_timeout**: The request to obtain the certificate has timed out.
*   **failed**: The certificate application request failed.', example='success'),
    }
  ](name='CertInfo')
  }(name='CertInfos', description='The certificate information of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5C1E43DC-9E51-4771-82C0-7D5ECEB547A1'),
}

model DescribeDcdnDomainCertificateInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainCertificateInfoResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnDomainCertificateInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainCertificateInfoResponse
 */
async function describeDcdnDomainCertificateInfoWithOptions(request: DescribeDcdnDomainCertificateInfoRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainCertificateInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainCertificateInfo',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnDomainCertificateInfoRequest
  * @return DescribeDcdnDomainCertificateInfoResponse
 */
async function describeDcdnDomainCertificateInfo(request: DescribeDcdnDomainCertificateInfoRequest): DescribeDcdnDomainCertificateInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainCertificateInfoWithOptions(request, runtime);
}

model DescribeDcdnDomainCnameRequest {
  domainName?: string(name='DomainName', description='The names of the accelerated domains. If you need to specify multiple accelerated domain names, separate them with commas (,).', example='example.com,example.org'),
}

model DescribeDcdnDomainCnameResponseBody = {
  cnameDatas?: {
    data?: [ 
    {
      cname?: string(name='Cname', description='The CNAME.', example='*.com'),
      domain?: string(name='Domain', description='The name of the accelerated domain returned.', example='.example.com'),
      status?: int32(name='Status', description='The configuration status of the CNAME record. If the operations returns 0 for the parameter, the configuration was successful. Otherwise, the configuration failed.', example='0'),
    }
  ](name='Data')
  }(name='CnameDatas', description='The CNAME information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
}

model DescribeDcdnDomainCnameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainCnameResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 80.
  *
  * @param request DescribeDcdnDomainCnameRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainCnameResponse
 */
async function describeDcdnDomainCnameWithOptions(request: DescribeDcdnDomainCnameRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainCnameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainCname',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 80.
  *
  * @param request DescribeDcdnDomainCnameRequest
  * @return DescribeDcdnDomainCnameResponse
 */
async function describeDcdnDomainCname(request: DescribeDcdnDomainCnameRequest): DescribeDcdnDomainCnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainCnameWithOptions(request, runtime);
}

model DescribeDcdnDomainConfigsRequest {
  configId?: string(name='ConfigId', description='The ID of the configuration.', example='5003576'),
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name in each call.', example='example.com'),
  functionNames?: string(name='FunctionNames', description='The names of the features to query. Separate features with commas (,).', example='filetype_based_ttl_set,set_req_host_header'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnDomainConfigsResponseBody = {
  domainConfigs?: {
    domainConfig?: [ 
    {
      configId?: string(name='ConfigId', description='The ID of the configuration.', example='5068995'),
      functionArgs?: {
        functionArg?: [ 
        {
          argName?: string(name='ArgName', description='The name of the configuration.', example='ttl'),
          argValue?: string(name='ArgValue', description='The value of the configuration.', example='13'),
        }
      ](name='FunctionArg')
      }(name='FunctionArgs', description='The configurations of the features.'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='set_req_host_header'),
      parentId?: string(name='ParentId', description='The ID of the advanced condition configuration.', example='1234567'),
      status?: string(name='Status', description='The status of the configuration. Valid values:

*   **success**
*   **testing**
*   **failed**
*   **configuring**', example='success'),
    }
  ](name='DomainConfig')
  }(name='DomainConfigs', description='The configurations of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F8AA0364-0FDB-4AD5-AC74-D69FAB8924ED'),
}

model DescribeDcdnDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainConfigsResponseBody(name='body'),
}

/**
  * > 
  * *   You can query the configurations of one or more features in a request.
  * *   You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnDomainConfigsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainConfigsResponse
 */
async function describeDcdnDomainConfigsWithOptions(request: DescribeDcdnDomainConfigsRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.functionNames)) {
    query['FunctionNames'] = request.functionNames;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainConfigs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can query the configurations of one or more features in a request.
  * *   You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnDomainConfigsRequest
  * @return DescribeDcdnDomainConfigsResponse
 */
async function describeDcdnDomainConfigs(request: DescribeDcdnDomainConfigsRequest): DescribeDcdnDomainConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainConfigsWithOptions(request, runtime);
}

model DescribeDcdnDomainDetailRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnDomainDetailResponseBody = {
  domainDetail?: {
    cname?: string(name='Cname', description='The CNAME that is assigned to the accelerated domain name. You must add the CNAME record to the system of your Domain Name System (DNS) provider to map the accelerated domain name to the CNAME.', example='example.aliyundoc.com'),
    description?: string(name='Description', description='The information about the Internet content provider (ICP) filing of the domain name.', example='Beijing ICP No. 1703xxxx'),
    domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
    domainStatus?: string(name='DomainStatus', description='The status of the accelerated domain name. Valid values:

*   **online**: The domain name is enabled.
*   **offline**: The domain name is disabled.
*   **configuring**: The domain name is being configured.
*   **configure_failed**: The domain name has failed to be configured.
*   **checking**: The domain name is under review.
*   **check_failed**: The domain name has failed the review.', example='online'),
    gmtCreated?: string(name='GmtCreated', description='The time when the accelerated domain name was created.', example='2017-11-27T06:51:26Z'),
    gmtModified?: string(name='GmtModified', description='The time when the accelerated domain name was last modified.', example='2017-11-27T06:51:25Z'),
    resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyuji4b6r4**'),
    SSLProtocol?: string(name='SSLProtocol', description='Indicates whether the Security Socket Layer (SSL) certificate is enabled. Valid values:

*   **on**: **enabled**.
*   **off**: **disabled**.', example='on'),
    SSLPub?: string(name='SSLPub', description='Indicates the public key of the certificate if the HTTPS protocol is enabled.', example='xxx'),
    scope?: string(name='Scope', description='The region where your acceleration service is deployed.

*   **domestic**: Chinese mainland. This is the default value.
*   **overseas**: outside the Chinese mainland.
*   **global**: all the countries in the world.', example='overseas'),
    sources?: {
      source?: [ 
      {
        content?: string(name='Content', description='The origin address.', example='example.org'),
        enabled?: string(name='Enabled', description='The status of the origin server.', example='online'),
        port?: int32(name='Port', description='The port over which back-to-origin requests are transmitted. Ports 443 and 80 are supported.', example='80'),
        priority?: string(name='Priority', description='The priority of the origin server.', example='50'),
        type?: string(name='Type', description='The type of origin server. Valid values:

*   **ipaddr**: the IP address of the origin server.
*   **domain**: the domain name of the origin server.
*   **oss**: the URL of an Object Storage Service (OSS) bucket.', example='oss'),
        weight?: string(name='Weight', description='The weight of the origin server if multiple origin servers have been specified.', example='20'),
      }
    ](name='Source')
    }(name='Sources', description='The information about the origin server.'),
  }(name='DomainDetail', description='The detailed information about the accelerated domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='09ABE829-6CD3-4FE0-AFEE-556113E29727'),
}

model DescribeDcdnDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainDetailResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnDomainDetailRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainDetailResponse
 */
async function describeDcdnDomainDetailWithOptions(request: DescribeDcdnDomainDetailRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainDetail',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnDomainDetailRequest
  * @return DescribeDcdnDomainDetailResponse
 */
async function describeDcdnDomainDetail(request: DescribeDcdnDomainDetailRequest): DescribeDcdnDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainDetailWithOptions(request, runtime);
}

model DescribeDcdnDomainHitRateDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name.

If you do not specify a value for this parameter, all domain names are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The end time must be later than the start time.', example='2018-03-02T15:00:00Z'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.', example='300'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-03-02T12:00:00Z'),
}

model DescribeDcdnDomainHitRateDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='3600'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2018-03-02T15:00:00Z'),
  hitRatePerInterval?: {
    dataModule?: [ 
    {
      byteHitRate?: float(name='ByteHitRate', description='The byte hit ratio.', example='0'),
      reqHitRate?: float(name='ReqHitRate', description='The request hit ratio.', example='0'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2018-03-02T13:00:00Z'),
    }
  ](name='DataModule')
  }(name='HitRatePerInterval', description='The byte hit ratio at each time interval. The byte hit ratio is measured in percentage.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4D07ABFE-4737-4834-B1B9-A661308C47B4'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2018-03-02T12:00:00Z'),
}

model DescribeDcdnDomainHitRateDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainHitRateDataResponseBody(name='body'),
}

/**
  * - You can call this operation up to 100 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainHitRateDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainHitRateDataResponse
 */
async function describeDcdnDomainHitRateDataWithOptions(request: DescribeDcdnDomainHitRateDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainHitRateDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainHitRateData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 100 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainHitRateDataRequest
  * @return DescribeDcdnDomainHitRateDataResponse
 */
async function describeDcdnDomainHitRateData(request: DescribeDcdnDomainHitRateDataRequest): DescribeDcdnDomainHitRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainHitRateDataWithOptions(request, runtime);
}

model DescribeDcdnDomainHttpCodeDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> The end time must be later than the start time.', example='2019-03-02T00:00:00Z'),
  interval?: string(name='Interval', description='The time granularity for a query. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the ISP.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2019-03-01T00:00:00Z'),
}

model DescribeDcdnDomainHttpCodeDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  dataPerInterval?: {
    dataModule?: [ 
    {
      httpCodeDataPerInterval?: {
        httpCodeDataModule?: [ 
        {
          code?: int32(name='Code', description='The HTTP status code returned.', example='404'),
          count?: float(name='Count', description='The total number of entries.', example='1'),
          proportion?: float(name='Proportion', description='The proportion of the HTTP status code.', example='33.333333'),
        }
      ](name='HttpCodeDataModule')
      }(name='HttpCodeDataPerInterval', description='The proportions of the HTTP status codes.'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2019-03-01T13:00:00Z'),
    }
  ](name='DataModule')
  }(name='DataPerInterval', description='The proportions of HTTP status codes at each time interval.'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2018-03-01T13:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='91FC2D9D-B042-4634-8A5C-7B8E7482C22D'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried.', example='2019-03-01T00:00:00Z'),
}

model DescribeDcdnDomainHttpCodeDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainHttpCodeDataResponseBody(name='body'),
}

/**
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * * You can call this operation up to 100 times per second per account.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainHttpCodeDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainHttpCodeDataResponse
 */
async function describeDcdnDomainHttpCodeDataWithOptions(request: DescribeDcdnDomainHttpCodeDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainHttpCodeDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainHttpCodeData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * * You can call this operation up to 100 times per second per account.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainHttpCodeDataRequest
  * @return DescribeDcdnDomainHttpCodeDataResponse
 */
async function describeDcdnDomainHttpCodeData(request: DescribeDcdnDomainHttpCodeDataRequest): DescribeDcdnDomainHttpCodeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainHttpCodeDataWithOptions(request, runtime);
}

model DescribeDcdnDomainHttpCodeDataByLayerRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify multiple domain names and separate them with commas (,). You can specify up to 500 domain names in each request. The query results of multiple domain names are aggregated.

If you do not specify a domain name, data of all domain names is queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2015-12-10T21:00:00Z'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP). You can call the DescribeDcdnRegionAndIsp operation to query the ISP name. If you do not specify a value for this parameter, all ISPs are queried.', example='telecom'),
  layer?: string(name='Layer', description='The layer at which you want to query the distribution of HTTP status codes. The network layer supports IPv4 and IPv6. The application layer supports http, https, and quic. You can also set the value to all.

Default value: all.', example='all'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. You can call the DescribeDcdnRegionAndIsp operation to query the region name. If you do not specify a value for this parameter, all regions are queried.', example='hangzhou'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The minimum data granularity is 5 minutes.

If you do not set this parameter, data in the last 24 hours is queried.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainHttpCodeDataByLayerResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  httpCodeDataInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2015-12-10T21:00:00Z'),
      totalValue?: string(name='TotalValue', description='The total number of times that HTTP status codes were returned.', example='110'),
      value?: map[string]any(name='Value', description='The number of times that the HTTP status code was returned.', example='{"200": 10,"206": 100}'),
    }
  ](name='DataModule')
  }(name='HttpCodeDataInterval', description='The distribution of HTTP status codes at each time interval.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BEA5625F-8FCF-48F4-851B-CA63946DA664'),
}

model DescribeDcdnDomainHttpCodeDataByLayerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainHttpCodeDataByLayerResponseBody(name='body'),
}

/**
  * - You can call this operation up to 20 times per second per account.
  * - You cannot query the distribution of HTTP status codes by IP protocol.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainHttpCodeDataByLayerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainHttpCodeDataByLayerResponse
 */
async function describeDcdnDomainHttpCodeDataByLayerWithOptions(request: DescribeDcdnDomainHttpCodeDataByLayerRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainHttpCodeDataByLayerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.layer)) {
    query['Layer'] = request.layer;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainHttpCodeDataByLayer',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 20 times per second per account.
  * - You cannot query the distribution of HTTP status codes by IP protocol.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainHttpCodeDataByLayerRequest
  * @return DescribeDcdnDomainHttpCodeDataByLayerResponse
 */
async function describeDcdnDomainHttpCodeDataByLayer(request: DescribeDcdnDomainHttpCodeDataByLayerRequest): DescribeDcdnDomainHttpCodeDataByLayerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainHttpCodeDataByLayerWithOptions(request, runtime);
}

model DescribeDcdnDomainIpaBpsDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.

Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  fixTimeGap?: string(name='FixTimeGap', description='Specify whether to implement padding with zeros. Valid values:

*   **true**
*   **false**', example='false'),
  interval?: string(name='Interval', description='The time granularity for a query. Unit: seconds.

The value varies based on the values of the **StartTime** and **EndTime** parameters. Valid values:

*   If the time range between StartTime and EndTime is less than 3 days, the valid values are **300**, **3600**, and **86400**. If you do not specify a value for this parameter, **300** is used.
*   If the time range between StartTime and EndTime is from 3 to 31 days (31 days excluded), the valid values are **3600** and **86400**. Default value: **3600**.
*   If the time range between StartTime and EndTime is 31 days or longer, the valid value is **86400**. Default value: **86400**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='Unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-10T20:00:00Z'),
  timeMerge?: string(name='TimeMerge', description='Specifies whether to automatically set the interval. If you set **TimeMerge** to **1**, the value of the **Interval** parameter is automatically assigned based on the **startTime** and **endTime** parameters. You can set either this parameter or the **Interval** parameter.', example='1'),
}

model DescribeDcdnDomainIpaBpsDataResponseBody = {
  bpsDataPerInterval?: {
    dataModule?: [ 
    {
      ipaBps?: float(name='IpaBps', description='The bandwidth value. Unit: bit/s.', example='11288111'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2017-12-10T20:00:00Z'),
    }
  ](name='DataModule')
  }(name='BpsDataPerInterval', description='The bandwidth data returned at each interval.'),
  dataInterval?: string(name='DataInterval', description='The time interval at which data is collected. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2017-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainIpaBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainIpaBpsDataResponseBody(name='body'),
}

/**
  * > 
  * *   Unit: bit/s.
  * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnDomainIpaBpsDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainIpaBpsDataResponse
 */
async function describeDcdnDomainIpaBpsDataWithOptions(request: DescribeDcdnDomainIpaBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainIpaBpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.fixTimeGap)) {
    query['FixTimeGap'] = request.fixTimeGap;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeMerge)) {
    query['TimeMerge'] = request.timeMerge;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainIpaBpsData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   Unit: bit/s.
  * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnDomainIpaBpsDataRequest
  * @return DescribeDcdnDomainIpaBpsDataResponse
 */
async function describeDcdnDomainIpaBpsData(request: DescribeDcdnDomainIpaBpsDataRequest): DescribeDcdnDomainIpaBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainIpaBpsDataWithOptions(request, runtime);
}

model DescribeDcdnDomainIpaConnDataRequest {
  domainName?: string(name='DomainName', description='The domain names accelerated by IPA. Separate multiple domain names with commas (,).

>  If you do not specify this parameter, the merged data of all accelerated domain names is returned.', example='example1.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2015-02-22T7:00:00Z'),
  splitBy?: string(name='SplitBy', description='Specifies how query results are grouped. By default, this parameter is empty. Valid values:

*   domain: Query results are grouped by accelerated domain name.
*   An empty string: Query results are not grouped.', example='domain'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2015-02-21T07:00:00Z'),
}

model DescribeDcdnDomainIpaConnDataResponseBody = {
  connectionDataPerInterval?: {
    dataModule?: [ 
    {
      connections?: long(name='Connections', description='The number of IPA user connections.', example='189095'),
      domain?: string(name='Domain', description='The accelerated domain name.', example='example1.com'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2022-02-21T15:00:00+08:00'),
    }
  ](name='DataModule')
  }(name='ConnectionDataPerInterval', description='The number of user connections at each time interval.'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2015-02-22T15:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A2A1EEF8-043E-43A1-807C-BEAC18EA1807'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2015-02-21T15:00:00Z'),
}

model DescribeDcdnDomainIpaConnDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainIpaConnDataResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 10 times per second per account.
  * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * *   The minimum time granularity at which the data is queried is 5 minutes. The maximum time range for a single query is 31 days. The period within which historical data is available is 366 days. The data latency is no more than 10 minutes.
  *
  * @param request DescribeDcdnDomainIpaConnDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainIpaConnDataResponse
 */
async function describeDcdnDomainIpaConnDataWithOptions(request: DescribeDcdnDomainIpaConnDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainIpaConnDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.splitBy)) {
    query['SplitBy'] = request.splitBy;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainIpaConnData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 10 times per second per account.
  * *   If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * *   The minimum time granularity at which the data is queried is 5 minutes. The maximum time range for a single query is 31 days. The period within which historical data is available is 366 days. The data latency is no more than 10 minutes.
  *
  * @param request DescribeDcdnDomainIpaConnDataRequest
  * @return DescribeDcdnDomainIpaConnDataResponse
 */
async function describeDcdnDomainIpaConnData(request: DescribeDcdnDomainIpaConnDataRequest): DescribeDcdnDomainIpaConnDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainIpaConnDataWithOptions(request, runtime);
}

model DescribeDcdnDomainIpaTrafficDataRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain name.

You can specify one or more accelerated domain names. Separate them with commas (,). By default, all accelerated domain names that belong to your Alibaba Cloud account are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0.

>  The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  fixTimeGap?: string(name='FixTimeGap', description='Specify whether to implement padding with zeros. Valid values:

*   **true**: Yes
*   **false**: No', example='false'),
  interval?: string(name='Interval', description='The time interval between the data entries returned. Unit: seconds.

The valid values vary based on the values of the **StartTime** and **EndTime** parameters. Valid values:

*   If the time range between StartTime and EndTime is less than 3 days, valid values are **300**, **3600**, and **86400**. Default value: **300**.
*   If the time range between StartTime and EndTime is from 3 to 31 days (31 days excluded), valid values are **3600** and **86400**. Default value: **3600**.
*   If the time range between StartTime and EndTime is 31 days or longer, the valid value is **86400**. Default value: **86400**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP) for Dynamic Route for CDN (DCDN).

You can call the [DescribeCdnRegionAndIsp](~~207199~~) operation to query the most recent ISP list. If you do not specify an ISP, all ISPs are queried.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeCdnRegionAndIsp](~~207199~~) operation to query the most recent region list. If you do not specify a region, all regions are queried.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC+0.', example='2017-12-10T20:00:00Z'),
  timeMerge?: string(name='TimeMerge', description='Specify whether to automatically calculate the value of the **Interval** parameter. If you set the **TimeMerge** parameter to **1**, the value of the **Interval** parameter is automatically assigned based on the **StartTime** and **EndTime** parameters. You can set this parameter or the **Interval** parameter.', example='1'),
}

model DescribeDcdnDomainIpaTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range that was queried.', example='2017-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The beginning of the time range that was queried.', example='2017-12-10T20:00:00Z'),
  trafficDataPerInterval?: {
    dataModule?: [ 
    {
      ipaTraffic?: float(name='IpaTraffic', description='The total amount of network traffic.', example='423304182'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2017-12-10T20:00:00Z'),
    }
  ](name='DataModule')
  }(name='TrafficDataPerInterval', description='The monitoring data of network traffic that was collected at each interval.'),
}

model DescribeDcdnDomainIpaTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainIpaTrafficDataResponseBody(name='body'),
}

/**
  * > 
  * *   If you do not set **StartTime** or **EndTime**, data collected within the last 24 hours is queried. If you set both **StartTime** and **EndTime**, data collected within the specified time range is queried.
  * *   The monitoring data is measured in bytes.
  * *   The maximum number of times that users can call this operation per second is 100.
  *
  * @param request DescribeDcdnDomainIpaTrafficDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainIpaTrafficDataResponse
 */
async function describeDcdnDomainIpaTrafficDataWithOptions(request: DescribeDcdnDomainIpaTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainIpaTrafficDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.fixTimeGap)) {
    query['FixTimeGap'] = request.fixTimeGap;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeMerge)) {
    query['TimeMerge'] = request.timeMerge;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainIpaTrafficData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   If you do not set **StartTime** or **EndTime**, data collected within the last 24 hours is queried. If you set both **StartTime** and **EndTime**, data collected within the specified time range is queried.
  * *   The monitoring data is measured in bytes.
  * *   The maximum number of times that users can call this operation per second is 100.
  *
  * @param request DescribeDcdnDomainIpaTrafficDataRequest
  * @return DescribeDcdnDomainIpaTrafficDataResponse
 */
async function describeDcdnDomainIpaTrafficData(request: DescribeDcdnDomainIpaTrafficDataRequest): DescribeDcdnDomainIpaTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainIpaTrafficDataWithOptions(request, runtime);
}

model DescribeDcdnDomainIspDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name in each request.

If you do not specify an accelerated domain name, the data of all accelerated domain names that belong to your account is queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2019-12-06T12:00:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2019-12-05T12:00:00Z'),
}

model DescribeDcdnDomainIspDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='86400'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2019-12-06T12:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2E5AD83F-BD7B-462E-8319-2E30E305519A'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2019-12-05T12:00:00Z'),
  value?: {
    ispProportionData?: [ 
    {
      avgObjectSize?: string(name='AvgObjectSize', description='The average response size. Unit: bytes.', example='800019.0'),
      avgResponseRate?: string(name='AvgResponseRate', description='The average response speed. Unit: byte/ms.', example='154.3345765545624'),
      avgResponseTime?: string(name='AvgResponseTime', description='The average response time. Unit: milliseconds.', example='5183.666666666667'),
      bps?: string(name='Bps', description='The bandwidth.', example='380.9614285714286'),
      bytesProportion?: string(name='BytesProportion', description='The proportion of network traffic. For example, a value of 90 indicates that 90% of network traffic was coming from the specified ISP.', example='0.003544181046236794'),
      isp?: string(name='Isp', description='The information about the ISP.'),
      ispEname?: string(name='IspEname', description='The name of the ISP.', example='unicom'),
      proportion?: string(name='Proportion', description='The proportion of requests.', example='0.01155980271270037'),
      qps?: string(name='Qps', description='The number of queries per second.', example='5.9523809523809524E-5'),
      totalBytes?: string(name='TotalBytes', description='The total amount of network traffic.', example='2400057'),
      totalQuery?: string(name='TotalQuery', description='The total number of requests.', example='3'),
    }
  ](name='IspProportionData')
  }(name='Value', description='The access statistics by ISP.'),
}

model DescribeDcdnDomainIspDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainIspDataResponseBody(name='body'),
}

/**
  * > 
  * *   You can call this operation up to 100 times per second.
  * *   If **StartTime** is set but **EndTime** is not set, the data within the hour that starts from **StartTime** is queried.
  * *   If **EndTime** is set but **StartTime** is not set, the data within the last hour that precedes **EndTime** is queried.
  * *   You can query data of a domain name or all domain names that belong to your account.
  * *   You can view data that is collected over the last seven days. The interval at which data is queried is based on the time range specified by **StartTime** and **EndTime**.
  *     *   **If the time range is shorter than or equal to one hour**, data is queried every minute.
  *     *   **If the time range is longer than 1 hour but shorter than or equal to three days**, data is queried every five minutes.
  *     *   **If the time range is longer than three days but shorter than or equal to seven days**, data is queried every hour.
  *
  * @param request DescribeDcdnDomainIspDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainIspDataResponse
 */
async function describeDcdnDomainIspDataWithOptions(request: DescribeDcdnDomainIspDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainIspDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainIspData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can call this operation up to 100 times per second.
  * *   If **StartTime** is set but **EndTime** is not set, the data within the hour that starts from **StartTime** is queried.
  * *   If **EndTime** is set but **StartTime** is not set, the data within the last hour that precedes **EndTime** is queried.
  * *   You can query data of a domain name or all domain names that belong to your account.
  * *   You can view data that is collected over the last seven days. The interval at which data is queried is based on the time range specified by **StartTime** and **EndTime**.
  *     *   **If the time range is shorter than or equal to one hour**, data is queried every minute.
  *     *   **If the time range is longer than 1 hour but shorter than or equal to three days**, data is queried every five minutes.
  *     *   **If the time range is longer than three days but shorter than or equal to seven days**, data is queried every hour.
  *
  * @param request DescribeDcdnDomainIspDataRequest
  * @return DescribeDcdnDomainIspDataResponse
 */
async function describeDcdnDomainIspData(request: DescribeDcdnDomainIspDataRequest): DescribeDcdnDomainIspDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainIspDataWithOptions(request, runtime);
}

model DescribeDcdnDomainLogRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name that you want to query. You can specify only one domain name in each call.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2021-11-07T18:00:00Z'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page **1**.

Default value: **1**.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page.

Valid values: **1** to **1000**. Default value: **300**. Maximum value: **1000**.', example='300'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-11-07T17:00:00Z'),
}

model DescribeDcdnDomainLogResponseBody = {
  domainLogDetails?: {
    domainLogDetail?: [ 
    {
      logCount?: long(name='LogCount', description='The total number of entries returned on the current page.', example='4'),
      logInfos?: {
        logInfoDetail?: [ 
        {
          endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2021-11-07T18:00:00Z'),
          logName?: string(name='LogName', description='The name of the log file.', example='example.com_2021_11_08_010000_020000.gz'),
          logPath?: string(name='LogPath', description='The path of the log file.

Take note of the Expires field (expiration timestamp) in the response parameter LogPath. If the log download URL expires, you must obtain it again. For more information, see [LogPath field](~~31952~~).', example='example.aliyundoc.com /v1.l1cache/105252530/example.com/2021_11_08/example.com_2021_11_08_010000_020000.gz?Expires=1636963354&OSSAccessKeyId=LTAIviCc6zy8****&Signature=u0V6foRfZniHE8i%2BHUdxGOhZsK****'),
          logSize?: long(name='LogSize', description='The size of the log file. Unit: bytes.', example='192'),
          startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2021-11-07T17:00:00Z'),
        }
      ](name='LogInfoDetail')
      }(name='LogInfos', description='The log information. The log information is indicated by the LogInfoDetail parameter.'),
      pageInfos?: {
        pageIndex?: long(name='PageIndex', description='The page number of the returned page.', example='1'),
        pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='10'),
        total?: long(name='Total', description='The total number of entries returned.', example='4'),
      }(name='PageInfos', description='The page information. The page information is indicated by the PageInfoDetail parameter.'),
    }
  ](name='DomainLogDetail')
  }(name='DomainLogDetails', description='The log information. The log information is indicated by the DomainLogDetail parameter.'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='95594003-CAC5-5636-AF72-2A094364****'),
}

model DescribeDcdnDomainLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainLogResponseBody(name='body'),
}

/**
  * > 
  * *   If you specify neither the **StartTime** parameter nor the **EndTime** parameter, the data in the last 24 hours is returned. If you specify the **StartTime** and **EndTime** parameters, the data within the specified time range is returned.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnDomainLogRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainLogResponse
 */
async function describeDcdnDomainLogWithOptions(request: DescribeDcdnDomainLogRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainLog',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   If you specify neither the **StartTime** parameter nor the **EndTime** parameter, the data in the last 24 hours is returned. If you specify the **StartTime** and **EndTime** parameters, the data within the specified time range is returned.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnDomainLogRequest
  * @return DescribeDcdnDomainLogResponse
 */
async function describeDcdnDomainLog(request: DescribeDcdnDomainLogRequest): DescribeDcdnDomainLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainLogWithOptions(request, runtime);
}

model DescribeDcdnDomainMultiUsageDataRequest {
  domainName?: string(name='DomainName', description='If this parameter is not set, data of all your accelerated domain names is queried.

You can specify one or more accelerated domain names. Separate domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end time must be later than the start time.

*   Specify the time in the ISO 8601 standard
*   in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.
*   You must set both the start time and the end time.', example='2017-12-10T21:00:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

*   Specify the time in the ISO 8601 standard
*   in the yyyy-MM-ddTHH:mm:ssZ format . The time must be in UTC.
*   The minimum time interval at which data is collected is 5 minutes.
*   If you do not specify a start time, data within the last 24 hours is queried.
*   You must set both the start time and the end time.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainMultiUsageDataResponseBody = {
  endTime?: string(name='EndTime', description='The end of the time range that was queried.', example='2017-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F'),
  requestPerInterval?: {
    requestDataModule?: [ 
    {
      domain?: string(name='Domain', description='The accelerated domain name.', example='example.com'),
      request?: long(name='Request', description='The number of requests.', example='1128'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data entry.', example='2017-12-10T20:00:00Z'),
      type?: string(name='Type', description='The type of the requests. Valid values: StaticHttps, DynamicHttps, DynamicHttp, StaticQuic, and DynamicQuic.', example='DynamicHttp'),
    }
  ](name='RequestDataModule')
  }(name='RequestPerInterval', description='The information about requests collected every 5 minutes.'),
  startTime?: string(name='StartTime', description='The beginning of the time range that was queried.', example='2017-12-10T20:00:00Z'),
  trafficPerInterval?: {
    trafficDataModule?: [ 
    {
      area?: string(name='Area', description='The name of the district.', example='CN'),
      bps?: float(name='Bps', description='The number of bits per second.', example='11288111.1'),
      domain?: string(name='Domain', description='The accelerated domain name.', example='example.com'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data entry.', example='2017-12-10T20:00:00Z'),
      type?: string(name='Type', description='The type of the network traffic. Valid values: Simple, IPA, and WebSocket.', example='Simple'),
    }
  ](name='TrafficDataModule')
  }(name='TrafficPerInterval', description='The statistics of network traffic collected every 5 minutes.'),
}

model DescribeDcdnDomainMultiUsageDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainMultiUsageDataResponseBody(name='body'),
}

/**
  * When you call this operation, take note of the following rules:
  * *   If you do not set the StartTime or EndTime parameter, data within the last 10 minutes is queried. You can set both the StartTime and EndTime parameters to specify a time range.
  * *   You can specify one or more accelerated domain names. Separate domain names with commas (,).
  * *   You can query data up to the last 90 days.
  * *   The time range cannot exceed 1 hour.
  *
  * @param request DescribeDcdnDomainMultiUsageDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainMultiUsageDataResponse
 */
async function describeDcdnDomainMultiUsageDataWithOptions(request: DescribeDcdnDomainMultiUsageDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainMultiUsageDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainMultiUsageData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * When you call this operation, take note of the following rules:
  * *   If you do not set the StartTime or EndTime parameter, data within the last 10 minutes is queried. You can set both the StartTime and EndTime parameters to specify a time range.
  * *   You can specify one or more accelerated domain names. Separate domain names with commas (,).
  * *   You can query data up to the last 90 days.
  * *   The time range cannot exceed 1 hour.
  *
  * @param request DescribeDcdnDomainMultiUsageDataRequest
  * @return DescribeDcdnDomainMultiUsageDataResponse
 */
async function describeDcdnDomainMultiUsageData(request: DescribeDcdnDomainMultiUsageDataRequest): DescribeDcdnDomainMultiUsageDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainMultiUsageDataWithOptions(request, runtime);
}

model DescribeDcdnDomainOriginBpsDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> The end time must be later than the start time.', example='2019-12-11T00:00:00Z'),
  interval?: string(name='Interval', description='The time granularity for a query. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.', example='300'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2019-12-10T00:00:00Z'),
}

model DescribeDcdnDomainOriginBpsDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2019-12-11T00:00:00Z'),
  originBpsDataPerInterval?: {
    dataModule?: [ 
    {
      dynamicHttpOriginBps?: float(name='DynamicHttpOriginBps', description='The bandwidth that was consumed for fetching dynamic content from the origin over HTTP.', example='100'),
      dynamicHttpsOriginBps?: float(name='DynamicHttpsOriginBps', description='The bandwidth that was consumed for fetching dynamic content from the origin over HTTPS.', example='100'),
      originBps?: float(name='OriginBps', description='The bandwidth that was consumed for fetching content from the origin.', example='100'),
      staticHttpOriginBps?: float(name='StaticHttpOriginBps', description='The bandwidth that was consumed for fetching static content from the origin over HTTP.', example='100'),
      staticHttpsOriginBps?: float(name='StaticHttpsOriginBps', description='The bandwidth that was consumed for fetching static content from the origin over HTTPS.', example='100'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2019-12-10T00:00:00Z'),
    }
  ](name='DataModule')
  }(name='OriginBpsDataPerInterval', description='The origin bandwidth data returned at each time interval. Unit: bit/s.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7CBCD6AD-B016-42E5-AE0B-B3731DE8F755'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried.', example='2019-12-10T00:00:00Z'),
}

model DescribeDcdnDomainOriginBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainOriginBpsDataResponseBody(name='body'),
}

/**
  * * You can call this operation up to 100 times per second per account.
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainOriginBpsDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainOriginBpsDataResponse
 */
async function describeDcdnDomainOriginBpsDataWithOptions(request: DescribeDcdnDomainOriginBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainOriginBpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainOriginBpsData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * * You can call this operation up to 100 times per second per account.
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainOriginBpsDataRequest
  * @return DescribeDcdnDomainOriginBpsDataResponse
 */
async function describeDcdnDomainOriginBpsData(request: DescribeDcdnDomainOriginBpsDataRequest): DescribeDcdnDomainOriginBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainOriginBpsDataWithOptions(request, runtime);
}

model DescribeDcdnDomainOriginTrafficDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.', example='300'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainOriginTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2017-12-10T21:00:00Z'),
  originTrafficDataPerInterval?: {
    dataModule?: [ 
    {
      dynamicHttpOriginTraffic?: float(name='DynamicHttpOriginTraffic', description='The amount of back-to-origin traffic that was consumed to deliver dynamic content over HTTP.', example='1000'),
      dynamicHttpsOriginTraffic?: float(name='DynamicHttpsOriginTraffic', description='The amount of back-to-origin traffic that was consumed to deliver dynamic content over HTTPS.', example='500'),
      originTraffic?: float(name='OriginTraffic', description='The amount of back-to-origin traffic.', example='100'),
      staticHttpOriginTraffic?: float(name='StaticHttpOriginTraffic', description='The amount of back-to-origin traffic that was consumed to deliver static content over HTTP.', example='0'),
      staticHttpsOriginTraffic?: float(name='StaticHttpsOriginTraffic', description='The amount of back-to-origin traffic that was consumed to deliver static content over HTTPS.', example='100'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2017-12-10T21:00:00Z'),
    }
  ](name='DataModule')
  }(name='OriginTrafficDataPerInterval', description='The amount of back-to-origin traffic returned at each time interval. Unit: bytes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A666D44F-19D6-490E-97CF-1A64AB962C57'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainOriginTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainOriginTrafficDataResponseBody(name='body'),
}

/**
  * - You can call this operation up to 100 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameters, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainOriginTrafficDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainOriginTrafficDataResponse
 */
async function describeDcdnDomainOriginTrafficDataWithOptions(request: DescribeDcdnDomainOriginTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainOriginTrafficDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainOriginTrafficData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 100 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameters, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainOriginTrafficDataRequest
  * @return DescribeDcdnDomainOriginTrafficDataResponse
 */
async function describeDcdnDomainOriginTrafficData(request: DescribeDcdnDomainOriginTrafficDataRequest): DescribeDcdnDomainOriginTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainOriginTrafficDataWithOptions(request, runtime);
}

model DescribeDcdnDomainPropertyRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name that you want to query. You can specify only one domain name in each call.', example='example.com'),
}

model DescribeDcdnDomainPropertyResponseBody = {
  domainName?: string(name='DomainName', description='The accelerated domain name that is queried.', example='example.com'),
  protocol?: string(name='Protocol', description='The name of the protocol. Valid values:

*   **udp**: User Datagram Protocol (UDP)
*   **tcp**: Transmission Control Protocol (TCP)', example='udp'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34AB41F1-04A5-496F-8C8D-634BDBE6A9FB'),
}

model DescribeDcdnDomainPropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainPropertyResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 10.
  *
  * @param request DescribeDcdnDomainPropertyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainPropertyResponse
 */
async function describeDcdnDomainPropertyWithOptions(request: DescribeDcdnDomainPropertyRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainProperty',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 10.
  *
  * @param request DescribeDcdnDomainPropertyRequest
  * @return DescribeDcdnDomainPropertyResponse
 */
async function describeDcdnDomainProperty(request: DescribeDcdnDomainPropertyRequest): DescribeDcdnDomainPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainPropertyWithOptions(request, runtime);
}

model DescribeDcdnDomainPvDataRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain. You can specify only one domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2019-11-29T00:00:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2019-11-28T00:00:00Z'),
}

model DescribeDcdnDomainPvDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The data collection interval. Unit: second.', example='3600'),
  domainName?: string(name='DomainName', description='The name of the accelerated domain for which the data was returned.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was collected.', example='2019-11-29T00:00:00Z'),
  pvDataInterval?: {
    usageData?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2015-11-28T03:00:00Z'),
      value?: string(name='Value', description='The consumed network traffic.', example='9292'),
    }
  ](name='UsageData')
  }(name='PvDataInterval', description='The number of PVs at each interval.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BCD7D917-76F1-442F-BB75-C810DE34C761'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was collected.', example='2019-11-28T00:00:00Z'),
}

model DescribeDcdnDomainPvDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainPvDataResponseBody(name='body'),
}

async function describeDcdnDomainPvDataWithOptions(request: DescribeDcdnDomainPvDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainPvDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainPvData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDcdnDomainPvData(request: DescribeDcdnDomainPvDataRequest): DescribeDcdnDomainPvDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainPvDataWithOptions(request, runtime);
}

model DescribeDcdnDomainQpsDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.

Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  interval?: string(name='Interval', description='The time granularity for a query. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainQpsDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2017-12-10T21:00:00Z'),
  qpsDataPerInterval?: {
    dataModule?: [ 
    {
      acc?: float(name='Acc', description='The total number of requests.', example='100'),
      dynamicHttpAcc?: float(name='DynamicHttpAcc', description='The number of requests for dynamic content delivery over HTTP.', example='0'),
      dynamicHttpQps?: float(name='DynamicHttpQps', description='The QPS for dynamic content delivery over HTTP.', example='0'),
      dynamicHttpsAcc?: float(name='DynamicHttpsAcc', description='The number of requests for dynamic content delivery over HTTPS.', example='0'),
      dynamicHttpsQps?: float(name='DynamicHttpsQps', description='The QPS for dynamic content delivery over HTTPS.', example='0'),
      qps?: float(name='Qps', description='The total QPS.', example='0.56'),
      staticHttpAcc?: float(name='StaticHttpAcc', description='The number of requests for static content delivery over HTTP.', example='0'),
      staticHttpQps?: float(name='StaticHttpQps', description='The QPS for static content delivery over HTTP.', example='0'),
      staticHttpsAcc?: float(name='StaticHttpsAcc', description='The number of requests for static content delivery over HTTPS.', example='0'),
      staticHttpsQps?: float(name='StaticHttpsQps', description='The QPS for static content delivery over HTTPS.', example='0'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2017-12-10T21:00:00Z'),
    }
  ](name='DataModule')
  }(name='QpsDataPerInterval', description='The QPS returned at each time interval.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BEA5625F-8FCF-48F4-851B-CA63946DA664'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainQpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainQpsDataResponseBody(name='body'),
}

/**
  * * You can call this operation up to 100 times per second per account.
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainQpsDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainQpsDataResponse
 */
async function describeDcdnDomainQpsDataWithOptions(request: DescribeDcdnDomainQpsDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainQpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainQpsData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * * You can call this operation up to 100 times per second per account.
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainQpsDataRequest
  * @return DescribeDcdnDomainQpsDataResponse
 */
async function describeDcdnDomainQpsData(request: DescribeDcdnDomainQpsDataRequest): DescribeDcdnDomainQpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainQpsDataWithOptions(request, runtime);
}

model DescribeDcdnDomainQpsDataByLayerRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify multiple domain names and separate them with commas (,). You can specify up to 500 domain names in each request. The query results of multiple domain names are aggregated.

If you do not specify a domain name, data of all domain names is queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2015-12-10T21:00:00Z'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the ISP. You can call the DescribeDcdnRegionAndIsp operation to query the ISP name. If you do not specify a value for this parameter, all ISPs are queried.', example='telecom'),
  layer?: string(name='Layer', description='The layers at which you want to query the QPS. The network layer supports IPv4 and IPv6. The application layer supports http, https, and quic. You can also set the value to all.

Default value: all.', example='all'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. You can call the DescribeDcdnRegionAndIsp operation to query the region name. If you do not specify a value for this parameter, all regions are queried.', example='hangzhou'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The minimum data granularity is 5 minutes.

If you do not set this parameter, data in the last 24 hours is queried.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainQpsDataByLayerResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2015-12-10T21:00:00Z'),
  layer?: string(name='Layer', description='The layer at which the data was collected.', example='all'),
  qpsDataInterval?: {
    dataModule?: [ 
    {
      accDomesticValue?: string(name='AccDomesticValue', description='The number of requests in the Chinese mainland.', example='12'),
      accOverseasValue?: string(name='AccOverseasValue', description='The number of requests outside the Chinese mainland.', example='44'),
      accValue?: string(name='AccValue', description='The total number of requests.', example='56'),
      domesticValue?: string(name='DomesticValue', description='The number of queries per second in the Chinese mainland.', example='0.12'),
      overseasValue?: string(name='OverseasValue', description='The number of queries per second outside the Chinese mainland.', example='0.44'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2015-12-10T21:00:00Z'),
      value?: string(name='Value', description='The total number of queries per second.', example='0.56'),
    }
  ](name='DataModule')
  }(name='QpsDataInterval', description='The QPS returned at each time interval.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BEA5625F-8FCF-48F4-851B-CA63946DA664'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainQpsDataByLayerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainQpsDataByLayerResponseBody(name='body'),
}

/**
  * - You can call this operation up to 20 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainQpsDataByLayerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainQpsDataByLayerResponse
 */
async function describeDcdnDomainQpsDataByLayerWithOptions(request: DescribeDcdnDomainQpsDataByLayerRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainQpsDataByLayerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.layer)) {
    query['Layer'] = request.layer;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainQpsDataByLayer',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 20 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainQpsDataByLayerRequest
  * @return DescribeDcdnDomainQpsDataByLayerResponse
 */
async function describeDcdnDomainQpsDataByLayer(request: DescribeDcdnDomainQpsDataByLayerRequest): DescribeDcdnDomainQpsDataByLayerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainQpsDataByLayerWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeBpsDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2018-01-02T11:00:00Z'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='telecom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-01-02T11:00:00Z'),
}

model DescribeDcdnDomainRealTimeBpsDataResponseBody = {
  data?: {
    bpsModel?: [ 
    {
      bps?: float(name='Bps', description='The bandwidth, in bit/s.', example='16710625.733333332'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.', example='2018-01-02T11:05:00Z'),
    }
  ](name='BpsModel')
  }(name='Data', description='The list of the data returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B49E6DDA-F413-422B-B58E-2FA23F286726'),
}

model DescribeDcdnDomainRealTimeBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeBpsDataResponseBody(name='body'),
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeBpsDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeBpsDataResponse
 */
async function describeDcdnDomainRealTimeBpsDataWithOptions(request: DescribeDcdnDomainRealTimeBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeBpsDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeBpsData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeBpsDataRequest
  * @return DescribeDcdnDomainRealTimeBpsDataResponse
 */
async function describeDcdnDomainRealTimeBpsData(request: DescribeDcdnDomainRealTimeBpsDataRequest): DescribeDcdnDomainRealTimeBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeBpsDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeByteHitRateDataRequest {
  domainName?: string(name='DomainName', description='The domain name. Separate multiple domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeByteHitRateDataResponseBody = {
  data?: {
    byteHitRateDataModel?: [ 
    {
      byteHitRate?: float(name='ByteHitRate', description='The byte hit ratio.', example='0.8956940476262277'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.', example='2016-10-20T04:00:00Z'),
    }
  ](name='ByteHitRateDataModel')
  }(name='Data', description='The list of byte hit ratios.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
}

model DescribeDcdnDomainRealTimeByteHitRateDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeByteHitRateDataResponseBody(name='body'),
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeByteHitRateDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeByteHitRateDataResponse
 */
async function describeDcdnDomainRealTimeByteHitRateDataWithOptions(request: DescribeDcdnDomainRealTimeByteHitRateDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeByteHitRateDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeByteHitRateData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeByteHitRateDataRequest
  * @return DescribeDcdnDomainRealTimeByteHitRateDataResponse
 */
async function describeDcdnDomainRealTimeByteHitRateData(request: DescribeDcdnDomainRealTimeByteHitRateDataRequest): DescribeDcdnDomainRealTimeByteHitRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeByteHitRateDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeDetailDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> The end time must be later than the start time, and the maximum time range to query is 10 minutes.', example='2019-11-30T05:40:00Z'),
  field?: string(name='Field', description='The type of the information that you want to query. Separate multiple types with commas (,). Valid values:

*   **qps**: queries per second
*   **bps**: bandwidth
*   **http_code**: HTTP status code', example='bps'),
  ispNameEn?: string(name='IspNameEn', description='The name of the ISP. You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query the ISP name.

If you do not specify a value for this parameter, all ISPs are queried.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query the region name.

If you do not specify a value for this parameter, all regions are queried.', example='beijing'),
  merge?: string(name='Merge', description='Specifies whether to return a summary value. Valid values:

*   **true**: yes
*   **false**: no

The default value is **false**.', example='true'),
  mergeLocIsp?: string(name='MergeLocIsp', description='Specifies whether to return a summary value of **LocationNameEn** and **IspNameEn**. Valid values:

*   **true**: yes
*   **false**: no

The default value is **false**.', example='true'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2019-11-30T05:33:00Z'),
}

model DescribeDcdnDomainRealTimeDetailDataResponseBody = {
  data?: string(name='Data', description='The information returned.', example='{ 			"time_stp": "2020-01-06T04:17:00Z", 			"bps": "297.29333333333335", 			"domain_name": "example.com" 		}'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A603F324-7A05-4FB3-ADF3-2563233D26CC'),
}

model DescribeDcdnDomainRealTimeDetailDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeDetailDataResponseBody(name='body'),
}

/**
  * > You can call this operation up to 10 times per second per account.
  * **Time granularity of general data returned by the operation**
  * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |1 minute|1 hour|7 days|5 minutes|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * Unless otherwise specified, statistics in the preceding table prevail.
  *
  * @param request DescribeDcdnDomainRealTimeDetailDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeDetailDataResponse
 */
async function describeDcdnDomainRealTimeDetailDataWithOptions(request: DescribeDcdnDomainRealTimeDetailDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeDetailDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeDetailData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can call this operation up to 10 times per second per account.
  * **Time granularity of general data returned by the operation**
  * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |1 minute|1 hour|7 days|5 minutes|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * Unless otherwise specified, statistics in the preceding table prevail.
  *
  * @param request DescribeDcdnDomainRealTimeDetailDataRequest
  * @return DescribeDcdnDomainRealTimeDetailDataResponse
 */
async function describeDcdnDomainRealTimeDetailData(request: DescribeDcdnDomainRealTimeDetailDataRequest): DescribeDcdnDomainRealTimeDetailDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeDetailDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeHttpCodeDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeHttpCodeDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='60'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2017-12-10T21:00:00Z'),
  realTimeHttpCodeData?: {
    usageData?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2017-12-10T20:00:00Z'),
      value?: {
        realTimeCodeProportionData?: [ 
        {
          code?: string(name='Code', description='The HTTP status code returned.', example='200'),
          count?: string(name='Count', description='The total number of entries.', example='1'),
          proportion?: string(name='Proportion', description='The proportion of the HTTP status code.', example='0.01155980271270037'),
        }
      ](name='RealTimeCodeProportionData')
      }(name='Value', description='The information about the HTTP status code returned.'),
    }
  ](name='UsageData')
  }(name='RealTimeHttpCodeData', description='The proportions of the HTTP status codes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeHttpCodeDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeHttpCodeDataResponseBody(name='body'),
}

/**
  * * You can call this operation up to 10 times per second per account.
  * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |1 minute|1 hour|7 days|5 minutes|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  *
  * @param request DescribeDcdnDomainRealTimeHttpCodeDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeHttpCodeDataResponse
 */
async function describeDcdnDomainRealTimeHttpCodeDataWithOptions(request: DescribeDcdnDomainRealTimeHttpCodeDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeHttpCodeDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeHttpCodeData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * * You can call this operation up to 10 times per second per account.
  * * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |1 minute|1 hour|7 days|5 minutes|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  *
  * @param request DescribeDcdnDomainRealTimeHttpCodeDataRequest
  * @return DescribeDcdnDomainRealTimeHttpCodeDataResponse
 */
async function describeDcdnDomainRealTimeHttpCodeData(request: DescribeDcdnDomainRealTimeHttpCodeDataRequest): DescribeDcdnDomainRealTimeHttpCodeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeHttpCodeDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeQpsDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2018-01-02T11:27:00Z'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='telecom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-01-02T11:26:00Z'),
}

model DescribeDcdnDomainRealTimeQpsDataResponseBody = {
  data?: {
    qpsModel?: [ 
    {
      qps?: float(name='Qps', description='The QPS data.', example='1851.25'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.', example='2018-01-02T11:26:00Z'),
    }
  ](name='QpsModel')
  }(name='Data', description='The list of the data returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='32DC9806-E9F9-4490-BBDC-B3A9E32FCC1D'),
}

model DescribeDcdnDomainRealTimeQpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeQpsDataResponseBody(name='body'),
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeQpsDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeQpsDataResponse
 */
async function describeDcdnDomainRealTimeQpsDataWithOptions(request: DescribeDcdnDomainRealTimeQpsDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeQpsDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeQpsData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeQpsDataRequest
  * @return DescribeDcdnDomainRealTimeQpsDataResponse
 */
async function describeDcdnDomainRealTimeQpsData(request: DescribeDcdnDomainRealTimeQpsDataRequest): DescribeDcdnDomainRealTimeQpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeQpsDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeReqHitRateDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The end time must be later than the start time.', example='2019-12-10T20:03:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2019-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeReqHitRateDataResponseBody = {
  data?: {
    reqHitRateDataModel?: [ 
    {
      reqHitRate?: float(name='ReqHitRate', description='The request hit ratio.', example='0.8956940476262277'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.', example='2016-10-20T04:00:00Z'),
    }
  ](name='ReqHitRateDataModel')
  }(name='Data', description='The list of request hit ratios.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
}

model DescribeDcdnDomainRealTimeReqHitRateDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeReqHitRateDataResponseBody(name='body'),
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeReqHitRateDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeReqHitRateDataResponse
 */
async function describeDcdnDomainRealTimeReqHitRateDataWithOptions(request: DescribeDcdnDomainRealTimeReqHitRateDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeReqHitRateDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeReqHitRateData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - The network traffic destined for different domain names may be redirected to the same origin server. Therefore, the byte hit ratios may be inaccurate. The accuracy of query results is based on the actual configurations.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeReqHitRateDataRequest
  * @return DescribeDcdnDomainRealTimeReqHitRateDataResponse
 */
async function describeDcdnDomainRealTimeReqHitRateData(request: DescribeDcdnDomainRealTimeReqHitRateDataRequest): DescribeDcdnDomainRealTimeReqHitRateDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeReqHitRateDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeSrcBpsDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The end time must be later than the start time.', example='2015-12-10T20:01:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeSrcBpsDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600(1 hour). For more information, see **Description**.', example='60'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2015-12-10T20:01:00Z'),
  realTimeSrcBpsDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2015-12-10T20:01:00Z'),
      value?: string(name='Value', description='The bandwidth data during back-to-origin routing.', example='0'),
    }
  ](name='DataModule')
  }(name='RealTimeSrcBpsDataPerInterval', description='The back-to-origin bandwidth data returned at each time interval. Unit: bit/s.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7CBCD6AD-B016-42E5-AE0B-B3731DE8F755'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeSrcBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeSrcBpsDataResponseBody(name='body'),
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeSrcBpsDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeSrcBpsDataResponse
 */
async function describeDcdnDomainRealTimeSrcBpsDataWithOptions(request: DescribeDcdnDomainRealTimeSrcBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeSrcBpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeSrcBpsData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeSrcBpsDataRequest
  * @return DescribeDcdnDomainRealTimeSrcBpsDataResponse
 */
async function describeDcdnDomainRealTimeSrcBpsData(request: DescribeDcdnDomainRealTimeSrcBpsDataRequest): DescribeDcdnDomainRealTimeSrcBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeSrcBpsDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com,example.org'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2019-11-30T05:40:00Z'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2019-11-30T05:39:00Z'),
}

model DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='60'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com,example.org'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.

The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.', example='2019-11-30T05:40:00Z'),
  realTimeSrcHttpCodeData?: {
    usageData?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2019-11-30T05:40:00Z'),
      value?: {
        realTimeSrcCodeProportionData?: [ 
        {
          code?: string(name='Code', description='The HTTP status code.', example='200'),
          count?: string(name='Count', description='The number of HTTP status codes.', example='2'),
          proportion?: string(name='Proportion', description='The proportion of the HTTP status code.', example='66.046511627907'),
        }
      ](name='RealTimeSrcCodeProportionData')
      }(name='Value', description='The proportions of HTTP status codes.'),
    }
  ](name='UsageData')
  }(name='RealTimeSrcHttpCodeData', description='The proportions of HTTP status codes at each time interval.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC858082-736F-4A25-867B-E5B67C85ACF7'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried. 

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2019-11-30T05:33:00Z'),
}

model DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeSrcHttpCodeDataResponseBody(name='body'),
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - If you do not set the StartTime or EndTime parameter, data collected over the last one hour is queried. If you set both the StartTime and EndTime parameters, data collected within the specified time range is queried.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse
 */
async function describeDcdnDomainRealTimeSrcHttpCodeDataWithOptions(request: DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeSrcHttpCodeData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 10 times per second per account.
  * - If you do not set the StartTime or EndTime parameter, data collected over the last one hour is queried. If you set both the StartTime and EndTime parameters, data collected within the specified time range is queried.
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest
  * @return DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse
 */
async function describeDcdnDomainRealTimeSrcHttpCodeData(request: DescribeDcdnDomainRealTimeSrcHttpCodeDataRequest): DescribeDcdnDomainRealTimeSrcHttpCodeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeSrcHttpCodeDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeSrcTrafficDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The end time must be later than the start time.', example='2015-12-10T20:01:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600(1 hour). For more information, see **Usage notes**.', example='60'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2015-12-10T20:01:00Z'),
  realTimeSrcTrafficDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2015-12-10T20:00:00Z'),
      value?: string(name='Value', description='The traffic value at each time interval.', example='0'),
    }
  ](name='DataModule')
  }(name='RealTimeSrcTrafficDataPerInterval', description='The amount of origin traffic returned at each time interval. Unit: bytes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A666D44F-19D6-490E-97CF-1A64AB962C57'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeSrcTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeSrcTrafficDataResponseBody(name='body'),
}

/**
  * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |1 minute|1 hour|7 days|5 minutes|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  *
  * @param request DescribeDcdnDomainRealTimeSrcTrafficDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeSrcTrafficDataResponse
 */
async function describeDcdnDomainRealTimeSrcTrafficDataWithOptions(request: DescribeDcdnDomainRealTimeSrcTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeSrcTrafficDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeSrcTrafficData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |1 minute|1 hour|7 days|5 minutes|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  *
  * @param request DescribeDcdnDomainRealTimeSrcTrafficDataRequest
  * @return DescribeDcdnDomainRealTimeSrcTrafficDataResponse
 */
async function describeDcdnDomainRealTimeSrcTrafficData(request: DescribeDcdnDomainRealTimeSrcTrafficDataRequest): DescribeDcdnDomainRealTimeSrcTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeSrcTrafficDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRealTimeTrafficDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify one or more domain names and separate them with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time.

>  If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.', example='2015-12-10T20:01:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last hour. If you set both the StartTime and EndTime parameters, the request returns the data collected within the specified time range.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600 (1 hour). For more information, see **Description**.', example='60'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2015-12-10T20:01:00Z'),
  realTimeTrafficDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2015-12-10T20:00:00Z'),
      value?: string(name='Value', description='The amount of back-to-origin network traffic.

>  The network traffic is measured in bytes.', example='0'),
    }
  ](name='DataModule')
  }(name='RealTimeTrafficDataPerInterval', description='The amount of back-to-origin network traffic returned at each interval.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A666D44F-19D6-490E-97CF-1A64AB962C57'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2015-12-10T20:00:00Z'),
}

model DescribeDcdnDomainRealTimeTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRealTimeTrafficDataResponseBody(name='body'),
}

/**
  * You can call this operation up to 50 times per second per account.  
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeTrafficDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRealTimeTrafficDataResponse
 */
async function describeDcdnDomainRealTimeTrafficDataWithOptions(request: DescribeDcdnDomainRealTimeTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRealTimeTrafficDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRealTimeTrafficData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation up to 50 times per second per account.  
  * **Time granularity**The time granularity varies with the time range specified by the StartTime and EndTime parameters. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 1 minute | 1 hour | 7 days | 5 minutes |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  *
  * @param request DescribeDcdnDomainRealTimeTrafficDataRequest
  * @return DescribeDcdnDomainRealTimeTrafficDataResponse
 */
async function describeDcdnDomainRealTimeTrafficData(request: DescribeDcdnDomainRealTimeTrafficDataRequest): DescribeDcdnDomainRealTimeTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRealTimeTrafficDataWithOptions(request, runtime);
}

model DescribeDcdnDomainRegionDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name.

If you do not specify an accelerated domain name, all accelerated domain names in your account are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2015-12-07T12:00:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2015-12-05T12:00:00Z'),
}

model DescribeDcdnDomainRegionDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The data collection interval. Unit: seconds.', example='86400'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was queried.', example='2015-12-07T12:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2E5AD83F-BD7B-462E-8319-2E30E305519A'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was queried.', example='2015-12-05T12:00:00Z'),
  value?: {
    regionProportionData?: [ 
    {
      avgObjectSize?: string(name='AvgObjectSize', description='The average response size. Unit: bytes.', example='0'),
      avgResponseRate?: string(name='AvgResponseRate', description='The average response speed. Unit: byte/s.', example='0'),
      avgResponseTime?: string(name='AvgResponseTime', description='The average response time. Unit: milliseconds.', example='0'),
      bps?: string(name='Bps', description='The bandwidth.', example='0'),
      bytesProportion?: string(name='BytesProportion', description='The proportion of network traffic occupied by the specified region based on the total amount of network traffic in percentile. For example, a value of 90 indicates that 90% of the network traffic was coming from the specified region.', example='0.003544181046236794'),
      proportion?: string(name='Proportion', description='The proportion of requests from the specified region based on the total number of requests in percentile. For example, a value of 90 indicates that 90% of the requests were coming from the specified region.', example='0'),
      qps?: string(name='Qps', description='The number of queries per second.', example='0'),
      region?: string(name='Region', description='The region.'),
      regionEname?: string(name='RegionEname', description='The name of the region.', example='chongqing'),
      totalBytes?: string(name='TotalBytes', description='The total amount of network traffic.', example='0'),
      totalQuery?: string(name='TotalQuery', description='The total number of requests.', example='0'),
    }
  ](name='RegionProportionData')
  }(name='Value', description='The proportions of requests that were initiated from each region.'),
}

model DescribeDcdnDomainRegionDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainRegionDataResponseBody(name='body'),
}

/**
  * > 
  * *   If you do not specify the StartTime or EndTime parameters, the data within the last 24 hours is queried by default.
  * *   If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
  * *   The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnDomainRegionDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainRegionDataResponse
 */
async function describeDcdnDomainRegionDataWithOptions(request: DescribeDcdnDomainRegionDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainRegionDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainRegionData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   If you do not specify the StartTime or EndTime parameters, the data within the last 24 hours is queried by default.
  * *   If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
  * *   The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnDomainRegionDataRequest
  * @return DescribeDcdnDomainRegionDataResponse
 */
async function describeDcdnDomainRegionData(request: DescribeDcdnDomainRegionDataRequest): DescribeDcdnDomainRegionDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainRegionDataWithOptions(request, runtime);
}

model DescribeDcdnDomainStagingConfigRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain.', example='example.com'),
  functionNames?: string(name='FunctionNames', description='The names of the features to query. You can specify multiple features and separate them with commas (,).', example='aliauth'),
}

model DescribeDcdnDomainStagingConfigResponseBody = {
  domainConfigs?: [ 
    {
      configId?: string(name='ConfigId', description='The ID of the configuration.', example='6295'),
      functionArgs?: [ 
        {
          argName?: string(name='ArgName', description='The name of the configuration.', example='auth_type'),
          argValue?: string(name='ArgValue', description='The value of the configuration.', example='req_auth'),
        }
      ](name='FunctionArgs', description='The descriptions of a feature.'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='aliauth'),
      status?: string(name='Status', description='The status of the feature. Valid values:

*   success
*   testing
*   failed
*   configuring', example='success'),
    }
  ](name='DomainConfigs', description='The configurations of accelerated domain names returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C80705BF-0F76-41FA-BAD1-5B59296A4E59'),
}

model DescribeDcdnDomainStagingConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainStagingConfigResponseBody(name='body'),
}

async function describeDcdnDomainStagingConfigWithOptions(request: DescribeDcdnDomainStagingConfigRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainStagingConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.functionNames)) {
    query['FunctionNames'] = request.functionNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainStagingConfig',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDcdnDomainStagingConfig(request: DescribeDcdnDomainStagingConfigRequest): DescribeDcdnDomainStagingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainStagingConfigWithOptions(request, runtime);
}

model DescribeDcdnDomainTopReferVisitRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name.', example='example.com'),
  sortBy?: string(name='SortBy', description='The method that is used to sort the web pages. Valid values:

*   **traf**: by network traffic.
*   **pv**: by the number of visits.

Default value**: pv**.', example='pv'),
  startTime?: string(name='StartTime', description='The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

To query the data on a specified day, use the yyyy-MM-ddT16:00:00Z format.

If you do not specify this parameter, data collected within the last 24 hours is queried by default.', example='2018-10-03T16:00:00Z'),
}

model DescribeDcdnDomainTopReferVisitResponseBody = {
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='95994621-8382-464B-8762-C708E73568D1'),
  startTime?: string(name='StartTime', description='The start of the time range during which the data is collected.', example='2018-10-03T16:00:00Z'),
  topReferList?: {
    referList?: [ 
    {
      flow?: string(name='Flow', description='The network traffic. Unit: bytes.', example='460486880'),
      flowProportion?: float(name='FlowProportion', description='The proportion of the network traffic.', example='0.35'),
      referDetail?: string(name='ReferDetail', description='The complete referenced URL.', example='192.168.0.1'),
      visitData?: string(name='VisitData', description='The number of visits to the URL.', example='229567'),
      visitProportion?: float(name='VisitProportion', description='The proportion of the visits.', example='0.35'),
    }
  ](name='ReferList')
  }(name='TopReferList', description='The list of frequently referenced URLs returned.'),
}

model DescribeDcdnDomainTopReferVisitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainTopReferVisitResponseBody(name='body'),
}

/**
  * **Before you call this operation, take note of the following considerations:**
  * *   If you do not set the StartTime parameter, the data on the previous day is queried.
  * *   You can specify only one domain name.
  *
  * @param request DescribeDcdnDomainTopReferVisitRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainTopReferVisitResponse
 */
async function describeDcdnDomainTopReferVisitWithOptions(request: DescribeDcdnDomainTopReferVisitRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainTopReferVisitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainTopReferVisit',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **Before you call this operation, take note of the following considerations:**
  * *   If you do not set the StartTime parameter, the data on the previous day is queried.
  * *   You can specify only one domain name.
  *
  * @param request DescribeDcdnDomainTopReferVisitRequest
  * @return DescribeDcdnDomainTopReferVisitResponse
 */
async function describeDcdnDomainTopReferVisit(request: DescribeDcdnDomainTopReferVisitRequest): DescribeDcdnDomainTopReferVisitResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainTopReferVisitWithOptions(request, runtime);
}

model DescribeDcdnDomainTopUrlVisitRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name in each call.', example='example.com'),
  sortBy?: string(name='SortBy', description='The method that is used to sort the web pages. Valid values:

*   **traf**: by network traffic.
*   **pv**: by the number of visits.

Default value: **pv**.', example='pv'),
  startTime?: string(name='StartTime', description='The start of the time range to query.

Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.

To query the data on a specified day, use the format: yyyy-MM-ddT16:00:00Z.

>  If you do not set this parameter, the data within the last 24 hours is queried.', example='2018-10-03T16:00:00Z'),
}

model DescribeDcdnDomainTopUrlVisitResponseBody = {
  allUrlList?: {
    urlList?: [ 
    {
      flow?: string(name='Flow', description='The network traffic that was consumed by visits to the URLs. Unit: bytes.', example='460486880'),
      flowProportion?: float(name='FlowProportion', description='The proportion of network traffic consumed for accessing the URL.', example='0.35'),
      urlDetail?: string(name='UrlDetail', description='The complete string of the URL that was queried.', example='http://example.com/nn_live/nn_x64/a0.m3u8'),
      visitData?: string(name='VisitData', description='The number of visits to the URL.', example='161673'),
      visitProportion?: float(name='VisitProportion', description='The proportion of visits.', example='0.35'),
    }
  ](name='UrlList')
  }(name='AllUrlList', description='A list of frequently requested URLs.'),
  domainName?: string(name='DomainName', description='The accelerated domain name for which the data was returned.', example='example.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='64D28B53-5902-409B-94F6-FD46680144FE'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was collected.', example='2018-10-03T16:00:00Z'),
  url200List?: {
    urlList?: [ 
    {
      flow?: string(name='Flow', description='The network traffic that was consumed by visits to the URLs. Unit: bytes.', example='460486880'),
      flowProportion?: float(name='FlowProportion', description='The proportion of network traffic consumed for accessing the URL.', example='0.35'),
      urlDetail?: string(name='UrlDetail', description='The complete string of the URL that was queried.', example='http://example.com/nn_live/nn_x64/a0.m3u8'),
      visitData?: string(name='VisitData', description='The number of visits to the URL.', example='161673'),
      visitProportion?: float(name='VisitProportion', description='The proportion of visits to the URL.', example='0.35'),
    }
  ](name='UrlList')
  }(name='Url200List', description='A list of URLs for which 2xx status codes were returned.'),
  url300List?: {
    urlList?: [ 
    {
      flow?: string(name='Flow', description='The network traffic that was consumed by visits to the URLs. Unit: bytes.', example='460486880'),
      flowProportion?: float(name='FlowProportion', description='The proportion of network traffic consumed for accessing the URL.', example='0.35'),
      urlDetail?: string(name='UrlDetail', description='The complete string of the URL that was queried.', example='http://example.com/nn_live/nn_x64/a0.m3u8'),
      visitData?: string(name='VisitData', description='The number of visits to the URL.', example='161673'),
      visitProportion?: float(name='VisitProportion', description='The proportion of visits.', example='0.35'),
    }
  ](name='UrlList')
  }(name='Url300List', description='A list of URLs for which 3xx status codes were returned.'),
  url400List?: {
    urlList?: [ 
    {
      flow?: string(name='Flow', description='The network traffic that was consumed by visits to the URLs. Unit: bytes.', example='460486880'),
      flowProportion?: float(name='FlowProportion', description='The proportion of network traffic consumed for accessing the URL.', example='0.35'),
      urlDetail?: string(name='UrlDetail', description='The complete string of the URL that was queried.', example='http://example.com/nn_live/nn_x64/a0.m3u8'),
      visitData?: string(name='VisitData', description='The number of visits to the URL.', example='161673'),
      visitProportion?: float(name='VisitProportion', description='The proportion of visits.', example='0.35'),
    }
  ](name='UrlList')
  }(name='Url400List', description='A list of URLs for which 4xx status codes were returned.'),
  url500List?: {
    urlList?: [ 
    {
      flow?: string(name='Flow', description='The network traffic that was consumed by visits to the URLs. Unit: bytes.', example='460486880'),
      flowProportion?: float(name='FlowProportion', description='The proportion of network traffic consumed for accessing the URL.', example='0.35'),
      urlDetail?: string(name='UrlDetail', description='The complete string of the URL that was queried.', example='http://example.com/nn_live/nn_x64/a0.m3u8'),
      visitData?: string(name='VisitData', description='The number of visits to the URL.', example='161673'),
      visitProportion?: float(name='VisitProportion', description='The proportion of visits.', example='0.35'),
    }
  ](name='UrlList')
  }(name='Url500List', description='A list of URLs for which 5xx status codes were returned.'),
}

model DescribeDcdnDomainTopUrlVisitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainTopUrlVisitResponseBody(name='body'),
}

/**
  * >  You can only query the data within the last seven days.
  *
  * @param request DescribeDcdnDomainTopUrlVisitRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainTopUrlVisitResponse
 */
async function describeDcdnDomainTopUrlVisitWithOptions(request: DescribeDcdnDomainTopUrlVisitRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainTopUrlVisitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainTopUrlVisit',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can only query the data within the last seven days.
  *
  * @param request DescribeDcdnDomainTopUrlVisitRequest
  * @return DescribeDcdnDomainTopUrlVisitResponse
 */
async function describeDcdnDomainTopUrlVisit(request: DescribeDcdnDomainTopUrlVisitRequest): DescribeDcdnDomainTopUrlVisitResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainTopUrlVisitWithOptions(request, runtime);
}

model DescribeDcdnDomainTrafficDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.

Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  interval?: string(name='Interval', description='The time granularity for a query. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2017-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2017-12-10T20:00:00Z'),
  trafficDataPerInterval?: {
    dataModule?: [ 
    {
      dynamicHttpTraffic?: float(name='DynamicHttpTraffic', description='The network traffic that was consumed to deliver dynamic content over HTTP.', example='0'),
      dynamicHttpsTraffic?: float(name='DynamicHttpsTraffic', description='The network traffic that was consumed to deliver dynamic content over HTTPS.', example='0'),
      staticHttpTraffic?: float(name='StaticHttpTraffic', description='The network traffic that was consumed to deliver static content over HTTP.', example='123'),
      staticHttpsTraffic?: float(name='StaticHttpsTraffic', description='The network traffic that was consumed to deliver static content over HTTPS.', example='132'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2017-12-10T20:00:00Z'),
      traffic?: float(name='Traffic', description='The total amount of network traffic.', example='0'),
    }
  ](name='DataModule')
  }(name='TrafficDataPerInterval', description='The network traffic returned at each time interval. Unit: bytes.'),
}

model DescribeDcdnDomainTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainTrafficDataResponseBody(name='body'),
}

/**
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * * You can call this operation up to 100 times per second per account.
  * **Time granularity**
  * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainTrafficDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainTrafficDataResponse
 */
async function describeDcdnDomainTrafficDataWithOptions(request: DescribeDcdnDomainTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainTrafficDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainTrafficData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * * You can call this operation up to 100 times per second per account.
  * **Time granularity**
  * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainTrafficDataRequest
  * @return DescribeDcdnDomainTrafficDataResponse
 */
async function describeDcdnDomainTrafficData(request: DescribeDcdnDomainTrafficDataRequest): DescribeDcdnDomainTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainTrafficDataWithOptions(request, runtime);
}

model DescribeDcdnDomainUsageDataRequest {
  area?: string(name='Area', description='The billable region. Valid values:

*   **CN**: Chinese mainland
*   **OverSeas**: outside the Chinese mainland
*   **AP1**: Asia Pacific 1
*   **AP2**: Asia Pacific 2
*   **AP3**: Asia Pacific 3
*   **NA**: North America
*   **SA**: South America
*   **EU**: Europe
*   **MEAA**: Middle East and Africa
*   **all**: all the preceding billable regions

Default value: **CN**', example='CN'),
  dataProtocol?: string(name='DataProtocol', description='The protocol of the data that you want query. Valid values:

*   **quic**: Quick UDP Internet Connections (QUIC)
*   **https**: HTTPS
*   **http**: HTTP
*   **all**: HTTP, HTTPS, and QUIC

Default value: **all**', example='all'),
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify up to 100 domain names in each request. Separate multiple domain names with commas (,).

> If you do not specify this parameter, the usage data of all accelerated domain names that belong to your Alibaba Cloud account is returned.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> The end time must be later than the start time. The maximum time range that can be queried is 31 days.', example='2015-12-10T22:00:00Z'),
  field?: string(name='Field', description='The type of data that you want to query. Valid values:

*   **bps**: bandwidth
*   **traf**: traffic
*   **acc**: requests

> If the value is set to **acc**, the **Area** parameter is not supported.', example='bps'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.', example='300'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> The minimum time granularity at which the data is queried is 5 minutes.', example='2015-12-10T20:00:00Z'),
  type?: string(name='Type'),
}

model DescribeDcdnDomainUsageDataResponseBody = {
  area?: string(name='Area', description='The billable region where the usage data was collected.', example='CN'),
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries. Unit: seconds.', example='/'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2015-12-10T22:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2015-12-10T20:00:00Z'),
  type?: string(name='Type', description='The type of the content returned.', example='static'),
  usageDataPerInterval?: {
    dataModule?: [ 
    {
      peakTime?: string(name='PeakTime', description='If the **Field** parameter in the request is set to **bps**, this parameter returns the time of the peak bandwidth value. Otherwise, this parameter returns the same value as the **TimeStamp** parameter.', example='2015-12-10T21:30:00Z'),
      specialValue?: string(name='SpecialValue', description='The data usage in a specific scenario.

> SpecialValue indicates the data usage in a specific scenario. If no special billable item is specified, ignore this parameter.', example='4233041**'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2015-12-10T21:30:00Z'),
      value?: string(name='Value', description='The amount of resource usage.', example='4233041**'),
    }
  ](name='DataModule')
  }(name='UsageDataPerInterval', description='The network traffic that was collected at each interval.'),
}

model DescribeDcdnDomainUsageDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainUsageDataResponseBody(name='body'),
}

/**
  * * You can call this operation up to 10 times per second per account.
  * * Usage data includes traffic (measured in bytes), bandwidth values (measured in bit/s), and the number of requests.
  * **Time granularity**:
  * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainUsageDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainUsageDataResponse
 */
async function describeDcdnDomainUsageDataWithOptions(request: DescribeDcdnDomainUsageDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainUsageDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.area)) {
    query['Area'] = request.area;
  }
  if (!Util.isUnset(request.dataProtocol)) {
    query['DataProtocol'] = request.dataProtocol;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.field)) {
    query['Field'] = request.field;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainUsageData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * * You can call this operation up to 10 times per second per account.
  * * Usage data includes traffic (measured in bytes), bandwidth values (measured in bit/s), and the number of requests.
  * **Time granularity**:
  * The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainUsageDataRequest
  * @return DescribeDcdnDomainUsageDataResponse
 */
async function describeDcdnDomainUsageData(request: DescribeDcdnDomainUsageDataRequest): DescribeDcdnDomainUsageDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainUsageDataWithOptions(request, runtime);
}

model DescribeDcdnDomainUvDataRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain. You can specify only one domain name.

By default, all the accelerated domains are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The end time must be later than the start time.', example='2015-11-30T00:00:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2015-11-29T00:00:00Z'),
}

model DescribeDcdnDomainUvDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The data collection interval. Unit: second.', example='3600'),
  domainName?: string(name='DomainName', description='The name of the accelerated domain for which the data was returned.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was collected.', example='2015-11-30T00:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E9D3257A-1B7C-414C-90C1-8D07AC47BCAC'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was collected.', example='2015-11-29T00:00:00Z'),
  uvDataInterval?: {
    usageData?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2015-11-29T00:00:00Z'),
      value?: string(name='Value', description='The number of UVs.', example='326'),
    }
  ](name='UsageData')
  }(name='UvDataInterval', description='The number of UVs at each interval.'),
}

model DescribeDcdnDomainUvDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainUvDataResponseBody(name='body'),
}

/**
  * **Before you call this operation, pay attention to the following considerations:**
  * *   If you do not specify the StartTime or EndTime parameter, the data collected within the last 24 hours is queried by default. If you specify the StartTime and EndTime parameters, the data collected within the specified time range is queried.
  * *   You can specify only one accelerated domain or all the accelerated domains under your account.
  *
  * @param request DescribeDcdnDomainUvDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainUvDataResponse
 */
async function describeDcdnDomainUvDataWithOptions(request: DescribeDcdnDomainUvDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainUvDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainUvData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **Before you call this operation, pay attention to the following considerations:**
  * *   If you do not specify the StartTime or EndTime parameter, the data collected within the last 24 hours is queried by default. If you specify the StartTime and EndTime parameters, the data collected within the specified time range is queried.
  * *   You can specify only one accelerated domain or all the accelerated domains under your account.
  *
  * @param request DescribeDcdnDomainUvDataRequest
  * @return DescribeDcdnDomainUvDataResponse
 */
async function describeDcdnDomainUvData(request: DescribeDcdnDomainUvDataRequest): DescribeDcdnDomainUvDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainUvDataWithOptions(request, runtime);
}

model DescribeDcdnDomainWebsocketBpsDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.

Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainWebsocketBpsDataResponseBody = {
  bpsDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2017-12-10T20:00:00Z'),
      websocketBps?: float(name='WebsocketBps', description='The bandwidth value. Unit: bit/s.', example='11288111'),
    }
  ](name='DataModule')
  }(name='BpsDataPerInterval', description='The bandwidth values returned at each interval.'),
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2017-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainWebsocketBpsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainWebsocketBpsDataResponseBody(name='body'),
}

/**
  * - You can call this operation up to 100 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainWebsocketBpsDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainWebsocketBpsDataResponse
 */
async function describeDcdnDomainWebsocketBpsDataWithOptions(request: DescribeDcdnDomainWebsocketBpsDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainWebsocketBpsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainWebsocketBpsData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - You can call this operation up to 100 times per second per account.
  * - If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last hour. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainWebsocketBpsDataRequest
  * @return DescribeDcdnDomainWebsocketBpsDataResponse
 */
async function describeDcdnDomainWebsocketBpsData(request: DescribeDcdnDomainWebsocketBpsDataRequest): DescribeDcdnDomainWebsocketBpsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainWebsocketBpsDataWithOptions(request, runtime);
}

model DescribeDcdnDomainWebsocketHttpCodeDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2018-03-01T06:00:00Z'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Description**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-03-01T05:00:00Z'),
}

model DescribeDcdnDomainWebsocketHttpCodeDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='3600'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2018-03-01T13:00:00Z'),
  httpCodeDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2018-03-01T13:00:00Z'),
      websocketHttpCode?: {
        httpCodeDataModule?: [ 
        {
          code?: int32(name='Code', description='The HTTP status code.', example='404'),
          count?: float(name='Count', description='The total number of times that the HTTP status code was returned.', example='16'),
          proportion?: float(name='Proportion', description='The proportion of the HTTP status code.', example='100'),
        }
      ](name='HttpCodeDataModule')
      }(name='WebsocketHttpCode', description='The information about the HTTP status codes.'),
    }
  ](name='DataModule')
  }(name='HttpCodeDataPerInterval', description='The HTTP status codes.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='91FC2D9D-B042-4634-8A5C-7B8E7482C22D'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2018-03-01T05:00:00Z'),
}

model DescribeDcdnDomainWebsocketHttpCodeDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainWebsocketHttpCodeDataResponseBody(name='body'),
}

/**
  * You can call this operation up to 100 times per second per account.  
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainWebsocketHttpCodeDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainWebsocketHttpCodeDataResponse
 */
async function describeDcdnDomainWebsocketHttpCodeDataWithOptions(request: DescribeDcdnDomainWebsocketHttpCodeDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainWebsocketHttpCodeDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainWebsocketHttpCodeData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation up to 100 times per second per account.  
  * **Time granularity**The time granularity supported by the Interval parameter varies with the maximum time range per query. The following table describes the time period within which historical data is available and the data delay. 
  * | Time granularity | Maximum time range per query | Historical data available | Data delay |
  * | ---------------- | ---------------------------- | ------------------------- | ---------- |
  * | 5 minutes | 3 days | 93 days | 15 minutes |
  * | 1 hour | 31 days | 186 days | 4 hours |
  * | 1 day | 366 days | 366 days | 04:00 on the next day |
  *
  * @param request DescribeDcdnDomainWebsocketHttpCodeDataRequest
  * @return DescribeDcdnDomainWebsocketHttpCodeDataResponse
 */
async function describeDcdnDomainWebsocketHttpCodeData(request: DescribeDcdnDomainWebsocketHttpCodeDataRequest): DescribeDcdnDomainWebsocketHttpCodeDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainWebsocketHttpCodeDataWithOptions(request, runtime);
}

model DescribeDcdnDomainWebsocketTrafficDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.

Separate multiple domain names with commas (,). If you do not specify a value for this parameter, all accelerated domain names are queried.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query.

The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.

> The end time must be later than the start time.', example='2017-12-10T21:00:00Z'),
  interval?: string(name='Interval', description='The time granularity for a query. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see **Usage notes**.', example='300'),
  ispNameEn?: string(name='IspNameEn', description='The name of the ISP.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query ISPs.', example='unicom'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query regions.', example='beijing'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-10T20:00:00Z'),
}

model DescribeDcdnDomainWebsocketTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2017-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The start of the time range during which data was queried.', example='2017-12-10T20:00:00Z'),
  trafficDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2017-12-10T20:00:00Z'),
      websocketTraffic?: float(name='WebsocketTraffic', description='The total volume of traffic.', example='423304182'),
    }
  ](name='DataModule')
  }(name='TrafficDataPerInterval', description='The network traffic returned at each time interval. Unit: bytes.'),
}

model DescribeDcdnDomainWebsocketTrafficDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnDomainWebsocketTrafficDataResponseBody(name='body'),
}

/**
  * * You can call this operation up to 100 times per second per account.
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainWebsocketTrafficDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnDomainWebsocketTrafficDataResponse
 */
async function describeDcdnDomainWebsocketTrafficDataWithOptions(request: DescribeDcdnDomainWebsocketTrafficDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnDomainWebsocketTrafficDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispNameEn)) {
    query['IspNameEn'] = request.ispNameEn;
  }
  if (!Util.isUnset(request.locationNameEn)) {
    query['LocationNameEn'] = request.locationNameEn;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnDomainWebsocketTrafficData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * * You can call this operation up to 100 times per second per account.
  * * If you do not set the **StartTime** or **EndTime** parameter, the request returns the data collected in the last 24 hours. If you set both the **StartTime** and **EndTime** parameters, the request returns the data collected within the specified time range.
  * **Time granularity**
  * The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|366 days|366 days|04:00 on the next day|
  *
  * @param request DescribeDcdnDomainWebsocketTrafficDataRequest
  * @return DescribeDcdnDomainWebsocketTrafficDataResponse
 */
async function describeDcdnDomainWebsocketTrafficData(request: DescribeDcdnDomainWebsocketTrafficDataRequest): DescribeDcdnDomainWebsocketTrafficDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnDomainWebsocketTrafficDataWithOptions(request, runtime);
}

model DescribeDcdnErUsageDataRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2018-10-31T16:00:00Z'),
  routineID?: string(name='RoutineID', description='The ID of the ER.', example='routine1.test'),
  spec?: string(name='Spec', description='The specification of the ER. Valid values:

*   5ms
*   50ms
*   100ms', example='50ms'),
  splitBy?: string(name='SplitBy', description='Specifies how the results are grouped. If you set this parameter to routine, the returned results are grouped based on the ER ID. If you set this parameter to spec, the returned results are grouped based on the ER specification.

>  If you leave this parameter empty, the returned results are not grouped.', example='routine'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-10-30T16:00:00Z'),
}

model DescribeDcdnErUsageDataResponseBody = {
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2018-10-31T16:00:00Z'),
  erAccData?: {
    erAccItem?: [ 
    {
      erAcc?: long(name='ErAcc', description='The number of ER requests.', example='125'),
      routine?: string(name='Routine', description='The ID of the ER. This parameter is returned only when SplitBy is set to routine.', example='routine1.test'),
      spec?: string(name='Spec', description='The specification of the ER. This parameter is returned only when SplitBy is set to spec.', example='50ms'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2018-10-30T13:00:00Z'),
    }
  ](name='ErAccItem')
  }(name='ErAccData', description='The list of the returned data.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C370DAF1-C838-4288-A1A0-9A87633D248E'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2018-10-30T16:00:00Z'),
}

model DescribeDcdnErUsageDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnErUsageDataResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 10 times per second per account.
  * *   The minimum time granularity for a query is one hour. The maximum time span for a query is 24 hours. The time period within which historical data is available for a query is 366 days.
  *
  * @param request DescribeDcdnErUsageDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnErUsageDataResponse
 */
async function describeDcdnErUsageDataWithOptions(request: DescribeDcdnErUsageDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnErUsageDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.routineID)) {
    query['RoutineID'] = request.routineID;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.splitBy)) {
    query['SplitBy'] = request.splitBy;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnErUsageData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 10 times per second per account.
  * *   The minimum time granularity for a query is one hour. The maximum time span for a query is 24 hours. The time period within which historical data is available for a query is 366 days.
  *
  * @param request DescribeDcdnErUsageDataRequest
  * @return DescribeDcdnErUsageDataResponse
 */
async function describeDcdnErUsageData(request: DescribeDcdnErUsageDataRequest): DescribeDcdnErUsageDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnErUsageDataWithOptions(request, runtime);
}

model DescribeDcdnHttpsDomainListRequest {
  keyword?: string(name='Keyword', description='The keyword used for search.', example='cert'),
  pageNumber?: int32(name='PageNumber', description='The number of pages to return. Valid values: **1 to 100000**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: **1 to 500**. Default value: **20**.', example='2'),
}

model DescribeDcdnHttpsDomainListResponseBody = {
  certInfos?: {
    certInfo?: [ 
    {
      certCommonName?: string(name='CertCommonName', description='The returned primary domain name of the certificate.', example='*.com'),
      certExpireTime?: string(name='CertExpireTime', description='The time when the certificate expires.', example='2018-12-26 14:45:09'),
      certName?: string(name='CertName', description='The name of the certificate.', example='cert'),
      certStartTime?: string(name='CertStartTime', description='The time when the certificate became effective.', example='2018-11-26 14:45:09'),
      certStatus?: string(name='CertStatus', description='The status of the certificate. Valid values:

*   **ok**: The certificate is working as expected.
*   **mismatch**: The certificate does not match the specified domain name.
*   **expired**: The certificate has expired.
*   **expire_soon**: The certificate is about to expire.', example='mismatch'),
      certType?: string(name='CertType', description='The type of the certificate. Valid values:

*   **free**: A free certificate.
*   **cas**: A certificate that is purchased through Alibaba Cloud SSL Certificates Service.
*   **upload**: A user-uploaded certificate.', example='upload'),
      certUpdateTime?: string(name='CertUpdateTime', description='The time when the certificate was updated.', example='2019-01-08 18:33:16'),
      domainName?: string(name='DomainName', description='The accelerated domain name for which the certificate information was queried.', example='*.com'),
    }
  ](name='CertInfo')
  }(name='CertInfos', description='The certificate information about the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F5E8DF64-7175-4186-9B06-F002C0BBD0C5'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='16'),
}

model DescribeDcdnHttpsDomainListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnHttpsDomainListResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnHttpsDomainListRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnHttpsDomainListResponse
 */
async function describeDcdnHttpsDomainListWithOptions(request: DescribeDcdnHttpsDomainListRequest, runtime: Util.RuntimeOptions): DescribeDcdnHttpsDomainListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnHttpsDomainList',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnHttpsDomainListRequest
  * @return DescribeDcdnHttpsDomainListResponse
 */
async function describeDcdnHttpsDomainList(request: DescribeDcdnHttpsDomainListRequest): DescribeDcdnHttpsDomainListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnHttpsDomainListWithOptions(request, runtime);
}

model DescribeDcdnIpInfoRequest {
  IP?: string(name='IP', description='The IP address. You can specify only one IP address.', example='10.10.10.10'),
}

model DescribeDcdnIpInfoResponseBody = {
  dcdnIp?: string(name='DcdnIp', description='Indicates whether the specified IP address is assigned to an Alibaba Cloud DCDN node.

*   True: The specified IP address is assigned to an Alibaba Cloud DCDN node.
*   False: The specified IP address is not assigned to an Alibaba Cloud DCDN node.', example='True'),
  ISP?: string(name='ISP', description='The Internet service provider (ISP) to which the specified IP address belongs.', example='telecom'),
  ispEname?: string(name='IspEname', description='The name of the ISP.', example='telecom'),
  region?: string(name='Region', description='The region to which the specified IP address belongs.', example='China - Guizhou Province - Guiyang City'),
  regionEname?: string(name='RegionEname', description='The name of the region.', example='China-Guizhou-guiyang'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1B1D0EE7-9559-489D-BC4E-279495EB8FB8'),
}

model DescribeDcdnIpInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnIpInfoResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnIpInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnIpInfoResponse
 */
async function describeDcdnIpInfoWithOptions(request: DescribeDcdnIpInfoRequest, runtime: Util.RuntimeOptions): DescribeDcdnIpInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.IP)) {
    query['IP'] = request.IP;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnIpInfo',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnIpInfoRequest
  * @return DescribeDcdnIpInfoResponse
 */
async function describeDcdnIpInfo(request: DescribeDcdnIpInfoRequest): DescribeDcdnIpInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnIpInfoWithOptions(request, runtime);
}

model DescribeDcdnIpaDomainConfigsRequest {
  domainName?: string(name='DomainName', description='The accelerated domain names. Separate multiple domain names with commas (,).', example='example.com'),
  functionNames?: string(name='FunctionNames', description='The name of the feature. Only the protogw value is supported, which indicates IP Application Accelerator (IPA).', example='protogw'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnIpaDomainConfigsResponseBody = {
  domainConfigs?: {
    domainConfig?: [ 
    {
      configId?: string(name='ConfigId', description='The ID of the configuration.', example='5003576'),
      functionArgs?: {
        functionArg?: [ 
        {
          argName?: string(name='ArgName', description='The name of the configuration.', example='file_type'),
          argValue?: string(name='ArgValue', description='The value of the configuration.', example='txt'),
        }
      ](name='FunctionArg')
      }(name='FunctionArgs', description='The list of features.'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='protogw'),
      status?: string(name='Status', description='The configuration status of the feature. Valid values:

*   **success**
*   **testing**
*   **failed**
*   **configuring**', example='success'),
    }
  ](name='DomainConfig')
  }(name='DomainConfigs', description='The configurations of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F8AA0364-0FDB-4AD5-AC74-D69FAB8924ED'),
}

model DescribeDcdnIpaDomainConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnIpaDomainConfigsResponseBody(name='body'),
}

/**
  * > You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnIpaDomainConfigsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnIpaDomainConfigsResponse
 */
async function describeDcdnIpaDomainConfigsWithOptions(request: DescribeDcdnIpaDomainConfigsRequest, runtime: Util.RuntimeOptions): DescribeDcdnIpaDomainConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.functionNames)) {
    query['FunctionNames'] = request.functionNames;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnIpaDomainConfigs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnIpaDomainConfigsRequest
  * @return DescribeDcdnIpaDomainConfigsResponse
 */
async function describeDcdnIpaDomainConfigs(request: DescribeDcdnIpaDomainConfigsRequest): DescribeDcdnIpaDomainConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnIpaDomainConfigsWithOptions(request, runtime);
}

model DescribeDcdnIpaDomainDetailRequest {
  domainName?: string(name='DomainName', description='The accelerated domain names for which you want to query basic information. You can specify only one domain name in each request.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnIpaDomainDetailResponseBody = {
  domainDetail?: {
    certName?: string(name='CertName', description='Indicates the name of the certificate if the HTTPS protocol is enabled.', example='yourCertName'),
    cname?: string(name='Cname', description='The CNAME assigned to the domain name.', example='example.com'),
    description?: string(name='Description', description='The description.', example='audit failed'),
    domainName?: string(name='DomainName', description='The accelerated domain names.', example='example.com'),
    domainStatus?: string(name='DomainStatus', description='The status of the accelerated domain name. Valid values:

*   **online**: The domain name is enabled.
*   **offline**: The domain name is disabled.
*   **configuring**: The domain name is being configured.
*   **configure_failed**: The domain name failed to be configured.
*   **checking**: The domain name is under review.
*   **check_failed**: The domain name failed the review.', example='online'),
    gmtCreated?: string(name='GmtCreated', description='The time when the accelerated domain name was created.', example='2017-11-27T06:51:26Z'),
    gmtModified?: string(name='GmtModified', description='The time when the accelerated domain name was last modified.', example='2017-11-27T06:51:26Z'),
    resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyuji4b6xxxx'),
    SSLProtocol?: string(name='SSLProtocol', description='Indicates whether the Security Socket Layer (SSL) certificate is enabled. Valid values:

*   **on**: The SSL certificate is enabled.
*   **off**: The SSL certificate is disabled.', example='on'),
    SSLPub?: string(name='SSLPub', description='Indicates the public key of the certificate if the HTTPS protocol is enabled.', example='SSLPub'),
    scope?: string(name='Scope', description='The accelerated region. Valid values:

*   domestic: Chinese mainland
*   overseas: global (excluding the Chinese mainland)
*   global: global', example='overseas'),
    sources?: {
      source?: [ 
      {
        content?: string(name='Content', description='The address of the origin server.', example='xxx.oss-cn-hangzhou.aliyuncs.com'),
        enabled?: string(name='Enabled', description='The status of the origin server.', example='online'),
        port?: int32(name='Port', description='The custom port. Valid values: **0** to **65535**.', example='80'),
        priority?: string(name='Priority', description='The priority of the origin server if multiple origin servers are specified.', example='50'),
        type?: string(name='Type', description='The type of the origin server. Valid values:

*   **ipaddr**: an IP address.
*   **domain**: a domain name.
*   **oss**: Object Storage Service (OSS) buckets are not supported.', example='oss'),
        weight?: string(name='Weight', description='The weight of the origin server if multiple origin servers are specified.', example='10'),
      }
    ](name='Source')
    }(name='Sources', description='The information about the origin server.'),
  }(name='DomainDetail', description='The details about the accelerated domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='09ABE829-6CD3-4FE0-AFEE-556113E29727'),
}

model DescribeDcdnIpaDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnIpaDomainDetailResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 30.
  *
  * @param request DescribeDcdnIpaDomainDetailRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnIpaDomainDetailResponse
 */
async function describeDcdnIpaDomainDetailWithOptions(request: DescribeDcdnIpaDomainDetailRequest, runtime: Util.RuntimeOptions): DescribeDcdnIpaDomainDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnIpaDomainDetail',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 30.
  *
  * @param request DescribeDcdnIpaDomainDetailRequest
  * @return DescribeDcdnIpaDomainDetailResponse
 */
async function describeDcdnIpaDomainDetail(request: DescribeDcdnIpaDomainDetailRequest): DescribeDcdnIpaDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnIpaDomainDetailWithOptions(request, runtime);
}

model DescribeDcdnIpaServiceRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnIpaServiceResponseBody = {
  changingAffectTime?: string(name='ChangingAffectTime', description='The time when the change of the billing method starts to take effect. The time is in GMT. This time appears on the frontend only when it is later than the current time.', example='2018-03-31T16:00:00Z'),
  changingChargeType?: string(name='ChangingChargeType', description='The new billing method to take effect. Valid values:

*   **PayByTraffic**
*   **PayByBandwidth**
*   **PayByBandwidth95**
*   **PayByBandwidth_monthavg**
*   **PayByBandwidth_month4th**
*   **PayByBandwidth_monthday95avg**
*   **PayByBandwidth_nighthalf95**', example='PayByBandwidth'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='1883927335936173'),
  internetChargeType?: string(name='InternetChargeType', description='The current billing method. Valid values:

*   **PayByTraffic**
*   **PayByBandwidth**
*   **PayByBandwidth95**
*   **PayByBandwidth_monthavg**
*   **PayByBandwidth_month4th**
*   **PayByBandwidth_monthday95avg**
*   **PayByBandwidth_nighthalf95**', example='PayByBandwidth'),
  openingTime?: string(name='OpeningTime', description='The time when the IPA service was activated. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mmZ format.', example='2018-03-19T11:16:11Z'),
  operationLocks?: {
    lockReason?: [ 
    {
      lockReason?: string(name='LockReason', description='The reason why the IPA service was locked. A value of **financial** indicates that your account has an overdue payment.', example='financial'),
    }
  ](name='LockReason')
  }(name='OperationLocks', description='The lock status of the IPA service.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EF2AEBC2-EDBD-41CF-BF64-7E095D42D6EF'),
}

model DescribeDcdnIpaServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnIpaServiceResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request DescribeDcdnIpaServiceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnIpaServiceResponse
 */
async function describeDcdnIpaServiceWithOptions(request: DescribeDcdnIpaServiceRequest, runtime: Util.RuntimeOptions): DescribeDcdnIpaServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnIpaService',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request DescribeDcdnIpaServiceRequest
  * @return DescribeDcdnIpaServiceResponse
 */
async function describeDcdnIpaService(request: DescribeDcdnIpaServiceRequest): DescribeDcdnIpaServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnIpaServiceWithOptions(request, runtime);
}

model DescribeDcdnIpaUserDomainsRequest {
  checkDomainShow?: boolean(name='CheckDomainShow', description='Specifies whether to display domain names that are under review, failed the review, or failed to be configured. Valid values:

*   **true**
*   **false**', example='false'),
  domainName?: string(name='DomainName', description='The domain name that is used as a keyword to filter domain names. Fuzzy match is supported.', example='example.com'),
  domainSearchType?: string(name='DomainSearchType', description='The search method. Default value: full_match. Valid values:

*   **fuzzy_match**: fuzzy match
*   **pre_match**: prefix match
*   **suf_match**: suffix match
*   **full_match**: exact match', example='fuzzy_match'),
  domainStatus?: string(name='DomainStatus', description='The status of the domain name. Valid values:

*   **online**: enabled
*   **offline**: disabled
*   **configuring**: configuring
*   **configure_failed**: configuration failed
*   **checking**: reviewing
*   **check_failed**: review failed', example='online'),
  funcFilter?: string(name='FuncFilter', description='The status of the feature.

*   config: The feature is enabled.
*   unconfig: The feature is not enabled.', example='config'),
  funcId?: string(name='FuncId', description='The ID of the feature. For example, a value of 7 specifies the feature of configuring an expiration rule for a specific directory. For more information about feature IDs, see [Parameters for configuring features for domain names](~~410622~~).', example='7'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: **1** to **100000**.

Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of domain names to return on each page. Default value: **20**. Maximum value: **500**.

Valid values: an integer from **1** to **500**.', example='5'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. Valid values of N: 1 to 20. You can call the TagDcdnResources operation to set a tag for a domain name.', example='1'),
      value?: string(name='Value', description='The tag value. Valid values of N: 1 to 20.', example='1'),
    }
  ](name='Tag'),
}

model DescribeDcdnIpaUserDomainsResponseBody = {
  domains?: {
    pageData?: [ 
    {
      cname?: string(name='Cname', description='The CNAME assigned to the accelerated domain name.', example='example.com.*.com'),
      description?: string(name='Description', description='The reason why the accelerated domain name failed the review.', example='audit failed'),
      domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
      domainStatus?: string(name='DomainStatus', description='The status of the accelerated domain name. Valid values:

*   **online**: enabled
*   **offline**: disabled
*   **configuring**: configuring
*   **configure_failed**: configuration failed
*   **checking**: reviewing
*   **check_failed**: review failed', example='online'),
      gmtCreated?: string(name='GmtCreated', description='The time when the accelerated domain name was added to Alibaba Cloud Dynamic Route for CDN (DCDN).', example='2015-10-28T09:32:51Z'),
      gmtModified?: string(name='GmtModified', description='The time when the accelerated domain name was modified.', example='2015-10-28T11:05:52Z'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='abcd1234abcd****'),
      SSLProtocol?: string(name='SSLProtocol', description='The status of HTTPS.

*   **on**
*   **off**', example='on'),
      sandbox?: string(name='Sandbox', description='Indicates whether the accelerated domain name was in a sandbox.', example='normal'),
      sources?: {
        source?: [ 
        {
          content?: string(name='Content', description='The address of the origin server.', example='*.aliyuncs.com'),
          port?: int32(name='Port', description='The port of the origin server.', example='80'),
          priority?: string(name='Priority', description='The priority of the origin server.', example='20'),
          type?: string(name='Type', description='The type of the origin server.'),
          weight?: string(name='Weight', description='The weight of the origin server if multiple origin servers have been specified.', example='20'),
        }
      ](name='Source')
      }(name='Sources', description='The information about the origin server.'),
    }
  ](name='PageData')
  }(name='Domains', description='The array that consists of multiple PageData parameters. The details about each accelerated domain name are included in a separate PageData parameter.'),
  pageNumber?: long(name='PageNumber', description='The number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of domain names returned per page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AA75AADB-5E25-4970-B480-EAA1F5658483'),
  totalCount?: long(name='TotalCount', description='The total number of domain names returned.', example='1'),
}

model DescribeDcdnIpaUserDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnIpaUserDomainsResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnIpaUserDomainsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnIpaUserDomainsResponse
 */
async function describeDcdnIpaUserDomainsWithOptions(request: DescribeDcdnIpaUserDomainsRequest, runtime: Util.RuntimeOptions): DescribeDcdnIpaUserDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkDomainShow)) {
    query['CheckDomainShow'] = request.checkDomainShow;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainSearchType)) {
    query['DomainSearchType'] = request.domainSearchType;
  }
  if (!Util.isUnset(request.domainStatus)) {
    query['DomainStatus'] = request.domainStatus;
  }
  if (!Util.isUnset(request.funcFilter)) {
    query['FuncFilter'] = request.funcFilter;
  }
  if (!Util.isUnset(request.funcId)) {
    query['FuncId'] = request.funcId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnIpaUserDomains',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnIpaUserDomainsRequest
  * @return DescribeDcdnIpaUserDomainsResponse
 */
async function describeDcdnIpaUserDomains(request: DescribeDcdnIpaUserDomainsRequest): DescribeDcdnIpaUserDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnIpaUserDomainsWithOptions(request, runtime);
}

model DescribeDcdnL2VipsRequest {
  domainName?: string(name='DomainName', example='example.com'),
}

model DescribeDcdnL2VipsResponseBody = {
  domainName?: string(name='DomainName', example='example.com'),
  requestId?: string(name='RequestId', example='820E7900-5CA9-4AEF-B0DD-20ED5F64BE55'),
  vips?: [ string ](name='Vips'),
}

model DescribeDcdnL2VipsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnL2VipsResponseBody(name='body'),
}

async function describeDcdnL2VipsWithOptions(request: DescribeDcdnL2VipsRequest, runtime: Util.RuntimeOptions): DescribeDcdnL2VipsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnL2Vips',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDcdnL2Vips(request: DescribeDcdnL2VipsRequest): DescribeDcdnL2VipsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnL2VipsWithOptions(request, runtime);
}

model DescribeDcdnRealTimeDeliveryFieldRequest {
  businessType?: string(name='BusinessType', description='The type of the collected logs. Default value: cdn_log_access_l1. Valid values:

*   **cdn_log_access_l1**: access logs of L1 Dynamic Route for CDN (DCDN) nodes
*   **cdn_log_origin**: back-to-origin logs
*   **cdn_log_er**: EdgeRoutine logs', example='cdn_log_access_l1'),
}

model DescribeDcdnRealTimeDeliveryFieldResponseBody = {
  content?: {
    fields?: [ 
    {
      description?: string(name='Description', description='The description of the field.', example='interview time'),
      fieldName?: string(name='FieldName', description='The name of the field. For more information about the fields in real-time log entries, see [Fields in a real-time log](~~324199~~).', example='unixtime'),
    }
  ](name='Fields')
  }(name='Content', description='The returned results.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3EACD23C-F49F-4BF7-B9AD-C2CD3BA888C4'),
}

model DescribeDcdnRealTimeDeliveryFieldResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnRealTimeDeliveryFieldResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnRealTimeDeliveryFieldRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnRealTimeDeliveryFieldResponse
 */
async function describeDcdnRealTimeDeliveryFieldWithOptions(request: DescribeDcdnRealTimeDeliveryFieldRequest, runtime: Util.RuntimeOptions): DescribeDcdnRealTimeDeliveryFieldResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnRealTimeDeliveryField',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnRealTimeDeliveryFieldRequest
  * @return DescribeDcdnRealTimeDeliveryFieldResponse
 */
async function describeDcdnRealTimeDeliveryField(request: DescribeDcdnRealTimeDeliveryFieldRequest): DescribeDcdnRealTimeDeliveryFieldResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnRealTimeDeliveryFieldWithOptions(request, runtime);
}

model DescribeDcdnRefreshQuotaRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnRefreshQuotaResponseBody = {
  blockQuota?: string(name='BlockQuota', description='The maximum number of URLs that can be blocked.', example='100'),
  blockRemain?: string(name='BlockRemain', description='The remaining number of URLs that can be blocked each day.', example='100'),
  dirQuota?: string(name='DirQuota', description='The maximum number of directories that can be refreshed each day.', example='100'),
  dirRemain?: string(name='DirRemain', description='The remaining number of directories that can be refreshed each day.', example='100'),
  preloadQuota?: string(name='PreloadQuota', description='The maximum number of URLs that can be prefetched each day.', example='500'),
  preloadRemain?: string(name='PreloadRemain', description='The remaining number of URLs that can be prefetched each day.', example='500'),
  regexQuota?: string(name='RegexQuota', description='The maximum number of URLs or directories that can be refreshed by using regular expressions each day.', example='100'),
  regexRemain?: string(name='RegexRemain', description='The remaining number of URLs or directories that can be refreshed by using regular expressions each day.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='42E0554B-80F4-4921-AED6-ACFB22CAAAD0'),
  urlQuota?: string(name='UrlQuota', description='The maximum number of URLs that can be refreshed each day.', example='2000'),
  urlRemain?: string(name='UrlRemain', description='The remaining number of URLs that can be refreshed each day.', example='2000'),
}

model DescribeDcdnRefreshQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnRefreshQuotaResponseBody(name='body'),
}

/**
  * > 
  * *   You can call the **RefreshDcdnObjectCaches** operation to refresh content and call the **PreloadDcdnObjectCaches** operation to prefetch content.
  * *   You can call this operation up to 20 times per second.
  *
  * @param request DescribeDcdnRefreshQuotaRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnRefreshQuotaResponse
 */
async function describeDcdnRefreshQuotaWithOptions(request: DescribeDcdnRefreshQuotaRequest, runtime: Util.RuntimeOptions): DescribeDcdnRefreshQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnRefreshQuota',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can call the **RefreshDcdnObjectCaches** operation to refresh content and call the **PreloadDcdnObjectCaches** operation to prefetch content.
  * *   You can call this operation up to 20 times per second.
  *
  * @param request DescribeDcdnRefreshQuotaRequest
  * @return DescribeDcdnRefreshQuotaResponse
 */
async function describeDcdnRefreshQuota(request: DescribeDcdnRefreshQuotaRequest): DescribeDcdnRefreshQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnRefreshQuotaWithOptions(request, runtime);
}

model DescribeDcdnRefreshTaskByIdRequest {
  taskId?: string(name='TaskId', description='The ID of the task that you want to query. You can query task IDs by performing the following operations:

*   Perform the [RefreshDcdnObjectCaches](~~130620~~) operation to query refresh task IDs.
*   Perform the [PreloadDcdnObjectCaches](~~130636~~) operation to query prefetch task IDs.

>  You can specify at most 10 task IDs in each call. Separate IDs with commas (,).', example='113681**'),
}

model DescribeDcdnRefreshTaskByIdResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='E0C2EF95-B1EC-4C93-855E-2059A7DA2B7B'),
  tasks?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the task was created. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in UTC.', example='2021-05-10T08:54:23Z'),
      description?: string(name='Description', description='The error returned when the refresh or prefetch task failed. Valid values:

*   **Internal Error**: An internal error occurred.
*   **Origin Timeout**: The response from the origin server timed out.
*   **Origin Return StatusCode 5XX**: The origin server returned an HTTP 5xx status code.', example='Internal Error'),
      objectPath?: string(name='ObjectPath', description='The path of the refresh or prefetch object.', example='http://example.com/image_01.png'),
      objectType?: string(name='ObjectType', description='The type of the refresh or prefetch task. Valid values:

*   **file**: refreshes an individual file.
*   **directory**: refreshes files under a specified directory.
*   **preload**: prefetches an individual file.', example='file'),
      process?: string(name='Process', description='The progress of the task, in percentage.', example='100%'),
      status?: string(name='Status', description='The status of the task. Valid values:

*   **Complete**: The task has completed.
*   **Pending**: The task is pending.
*   **Refreshing**: The task is in progress.
*   **Failed**: The task has failed.', example='Complete'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='113681**'),
    }
  ](name='Tasks', description='A list of prefetch or refresh tasks.'),
  totalCount?: long(name='TotalCount', description='The total number of tasks.', example='2'),
}

model DescribeDcdnRefreshTaskByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnRefreshTaskByIdResponseBody(name='body'),
}

/**
  * > 
  * *   You can query data within the last three days.
  * *   The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnRefreshTaskByIdRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnRefreshTaskByIdResponse
 */
async function describeDcdnRefreshTaskByIdWithOptions(request: DescribeDcdnRefreshTaskByIdRequest, runtime: Util.RuntimeOptions): DescribeDcdnRefreshTaskByIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnRefreshTaskById',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can query data within the last three days.
  * *   The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnRefreshTaskByIdRequest
  * @return DescribeDcdnRefreshTaskByIdResponse
 */
async function describeDcdnRefreshTaskById(request: DescribeDcdnRefreshTaskByIdRequest): DescribeDcdnRefreshTaskByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnRefreshTaskByIdWithOptions(request, runtime);
}

model DescribeDcdnRefreshTasksRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name in each call.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2017-01-01T12:13:20Z'),
  objectPath?: string(name='ObjectPath', description='The path of the object. The path is used as a condition for exact matching.', example='http://example.com/examplefile.txt'),
  objectType?: string(name='ObjectType', description='The type of the task.

*   **file**: URL-based refresh
*   **directory**: directory-based refresh
*   **preload**: URL-based prefetch

If you set the **DomainName** or **Status** parameter, you must also set this parameter.', example='file'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: **1** to **100000**.', example='2'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**. Maximum value: **50**. Valid values: **1** to **50**.', example='20'),
  securityToken?: string(name='SecurityToken'),
  startTime?: string(name='StartTime', description='The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-01-01T12:12:20Z'),
  status?: string(name='Status', description='The status of the task.

*   **Complete**: The task has completed.
*   **Refreshing**: The task is in progress.
*   **Failed**: The task failed.', example='Complete'),
  taskId?: string(name='TaskId', description='The ID of the task. A task ID is assigned when you create a refresh or prefetch task.', example='704225667'),
}

model DescribeDcdnRefreshTasksResponseBody = {
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='2'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='174F6032-AA26-470D-B90E-36F0EB205BEE'),
  tasks?: {
    task?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the task was created. The time is displayed in UTC.', example='2014-11-27T08:23:22Z'),
      description?: string(name='Description', description='The type of error returned when the refresh or prefetch task has failed.

*   **InternalError**: An internal error occurred.
*   **OriginTimeout**: The response from the origin server timed out.
*   **OriginReturn StatusCode 5XX**: The origin server returned a 5XX error.', example='Internal Error'),
      objectPath?: string(name='ObjectPath', description='The URL of the object to be refreshed.', example='http://example.com/examplefile.txt'),
      objectType?: string(name='ObjectType', description='The type of the task.

*   **file**: URL-based refresh
*   **path**: directory-based refresh
*   **preload**: URL-based prefetch', example='file'),
      process?: string(name='Process', description='The progress of the task, in percentage.', example='10'),
      status?: string(name='Status', description='The status of the task.

*   **Complete**: The task has completed.
*   **Refreshing**: The task is in progress.
*   **Failed**: The task failed.', example='Complete'),
      taskId?: string(name='TaskId', description='The ID of the task.', example='123'),
    }
  ](name='Task')
  }(name='Tasks', description='Details about tasks.'),
  totalCount?: long(name='TotalCount', description='The number of tasks.', example='20'),
}

model DescribeDcdnRefreshTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnRefreshTasksResponseBody(name='body'),
}

/**
  * > 
  * *   You can query the status information by task ID or URL.
  * *   You can set both the **TaskId** parameter and the **ObjectPath** parameter to query. If you set neither the **TaskId** parameter nor the **ObjectPath** parameter, the data in the last 3 days on the first page is returned. By default, a maximum of 20 entries can be displayed on each page.
  * *   If you specify the **DomainName** or **Status** parameter, you must also specify the **ObjectType** parameter.
  * *   You can call this operation up to 10 times per second per account.
  *
  * @param request DescribeDcdnRefreshTasksRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnRefreshTasksResponse
 */
async function describeDcdnRefreshTasksWithOptions(request: DescribeDcdnRefreshTasksRequest, runtime: Util.RuntimeOptions): DescribeDcdnRefreshTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.objectPath)) {
    query['ObjectPath'] = request.objectPath;
  }
  if (!Util.isUnset(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnRefreshTasks',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   You can query the status information by task ID or URL.
  * *   You can set both the **TaskId** parameter and the **ObjectPath** parameter to query. If you set neither the **TaskId** parameter nor the **ObjectPath** parameter, the data in the last 3 days on the first page is returned. By default, a maximum of 20 entries can be displayed on each page.
  * *   If you specify the **DomainName** or **Status** parameter, you must also specify the **ObjectType** parameter.
  * *   You can call this operation up to 10 times per second per account.
  *
  * @param request DescribeDcdnRefreshTasksRequest
  * @return DescribeDcdnRefreshTasksResponse
 */
async function describeDcdnRefreshTasks(request: DescribeDcdnRefreshTasksRequest): DescribeDcdnRefreshTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnRefreshTasksWithOptions(request, runtime);
}

model DescribeDcdnRegionAndIspRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnRegionAndIspResponseBody = {
  isps?: {
    isp?: [ 
    {
      nameEn?: string(name='NameEn', description='The English name of the ISP.', example='unicom'),
      nameZh?: string(name='NameZh', description='The Chinese name of the ISP.'),
    }
  ](name='Isp')
  }(name='Isps', description='The list of ISPs.'),
  regions?: {
    region?: [ 
    {
      nameEn?: string(name='NameEn', description='The English name of the region.', example='liaoning'),
      nameZh?: string(name='NameZh', description='The Chinese name of the region.'),
    }
  ](name='Region')
  }(name='Regions', description='The list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2387C335-932C-4E1E-862C-1C4363B6DE72'),
}

model DescribeDcdnRegionAndIspResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnRegionAndIspResponseBody(name='body'),
}

/**
  * > You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnRegionAndIspRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnRegionAndIspResponse
 */
async function describeDcdnRegionAndIspWithOptions(request: DescribeDcdnRegionAndIspRequest, runtime: Util.RuntimeOptions): DescribeDcdnRegionAndIspResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnRegionAndIsp',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnRegionAndIspRequest
  * @return DescribeDcdnRegionAndIspResponse
 */
async function describeDcdnRegionAndIsp(request: DescribeDcdnRegionAndIspRequest): DescribeDcdnRegionAndIspResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnRegionAndIspWithOptions(request, runtime);
}

model DescribeDcdnReportRequest {
  area?: string(name='Area', description='The region. You can call the [DescribeDcdnRegionAndIsp](~~207199~~) operation to query the most recent region list.

*   If you do not specify a region, all regions are queried.
*   If you specify a region, data about the specified region is returned. You can specify one or more regions. Separate multiple regions with commas (,).', example='shanghai'),
  domainName?: string(name='DomainName', description='The domain names that you want to query. Separate domain names with commas (,).', example='www.example.com,www.example.org'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The time in the ISO 8601 standard in the YYYY-MM-DDTHH:mm:ssZ format. The time must be in UTC+0.', example='2021-07-02T01:00:00Z'),
  httpCode?: string(name='HttpCode', description='The HTTP status code. Valid values:

*   **2xx**: HTTP 2xx status codes
*   **3xx**: HTTP 3xx status codes
*   **4xx**: HTTP 4xx status codes
*   **5xx**: HTTP 5xx status codes

If you do not specify an HTTP status code, all HTTP status codes are queried.', example='2xx'),
  isOverseas?: string(name='IsOverseas', description='Specifies whether the region is outside the Chinese mainland. Valid values:

*   **1**: outside the Chinese mainland
*   **0**: inside the Chinese mainland', example='0'),
  reportId?: long(name='ReportId', description='The ID of the operations report that you want to query. You can specify only one ID in each call. You can call the [DescribeDcdnSubList](~~270075~~) operation to query report IDs.', example='2'),
  startTime?: string(name='StartTime', description='The start of the time range to query. The time in the ISO 8601 standard in the YYYY-MM-DDTHH:mm:ssZ format. The time must be in UTC+0.', example='2021-07-02T00:00:00Z'),
}

model DescribeDcdnReportResponseBody = {
  content?: map[string]any(name='Content', description='The content of the operations report.', example='"data":[{"deliver":{ "report":{"title":"TopUrlByAcc","format":"table","sape":"","header":["url","traf","traf_rate","acc","acc_rate"]}}, "data":[{"acc":440,"acc_rate":"0.200%","traf":22,"url":"http://example.com","traf_rate":"0.100%"},{"acc":440,"acc_rate":"0.200%","traf":22,"url":"http://example.org","traf_rate":"0.100%"}]}]'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DescribeDcdnReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnReportResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 3.
  *
  * @param request DescribeDcdnReportRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnReportResponse
 */
async function describeDcdnReportWithOptions(request: DescribeDcdnReportRequest, runtime: Util.RuntimeOptions): DescribeDcdnReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.area)) {
    query['Area'] = request.area;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.httpCode)) {
    query['HttpCode'] = request.httpCode;
  }
  if (!Util.isUnset(request.isOverseas)) {
    query['IsOverseas'] = request.isOverseas;
  }
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnReport',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 3.
  *
  * @param request DescribeDcdnReportRequest
  * @return DescribeDcdnReportResponse
 */
async function describeDcdnReport(request: DescribeDcdnReportRequest): DescribeDcdnReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnReportWithOptions(request, runtime);
}

model DescribeDcdnReportListRequest {
  reportId?: long(name='ReportId', description='The ID of the operations report that you want to query. If you do not specify an ID, all operations reports are queried.', example='2'),
}

model DescribeDcdnReportListResponseBody = {
  content?: string(name='Content', description='The information about the report that is queried.', example='"data": [{"reportId":2,"deliver":{"report":{"title":"DomainPvUv","format":"chart","shape":"line","xAxis":"ds","yAxis":"cnt","legend":"cnt_type","header":["ds","cnt_type","cnt"]}}}'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DescribeDcdnReportListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnReportListResponseBody(name='body'),
}

/**
  * > 
  * *   This operation queries the metadata of all operations reports. The statistics in the reports are not returned.
  * *   You can call this API operation up to three times per second per account.
  *
  * @param request DescribeDcdnReportListRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnReportListResponse
 */
async function describeDcdnReportListWithOptions(request: DescribeDcdnReportListRequest, runtime: Util.RuntimeOptions): DescribeDcdnReportListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.reportId)) {
    query['ReportId'] = request.reportId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnReportList',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   This operation queries the metadata of all operations reports. The statistics in the reports are not returned.
  * *   You can call this API operation up to three times per second per account.
  *
  * @param request DescribeDcdnReportListRequest
  * @return DescribeDcdnReportListResponse
 */
async function describeDcdnReportList(request: DescribeDcdnReportListRequest): DescribeDcdnReportListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnReportListWithOptions(request, runtime);
}

model DescribeDcdnSLSRealtimeLogDeliveryRequest {
  projectName?: string(name='ProjectName', description='The name of a real-time log delivery project.', example='example'),
}

model DescribeDcdnSLSRealtimeLogDeliveryResponseBody = {
  content?: {
    businessType?: string(name='BusinessType', description='The type of the collected logs. Default value: cdn_log_access_l1. Valid values:

*   **cdn_log_access_l1**: access logs of Dynamic Route for CDN (DCDN) points of presence (POPs)
*   **cdn_log_origin**: back-to-origin logs
*   **cdn_log_er**: EdgeRoutine logs', example='cdn_log_access_l1'),
    dataCenter?: string(name='DataCenter', description='The region from which logs were collected.', example='cn'),
    domainName?: string(name='DomainName', description='The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).', example='example.com,example.org'),
    fieldName?: string(name='FieldName', description='The name of the field. For more information about fields in real-time log entries, see [Fields in a real-time log](~~324199~~).', example='field1,field2'),
    projectName?: string(name='ProjectName', description='The name of the Log Service project', example='example'),
    SLSLogStore?: string(name='SLSLogStore', description='The name of the Logstore.', example='example-cn'),
    SLSProject?: string(name='SLSProject', description='The name of the Log Service project.', example='example-cn'),
    SLSRegion?: string(name='SLSRegion', description='The region to which logs were delivered.', example='cn-hangzhou'),
    samplingRate?: string(name='SamplingRate', description='The sampling rate.', example='1.0'),
    status?: string(name='Status', description='The status of real-time logs.

*   **success**: The transcoded stream is uploaded.
*   **fail**: The transcoded stream fails to be uploaded.', example='success'),
    type?: string(name='Type', description='The type of log delivery. Only **SLS_POST** is supported.', example='SLS_POST'),
  }(name='Content', description='The configuration results of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F32C57AA-7BF8-49AE-A2CC-9F42390F5A19'),
}

model DescribeDcdnSLSRealtimeLogDeliveryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnSLSRealtimeLogDeliveryResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnSLSRealtimeLogDeliveryRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnSLSRealtimeLogDeliveryResponse
 */
async function describeDcdnSLSRealtimeLogDeliveryWithOptions(request: DescribeDcdnSLSRealtimeLogDeliveryRequest, runtime: Util.RuntimeOptions): DescribeDcdnSLSRealtimeLogDeliveryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnSLSRealtimeLogDelivery',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnSLSRealtimeLogDeliveryRequest
  * @return DescribeDcdnSLSRealtimeLogDeliveryResponse
 */
async function describeDcdnSLSRealtimeLogDelivery(request: DescribeDcdnSLSRealtimeLogDeliveryRequest): DescribeDcdnSLSRealtimeLogDeliveryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnSLSRealtimeLogDeliveryWithOptions(request, runtime);
}

model DescribeDcdnSMCertificateDetailRequest {
  certIdentifier?: string(name='CertIdentifier', description='The ID of the certificate.', example='648****-cn-hangzhou'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnSMCertificateDetailResponseBody = {
  certExpireTime?: string(name='CertExpireTime', description='The time when the certificate expires. The time is displayed in UTC.', example='2022-08-31T09:42:28Z'),
  certIdentifier?: string(name='CertIdentifier', description='The ID of the certificate.', example='648****-cn-hangzhou'),
  certName?: string(name='CertName', description='The name of the certificate.', example='yourCertName'),
  certOrg?: string(name='CertOrg', description='The certificate authority (CA) that issued the certificate.', example='DigiCert Inc'),
  commonName?: string(name='CommonName', description='The top-level domain name.', example='example.com'),
  encryptCertificate?: string(name='EncryptCertificate', description='The content of the encryption certificate.', example='--BEGIN CERTIFICATE-----***-----END CERTIFICATE--'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A7C69682-7F88-40DD-A198-10D0309E439D'),
  sans?: string(name='Sans', description='The subdomain name.', example='***.example.com'),
  signCertificate?: string(name='SignCertificate', description='The content of the signature certificate.', example='--BEGIN CERTIFICATE-----***-----END CERTIFICATE--'),
}

model DescribeDcdnSMCertificateDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnSMCertificateDetailResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second.
  *
  * @param request DescribeDcdnSMCertificateDetailRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnSMCertificateDetailResponse
 */
async function describeDcdnSMCertificateDetailWithOptions(request: DescribeDcdnSMCertificateDetailRequest, runtime: Util.RuntimeOptions): DescribeDcdnSMCertificateDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnSMCertificateDetail',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second.
  *
  * @param request DescribeDcdnSMCertificateDetailRequest
  * @return DescribeDcdnSMCertificateDetailResponse
 */
async function describeDcdnSMCertificateDetail(request: DescribeDcdnSMCertificateDetailRequest): DescribeDcdnSMCertificateDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnSMCertificateDetailWithOptions(request, runtime);
}

model DescribeDcdnSMCertificateListRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name whose SM certificates you want to query.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnSMCertificateListResponseBody = {
  certificateListModel?: {
    certList?: [ 
      {
        certIdentifier?: string(name='CertIdentifier', description='The ID of the certificate.', example='yourCertldentifier'),
        certName?: string(name='CertName', description='The name of the certificate.', example='yourCertName'),
        common?: string(name='Common', description='The common name of the certificate.', example='yourCertCommon'),
        issuer?: string(name='Issuer', description='The certificate authority (CA) that issued the certificate.', example='yourCertIssuer'),
      }
    ](name='CertList', description='A list of certificates.'),
    count?: int32(name='Count', description='The number of certificates that are returned.', example='2'),
  }(name='CertificateListModel', description='The type of the certificate information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DC0E34AC-0239-44A7-AB0E-800DE522C8DC'),
}

model DescribeDcdnSMCertificateListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnSMCertificateListResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnSMCertificateListRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnSMCertificateListResponse
 */
async function describeDcdnSMCertificateListWithOptions(request: DescribeDcdnSMCertificateListRequest, runtime: Util.RuntimeOptions): DescribeDcdnSMCertificateListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnSMCertificateList',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnSMCertificateListRequest
  * @return DescribeDcdnSMCertificateListResponse
 */
async function describeDcdnSMCertificateList(request: DescribeDcdnSMCertificateListRequest): DescribeDcdnSMCertificateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnSMCertificateListWithOptions(request, runtime);
}

model DescribeDcdnSecFuncInfoRequest {
  lang?: string(name='Lang', description='The language. Valid values: en and zh. Default value: en.', example='en'),
  secFuncType?: string(name='SecFuncType', description='The type of the drop-down list. Valid values: RobotRuleName and RobotObject.', example='RobotRuleName'),
}

model DescribeDcdnSecFuncInfoResponseBody = {
  content?: [ 
    {
      label?: string(name='Label', description='The language (Chinese or English).', example='ai_defense'),
      value?: string(name='Value', description='The options in the drop-down list.', example='ai_defense'),
    }
  ](name='Content', description='The parameters required by the code.'),
  description?: string(name='Description', description='The description of HTTP responses.', example='OK'),
  httpStatus?: string(name='HttpStatus', description='The HTTP status code.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='30A3A25A-86B3-4C1D-BAA8-12B8607A5CFD'),
  retCode?: string(name='RetCode', description='The return value for HTTP requests.

*   0: OK.
*   Values other than 0: an error.', example='0'),
}

model DescribeDcdnSecFuncInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnSecFuncInfoResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnSecFuncInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnSecFuncInfoResponse
 */
async function describeDcdnSecFuncInfoWithOptions(request: DescribeDcdnSecFuncInfoRequest, runtime: Util.RuntimeOptions): DescribeDcdnSecFuncInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.secFuncType)) {
    query['SecFuncType'] = request.secFuncType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnSecFuncInfo',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnSecFuncInfoRequest
  * @return DescribeDcdnSecFuncInfoResponse
 */
async function describeDcdnSecFuncInfo(request: DescribeDcdnSecFuncInfoRequest): DescribeDcdnSecFuncInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnSecFuncInfoWithOptions(request, runtime);
}

model DescribeDcdnSecSpecInfoResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='32f6cbb7-13e5-403a-9941-4d4e978dd227'),
  specInfos?: [ 
    {
      ruleCode?: string(name='RuleCode', description='The code of the security rule.', example='accurate_***'),
      ruleConfigs?: [ 
        {
          code?: string(name='Code', description='The configuration code of the security rule.', example='custom_****_number'),
          expr?: string(name='Expr', description='The configuration expression of the security rule.', example='equal'),
          value?: string(name='Value', description='The value of the configuration expression of the security rule.', example='20'),
        }
      ](name='RuleConfigs', description='The configurations of the security rule.'),
    }
  ](name='SpecInfos', description='The code and configurations of the security rules.'),
  version?: string(name='Version', description='The version of secure DCDN.', example='enterprise'),
}

model DescribeDcdnSecSpecInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnSecSpecInfoResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 50 times per second.
  *
  * @param request DescribeDcdnSecSpecInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnSecSpecInfoResponse
 */
async function describeDcdnSecSpecInfoWithOptions(runtime: Util.RuntimeOptions): DescribeDcdnSecSpecInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeDcdnSecSpecInfo',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 50 times per second.
  *
  * @return DescribeDcdnSecSpecInfoResponse
 */
async function describeDcdnSecSpecInfo(): DescribeDcdnSecSpecInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnSecSpecInfoWithOptions(runtime);
}

model DescribeDcdnServiceRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnServiceResponseBody = {
  changingAffectTime?: string(name='ChangingAffectTime', description='The start time when the next billing method takes effect. The time is displayed in UTC.', example='2018-03-31T16:00:00Z'),
  changingChargeType?: string(name='ChangingChargeType', description='The next billing method that takes effect. Valid values:

*   **PayByTraffic**: traffic
*   **PayByBandwidth**: bandwidth
*   **PayByBandwidth95**: 95th percentile bandwidth
*   **PayByBandwidth_monthavg**: monthly average bandwidth
*   **PayByBandwidth_month4th**: the fourth peak bandwidth in each month
*   **PayByBandwidth_monthday95avg**: monthly average 95th percentile bandwidth
*   **PayByBandwidth_nighthalf95**: 95th percentile bandwidth of half idle bandwidth in the nighttime', example='PayByBandwidth'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='FP-mkqgwxxxx'),
  internetChargeType?: string(name='InternetChargeType', description='The current billing method. Valid values:

*   **PayByTraffic**: traffic
*   **PayByBandwidth**: bandwidth
*   **PayByBandwidth95**: 95th percentile bandwidth
*   **PayByBandwidth_monthavg**: monthly average bandwidth
*   **PayByBandwidth_month4th**: the fourth peak bandwidth in each month
*   **PayByBandwidth_monthday95avg**: monthly average 95th percentile bandwidth
*   **PayByBandwidth_nighthalf95**: 95th percentile bandwidth of half idle bandwidth in the nighttime', example='PayByTraffic'),
  openingTime?: string(name='OpeningTime', description='The time when the DCDN service was activated. The time follows the ISO 8601 standard.', example='2018-03-19T11:16:11Z'),
  operationLocks?: {
    lockReason?: [ 
    {
      lockReason?: string(name='LockReason', description='The reason why the service was locked. For example, a value of financial indicates that an overdue payment exists.', example='financial'),
    }
  ](name='LockReason')
  }(name='OperationLocks', description='The lock status of the DCDN service.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EF2AEBC2-EDBD-41CF-BF64-7E095D42D6EF'),
  websocketChangingTime?: string(name='WebsocketChangingTime', description='The time when the changes of the WebSocket configuration take effect. The value is the same as that of the ChangingAffectTime parameter. This parameter can be displayed in the console only if the specified time is later than the current time.', example='2018-03-19T11:16:11Z'),
  websocketChangingType?: string(name='WebsocketChangingType', description='The next effective billing method of WebSocket. Valid values: **websockettraffic** and **websocketbps**. A value of websockettraffic indicates that you are billed based on the traffic volume. A value of websocketbps indicates that you are billed based on the bandwidth.', example='websocketbps'),
  websocketType?: string(name='WebsocketType', description='The current billing method of WebSocket. Valid values: **websockettraffic** and **websocketbps**. A value of websockettraffic indicates that you are billed based on the traffic volume. A value of websocketbps indicates that you are billed based on the bandwidth.', example='websocketbps'),
}

model DescribeDcdnServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnServiceResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnServiceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnServiceResponse
 */
async function describeDcdnServiceWithOptions(request: DescribeDcdnServiceRequest, runtime: Util.RuntimeOptions): DescribeDcdnServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnService',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnServiceRequest
  * @return DescribeDcdnServiceResponse
 */
async function describeDcdnService(request: DescribeDcdnServiceRequest): DescribeDcdnServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnServiceWithOptions(request, runtime);
}

model DescribeDcdnStagingIpResponseBody = {
  IPV4s?: {
    IPV4?: [ string ](name='IPV4')
  }(name='IPV4s', description='The IPv4 addresses.format'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1B9E0E83-24AC-49F4-9EE0-BF5EB03E8381'),
}

model DescribeDcdnStagingIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnStagingIpResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnStagingIpRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnStagingIpResponse
 */
async function describeDcdnStagingIpWithOptions(runtime: Util.RuntimeOptions): DescribeDcdnStagingIpResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeDcdnStagingIp',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @return DescribeDcdnStagingIpResponse
 */
async function describeDcdnStagingIp(): DescribeDcdnStagingIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnStagingIpWithOptions(runtime);
}

model DescribeDcdnSubListResponseBody = {
  content?: string(name='Content', description='The information about the custom report task.', example='"data": [{"subId": 336,"reportId": [6,8],"createTime": "2021-07-05T06:18:46Z","domains": ["example.com"],"effectiveFrom": "2021-07-05T06:18:46Z","effectiveEnd": "2021-10-05T06:18:46Z","status": "enable"}]'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3250A51D-C11D-46BA-B6B3-95348EEDE652'),
}

model DescribeDcdnSubListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnSubListResponseBody(name='body'),
}

/**
  * > 
  * *   By default, this operation queries all custom report tasks. However, only one task can be displayed. Therefore, only one task is returned.
  * *   You can call this operation up to three times per second per account.
  *
  * @param request DescribeDcdnSubListRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnSubListResponse
 */
async function describeDcdnSubListWithOptions(runtime: Util.RuntimeOptions): DescribeDcdnSubListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeDcdnSubList',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   By default, this operation queries all custom report tasks. However, only one task can be displayed. Therefore, only one task is returned.
  * *   You can call this operation up to three times per second per account.
  *
  * @return DescribeDcdnSubListResponse
 */
async function describeDcdnSubList(): DescribeDcdnSubListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnSubListWithOptions(runtime);
}

model DescribeDcdnTagResourcesRequest {
  resourceId?: [ string ](name='ResourceId', example='example.com'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Set the value to **DOMAIN**.', example='DOMAIN'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N. Valid values of N: **1** to **20**.', example='env'),
      value?: string(name='Value', description='The value of tag N. Valid values of N: **1** to **20**.', example='product'),
    }
  ](name='Tag'),
}

model DescribeDcdnTagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='34AB41F1-04A5-496F-8C8D-634BDBE6A9FB'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the resource.', example='example.com'),
      tag?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='env'),
          value?: string(name='Value', description='The value of the tag.', example='product'),
        }
      ](name='Tag', description='The tags.'),
    }
  ](name='TagResources', description='The tags of the instance.'),
}

model DescribeDcdnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnTagResourcesResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 10 times per second per account.
  *
  * @param request DescribeDcdnTagResourcesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnTagResourcesResponse
 */
async function describeDcdnTagResourcesWithOptions(request: DescribeDcdnTagResourcesRequest, runtime: Util.RuntimeOptions): DescribeDcdnTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnTagResources',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 10 times per second per account.
  *
  * @param request DescribeDcdnTagResourcesRequest
  * @return DescribeDcdnTagResourcesResponse
 */
async function describeDcdnTagResources(request: DescribeDcdnTagResourcesRequest): DescribeDcdnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnTagResourcesWithOptions(request, runtime);
}

model DescribeDcdnTopDomainsByFlowRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

The end time must be later than the start time.', example='2016-03-14T07:34:00Z'),
  limit?: long(name='Limit', description='The maximum number of domain names to return. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2016-03-01T04:00:00Z'),
}

model DescribeDcdnTopDomainsByFlowResponseBody = {
  domainCount?: long(name='DomainCount', description='The total number of accelerated domains under your account.', example='68'),
  domainOnlineCount?: long(name='DomainOnlineCount', description='The total number of accelerated domains that are in the **Enabled** state under your account.', example='68'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was collected.', example='2016-03-14T07:34:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4E09C5D7-E1CF-4CAA-A45E-8727F4C8FD70'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was collected.', example='2016-03-14T06:34:00Z'),
  topDomains?: {
    topDomain?: [ 
    {
      domainName?: string(name='DomainName', description='The name of the accelerated domain.', example='example.com'),
      maxBps?: long(name='MaxBps', description='The peak bandwidth.', example='22139626'),
      maxBpsTime?: string(name='MaxBpsTime', description='The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.', example='2018-11-01T08:10:00Z'),
      rank?: long(name='Rank', description='The ranking of the domains.', example='1'),
      totalAccess?: long(name='TotalAccess', description='The number of visits to the URL that was queried.', example='3'),
      totalTraffic?: string(name='TotalTraffic', description='The total amount of network traffic.', example='123'),
      trafficPercent?: string(name='TrafficPercent', description='The proportion of the network traffic that was consumed for accessing the URL.', example='21.686305274906182'),
    }
  ](name='TopDomain')
  }(name='TopDomains', description='The top N domain names ranked by network traffic.'),
}

model DescribeDcdnTopDomainsByFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnTopDomainsByFlowResponseBody(name='body'),
}

/**
  * **Before you call this operation, pay attention to the following considerations:**If you do not specify the StartTime and EndTime parameters, the data within the current month is queried by default. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
  *
  * @param request DescribeDcdnTopDomainsByFlowRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnTopDomainsByFlowResponse
 */
async function describeDcdnTopDomainsByFlowWithOptions(request: DescribeDcdnTopDomainsByFlowRequest, runtime: Util.RuntimeOptions): DescribeDcdnTopDomainsByFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnTopDomainsByFlow',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **Before you call this operation, pay attention to the following considerations:**If you do not specify the StartTime and EndTime parameters, the data within the current month is queried by default. If you specify the StartTime and EndTime parameters, the data within the specified time range is queried.
  *
  * @param request DescribeDcdnTopDomainsByFlowRequest
  * @return DescribeDcdnTopDomainsByFlowResponse
 */
async function describeDcdnTopDomainsByFlow(request: DescribeDcdnTopDomainsByFlowRequest): DescribeDcdnTopDomainsByFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnTopDomainsByFlowWithOptions(request, runtime);
}

model DescribeDcdnUserBillHistoryRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0.

The end time must be later than the start time.', example='2018-10-31T16:00:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard

in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC+0.

The minimum data collection interval is 5 minutes.', example='2018-09-30T16:00:00Z'),
}

model DescribeDcdnUserBillHistoryResponseBody = {
  billHistoryData?: {
    billHistoryDataItem?: [ 
    {
      billTime?: string(name='BillTime', description='The start time of the billing cycle.', example='2018-09-30T17:00:00Z'),
      billType?: string(name='BillType', description='The billing method.', example='month_4th_day_bandwidth'),
      billingData?: {
        billingDataItem?: [ 
        {
          bandwidth?: float(name='Bandwidth', description='The bandwidth. Unit: bit/s.', example='4839'),
          cdnRegion?: string(name='CdnRegion', description='The region for which the billing records are generated. Valid values: **CN**, **OverSeas**, **AP1**, **AP2**, **AP3**, **NA**, **SA**, **EU**, and **MEAA**.', example='AP1'),
          chargeType?: string(name='ChargeType', description='The billing type. Valid values: **StaticHttp**, **DynamicHttp**, and **DynamicHttps**.', example='DynamicHttp'),
          count?: float(name='Count', description='The number of billing entries.', example='205624'),
          flow?: float(name='Flow', description='The traffic. Unit: byte.', example='2456'),
        }
      ](name='BillingDataItem')
      }(name='BillingData', description='The billing data.'),
      dimension?: string(name='Dimension', description='The dimension.', example='vas'),
    }
  ](name='BillHistoryDataItem')
  }(name='BillHistoryData', description='The billing records.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='ED61C6C3-8241-4187-AAA7-5157AE175CEC'),
}

model DescribeDcdnUserBillHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserBillHistoryResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnUserBillHistoryRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserBillHistoryResponse
 */
async function describeDcdnUserBillHistoryWithOptions(request: DescribeDcdnUserBillHistoryRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserBillHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserBillHistory',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnUserBillHistoryRequest
  * @return DescribeDcdnUserBillHistoryResponse
 */
async function describeDcdnUserBillHistory(request: DescribeDcdnUserBillHistoryRequest): DescribeDcdnUserBillHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserBillHistoryWithOptions(request, runtime);
}

model DescribeDcdnUserBillTypeRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query.

Specify the time in the ISO 8601 standard

in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-10-31T16:00:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard

in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-09-30T16:00:00Z'),
}

model DescribeDcdnUserBillTypeResponseBody = {
  billTypeData?: {
    billTypeDataItem?: [ 
    {
      billType?: string(name='BillType', description='The metering method. Valid values:

*   **hour_flow**: pay by data transfer per hour
*   **day_bandwidth**: pay by bandwidth per day
*   **month\\_95**: pay by 95th percentile
*   **month_avg_day_bandwidth**: pay by average daily peak bandwidth per month
*   **month\\_4th_day_bandwidth**: pay by 4th peak bandwidth per month
*   **month_avg_day\\_95**: pay by average daily 95th percentile per month
*   **month\\_95\\_night_half**: pay by 95th percentile (50 % off during nighttime)
*   **hour_vas**: pay by value-added service per month
*   **quic_hour_count**: pay by QUIC request per hour
*   **hour_count**: pay by request per hour
*   **rtlog_count_day**: pay by real-time log entry', example='month_avg_day_bandwidth_overseas'),
      billingCycle?: string(name='BillingCycle', description='The billing cycle.', example='month'),
      dimension?: string(name='Dimension', description='The dimension. Valid values:

*   **flow**: network traffic and bandwidth
*   **vas**: value-added services (HTTPS and requests for dynamic content)
*   **websocket**: WebSocket
*   **quic**: the number of QUIC requests
*   **rtlog2sls**: log entries delivered to Log Service in real time', example='flow'),
      endTime?: string(name='EndTime', description='The time when the metering method ends.', example='2018-10-31T16:00:00Z'),
      product?: string(name='Product', description='The name of the service.', example='dcdn'),
      startTime?: string(name='StartTime', description='The time when the metering method takes effect.', example='2018-10-30T16:00:00Z'),
    }
  ](name='BillTypeDataItem')
  }(name='BillTypeData', description='The information about the metering method.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C370DAF1-C838-4288-A1A0-9A87633D248E'),
}

model DescribeDcdnUserBillTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserBillTypeResponseBody(name='body'),
}

async function describeDcdnUserBillTypeWithOptions(request: DescribeDcdnUserBillTypeRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserBillTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserBillType',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDcdnUserBillType(request: DescribeDcdnUserBillTypeRequest): DescribeDcdnUserBillTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserBillTypeWithOptions(request, runtime);
}

model DescribeDcdnUserCertificateExpireCountResponseBody = {
  expireWithin30DaysCount?: int32(name='ExpireWithin30DaysCount', description='The number of domain names whose SSL certificates are about to expires within 30 days.', example='0'),
  expiredCount?: int32(name='ExpiredCount', description='The number of domain names whose SSL certificates have already expired.', example='6'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F5E8DF64-7175-4186-9B06-F002C0BBD0C5'),
}

model DescribeDcdnUserCertificateExpireCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserCertificateExpireCountResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnUserCertificateExpireCountRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserCertificateExpireCountResponse
 */
async function describeDcdnUserCertificateExpireCountWithOptions(runtime: Util.RuntimeOptions): DescribeDcdnUserCertificateExpireCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserCertificateExpireCount',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @return DescribeDcdnUserCertificateExpireCountResponse
 */
async function describeDcdnUserCertificateExpireCount(): DescribeDcdnUserCertificateExpireCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserCertificateExpireCountWithOptions(runtime);
}

model DescribeDcdnUserConfigsRequest {
  functionName?: string(name='FunctionName', description='The configuration that you want to query. Valid values:

*   domain_business_control: user configurations
*   bot_basic: the basic edition of bot traffic management, which supports authorized crawlers and provides threat intelligence
*   bot_Advance: the advanced edition of bot traffic management, which supports authorized crawlers and AI intelligent protection and provides threat intelligence', example='domain_business_control'),
}

model DescribeDcdnUserConfigsResponseBody = {
  configs?: [ 
    {
      argName?: string(name='ArgName', description='The name of the configuration.

The configuration that is specified by enterprise users and public service sectors.', example='allow_function'),
      argValue?: string(name='ArgValue', description='The value of the configuration. Valid values:

*   cc_rule: HTTP flood protection
*   ddos_dispatch: DDoS mitigation
*   edge_safe: application security on edge nodes
*   blocked_regions: region blacklist
*   http_acl_policy: precise access control
*   bot_manager: bot traffic management
*   ip_reputation: IP reputation library', example='{\\"dcdn_allow\\":[\\"cc_rule\\",\\"ddos_dispatch\\"]}'),
      functionName?: string(name='FunctionName', description='The configuration returned.', example='domain_business_control'),
    }
  ](name='Configs', description='The user configurations.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='06D29681-B7CD-4034-A8CC-28AFFA213539'),
}

model DescribeDcdnUserConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserConfigsResponseBody(name='body'),
}

/**
  * >You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnUserConfigsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserConfigsResponse
 */
async function describeDcdnUserConfigsWithOptions(request: DescribeDcdnUserConfigsRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserConfigs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnUserConfigsRequest
  * @return DescribeDcdnUserConfigsResponse
 */
async function describeDcdnUserConfigs(request: DescribeDcdnUserConfigsRequest): DescribeDcdnUserConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserConfigsWithOptions(request, runtime);
}

model DescribeDcdnUserDomainsRequest {
  changeEndTime?: string(name='ChangeEndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0.

> The end time must be later than the start time.', example='2018-05-10T14:00:00Z'),
  changeStartTime?: string(name='ChangeStartTime', description='The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0.', example='2018-05-10T12:00:00Z'),
  checkDomainShow?: boolean(name='CheckDomainShow', description='Specifies whether to display domain names that are under review, failed the review, or failed to be configured. Valid values:

*   true: displays domain names.
*   false: does not display domain names.', example='false'),
  coverage?: string(name='Coverage', description='The acceleration region. By default, all acceleration regions are queried.

*   **domestic**: Chinese mainland
*   **overseas**: global (excluding the Chinese mainland)
*   **global**: global', example='domestic'),
  domainName?: string(name='DomainName', description='The accelerated domain names. If you do not set this parameter, configurations of all domain names that match the conditions are returned.', example='example.com'),
  domainSearchType?: string(name='DomainSearchType', description='The search method. Default value: full_match. Valid values:

*   **fuzzy_match**: fuzzy match
*   **pre_match**: prefix match
*   **suf_match**: suffix match
*   **full_match**: exact match

> If you specify the domain names to query but do not set the DomainSearchType parameter, the exact match mode is used.', example='fuzzy_match'),
  domainStatus?: string(name='DomainStatus', description='The status of the domain name. Valid values:

*   **online**: enabled
*   **offline**: disabled
*   **configuring**: configuring
*   **configure_failed**: configuration failed
*   **checking**: reviewing
*   **check_failed:** review failed', example='online'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: **1** to **100000**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**. Valid values: **1** to **500**.', example='20'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmv6jutt**'),
  securityToken?: string(name='SecurityToken'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag. Valid values of N: **1** to **20**. You can call the TagDcdnResources operation to set a tag for a domain name.', example='1'),
      value?: string(name='Value', description='The value of the tag. Valid values of N: **1** to **20**.', example='1'),
    }
  ](name='Tag', description='The tags of the domain names.'),
}

model DescribeDcdnUserDomainsResponseBody = {
  domains?: {
    pageData?: [ 
    {
      cname?: string(name='Cname', description='The CNAME assigned to the accelerated domain name.', example='test.aliyun.com.w.alikunlun.com'),
      description?: string(name='Description', description='The reason why the accelerated domain name failed the review.', example='audit failed'),
      domainId?: long(name='DomainId', description='The ID of the accelerated domain name.', example='11223344'),
      domainName?: string(name='DomainName', description='The information about the accelerated domain name.', example='www.example.com'),
      domainStatus?: string(name='DomainStatus', description='The status of the accelerated domain name.

*   **online**: enabled
*   **offline**: disabled
*   **configuring**: configuring
*   **configure_failed**: configuration failed
*   **checking**: reviewing
*   **check_failed:** review failed', example='online'),
      gmtCreated?: string(name='GmtCreated', description='The time when the accelerated domain name was added.', example='2015-10-28T11:05:50Z'),
      gmtModified?: string(name='GmtModified', description='The time when the accelerated domain name was modified.', example='2015-10-28T09:31:59Z'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmv6jutt**'),
      SSLProtocol?: string(name='SSLProtocol', description='Indicates whether HTTPS is enabled.

*   **on**
*   **off**', example='on'),
      sandbox?: string(name='Sandbox', description='Indicates whether the accelerated domain name was in a sandbox.', example='normal'),
      sources?: {
        source?: [ 
        {
          content?: string(name='Content', description='The address of the origin server.', example='example.com'),
          port?: int32(name='Port', description='The port of the origin server.', example='80'),
          priority?: string(name='Priority', description='The priority.', example='20'),
          type?: string(name='Type', description='The type of the origin server.', example='oss'),
          weight?: string(name='Weight', description='The weight.', example='20'),
        }
      ](name='Source')
      }(name='Sources', description='The information about the origin server.'),
    }
  ](name='PageData')
  }(name='Domains', description='The detailed information about each accelerated domain name. The returned information is displayed in the format that is specified by the PageData parameter.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='12'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AA75AADB-5E25-4970-B480-EAA1F5658483'),
  totalCount?: long(name='TotalCount', description='The total number of entries returned.', example='12'),
}

model DescribeDcdnUserDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserDomainsResponseBody(name='body'),
}

/**
  * > You can call this operation up to 80 times per second per account.
  *
  * @param request DescribeDcdnUserDomainsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserDomainsResponse
 */
async function describeDcdnUserDomainsWithOptions(request: DescribeDcdnUserDomainsRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.changeEndTime)) {
    query['ChangeEndTime'] = request.changeEndTime;
  }
  if (!Util.isUnset(request.changeStartTime)) {
    query['ChangeStartTime'] = request.changeStartTime;
  }
  if (!Util.isUnset(request.checkDomainShow)) {
    query['CheckDomainShow'] = request.checkDomainShow;
  }
  if (!Util.isUnset(request.coverage)) {
    query['Coverage'] = request.coverage;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainSearchType)) {
    query['DomainSearchType'] = request.domainSearchType;
  }
  if (!Util.isUnset(request.domainStatus)) {
    query['DomainStatus'] = request.domainStatus;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserDomains',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can call this operation up to 80 times per second per account.
  *
  * @param request DescribeDcdnUserDomainsRequest
  * @return DescribeDcdnUserDomainsResponse
 */
async function describeDcdnUserDomains(request: DescribeDcdnUserDomainsRequest): DescribeDcdnUserDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserDomainsWithOptions(request, runtime);
}

model DescribeDcdnUserDomainsByFuncRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  funcFilter?: string(name='FuncFilter', description='Specifies whether the feature that is specified by the FuncId parameter is enabled. Valid values:

*   **config**: enabled
*   **unconfig**: not enabled', example='config'),
  funcId?: int32(name='FuncId', description='The ID of the feature. For more information about how to query feature IDs, see [Feature settings for a domain name](~~410622~~). For example, the ID of the origin host feature (set_req_host_header) is 18.', example='7'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: **1**. Valid values: **1 to 100000**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **20**. Valid values: **1 to 500**.', example='20'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyuji4b6r4**'),
}

model DescribeDcdnUserDomainsByFuncResponseBody = {
  domains?: {
    pageData?: [ 
    {
      cname?: string(name='Cname', description='The CNAME assigned to the accelerated domain name.', example='example.com.w.alikunlun.net'),
      description?: string(name='Description', description='The reason why the accelerated domain name failed the review.', example='audit failed'),
      domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
      domainStatus?: string(name='DomainStatus', description='The status of the accelerated domain name. Valid values:

*   **online**: enabled
*   **offline**: disabled
*   **configuring**: configuring
*   **configure_failed**: configuration failed
*   **checking**: reviewing
*   **check_failed**: failed the review', example='configure_failed'),
      gmtCreated?: string(name='GmtCreated', description='The time when the accelerated domain name was added.', example='2015-10-28T09:32:51Z'),
      gmtModified?: string(name='GmtModified', description='The time when the accelerated domain name was modified.', example='2015-10-28T11:05:50Z'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyuji4b6r4**'),
      sandbox?: string(name='Sandbox', description='Indicates whether the accelerated domain name was in a sandbox.', example='normal'),
      sources?: {
        source?: [ 
        {
          content?: string(name='Content', description='The address of the origin server.', example='image.developer.aliyundoc.com'),
          port?: int32(name='Port', description='The port of the origin server.', example='80'),
          priority?: string(name='Priority', description='The priority.', example='20'),
          type?: string(name='Type', description='The type of the origin server.', example='oss'),
          weight?: string(name='Weight', description='The weight of the origin server if multiple origin servers have been specified.', example='20'),
        }
      ](name='Source')
      }(name='Sources', description='The information about the origin server.'),
      sslProtocol?: string(name='SslProtocol', description='Indicates whether HTTPS is enabled. Valid values:

*   **on**
*   **off**', example='on'),
    }
  ](name='PageData')
  }(name='Domains', description='The detailed information about each accelerated domain name. The returned information is displayed in the format that is specified by the PageData parameter.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AA75AADB-5E25-4970-B480-EAA1F5658483'),
  totalCount?: long(name='TotalCount', description='The total number of domain names returned.', example='16'),
}

model DescribeDcdnUserDomainsByFuncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserDomainsByFuncResponseBody(name='body'),
}

/**
  * > You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnUserDomainsByFuncRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserDomainsByFuncResponse
 */
async function describeDcdnUserDomainsByFuncWithOptions(request: DescribeDcdnUserDomainsByFuncRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserDomainsByFuncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.funcFilter)) {
    query['FuncFilter'] = request.funcFilter;
  }
  if (!Util.isUnset(request.funcId)) {
    query['FuncId'] = request.funcId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserDomainsByFunc',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnUserDomainsByFuncRequest
  * @return DescribeDcdnUserDomainsByFuncResponse
 */
async function describeDcdnUserDomainsByFunc(request: DescribeDcdnUserDomainsByFuncRequest): DescribeDcdnUserDomainsByFuncResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserDomainsByFuncWithOptions(request, runtime);
}

model DescribeDcdnUserQuotaRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnUserQuotaResponseBody = {
  blockQuota?: int32(name='BlockQuota', description='The maximum number of URLs that can be blocked.', example='20'),
  blockRemain?: int32(name='BlockRemain', description='The remaining number of URLs that can be blocked.', example='500'),
  domainQuota?: int32(name='DomainQuota', description='The maximum number of accelerated domains.', example='50'),
  preloadQuota?: int32(name='PreloadQuota', description='The maximum number of URLs that can be prefetched.', example='500'),
  preloadRemain?: int32(name='PreloadRemain', description='The remaining number of URLs that can be prefetched.', example='300'),
  refreshDirQuota?: int32(name='RefreshDirQuota', description='The maximum number of directories that can be refreshed.', example='100'),
  refreshDirRemain?: int32(name='RefreshDirRemain', description='The remaining number of directories that can be refreshed.', example='100'),
  refreshUrlQuota?: int32(name='RefreshUrlQuota', description='The maximum number of URLs that can be refreshed.', example='100'),
  refreshUrlRemain?: int32(name='RefreshUrlRemain', description='The remaining number of URLs that can be refreshed.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BFFCDFAD-DACC-484E-9BE6-0AF3B3A0DD23'),
}

model DescribeDcdnUserQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserQuotaResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnUserQuotaRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserQuotaResponse
 */
async function describeDcdnUserQuotaWithOptions(request: DescribeDcdnUserQuotaRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserQuota',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeDcdnUserQuotaRequest
  * @return DescribeDcdnUserQuotaResponse
 */
async function describeDcdnUserQuota(request: DescribeDcdnUserQuotaRequest): DescribeDcdnUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserQuotaWithOptions(request, runtime);
}

model DescribeDcdnUserRealTimeDeliveryFieldRequest {
  businessType?: string(name='BusinessType', description='The type of the collected logs. Default value: cdn_log_access_l1. Valid values:

*   **cdn_log_access_l1**: access logs of L1 Dynamic Route for CDN (DCDN) nodes
*   **cdn_log_origin**: back-to-origin logs
*   **cdn_log_er**: EdgeRoutine logs', example='cdn_log_access_l1'),
}

model DescribeDcdnUserRealTimeDeliveryFieldResponseBody = {
  content?: {
    fields?: [ 
    {
      description?: string(name='Description', description='The description of the field.', example='interview time'),
      fieldName?: string(name='FieldName', description='The name of the field.', example='unixtime'),
      selected?: boolean(name='Selected', description='Indicates whether a field was selected.

*   **true**: The field was selected.
*   **false**: The field was not selected.', example='true'),
    }
  ](name='Fields')
  }(name='Content', description='The configuration results of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3EACD23C-F49F-4BF7-B9AD-C2CD3BA888C4'),
}

model DescribeDcdnUserRealTimeDeliveryFieldResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserRealTimeDeliveryFieldResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnUserRealTimeDeliveryFieldRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserRealTimeDeliveryFieldResponse
 */
async function describeDcdnUserRealTimeDeliveryFieldWithOptions(request: DescribeDcdnUserRealTimeDeliveryFieldRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserRealTimeDeliveryFieldResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserRealTimeDeliveryField',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnUserRealTimeDeliveryFieldRequest
  * @return DescribeDcdnUserRealTimeDeliveryFieldResponse
 */
async function describeDcdnUserRealTimeDeliveryField(request: DescribeDcdnUserRealTimeDeliveryFieldRequest): DescribeDcdnUserRealTimeDeliveryFieldResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserRealTimeDeliveryFieldWithOptions(request, runtime);
}

model DescribeDcdnUserResourcePackageRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
  status?: string(name='Status', description='The status of the resource plan. Valid values:

*   **valid**: The resource plan is valid.
*   **closed**: The resource plan is expired.
*   If you leave this parameter empty, all resource plans are queried.', example='valid'),
}

model DescribeDcdnUserResourcePackageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='96ED3127-EC7A-57C5-AFA6-A689B24B2530'),
  resourcePackageInfos?: {
    resourcePackageInfo?: [ 
    {
      commodityCode?: string(name='CommodityCode', description='The commodity code of the resource plan.', example='dcdnpaybag'),
      currCapacity?: string(name='CurrCapacity', description='The remaining quota of the resource plan.

*   The unit for traffic: bytes.
*   The unit for requests: count.', example='10000000'),
      displayName?: string(name='DisplayName', description='The name of the resource plan.', example='HTTPS requests for static content'),
      endTime?: string(name='EndTime', description='The time when the resource plan expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2022-08-24T16:00:00Z'),
      initCapacity?: string(name='InitCapacity', description='The total quota of the resource plan.

*   The unit for traffic: bytes.
*   The unit for requests: count.', example='10000000'),
      instanceId?: string(name='InstanceId', description='The ID of the resource plan.', example='CDNFLOWBAG-cn-7pp2bihrb01ii0'),
      startTime?: string(name='StartTime', description='The time when the resource plan takes effect. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-08-24T04:09:22Z'),
      status?: string(name='Status', description='The status of the resource plan. Valid values:

*   **valid**: The resource plan is valid.
*   **closed**: The resource package is expired.', example='valid'),
      templateName?: string(name='TemplateName', description='The name of the template.', example='FPT_dcdnpaybag_deadlineAcc_1541151058'),
    }
  ](name='ResourcePackageInfo')
  }(name='ResourcePackageInfos', description='The detailed information about resource plans. The returned information is displayed in the format that is specified by the ResourcePackageInfo parameter.'),
}

model DescribeDcdnUserResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserResourcePackageResponseBody(name='body'),
}

/**
  * > You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnUserResourcePackageRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserResourcePackageResponse
 */
async function describeDcdnUserResourcePackageWithOptions(request: DescribeDcdnUserResourcePackageRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserResourcePackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserResourcePackage',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > You can call this operation up to 30 times per second per account.
  *
  * @param request DescribeDcdnUserResourcePackageRequest
  * @return DescribeDcdnUserResourcePackageResponse
 */
async function describeDcdnUserResourcePackage(request: DescribeDcdnUserResourcePackageRequest): DescribeDcdnUserResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserResourcePackageWithOptions(request, runtime);
}

model DescribeDcdnUserSecDropRequest {
  data?: string(name='Data', description='The date or month that you want to query.

*   If data is collected every day, set the date in the format of yyyymmdd, such as 20201203.
*   If data is collected every month, set the month in the format of yyyymm, such as 202012.', example='20201203'),
  metric?: string(name='Metric', description='The time interval at which data is collected.

*   If data is collected every day, the number of blocked packets on the specified day is calculated.
*   If data is collected every month, the number of blocked packets in the specified month is calculated.', example='1day'),
  secFunc?: string(name='SecFunc', description='The security feature. Valid values:

*   waf: WAF
*   tmd: rate limiting
*   robot: bot traffic recognition
*   l4\\_dm_drop: domain name blocking on Layer 4', example='waf'),
}

model DescribeDcdnUserSecDropResponseBody = {
  drops?: int32(name='Drops', description='The number of packets that are blocked.', example='233023208'),
  msg?: string(name='Msg', description='Indicates whether the information is found.

*   Found: yes
*   Not Found: no', example='Found'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4A1295C0-7A5C-4F27-8D70-C3A648E7037F'),
  uuidStr?: string(name='UuidStr', description='The character string that is concatenated based on the request parameters and is used to locate causes when data is not found.', example='1day10811******6429wafDCDN'),
}

model DescribeDcdnUserSecDropResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserSecDropResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnUserSecDropRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserSecDropResponse
 */
async function describeDcdnUserSecDropWithOptions(request: DescribeDcdnUserSecDropRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserSecDropResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.metric)) {
    query['Metric'] = request.metric;
  }
  if (!Util.isUnset(request.secFunc)) {
    query['SecFunc'] = request.secFunc;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserSecDrop',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnUserSecDropRequest
  * @return DescribeDcdnUserSecDropResponse
 */
async function describeDcdnUserSecDrop(request: DescribeDcdnUserSecDropRequest): DescribeDcdnUserSecDropResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserSecDropWithOptions(request, runtime);
}

model DescribeDcdnUserSecDropByMinuteRequest {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0. Example: 2006-01-02T15:05:04Z.

>  The end time must be later than the start time.', example='2006-01-02T15:05:04Z'),
  lang?: string(name='Lang', description='The language. Valid values: en and zh. Default value: en', example='zh'),
  object?: string(name='Object', description='The object that triggered the rule.', example='robot_fingerprint_ai'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Pages start from page 1.', example='10'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Maximum value: 100.', example='2'),
  ruleName?: string(name='RuleName', description='The rule that was triggered.', example='robot_ai'),
  secFunc?: string(name='SecFunc', description='The name of the security feature.', example='robot'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0. Example: 2006-01-02T15:04:04Z.', example='2006-01-02T15:04:04Z'),
}

model DescribeDcdnUserSecDropByMinuteResponseBody = {
  description?: string(name='Description', description='The description of HTTP responses.', example='OK'),
  len?: int32(name='Len', description='The total number of entries returned.', example='2'),
  pageNumber?: int32(name='PageNumber', description='The number of the returned page.', example='10'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on each page.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='8143fA8A-B2B2-4915-538D-546B538D25FA'),
  rows?: [ 
    {
      domain?: string(name='Domain', description='The domain name.', example='example.aliyundoc.com'),
      drops?: int32(name='Drops', description='The number of packets blocked within 5 minutes.', example='264'),
      object?: string(name='Object', description='The object that triggered the rule.'),
      ruleName?: string(name='RuleName', description='The rule that is triggered.'),
      secFunc?: string(name='SecFunc', description='The security feature that blocked the packets.', example='robot'),
      tmStr?: string(name='TmStr', description='The beginning of the time range that was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is in UTC+0.', example='2021-01-31T15:04:04Z'),
    }
  ](name='Rows', description='The array returned.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='5738'),
}

model DescribeDcdnUserSecDropByMinuteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserSecDropByMinuteResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnUserSecDropByMinuteRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserSecDropByMinuteResponse
 */
async function describeDcdnUserSecDropByMinuteWithOptions(request: DescribeDcdnUserSecDropByMinuteRequest, runtime: Util.RuntimeOptions): DescribeDcdnUserSecDropByMinuteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.object)) {
    query['Object'] = request.object;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.secFunc)) {
    query['SecFunc'] = request.secFunc;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserSecDropByMinute',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 50.
  *
  * @param request DescribeDcdnUserSecDropByMinuteRequest
  * @return DescribeDcdnUserSecDropByMinuteResponse
 */
async function describeDcdnUserSecDropByMinute(request: DescribeDcdnUserSecDropByMinuteRequest): DescribeDcdnUserSecDropByMinuteResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserSecDropByMinuteWithOptions(request, runtime);
}

model DescribeDcdnUserTagsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='34AB41F1-04A5-496F-8C8D-634BDBE6A9FB'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the returned tag.', example='region'),
      value?: [ string ](name='Value', description='The value of the returned tag.'),
    }
  ](name='Tags', description='The tags.'),
}

model DescribeDcdnUserTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnUserTagsResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 100.
  *
  * @param request DescribeDcdnUserTagsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnUserTagsResponse
 */
async function describeDcdnUserTagsWithOptions(runtime: Util.RuntimeOptions): DescribeDcdnUserTagsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeDcdnUserTags',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 100.
  *
  * @return DescribeDcdnUserTagsResponse
 */
async function describeDcdnUserTags(): DescribeDcdnUserTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnUserTagsWithOptions(runtime);
}

model DescribeDcdnVerifyContentRequest {
  domainName?: string(name='DomainName', description='The domain name for which you want to query the ownership verification content. You can specify only one domain name in one request.', example='**example**.com'),
}

model DescribeDcdnVerifyContentResponseBody = {
  content?: string(name='Content', description='The verification content.', example='verify_dffeb6610035dcb78b413a59c31cd9**'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34AB41F1-04A5-496F-8C8D-634BDBE6A9FB'),
}

model DescribeDcdnVerifyContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnVerifyContentResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnVerifyContentRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnVerifyContentResponse
 */
async function describeDcdnVerifyContentWithOptions(request: DescribeDcdnVerifyContentRequest, runtime: Util.RuntimeOptions): DescribeDcdnVerifyContentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnVerifyContent',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request DescribeDcdnVerifyContentRequest
  * @return DescribeDcdnVerifyContentResponse
 */
async function describeDcdnVerifyContent(request: DescribeDcdnVerifyContentRequest): DescribeDcdnVerifyContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnVerifyContentWithOptions(request, runtime);
}

model DescribeDcdnWafDomainRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. If you do not specify an accelerated domain name, all accelerated domain names are queried.', example='example.com'),
  regionId?: string(name='RegionId', description='The region where WAF is enabled.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. If you leave this parameter empty, the default resource group is used.', example='/'),
}

model DescribeDcdnWafDomainResponseBody = {
  outPutDomains?: [ 
    {
      aclStatus?: int32(name='AclStatus', description='The status of the ACL. Valid values:

*   0: disabled
*   1: enabled', example='1'),
      ccStatus?: int32(name='CcStatus', description='The status of protection against HTTP flood attacks. Valid values:

*   0: disabled
*   1: enabled', example='1'),
      domain?: string(name='Domain', description='The domain name that has WAF enabled.', example='example.com'),
      status?: int32(name='Status', description='The status of the domain name. Valid values:

*   1: The domain name is added to WAF, or the domain name is valid.
*   10: The domain name is being added to WAF.
*   11: The domain name failed to be added to WAF.', example='1'),
      wafStatus?: int32(name='WafStatus', description='The status of WAF. Valid values:

*   0: disabled
*   1: enabled', example='1'),
    }
  ](name='OutPutDomains', description='Details about the accelerated domain names.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-802B-72F8FD6DA2FE'),
  totalCount?: int32(name='TotalCount', description='The number of accelerated domain names returned.', example='1'),
}

model DescribeDcdnWafDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafDomainResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 150 times per second per account.
  *
  * @param request DescribeDcdnWafDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafDomainResponse
 */
async function describeDcdnWafDomainWithOptions(request: DescribeDcdnWafDomainRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 150 times per second per account.
  *
  * @param request DescribeDcdnWafDomainRequest
  * @return DescribeDcdnWafDomainResponse
 */
async function describeDcdnWafDomain(request: DescribeDcdnWafDomainRequest): DescribeDcdnWafDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafDomainWithOptions(request, runtime);
}

model DescribeDcdnWafDomainDetailRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name in each request. Exact match is supported.', example='example.com'),
}

model DescribeDcdnWafDomainDetailResponseBody = {
  domain?: {
    defenseScenes?: [ 
      {
        defenseScene?: string(name='DefenseScene', description='The type of the protection policy. Valid values:

*   waf_group: basic web protection
*   custom_acl: custom protection
*   whitelist: IP address whitelist', example='waf_group'),
        policyId?: long(name='PolicyId', description='The ID of the protection policy. If multiple IDs exist, only one ID is returned.', example='10000002'),
        policyIds?: string(name='PolicyIds', description='The IDs of the protection policies. Multiple IDs are separated by commas (,).', example='10000001,10000004'),
      }
    ](name='DefenseScenes', description='The types of the protection policies.'),
    domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  }(name='Domain', description='The information about the accelerated domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BEA5625F-8FCF-48F4-851B-CA63946DA630'),
}

model DescribeDcdnWafDomainDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafDomainDetailResponseBody(name='body'),
}

/**
  * # Usage notes
  * You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafDomainDetailRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafDomainDetailResponse
 */
async function describeDcdnWafDomainDetailWithOptions(request: DescribeDcdnWafDomainDetailRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafDomainDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafDomainDetail',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * # Usage notes
  * You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafDomainDetailRequest
  * @return DescribeDcdnWafDomainDetailResponse
 */
async function describeDcdnWafDomainDetail(request: DescribeDcdnWafDomainDetailRequest): DescribeDcdnWafDomainDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafDomainDetailWithOptions(request, runtime);
}

model DescribeDcdnWafDomainsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Valid values: **1** to **100000**.

Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of domain names to return per page. Valid values: an integer from **1** to **500**. Default value: **20**.', example='20'),
  queryArgs?: string(name='QueryArgs', description='The query conditions. You can filter domain names by name. Fuzzy match is supported

    QueryArgs={"DomainName":"Accelerated domain name"}', example='{"DomainName":"example.com"}'),
}

model DescribeDcdnWafDomainsResponseBody = {
  domains?: [ 
    {
      clientIpTag?: string(name='ClientIpTag', description='The header of IP address of the client that is connected to the point of presence (POP).', example='X-Forwarded-For'),
      domainName?: string(name='DomainName', description='The protected domain name.', example='example.com'),
      policyCount?: int32(name='PolicyCount', description='The number of protection policies that were configured for the protected domain name.', example='3'),
    }
  ](name='Domains', description='The protected domain names.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page, which is the same as the PageNumber parameter in request parameters.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of domain names returned per page, which is the same as the PageSize parameter in request parameters.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='153ca2cd-3c01-44be-b408-64dbc6c88630'),
  totalCount?: int32(name='TotalCount', description='The total number of protected domain names.', example='15'),
}

model DescribeDcdnWafDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafDomainsResponseBody(name='body'),
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafDomainsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafDomainsResponse
 */
async function describeDcdnWafDomainsWithOptions(request: DescribeDcdnWafDomainsRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryArgs)) {
    query['QueryArgs'] = request.queryArgs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafDomains',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafDomainsRequest
  * @return DescribeDcdnWafDomainsResponse
 */
async function describeDcdnWafDomains(request: DescribeDcdnWafDomainsRequest): DescribeDcdnWafDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafDomainsWithOptions(request, runtime);
}

model DescribeDcdnWafFilterInfoRequest {
  defenseScenes?: string(name='DefenseScenes', description='The type of the protection policy. Separate multiple types with commas (,). Valid values:

*   waf_group: basic web protection
*   custom_acl: custom
*   whitelist: whitelist

>  If you do not specify this parameter, all types are returned.', example='custom_acl'),
  language?: string(name='Language', description='The language of the returned information. Default value: en. Valid values:

*   en: English
*   cn: Simplified Chinese', example='cn'),
}

model DescribeDcdnWafFilterInfoResponseBody = {
  content?: [ 
    {
      defenseScene?: string(name='DefenseScene', description='The type of the protection policy, which is the same as the DefenseScenes parameter in request parameters.', example='custom_acl'),
      fields?: [ 
        {
          extendField?: string(name='ExtendField', description='The description of the match field. If this parameter is not returned or if this parameter is empty, the match field does not have a description.'),
          logicalSymbol?: [ 
            {
              description?: string(name='Description', description='The logical symbol that is displayed in the Dynamic Route for CDN (DCDN) console.'),
              maxLength?: int32(name='MaxLength', description='The maximum number of match contents that you can specify. The value of this parameter varies based on the value of the Type parameter. Valid values:

*   If the value of the Type parameter is **multi**, the value of this parameter is the maximum number of match contents.
*   If the value of the Type parameter is **single**, the value of this parameter is 1.
*   If the value of the Type parameter is **none**, the value of this parameter is 0.', example='50'),
              regexp?: {
                errMsg?: string(name='ErrMsg', description='The error message returned because no items match the regular expression.'),
                pattern?: string(name='Pattern', description='The regular expression.', example='^\\S+$'),
              }(name='Regexp', description='The information about the regular expression.'),
              symbol?: string(name='Symbol', description='The logical symbol that is passed to the backend.', example='match-one'),
              tip?: string(name='Tip', description='The tips that are displayed in the match content.'),
              type?: string(name='Type', description='The number of match contents that you can specify. Valid values:

*   multi: You can specify multiple match contents.
*   single: You can specify only a match content.
*   none: You cannot specify a match content.', example='multi'),
            }
          ](name='LogicalSymbol', description='The information about the logical symbol.'),
          matchField?: string(name='MatchField', description='The match field.', example='Header'),
        }
      ](name='Fields', description='The information about the match condition.'),
    }
  ](name='Content', description='The returned information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='153ca2cd-3c01-44be-204c-64dbc6c88630'),
}

model DescribeDcdnWafFilterInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafFilterInfoResponseBody(name='body'),
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafFilterInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafFilterInfoResponse
 */
async function describeDcdnWafFilterInfoWithOptions(request: DescribeDcdnWafFilterInfoRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafFilterInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenseScenes)) {
    query['DefenseScenes'] = request.defenseScenes;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafFilterInfo',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafFilterInfoRequest
  * @return DescribeDcdnWafFilterInfoResponse
 */
async function describeDcdnWafFilterInfo(request: DescribeDcdnWafFilterInfoRequest): DescribeDcdnWafFilterInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafFilterInfoWithOptions(request, runtime);
}

model DescribeDcdnWafGeoInfoRequest {
  language?: string(name='Language', description='The language of the information to return. Valid values:

*   cn: Chinese
*   en: English', example='cn'),
}

model DescribeDcdnWafGeoInfoResponseBody = {
  content?: [ 
    {
      continents?: [ 
        {
          name?: string(name='Name', description='The district to which the country or region belongs.'),
          regions?: [ 
            {
              name?: string(name='Name', description='The name of the country or region.'),
              value?: string(name='Value', description='The code of the country or region.', example='110000'),
            }
          ](name='Regions', description='The region information.'),
        }
      ](name='Continents', description='The information about the country or region.'),
      type?: string(name='Type', description='The type of the region.

*   CN: China
*   Other: outside China', example='CN'),
    }
  ](name='Content', description='The type of information about the country or region.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='66A98669-CC6E-4F3E-80A6-3014697B11AE'),
}

model DescribeDcdnWafGeoInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafGeoInfoResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafGeoInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafGeoInfoResponse
 */
async function describeDcdnWafGeoInfoWithOptions(request: DescribeDcdnWafGeoInfoRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafGeoInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafGeoInfo',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafGeoInfoRequest
  * @return DescribeDcdnWafGeoInfoResponse
 */
async function describeDcdnWafGeoInfo(request: DescribeDcdnWafGeoInfoRequest): DescribeDcdnWafGeoInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafGeoInfoWithOptions(request, runtime);
}

model DescribeDcdnWafLogsRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query the logs.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-22T08:00:00Z'),
  pageNumber?: long(name='PageNumber', description='The number of the page to return. Valid values: positive integers.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries to return on each page. Default value: **300**. Valid values: **1 to 1000**.', example='300'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query the logs.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-21T08:00:00Z'),
}

model DescribeDcdnWafLogsResponseBody = {
  domainLogDetails?: [ 
    {
      domainName?: string(name='DomainName', description='The WAF domain name.', example='example.com'),
      logCount?: long(name='LogCount', description='The total number of entries returned on the current page.', example='10'),
      logInfos?: [ 
        {
          endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2015-05-23T14:00:00Z'),
          logName?: string(name='LogName', description='The name of the log file.', example='demo.aliyundoc.com_2015_05_23_2100_2200.xxxxxx.gz'),
          logPath?: string(name='LogPath', description='The path of the log file.', example='guide.aliyundoc.com-hangzhou.xxx'),
          logSize?: long(name='LogSize', description='The size of the log file. Unit: bytes.', example='258'),
          startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2015-05-23T13:00:00Z'),
        }
      ](name='LogInfos', description='The log information.'),
      pageInfos?: {
        pageIndex?: long(name='PageIndex', description='The page number of the returned page.', example='1'),
        pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='20'),
        total?: long(name='Total', description='The total number of entries returned.', example='20'),
      }(name='PageInfos', description='The page information. The page information is indicated by the PageInfoDetail parameter.'),
    }
  ](name='DomainLogDetails', description='Details about domain logs.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0985A362-C81E-5A56-891D-90226BEECA7C'),
}

model DescribeDcdnWafLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafLogsResponseBody(name='body'),
}

/**
  * > 
  * *   If you do not set StartTime or EndTime, data collected in the last 24 hours is queried. If you set both StartTime and EndTime, data collected within the specified time range is queried.
  * *   The log data is collected every hour.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnWafLogsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafLogsResponse
 */
async function describeDcdnWafLogsWithOptions(request: DescribeDcdnWafLogsRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafLogs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   If you do not set StartTime or EndTime, data collected in the last 24 hours is queried. If you set both StartTime and EndTime, data collected within the specified time range is queried.
  * *   The log data is collected every hour.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeDcdnWafLogsRequest
  * @return DescribeDcdnWafLogsResponse
 */
async function describeDcdnWafLogs(request: DescribeDcdnWafLogsRequest): DescribeDcdnWafLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafLogsWithOptions(request, runtime);
}

model DescribeDcdnWafPoliciesRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of protection policies to return per page. Valid values: an integer from **1** to **500**. Default value: **20**.', example='20'),
  queryArgs?: string(name='QueryArgs', description='The query conditions. The value is a string in the JSON format.

Format:

    QueryArgs={"PolicyIds":"The ID of the proteuleIds":"Thection policy","R range of protection rule IDs","PolicyNameLike":"The name of the protection policy","DomainNames":"The protected domain names","PolicyType":"default","DefenseScenes":"waf_group","PolicyStatus":"on","OrderBy":"GmtModified","Desc":"false"}

>  If you do not set this parameter, all protection policies are queried.', example='{"PolicyNameLIike":"test_policy"}'),
}

model DescribeDcdnWafPoliciesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Valid values: **1** to **100000**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of protection policies returned per page. Valid values: an integer from **1** to **500**. Default value: **20**.', example='20'),
  policies?: [ 
    {
      defenseScene?: string(name='DefenseScene', description='The type of the protection policy, which is the same as the DefenseScenes field in the QueryArgs parameter in request parameters.', example='custom_acl'),
      domainCount?: int32(name='DomainCount', description='The number of domain names that use this protection policy.', example='22'),
      gmtModified?: string(name='GmtModified', description='The time when the protection policy was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-12-29T17:08:45Z'),
      policyId?: long(name='PolicyId', description='The ID of the protection policy.', example='100001'),
      policyName?: string(name='PolicyName', description='The name of the protection policy.', example='policy_test'),
      policyStatus?: string(name='PolicyStatus', description='The status of the protection policy, which is the same as the PolicyStatus field in the QueryArgs parameter in request parameters.', example='on'),
      policyType?: string(name='PolicyType', description='Indicates whether this protection policy is the default policy, which is the same as the PolicyType field in the QueryArgs parameter in request parameters.', example='default'),
      ruleCount?: long(name='RuleCount', description='The number of protection rules in this protection policy.', example='9'),
    }
  ](name='Policies', description='The protection policies.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='153ca2cd-3c01-44be-2e83-64dbc6c88630'),
  totalCount?: int32(name='TotalCount', description='The total number of protection policies.', example='15'),
}

model DescribeDcdnWafPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafPoliciesResponseBody(name='body'),
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafPoliciesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafPoliciesResponse
 */
async function describeDcdnWafPoliciesWithOptions(request: DescribeDcdnWafPoliciesRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryArgs)) {
    query['QueryArgs'] = request.queryArgs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafPolicies',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafPoliciesRequest
  * @return DescribeDcdnWafPoliciesResponse
 */
async function describeDcdnWafPolicies(request: DescribeDcdnWafPoliciesRequest): DescribeDcdnWafPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafPoliciesWithOptions(request, runtime);
}

model DescribeDcdnWafPolicyRequest {
  policyId?: long(name='PolicyId', description='The ID of the protection policy. You can specify only one ID in each request.', example='1000001'),
}

model DescribeDcdnWafPolicyResponseBody = {
  policy?: {
    defenseScene?: string(name='DefenseScene', description='The type of the protection policy. Valid values:

*   waf_group: basic web protection
*   custom_acl: custom
*   whitelist: whitelist', example='waf_group'),
    domainCount?: int32(name='DomainCount', description='The number of domain names that use the protection policy.', example='22'),
    gmtModified?: string(name='GmtModified', description='The time when the protection policy was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-12-29T17:08:45Z'),
    policyId?: long(name='PolicyId', description='The ID of the protection policy.', example='100001'),
    policyName?: string(name='PolicyName', description='The name of the protection policy.', example='policy_test'),
    policyStatus?: string(name='PolicyStatus', description='The status of the protection policy. Valid values:

*   on
*   off', example='on'),
    policyType?: string(name='PolicyType', description='Indicates whether the current policy is the default policy. Valid values:

*   default: The current policy is the default policy.
*   custom: The current policy is not the default policy.', example='default'),
    ruleConfigs?: string(name='RuleConfigs', description='The protection rule configurations corresponding to the protection policy. The configurations only support Bot management. For more information, see [Configure protection rules](~~423350~~).', example='{     "type":"target_type",     "status":"on",     "config":{"target":"app"},     "action":""   }'),
    ruleCount?: long(name='RuleCount', description='The number of protection rules in the protection policy.', example='9'),
  }(name='Policy', description='The information about the protection policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='66A98669-CC6E-4F3E-80A6-3014697B11AE'),
}

model DescribeDcdnWafPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafPolicyResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafPolicyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafPolicyResponse
 */
async function describeDcdnWafPolicyWithOptions(request: DescribeDcdnWafPolicyRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafPolicy',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafPolicyRequest
  * @return DescribeDcdnWafPolicyResponse
 */
async function describeDcdnWafPolicy(request: DescribeDcdnWafPolicyRequest): DescribeDcdnWafPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafPolicyWithOptions(request, runtime);
}

model DescribeDcdnWafPolicyDomainsRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of domain names to return per page. Valid values: an integer from **1** to **500**. Default value: **20**.', example='20'),
  policyId?: long(name='PolicyId', description='The ID of the protection policy. You can specify only one ID in each request.', example='100001'),
}

model DescribeDcdnWafPolicyDomainsResponseBody = {
  domains?: [ 
    {
      domainName?: string(name='DomainName', description='The accelerated domain name that was protected by the specified protection policy.', example='example.com'),
    }
  ](name='Domains', description='The accelerated domain names.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page, which is the same as the PageNumber parameter in request parameters.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of domain names returned per page, which is the same as the PageSize parameter in request parameters.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='153ca2cd-3c01-44be-b480-64dbc6c88630'),
  totalCount?: int32(name='TotalCount', description='The total number of domain names returned.', example='2'),
}

model DescribeDcdnWafPolicyDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafPolicyDomainsResponseBody(name='body'),
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafPolicyDomainsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafPolicyDomainsResponse
 */
async function describeDcdnWafPolicyDomainsWithOptions(request: DescribeDcdnWafPolicyDomainsRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafPolicyDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafPolicyDomains',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafPolicyDomainsRequest
  * @return DescribeDcdnWafPolicyDomainsResponse
 */
async function describeDcdnWafPolicyDomains(request: DescribeDcdnWafPolicyDomainsRequest): DescribeDcdnWafPolicyDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafPolicyDomainsWithOptions(request, runtime);
}

model DescribeDcdnWafPolicyValidDomainsRequest {
  defenseScene?: string(name='DefenseScene', description='The type of the Web Application Firewall (WAF) protection policy. Valid values:

*   waf_group: basic web protection
*   custom_acl: custom protection
*   whitelist: IP address whitelist
*   ip_blacklist: IP address blacklist
*   region_block: region blacklist
*   bot: bot management', example='custom_acl'),
  domainNameLike?: string(name='DomainNameLike', description='The protected domain name. Fuzzy search is supported.', example='example.com'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of domain names to return on each page. Valid values: an integer from **1** to **500**. Default value: **20**.', example='20'),
}

model DescribeDcdnWafPolicyValidDomainsResponseBody = {
  domains?: [ 
    {
      domainName?: string(name='DomainName', description='The protected domain name.', example='example.com'),
      policies?: [ 
        {
          id?: long(name='Id', description='The ID of the policy.', example='10000002'),
          name?: string(name='Name', description='The name of the policy.', example='test2'),
          type?: string(name='Type', description='The type of the policy.', example='custom'),
        }
      ](name='Policies', description='The policy that is bound to the domain name.'),
      policyId?: long(name='PolicyId', description='The ID of the protection policy.', example='1000001'),
      policyName?: string(name='PolicyName', description='The name of the protection policy.', example='test1'),
      policyType?: string(name='PolicyType', description='Indicates whether the protection policy is the default policy. Valid values:

*   default: The protection policy is the default policy.
*   custom: The protection policy is not the default policy.', example='default'),
    }
  ](name='Domains', description='The information about the protected domain names.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page, which is the same as the PageNumber parameter in request parameters.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of domain names returned per page, which is the same as the PageSize parameter in request parameters.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92C630'),
  totalCount?: int32(name='TotalCount', description='The total number of domain names returned.', example='2'),
}

model DescribeDcdnWafPolicyValidDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafPolicyValidDomainsResponseBody(name='body'),
}

/**
  * # Usage notes
  * You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafPolicyValidDomainsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafPolicyValidDomainsResponse
 */
async function describeDcdnWafPolicyValidDomainsWithOptions(request: DescribeDcdnWafPolicyValidDomainsRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafPolicyValidDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenseScene)) {
    query['DefenseScene'] = request.defenseScene;
  }
  if (!Util.isUnset(request.domainNameLike)) {
    query['DomainNameLike'] = request.domainNameLike;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafPolicyValidDomains',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * # Usage notes
  * You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafPolicyValidDomainsRequest
  * @return DescribeDcdnWafPolicyValidDomainsResponse
 */
async function describeDcdnWafPolicyValidDomains(request: DescribeDcdnWafPolicyValidDomainsRequest): DescribeDcdnWafPolicyValidDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafPolicyValidDomainsWithOptions(request, runtime);
}

model DescribeDcdnWafRuleRequest {
  ruleId?: long(name='RuleId', description='The ID of the protection rule. You can specify only one ID in each request.', example='1000001'),
}

model DescribeDcdnWafRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='66A98669-CC6E-4F3E-80A6-3014697B11AE'),
  rule?: {
    defenseScene?: string(name='DefenseScene', description='The type of the protection policy. Valid values:

- waf_group: basic web protection
- custom_acl: custom
- whitelist: whitelist', example='custom_acl'),
    gmtModified?: string(name='GmtModified', description='The time at which the protection rule was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-12-29T17:08:45Z'),
    policyId?: long(name='PolicyId', description='The ID of the protection policy.', example='200001'),
    ruleConfig?: string(name='RuleConfig', description='The configurations of the protection rule.', example='{\\"action\\":\\"monitor\\",\\"actionExternal\\":\\"{}\\",\\"ccStatus\\":1,\\"conditions\\":[{\\"key\\":\\"URL\\",\\"opValue\\":\\"eq\\",\\"targetKey\\":\\"request_uri\\",\\"values\\":\\"/example\\"},{\\"key\\":\\"Header\\",\\"opValue\\":\\"eq\\",\\"subKey\\":\\"trt\\",\\"targetKey\\":\\"header.trt\\",\\"values\\":\\"3333\\"}],\\"effect\\":\\"service\\",\\"name\\":\\"aaa333\\",\\"origin\\":\\"custom\\",\\"ratelimit\\":{\\"interval\\":5,\\"status\\":{\\"code\\":404,\\"count\\":2,\\"stat\\":{\\"mode\\":\\"count\\",\\"value\\":2.0}},\\"target\\":\\"remote_addr\\",\\"threshold\\":2,\\"ttl\\":1800}}'),
    ruleId?: long(name='RuleId', description='The ID of the protection rule.', example='100001'),
    ruleName?: string(name='RuleName', description='The name of the protection rule.', example='rule_1'),
    ruleStatus?: string(name='RuleStatus', description='The status of the protection rule. Valid values:

- on
- off', example='on'),
  }(name='Rule', description='The information about the protection rule.'),
}

model DescribeDcdnWafRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafRuleResponseBody(name='body'),
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafRuleResponse
 */
async function describeDcdnWafRuleWithOptions(request: DescribeDcdnWafRuleRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafRule',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafRuleRequest
  * @return DescribeDcdnWafRuleResponse
 */
async function describeDcdnWafRule(request: DescribeDcdnWafRuleRequest): DescribeDcdnWafRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafRuleWithOptions(request, runtime);
}

model DescribeDcdnWafRulesRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: **1** to **100000**. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of protection rules to return per page. Valid values: an integer from **1** to **500**. Default value: **20**.', example='20'),
  queryArgs?: string(name='QueryArgs', description='The query conditions. The value is a string in the JSON format: `QueryArgs={"PolicyIds":"The range of protection policy IDs","RuleIds":"The range of protection rule IDs","RuleNameLike":"The name of the protection rule","DomainNames":"The protected domain names","DefenseScenes":"waf_group","RuleStatus":"on","OrderBy":"GmtModified","Desc":"false"}`

>  If you do not specify this parameter, all protection rules are queried.', example='{"RuleIds":"100001,200002"}'),
}

model DescribeDcdnWafRulesResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page, which is the same as the PageNumber parameter in request parameters.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of protection rules returned per page, which is the same as the PageSize parameter in request parameters.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='66A98669-CC6E-4F3E-80A6-3014697B11AE'),
  rules?: [ 
    {
      defenseScene?: string(name='DefenseScene', description='The type of the protection policy, which is the same as the DefenseScenes field in the QueryArgs parameter.', example='custom_acl'),
      gmtModified?: string(name='GmtModified', description='The modification time. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-12-29T17:08:45Z'),
      policyId?: long(name='PolicyId', description='The ID of the protection policy.', example='200001'),
      ruleConfig?: string(name='RuleConfig', description='The configuration information about the protection rule.', example='{\\"action\\":\\"monitor\\",\\"actionExternal\\":\\"{}\\",\\"ccStatus\\":1,\\"conditions\\":[{\\"key\\":\\"URL\\",\\"opValue\\":\\"eq\\",\\"targetKey\\":\\"request_uri\\",\\"values\\":\\"/example\\"},{\\"key\\":\\"Header\\",\\"opValue\\":\\"eq\\",\\"subKey\\":\\"trt\\",\\"targetKey\\":\\"header.trt\\",\\"values\\":\\"3333\\"}],\\"effect\\":\\"service\\",\\"name\\":\\"aaa333\\",\\"origin\\":\\"custom\\",\\"ratelimit\\":{\\"interval\\":5,\\"status\\":{\\"code\\":404,\\"count\\":2,\\"stat\\":{\\"mode\\":\\"count\\",\\"value\\":2.0}},\\"target\\":\\"remote_addr\\",\\"threshold\\":2,\\"ttl\\":1800}}'),
      ruleId?: long(name='RuleId', description='The ID of the protection rule.', example='100001'),
      ruleName?: string(name='RuleName', description='The name of the protection rule.', example='rule_1'),
      ruleStatus?: string(name='RuleStatus', description='The status of the protection rule, which is the same as the RuleStatus field in the QueryArgs parameter.', example='on'),
    }
  ](name='Rules', description='The information about the protection rule.'),
  totalCount?: int32(name='TotalCount', description='The total number of protection rules.', example='121'),
}

model DescribeDcdnWafRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafRulesResponseBody(name='body'),
}

/**
  * You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafRulesResponse
 */
async function describeDcdnWafRulesWithOptions(request: DescribeDcdnWafRulesRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryArgs)) {
    query['QueryArgs'] = request.queryArgs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafRules',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafRulesRequest
  * @return DescribeDcdnWafRulesResponse
 */
async function describeDcdnWafRules(request: DescribeDcdnWafRulesRequest): DescribeDcdnWafRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafRulesWithOptions(request, runtime);
}

model DescribeDcdnWafScenesRequest {
  defenseScenes?: string(name='DefenseScenes', description='The types of the protection policies that you want to query. Separate multiple types with commas (,). Valid values:

*   waf_group: basic web protection
*   custom_acl: custom protection
*   whitelist: IP address whitelist
*   ip_blacklist: IP address blacklist
*   region_block: region blacklist
*   bot: bot management

>  If you do not set this parameter, all types of protection policies are queried.', example='waf_group,custom_acl,whitelist'),
}

model DescribeDcdnWafScenesResponseBody = {
  defenseScenes?: [ 
    {
      defenseScene?: string(name='DefenseScene', description='The type of the protection policy, which is the same as the DefenseScenes parameter in request parameters.', example='waf_group'),
      policyCount?: int32(name='PolicyCount', description='The total number of policies of this type that were configured.', example='10'),
      ruleCount?: int32(name='RuleCount', description='The total number of protection rules that were configured in this type of the policy.', example='12'),
    }
  ](name='DefenseScenes', description='The types of the protection policies.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3D7BB13C-DD84-5654-A835-B8E1385DE274'),
}

model DescribeDcdnWafScenesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafScenesResponseBody(name='body'),
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafScenesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafScenesResponse
 */
async function describeDcdnWafScenesWithOptions(request: DescribeDcdnWafScenesRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafScenesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenseScenes)) {
    query['DefenseScenes'] = request.defenseScenes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafScenes',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafScenesRequest
  * @return DescribeDcdnWafScenesResponse
 */
async function describeDcdnWafScenes(request: DescribeDcdnWafScenesRequest): DescribeDcdnWafScenesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafScenesWithOptions(request, runtime);
}

model DescribeDcdnWafServiceRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnWafServiceResponseBody = {
  edition?: string(name='Edition', description='The edition of WAF.', example='dcdnwaf_afterpay'),
  enabled?: string(name='Enabled', description='The activation status of WAF. Valid values:

*   on
*   off', example='on'),
  openingTime?: string(name='OpeningTime', description='The time when WAF was enabled.', example='2021-09-26T16:00:00Z'),
  requestBillingType?: string(name='RequestBillingType', description='The billing method for requests.', example='dcdn_waf_req'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4A95CA90-E0F2-1BF6-99E0-8C1510CAF649'),
  ruleBillingType?: string(name='RuleBillingType', description='The billing method for rules. You are charged for the number of SeCUs.', example='dcdn_waf_rule'),
  status?: string(name='Status', description='The status of WAF. Valid values:

*   Normal
*   WaitForExpire
*   Expired
*   Released', example='Normal'),
}

model DescribeDcdnWafServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafServiceResponseBody(name='body'),
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafServiceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafServiceResponse
 */
async function describeDcdnWafServiceWithOptions(request: DescribeDcdnWafServiceRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafService',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafServiceRequest
  * @return DescribeDcdnWafServiceResponse
 */
async function describeDcdnWafService(request: DescribeDcdnWafServiceRequest): DescribeDcdnWafServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafServiceWithOptions(request, runtime);
}

model DescribeDcdnWafSpecInfoResponseBody = {
  edition?: string(name='Edition', description='The version of WAF.', example='dcdnwaf_afterpay'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7281593a-f414-42c1-b7ba-2ce65e21cc00'),
  specInfos?: [ 
    {
      configs?: [ 
        {
          config?: string(name='Config', description='The configuration code of the protection rule.', example='enable'),
          expr?: string(name='Expr', description='The configuration expression of the protection rule.', example='equal'),
          value?: string(name='Value', description='The value of the configuration expression of the protection rule.', example='on'),
        }
      ](name='Configs', description='The configuration information of the protection rule.'),
      defenseScene?: string(name='DefenseScene', description='The type of the protection policy. Valid values:

*   waf_group: basic web protection
*   custom_acl: custom protection
*   whitelist: IP address whitelist
*   ip_blacklist: IP address blacklist
*   region_block: region blacklist
*   bot: bot management', example='custom_acl'),
    }
  ](name='SpecInfos', description='The supported types of protection policies and the configuration information of protection rules.'),
}

model DescribeDcdnWafSpecInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafSpecInfoResponseBody(name='body'),
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @param request DescribeDcdnWafSpecInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafSpecInfoResponse
 */
async function describeDcdnWafSpecInfoWithOptions(runtime: Util.RuntimeOptions): DescribeDcdnWafSpecInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafSpecInfo',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >You can call this operation up to 20 times per second per account.
  *
  * @return DescribeDcdnWafSpecInfoResponse
 */
async function describeDcdnWafSpecInfo(): DescribeDcdnWafSpecInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafSpecInfoWithOptions(runtime);
}

model DescribeDcdnWafUsageDataRequest {
  domainName?: string(name='DomainName', description='The domain name that you want to query. If you do not specify an accelerated domain name, all accelerated domain names are queried by default.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2018-10-01T16:00:00Z'),
  interval?: string(name='Interval', description='The time granularity for a query. Unit: seconds.

The time granularity varies with the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day).', example='300'),
  splitBy?: string(name='SplitBy', description='Specifies how query results are grouped. By default, this parameter is empty. Valid values:

*   domain: Query results are grouped by accelerated domain name.
*   An empty string: Query results are not grouped.', example='domain'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-09-30T16:00:00Z'),
}

model DescribeDcdnWafUsageDataResponseBody = {
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2018-10-01T16:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-802B-72F8FD6DA2FE'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2018-09-30T16:00:00Z",'),
  wafUsageData?: {
    wafUsageDataItem?: [ 
    {
      accessCnt?: long(name='AccessCnt', description='The number of allowed requests.', example='600'),
      blockCnt?: long(name='BlockCnt', description='The number of blocked requests.', example='300'),
      domain?: string(name='Domain', description='The accelerated domain name.', example='example.com'),
      observeCnt?: long(name='ObserveCnt', description='The number of monitored requests.', example='300'),
      secCu?: long(name='SecCu', description='The number of used SeCUs.', example='50'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2018-09-30T16:00:00Z'),
    }
  ](name='WafUsageDataItem')
  }(name='WafUsageData', description='The WAF information about the accelerated domain name.'),
}

model DescribeDcdnWafUsageDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnWafUsageDataResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 10 times per second per account.
  * *   The minimum time granularity for a query is 5 minutes. The maximum time span for a query is 31 days. The time period within which historical data is available for a query is 90 days.
  *
  * @param request DescribeDcdnWafUsageDataRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnWafUsageDataResponse
 */
async function describeDcdnWafUsageDataWithOptions(request: DescribeDcdnWafUsageDataRequest, runtime: Util.RuntimeOptions): DescribeDcdnWafUsageDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.splitBy)) {
    query['SplitBy'] = request.splitBy;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnWafUsageData',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 10 times per second per account.
  * *   The minimum time granularity for a query is 5 minutes. The maximum time span for a query is 31 days. The time period within which historical data is available for a query is 90 days.
  *
  * @param request DescribeDcdnWafUsageDataRequest
  * @return DescribeDcdnWafUsageDataResponse
 */
async function describeDcdnWafUsageData(request: DescribeDcdnWafUsageDataRequest): DescribeDcdnWafUsageDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnWafUsageDataWithOptions(request, runtime);
}

model DescribeDcdnsecServiceRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDcdnsecServiceResponseBody = {
  changingAffectTime?: string(name='ChangingAffectTime', description='The time when the renewed secure DCDN takes effect. The time is displayed in UTC.', example='2021-09-30T16:00:00Z'),
  changingChargeType?: string(name='ChangingChargeType', description='The new metering method for the renewed secure DCDN. Valid values:

*   **PayByTraffic**: pay-by-data-transfer
*   **PayByBandwidth**: pay-by-bandwidth
*   **PayByBandwidth95**: pay-by-95th percentile bandwidth
*   **PayByBandwidth_monthavg**: pay-by-monthly average bandwidth
*   **PayByBandwidth_month4th**: pay-by-fourth peak bandwidth per month
*   **PayByBandwidth_monthday95avg**: pay-by-monthly average 95th percentile bandwidth
*   **PayByBandwidth_nighthalf95**: pay-by-95th percentile bandwidth (50% off during nighttime)', example='PayByBandwidth'),
  domainNum?: string(name='DomainNum', description='The number of accelerated domain names that use secure DCDN.', example='130'),
  endTime?: string(name='EndTime', description='The time when secure DCDN expires.', example='2021-09-26T16:00:00Z'),
  flowType?: string(name='FlowType', description='The metering method for traffic.', example='PayBySecTraffic'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='dcdn_dcdnsec_public_cn-123***'),
  internetChargeType?: string(name='InternetChargeType', description='The current metering method. Valid values:

*   **PayByTraffic**: pay-by-data-transfer
*   **PayByBandwidth**: pay-by-bandwidth
*   **PayByBandwidth95**: pay-by-95th percentile bandwidth
*   **PayByBandwidth_monthavg**: pay-by-monthly average bandwidth
*   **PayByBandwidth_month4th**: pay-by-fourth peak bandwidth per month
*   **PayByBandwidth_monthday95avg**: pay-by-monthly average 95th percentile bandwidth
*   **PayByBandwidth_nighthalf95**: pay-by-95th percentile bandwidth (50% off during nighttime)', example='PayByTraffic'),
  operationLocks?: {
    lockReason?: [ 
    {
      lockReason?: string(name='LockReason', description='The reason why secure DCDN was locked.', example='financial'),
    }
  ](name='LockReason')
  }(name='OperationLocks', description='The lock status of secure DCDN.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E20B46E1-9BCD-10E5-AAEF-6D7B737467A1'),
  requestType?: string(name='RequestType', description='The metering method for requests.', example='PayBySecRequest'),
  startTime?: string(name='StartTime', description='The time when secure DCDN was enabled.', example='2021-08-26T02:52:08Z'),
  version?: string(name='Version', description='The version of secure DCDN.', example='enterprise'),
}

model DescribeDcdnsecServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDcdnsecServiceResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 20 times per second.
  *
  * @param request DescribeDcdnsecServiceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeDcdnsecServiceResponse
 */
async function describeDcdnsecServiceWithOptions(request: DescribeDcdnsecServiceRequest, runtime: Util.RuntimeOptions): DescribeDcdnsecServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDcdnsecService',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 20 times per second.
  *
  * @param request DescribeDcdnsecServiceRequest
  * @return DescribeDcdnsecServiceResponse
 */
async function describeDcdnsecService(request: DescribeDcdnsecServiceRequest): DescribeDcdnsecServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDcdnsecServiceWithOptions(request, runtime);
}

model DescribeRDDomainConfigRequest {
  domainName?: string(name='DomainName', example='example.com'),
  functionName?: string(name='FunctionName', example='source_group'),
}

model DescribeRDDomainConfigResponseBody = {
  domainConfigs?: [ 
    {
      configId?: long(name='ConfigId', example='6295'),
      functionArgs?: [ 
        {
          argName?: string(name='ArgName', example='source_group_name'),
          argValue?: string(name='ArgValue', example='123'),
        }
      ](name='FunctionArgs'),
      functionName?: string(name='FunctionName', example='set_req_host_header'),
      parentId?: string(name='ParentId', example='1234567'),
      status?: string(name='Status', example='success'),
    }
  ](name='DomainConfigs'),
  requestId?: string(name='RequestId', example='C80705BF-0F76-41FA-BAD1-5B59296A4E59'),
}

model DescribeRDDomainConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRDDomainConfigResponseBody(name='body'),
}

async function describeRDDomainConfigWithOptions(request: DescribeRDDomainConfigRequest, runtime: Util.RuntimeOptions): DescribeRDDomainConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRDDomainConfig',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRDDomainConfig(request: DescribeRDDomainConfigRequest): DescribeRDDomainConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRDDomainConfigWithOptions(request, runtime);
}

model DescribeRDDomainsRequest {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', example='5'),
}

model DescribeRDDomainsResponseBody = {
  domains?: {
    pageData?: [ 
    {
      bizName?: string(name='BizName'),
      cname?: string(name='Cname', example='image.developer.aliyundoc.com'),
      description?: string(name='Description', example='audit failed'),
      domainName?: string(name='DomainName', example='example.com'),
      domainStatus?: string(name='DomainStatus', example='online'),
      gmtCreated?: string(name='GmtCreated', example='2015-10-27T06:26:34Z'),
      gmtModified?: string(name='GmtModified', example='2015-10-23T09:30:00Z'),
      resourceGroupId?: string(name='ResourceGroupId', example='abcd1234abcd1234'),
      sandbox?: string(name='Sandbox', example='normal'),
      serviceCode?: string(name='ServiceCode'),
      sources?: {
        source?: [ 
        {
          content?: string(name='Content', example='example.aliyundoc.com'),
          port?: int32(name='Port', example='80'),
          priority?: string(name='Priority', example='20'),
          type?: string(name='Type', example='oss'),
          weight?: string(name='Weight', example='20'),
        }
      ](name='Source')
      }(name='Sources'),
      sslProtocol?: string(name='SslProtocol', example='on'),
    }
  ](name='PageData')
  }(name='Domains'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='5'),
  requestId?: string(name='RequestId', example='AA75AADB-5E25-4970-B480-EAA1F5658483'),
  totalCount?: long(name='TotalCount', example='16'),
}

model DescribeRDDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRDDomainsResponseBody(name='body'),
}

async function describeRDDomainsWithOptions(request: DescribeRDDomainsRequest, runtime: Util.RuntimeOptions): DescribeRDDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRDDomains',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRDDomains(request: DescribeRDDomainsRequest): DescribeRDDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRDDomainsWithOptions(request, runtime);
}

model DescribeRoutineRequest {
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
}

model DescribeRoutineResponseBody = {
  content?: map[string]any(name='Content', description='The metadata of the routine. The next table describes the fields.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4DBA68F5-04A9-406B-B1E4-F2CB635E103F'),
}

model DescribeRoutineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRoutineResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeRoutineRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRoutineResponse
 */
async function describeRoutineWithOptions(request: DescribeRoutineRequest, runtime: Util.RuntimeOptions): DescribeRoutineResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRoutine',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeRoutineRequest
  * @return DescribeRoutineResponse
 */
async function describeRoutine(request: DescribeRoutineRequest): DescribeRoutineResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRoutineWithOptions(request, runtime);
}

model DescribeRoutineCanaryEnvsResponseBody = {
  content?: map[string]any(name='Content', description='The canary release environments that are supported by the edge routine.', example='presetCanaryShanghai'),
  requestId?: string(name='RequestId', description='The ID of the region.', example='CDCD94C0-F7FE-412F-B8F8-7E3C610C78E5'),
}

model DescribeRoutineCanaryEnvsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRoutineCanaryEnvsResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeRoutineCanaryEnvsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRoutineCanaryEnvsResponse
 */
async function describeRoutineCanaryEnvsWithOptions(runtime: Util.RuntimeOptions): DescribeRoutineCanaryEnvsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRoutineCanaryEnvs',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @return DescribeRoutineCanaryEnvsResponse
 */
async function describeRoutineCanaryEnvs(): DescribeRoutineCanaryEnvsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRoutineCanaryEnvsWithOptions(runtime);
}

model DescribeRoutineCodeRevisionRequest {
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
  selectCodeRevision?: string(name='SelectCodeRevision', description='The version of the JavaScript code that you want to query.', example='1611151912787121550'),
}

model DescribeRoutineCodeRevisionResponseBody = {
  content?: map[string]any(name='Content', description='The JavaScript code returned.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D24F0C48-1B27-4C58-8B84-1A0C001A514E'),
}

model DescribeRoutineCodeRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRoutineCodeRevisionResponseBody(name='body'),
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @param request DescribeRoutineCodeRevisionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRoutineCodeRevisionResponse
 */
async function describeRoutineCodeRevisionWithOptions(request: DescribeRoutineCodeRevisionRequest, runtime: Util.RuntimeOptions): DescribeRoutineCodeRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.selectCodeRevision)) {
    body['SelectCodeRevision'] = request.selectCodeRevision;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRoutineCodeRevision',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @param request DescribeRoutineCodeRevisionRequest
  * @return DescribeRoutineCodeRevisionResponse
 */
async function describeRoutineCodeRevision(request: DescribeRoutineCodeRevisionRequest): DescribeRoutineCodeRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRoutineCodeRevisionWithOptions(request, runtime);
}

model DescribeRoutineSpecResponseBody = {
  content?: map[string]any(name='Content', description='The specification of the CPU time slice. Valid values: 5 ms, 50 ms, and 100 ms.', example='5ms、50ms、100ms'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AE4E1B80-D5F3-47DB-824A-DA98A21854C8'),
}

model DescribeRoutineSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRoutineSpecResponseBody(name='body'),
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @param request DescribeRoutineSpecRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRoutineSpecResponse
 */
async function describeRoutineSpecWithOptions(runtime: Util.RuntimeOptions): DescribeRoutineSpecResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRoutineSpec',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The call frequency of the API is no more than 100 queries per second.
  *
  * @return DescribeRoutineSpecResponse
 */
async function describeRoutineSpec(): DescribeRoutineSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRoutineSpecWithOptions(runtime);
}

model DescribeRoutineUserInfoResponseBody = {
  content?: map[string]any(name='Content', description='The content returned by calling the operation.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='691DEEE5-4BDB-47F3-930E-F57176427717'),
}

model DescribeRoutineUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRoutineUserInfoResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request DescribeRoutineUserInfoRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeRoutineUserInfoResponse
 */
async function describeRoutineUserInfoWithOptions(runtime: Util.RuntimeOptions): DescribeRoutineUserInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRoutineUserInfo',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @return DescribeRoutineUserInfoResponse
 */
async function describeRoutineUserInfo(): DescribeRoutineUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRoutineUserInfoWithOptions(runtime);
}

model DescribeUserDcdnIpaStatusRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeUserDcdnIpaStatusResponseBody = {
  enabled?: boolean(name='Enabled', description='Indicates whether the IPA service is activated.', example='true'),
  inDebt?: boolean(name='InDebt', description='Indicates whether your IPA service has overdue payments.', example='false'),
  inDebtOverdue?: boolean(name='InDebtOverdue', description='Indicates whether an overdue bill has been paid within a specified period.', example='false'),
  onService?: boolean(name='OnService', description='Indicates whether the IPA service is available. The IPA service is available when no payment is overdue.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F51E9C3-728F-4E35-952D-0ED87A06A8A1'),
}

model DescribeUserDcdnIpaStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserDcdnIpaStatusResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request DescribeUserDcdnIpaStatusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeUserDcdnIpaStatusResponse
 */
async function describeUserDcdnIpaStatusWithOptions(request: DescribeUserDcdnIpaStatusRequest, runtime: Util.RuntimeOptions): DescribeUserDcdnIpaStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserDcdnIpaStatus',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request DescribeUserDcdnIpaStatusRequest
  * @return DescribeUserDcdnIpaStatusResponse
 */
async function describeUserDcdnIpaStatus(request: DescribeUserDcdnIpaStatusRequest): DescribeUserDcdnIpaStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserDcdnIpaStatusWithOptions(request, runtime);
}

model DescribeUserDcdnStatusRequest {
  ownerId?: long(name='OwnerId'),
}

model DescribeUserDcdnStatusResponseBody = {
  enabled?: boolean(name='Enabled', description='Indicates whether the DCDN service is activated.', example='true'),
  inDebt?: boolean(name='InDebt', description='Indicates whether the DCDN service has overdue payments.', example='false'),
  inDebtOverdue?: boolean(name='InDebtOverdue', description='Indicates whether an overdue bill has been paid within the specified period.', example='false'),
  onService?: boolean(name='OnService', description='Indicates whether the service is available.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F51E9C3-728F-4E35-952D-0ED87A06A8A1'),
}

model DescribeUserDcdnStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserDcdnStatusResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeUserDcdnStatusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeUserDcdnStatusResponse
 */
async function describeUserDcdnStatusWithOptions(request: DescribeUserDcdnStatusRequest, runtime: Util.RuntimeOptions): DescribeUserDcdnStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserDcdnStatus',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeUserDcdnStatusRequest
  * @return DescribeUserDcdnStatusResponse
 */
async function describeUserDcdnStatus(request: DescribeUserDcdnStatusRequest): DescribeUserDcdnStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserDcdnStatusWithOptions(request, runtime);
}

model DescribeUserErStatusRequest {
  ownerId?: long(name='OwnerId'),
}

model DescribeUserErStatusResponseBody = {
  enabled?: boolean(name='Enabled', description='Indicates whether ER is activated.

*   true: activated
*   false: not activated', example='true'),
  inDebt?: boolean(name='InDebt', description='Indicates whether ER has an overdue payment.

*   true: has an overdue payment
*   false: does not have an overdue payment', example='false'),
  inDebtOverdue?: boolean(name='InDebtOverdue', description='Indicates whether an overdue payment of ER has passed the grace period.

*   true: has passed the grace period
*   false: has not passed the grace period', example='false'),
  onService?: boolean(name='OnService', description='Indicates whether ER is available.

*   true: available
*   false: unavailable', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F51E9C3-728F-4E35-952D-0ED87A06A8A1'),
}

model DescribeUserErStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserErStatusResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeUserErStatusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeUserErStatusResponse
 */
async function describeUserErStatusWithOptions(request: DescribeUserErStatusRequest, runtime: Util.RuntimeOptions): DescribeUserErStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserErStatus',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request DescribeUserErStatusRequest
  * @return DescribeUserErStatusResponse
 */
async function describeUserErStatus(request: DescribeUserErStatusRequest): DescribeUserErStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserErStatusWithOptions(request, runtime);
}

model DescribeUserLogserviceStatusRequest {
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeUserLogserviceStatusResponseBody = {
  enabled?: boolean(name='Enabled', description='Indicates whether Log Service is activated.

*   true: activated
*   false: not activated', example='true'),
  inDebt?: boolean(name='InDebt', description='Indicates whether your Log Service has overdue payments.

*   true: Your Log Service has overdue payments.
*   false: Your Log Service does not have overdue payments.', example='false'),
  inDebtOverdue?: boolean(name='InDebtOverdue', description='Indicates whether the overdue payments of Log Service have passed the grace period.

*   true: The overdue payments of Log Service have passed the grace period.
*   false: The overdue payments of Log Service have not passed the grace period.', example='false'),
  onService?: boolean(name='OnService', description='Indicates whether Log Service is available.

*   true: available
*   false: unavailable', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F51E9C3-728F-4E35-952D-0ED87A06A8A1'),
}

model DescribeUserLogserviceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUserLogserviceStatusResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 20.
  *
  * @param request DescribeUserLogserviceStatusRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeUserLogserviceStatusResponse
 */
async function describeUserLogserviceStatusWithOptions(request: DescribeUserLogserviceStatusRequest, runtime: Util.RuntimeOptions): DescribeUserLogserviceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserLogserviceStatus',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 20.
  *
  * @param request DescribeUserLogserviceStatusRequest
  * @return DescribeUserLogserviceStatusResponse
 */
async function describeUserLogserviceStatus(request: DescribeUserLogserviceStatusRequest): DescribeUserLogserviceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserLogserviceStatusWithOptions(request, runtime);
}

model EditRoutineConfRequest {
  description?: string(name='Description', description='The description of the routine.', example='the description of this routine'),
  envConf?: map[string]any(name='EnvConf', description='The configurations of the specified environment.', example='{"staging":{"SpecName":"50ms","AllowedHosts":["test-a.alicdn.com","test-b.alicdn.com"]},"production":{"SpecName":"50ms","AllowedHosts":["test-c.alicdn.com","test-d.alicdn.com"]},"presetCanaryZhejiang":{"SpecName":"100ms","AllowedHosts":["test-e.alicdn.com","test-f.alicdn.com"]},"presetCanaryBeijing":{"SpecName":"5ms","AllowedHosts":["test-g.alicdn.com","test-h.alicdn.com"]},"presetCanaryNotExist":{"SpecName":"5ms","CodeRev":"1622446907645949975","AllowedHosts":["error hosts"]}}'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test-slc'),
}

model EditRoutineConfShrinkRequest {
  description?: string(name='Description', description='The description of the routine.', example='the description of this routine'),
  envConfShrink?: string(name='EnvConf', description='The configurations of the specified environment.', example='{"staging":{"SpecName":"50ms","AllowedHosts":["test-a.alicdn.com","test-b.alicdn.com"]},"production":{"SpecName":"50ms","AllowedHosts":["test-c.alicdn.com","test-d.alicdn.com"]},"presetCanaryZhejiang":{"SpecName":"100ms","AllowedHosts":["test-e.alicdn.com","test-f.alicdn.com"]},"presetCanaryBeijing":{"SpecName":"5ms","AllowedHosts":["test-g.alicdn.com","test-h.alicdn.com"]},"presetCanaryNotExist":{"SpecName":"5ms","CodeRev":"1622446907645949975","AllowedHosts":["error hosts"]}}'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test-slc'),
}

model EditRoutineConfResponseBody = {
  content?: map[string]any(name='Content', description='The description of the execution errors and the version number of the latest environment configurations.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BAECB354-6D42-42C1-87DA-C9992EF1E7C8'),
}

model EditRoutineConfResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EditRoutineConfResponseBody(name='body'),
}

/**
  * > 
  * *   This operation modifies only the specified configurations. Other configurations remain unchanged.
  * *   If you want to delete a setting, delete the parameter value.
  * *   This operation can add canary release environments. Make sure that the environment names comply with the naming rules. Otherwise, you will fail to add the environments.
  * *   Dynamic Route for CDN (DCDN) provides 35 canary release environments. Among these environments, 34 are deployed in China and 1 is deployed outside China. The canary release environments are:
  *     *   Outside China: presetCanaryOverseas.
  *     *   In China: The 34 canary release environments are named in the format of presetCanaryXX. For example, presetCanaryBeijing represents the canary release environment in Beijing. A canary release environment is in each of the following regions: Anhui, Beijing, Chongqing, Fujian, Gansu, Guangdong, Guangxi, Guizhou, Hainan, Hebei, Heilongjiang, Henan, Hong Kong, Hubei, Hunan, Jiangsu, Jiangxi, Jilin, Liaoning, Macao, Neimenggu, Ningxia, Qinghai, Shaanxi, Shandong, Shanghai, Shanxi, Sichuan, Taiwan, Tianjin, Xinjiang, Xizang, Yunan, and Zhejiang.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param tmpReq EditRoutineConfRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return EditRoutineConfResponse
 */
async function editRoutineConfWithOptions(tmpReq: EditRoutineConfRequest, runtime: Util.RuntimeOptions): EditRoutineConfResponse {
  Util.validateModel(tmpReq);
  var request = new EditRoutineConfShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.envConf)) {
    request.envConfShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.envConf, 'EnvConf', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.envConfShrink)) {
    body['EnvConf'] = request.envConfShrink;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EditRoutineConf',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   This operation modifies only the specified configurations. Other configurations remain unchanged.
  * *   If you want to delete a setting, delete the parameter value.
  * *   This operation can add canary release environments. Make sure that the environment names comply with the naming rules. Otherwise, you will fail to add the environments.
  * *   Dynamic Route for CDN (DCDN) provides 35 canary release environments. Among these environments, 34 are deployed in China and 1 is deployed outside China. The canary release environments are:
  *     *   Outside China: presetCanaryOverseas.
  *     *   In China: The 34 canary release environments are named in the format of presetCanaryXX. For example, presetCanaryBeijing represents the canary release environment in Beijing. A canary release environment is in each of the following regions: Anhui, Beijing, Chongqing, Fujian, Gansu, Guangdong, Guangxi, Guizhou, Hainan, Hebei, Heilongjiang, Henan, Hong Kong, Hubei, Hunan, Jiangsu, Jiangxi, Jilin, Liaoning, Macao, Neimenggu, Ningxia, Qinghai, Shaanxi, Shandong, Shanghai, Shanxi, Sichuan, Taiwan, Tianjin, Xinjiang, Xizang, Yunan, and Zhejiang.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request EditRoutineConfRequest
  * @return EditRoutineConfResponse
 */
async function editRoutineConf(request: EditRoutineConfRequest): EditRoutineConfResponse {
  var runtime = new Util.RuntimeOptions{};
  return editRoutineConfWithOptions(request, runtime);
}

model ListDcdnRealTimeDeliveryProjectRequest {
  businessType?: string(name='BusinessType', description='The type of the collected logs. Valid values:

*   **cdn_log_access_l1**: access logs of Dynamic Route for CDN (DCDN) points of presence (POP)
*   **cdn_log_origin**: back-to-origin logs
*   **cdn_log_er**: EdgeRoutine logs
*   By default, this parameter is left empty, and all logs are returned.', example='cdn_log_access_l1'),
  domainName?: string(name='DomainName', description='The domain name. You can specify only one domain name in each request. If this parameter is not specified, all domain names are queried.', example='example.com'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Valid values: **1** to **100000**. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. The default value is 20.', example='20'),
}

model ListDcdnRealTimeDeliveryProjectResponseBody = {
  content?: {
    projects?: [ 
    {
      businessType?: string(name='BusinessType', description='The type of the collected logs. Default value: cdn_log_access_l1. Valid values:

*   **cdn_log_access_l1**: access logs of DCDN POPs
*   **cdn_log_origin**: back-to-origin logs
*   **cdn_log_er**: EdgeRoutine logs', example='cdn_log_access_l1'),
      dataCenter?: string(name='DataCenter', description='The region from which logs were collected.', example='cn'),
      domainName?: string(name='DomainName', description='The domain names from which logs were collected. You can specify one or more domain names. Separate multiple domain names with commas (,).', example='example.com,example.org'),
      fieldName?: string(name='FieldName', description='The name of the field. For more information about fields in real-time log entries, see [Fields in a real-time log](~~324199~~).', example='field1,field2'),
      projectName?: string(name='ProjectName', description='The name of the Log Service project', example='example'),
      SLSLogStore?: string(name='SLSLogStore', description='The name of the Logstore.', example='example-cn'),
      SLSProject?: string(name='SLSProject', description='The name of the Log Service project.', example='example-cn'),
      SLSRegion?: string(name='SLSRegion', description='The region to which logs were delivered.', example='cn-hangzhou'),
      samplingRate?: float(name='SamplingRate', description='The sampling rate.', example='1'),
      type?: string(name='Type', description='The type of log delivery. Only **SLS_POST** is supported.', example='SLS_POST'),
    }
  ](name='Projects')
  }(name='Content', description='The configuration results of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3EACD23C-F49F-4BF7-B9AD-C2CD3BA888C4'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='2'),
}

model ListDcdnRealTimeDeliveryProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDcdnRealTimeDeliveryProjectResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request ListDcdnRealTimeDeliveryProjectRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListDcdnRealTimeDeliveryProjectResponse
 */
async function listDcdnRealTimeDeliveryProjectWithOptions(request: ListDcdnRealTimeDeliveryProjectRequest, runtime: Util.RuntimeOptions): ListDcdnRealTimeDeliveryProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDcdnRealTimeDeliveryProject',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request ListDcdnRealTimeDeliveryProjectRequest
  * @return ListDcdnRealTimeDeliveryProjectResponse
 */
async function listDcdnRealTimeDeliveryProject(request: ListDcdnRealTimeDeliveryProjectRequest): ListDcdnRealTimeDeliveryProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDcdnRealTimeDeliveryProjectWithOptions(request, runtime);
}

model ModifyDCdnDomainSchdmByPropertyRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain for which you want to change the acceleration region. You can specify only one domain name.', example='example.com'),
  property?: string(name='Property', description='The region where the acceleration service is deployed. Valid values:

*   **domestic**: Chinese mainland
*   **overseas**: outside the Chinese mainland
*   **global**: all the countries around the world', example='{"coverage":"overseas"}'),
}

model ModifyDCdnDomainSchdmByPropertyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
}

model ModifyDCdnDomainSchdmByPropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDCdnDomainSchdmByPropertyResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request ModifyDCdnDomainSchdmByPropertyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDCdnDomainSchdmByPropertyResponse
 */
async function modifyDCdnDomainSchdmByPropertyWithOptions(request: ModifyDCdnDomainSchdmByPropertyRequest, runtime: Util.RuntimeOptions): ModifyDCdnDomainSchdmByPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.property)) {
    query['Property'] = request.property;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDCdnDomainSchdmByProperty',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request ModifyDCdnDomainSchdmByPropertyRequest
  * @return ModifyDCdnDomainSchdmByPropertyResponse
 */
async function modifyDCdnDomainSchdmByProperty(request: ModifyDCdnDomainSchdmByPropertyRequest): ModifyDCdnDomainSchdmByPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDCdnDomainSchdmByPropertyWithOptions(request, runtime);
}

model ModifyDcdnWafPolicyRequest {
  policyId?: long(name='PolicyId', description='The ID of the protection policy that you want to modify. You can specify only one ID in each request.', example='1000001'),
  policyName?: string(name='PolicyName', description='The new name of the protection policy.

>  You must specify PolicyName or PolicyStatus.', example='policy_test'),
  policyStatus?: string(name='PolicyStatus', description='The new status of the protection policy. Valid values:

*   **on**
*   **off**

>  You must specify PolicyName or PolicyStatus.', example='on'),
}

model ModifyDcdnWafPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-C730-72F8FD6DA2FE'),
}

model ModifyDcdnWafPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDcdnWafPolicyResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request ModifyDcdnWafPolicyRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDcdnWafPolicyResponse
 */
async function modifyDcdnWafPolicyWithOptions(request: ModifyDcdnWafPolicyRequest, runtime: Util.RuntimeOptions): ModifyDcdnWafPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.policyStatus)) {
    body['PolicyStatus'] = request.policyStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDcdnWafPolicy',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request ModifyDcdnWafPolicyRequest
  * @return ModifyDcdnWafPolicyResponse
 */
async function modifyDcdnWafPolicy(request: ModifyDcdnWafPolicyRequest): ModifyDcdnWafPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDcdnWafPolicyWithOptions(request, runtime);
}

model ModifyDcdnWafPolicyDomainsRequest {
  bindDomains?: string(name='BindDomains', description='The domain names that you want to bind to the protection policy. You can specify up to 50 domain names. Separate multiple domain names with commas (,).

> You can configure only one of the **BindDomains** and **UnbindDomains** parameters.', example='example.com,example2.com'),
  method?: int32(name='Method'),
  policyId?: long(name='PolicyId', description='The ID of the protection policy. You can specify only one ID in each request.', example='1000001'),
  unbindDomains?: string(name='UnbindDomains', description='The domain names that you want to unbind from the protection policy. You can specify up to 50 domain names. Separate multiple domain names with commas (,).

> You can configure only one of the **BindDomains** and **UnbindDomains** parameters.', example='example3.com'),
}

model ModifyDcdnWafPolicyDomainsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-2B35-72F8FD6DA2FE'),
}

model ModifyDcdnWafPolicyDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDcdnWafPolicyDomainsResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 20 times per second.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request ModifyDcdnWafPolicyDomainsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDcdnWafPolicyDomainsResponse
 */
async function modifyDcdnWafPolicyDomainsWithOptions(request: ModifyDcdnWafPolicyDomainsRequest, runtime: Util.RuntimeOptions): ModifyDcdnWafPolicyDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bindDomains)) {
    body['BindDomains'] = request.bindDomains;
  }
  if (!Util.isUnset(request.method)) {
    body['Method'] = request.method;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.unbindDomains)) {
    body['UnbindDomains'] = request.unbindDomains;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDcdnWafPolicyDomains',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 20 times per second.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  *
  * @param request ModifyDcdnWafPolicyDomainsRequest
  * @return ModifyDcdnWafPolicyDomainsResponse
 */
async function modifyDcdnWafPolicyDomains(request: ModifyDcdnWafPolicyDomainsRequest): ModifyDcdnWafPolicyDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDcdnWafPolicyDomainsWithOptions(request, runtime);
}

model ModifyDcdnWafRuleRequest {
  ruleConfig?: string(name='RuleConfig', description='The new configurations of the protection rule.

>  After you modify the configurations of the protection rule, the previous configurations are overwritten.', example='{\\"origin\\":\\"custom\\",\\"conditions\\":[{\\"opValue\\":\\"eq\\",\\"key\\":\\"URL\\",\\"values\\":\\"/example\\"},{\\"opValue\\":\\"eq\\",\\"key\\":\\"Header\\",\\"values\\":\\"3333\\",\\"subKey\\":\\"trt\\"}],\\"actionExternal\\":{},\\"action\\":\\"monitor\\",\\"ccStatus\\":1,\\"ratelimit\\":{\\"target\\":\\"remote_addr\\",\\"interval\\":\\"5\\",\\"threshold\\":\\"2\\",\\"effect\\":\\"rule\\",\\"status\\":{\\"code\\":\\"404\\",\\"count\\":\\"2\\"},\\"ttl\\":\\"1800\\"}}\\"'),
  ruleId?: long(name='RuleId', description='The ID of the protection rule. You can specify only one ID in each request.', example='200001'),
  ruleName?: string(name='RuleName', description='The new name of the protection rule.', example='test'),
  ruleStatus?: string(name='RuleStatus', description='The new status of the protection rule. Valid values:

*   **on**
*   **off**', example='off'),
}

model ModifyDcdnWafRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB1A380B-09F0-41BB-3C2B-72F8FD6DA2FE'),
}

model ModifyDcdnWafRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDcdnWafRuleResponseBody(name='body'),
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  * *   You must configure at least one of the **RuleStatus**, **RuleName** and **RuleConfig** parameters.
  *
  * @param request ModifyDcdnWafRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ModifyDcdnWafRuleResponse
 */
async function modifyDcdnWafRuleWithOptions(request: ModifyDcdnWafRuleRequest, runtime: Util.RuntimeOptions): ModifyDcdnWafRuleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ruleConfig)) {
    body['RuleConfig'] = request.ruleConfig;
  }
  if (!Util.isUnset(request.ruleId)) {
    body['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleStatus)) {
    body['RuleStatus'] = request.ruleStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDcdnWafRule',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >*   You can call this operation up to 20 times per second per account.
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests.
  * *   You must configure at least one of the **RuleStatus**, **RuleName** and **RuleConfig** parameters.
  *
  * @param request ModifyDcdnWafRuleRequest
  * @return ModifyDcdnWafRuleResponse
 */
async function modifyDcdnWafRule(request: ModifyDcdnWafRuleRequest): ModifyDcdnWafRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDcdnWafRuleWithOptions(request, runtime);
}

model OpenDcdnServiceRequest {
  billType?: string(name='BillType', description='The metering method of DCDN. Valid values:

*   **PayByTraffic**: pay-by-traffic
*   **PayByBandwidth**: pay-by-bandwidth', example='PayByTraffic'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
  websocketBillType?: string(name='WebsocketBillType', description='The metering method of WebSocket. Default value: off. Valid values:

*   **websockettraffic**: pay-by-data-transfer
*   **websocketbps**: pay-by-bandwidth', example='websockettraffic'),
}

model OpenDcdnServiceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='97C68796-EB7F-4D41-9D5B-12B909D76503'),
}

model OpenDcdnServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenDcdnServiceResponseBody(name='body'),
}

/**
  * > 
  * *   DCDN can be activated only once per Alibaba Cloud account. The Alibaba Cloud account must pass real-name verification.
  * *   You can call this operation up to five times per second per account.
  *
  * @param request OpenDcdnServiceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return OpenDcdnServiceResponse
 */
async function openDcdnServiceWithOptions(request: OpenDcdnServiceRequest, runtime: Util.RuntimeOptions): OpenDcdnServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billType)) {
    query['BillType'] = request.billType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.websocketBillType)) {
    query['WebsocketBillType'] = request.websocketBillType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenDcdnService',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   DCDN can be activated only once per Alibaba Cloud account. The Alibaba Cloud account must pass real-name verification.
  * *   You can call this operation up to five times per second per account.
  *
  * @param request OpenDcdnServiceRequest
  * @return OpenDcdnServiceResponse
 */
async function openDcdnService(request: OpenDcdnServiceRequest): OpenDcdnServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openDcdnServiceWithOptions(request, runtime);
}

model PreloadDcdnObjectCachesRequest {
  area?: string(name='Area', description='The acceleration region in which you want to prefetch content. If you do not specify a region, the value overseas is used.

*   **domestic**: Chinese mainland
*   **overseas**: global (excluding the Chinese mainland)', example='domestic'),
  l2Preload?: boolean(name='L2Preload', description='Specifies whether to prefetch content to POPs. Default value: false. Valid values:

*   **true**: prefetches content to POPs that include L2 POPs.
*   **false**: prefetches content to L2 POPs or L3 POPs.', example='true'),
  objectPath?: string(name='ObjectPath', description='The path of the content that you want to prefetch. Separate multiple URLs with line feed characters (\\n) or a pair of carriage return and line feed characters (\\r\\n).', example='example.com/examplefile.txt'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
  withHeader?: string(name='WithHeader', description='The custom header for prefetch in JSON format.', example='{
      "Accept-Encoding": [
            "gzip"
      ]
}'),
}

model PreloadDcdnObjectCachesResponseBody = {
  preloadTaskId?: string(name='PreloadTaskId', description='The ID of the prefetch task. Multiple IDs are separated by commas (,).', example='95248880'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E5BD4B50-7A02-493A-AE0B-97B9024B4135'),
}

model PreloadDcdnObjectCachesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PreloadDcdnObjectCachesResponseBody(name='body'),
}

/**
  * # Usage notes
  * *   You can call the [RefreshDcdnObjectCaches](~~130620~~) operation to refresh content and call the [PreloadDcdnObjectCaches](~~130636~~) operation to prefetch content.
  * *   Dynamic Route for CDN (DCDN) supports POST requests in which parameters are sent as a form.
  * *   By default, each Alibaba Cloud account can submit up to 1,000 URLs per day. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to increase your daily quota. Alibaba Cloud reviews your application and then increases the quota accordingly.
  * *   Each Alibaba Cloud account can submit up to 100 URLs in a request.
  * *   The prefetch queue of each Alibaba Cloud account can contain up to 50,000 URLs. DCDN executes prefetch tasks based on the time at which you submit the URLs.
  * *   You can call this operation up to 15 times per second per account.
  * # Precautions
  * *   After a refresh task is submitted and executed, the POPs immediately start to retrieve resources from the origin server. Therefore, a large number of refresh tasks cause a large number of concurrent download tasks. This increases the number of requests that are redirected to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
  * *   The time required for a prefetch task to complete is proportional to the size of the prefetched file. In actual practice, most prefetch tasks take 5 to 30 minutes to complete. A task with a smaller average file size takes less time.
  * *   To allow Resource Access Management (RAM) users to perform this operation, you must first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~445051~~).
  *
  * @param request PreloadDcdnObjectCachesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return PreloadDcdnObjectCachesResponse
 */
async function preloadDcdnObjectCachesWithOptions(request: PreloadDcdnObjectCachesRequest, runtime: Util.RuntimeOptions): PreloadDcdnObjectCachesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.area)) {
    query['Area'] = request.area;
  }
  if (!Util.isUnset(request.l2Preload)) {
    query['L2Preload'] = request.l2Preload;
  }
  if (!Util.isUnset(request.objectPath)) {
    query['ObjectPath'] = request.objectPath;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.withHeader)) {
    query['WithHeader'] = request.withHeader;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PreloadDcdnObjectCaches',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * # Usage notes
  * *   You can call the [RefreshDcdnObjectCaches](~~130620~~) operation to refresh content and call the [PreloadDcdnObjectCaches](~~130636~~) operation to prefetch content.
  * *   Dynamic Route for CDN (DCDN) supports POST requests in which parameters are sent as a form.
  * *   By default, each Alibaba Cloud account can submit up to 1,000 URLs per day. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to increase your daily quota. Alibaba Cloud reviews your application and then increases the quota accordingly.
  * *   Each Alibaba Cloud account can submit up to 100 URLs in a request.
  * *   The prefetch queue of each Alibaba Cloud account can contain up to 50,000 URLs. DCDN executes prefetch tasks based on the time at which you submit the URLs.
  * *   You can call this operation up to 15 times per second per account.
  * # Precautions
  * *   After a refresh task is submitted and executed, the POPs immediately start to retrieve resources from the origin server. Therefore, a large number of refresh tasks cause a large number of concurrent download tasks. This increases the number of requests that are redirected to the origin server. The back-to-origin routing process consumes more bandwidth resources and the origin server may be overwhelmed.
  * *   The time required for a prefetch task to complete is proportional to the size of the prefetched file. In actual practice, most prefetch tasks take 5 to 30 minutes to complete. A task with a smaller average file size takes less time.
  * *   To allow Resource Access Management (RAM) users to perform this operation, you must first grant them the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](~~445051~~).
  *
  * @param request PreloadDcdnObjectCachesRequest
  * @return PreloadDcdnObjectCachesResponse
 */
async function preloadDcdnObjectCaches(request: PreloadDcdnObjectCachesRequest): PreloadDcdnObjectCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return preloadDcdnObjectCachesWithOptions(request, runtime);
}

model PublishDcdnStagingConfigToProductionRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain. You can specify only one domain name.', example='example.com'),
  functionName?: string(name='FunctionName', description='The name of the feature.', example='aliauth'),
}

model PublishDcdnStagingConfigToProductionResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model PublishDcdnStagingConfigToProductionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishDcdnStagingConfigToProductionResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 30.
  *
  * @param request PublishDcdnStagingConfigToProductionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return PublishDcdnStagingConfigToProductionResponse
 */
async function publishDcdnStagingConfigToProductionWithOptions(request: PublishDcdnStagingConfigToProductionRequest, runtime: Util.RuntimeOptions): PublishDcdnStagingConfigToProductionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.functionName)) {
    query['FunctionName'] = request.functionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishDcdnStagingConfigToProduction',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 30.
  *
  * @param request PublishDcdnStagingConfigToProductionRequest
  * @return PublishDcdnStagingConfigToProductionResponse
 */
async function publishDcdnStagingConfigToProduction(request: PublishDcdnStagingConfigToProductionRequest): PublishDcdnStagingConfigToProductionResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishDcdnStagingConfigToProductionWithOptions(request, runtime);
}

model PublishRoutineCodeRevisionRequest {
  envs?: map[string]any(name='Envs', description='The environment to which you want to publish the code.

> 
*   production: the name of the environment, including the environment name (SpecName) and the domain name whitelist (AllowedHosts).
*   presetCanary: **You can add canary release environments based on your business requirements. This parameter is optional.', example='["production","presetCanaryZhejiang"]'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
  selectCodeRevision?: string(name='SelectCodeRevision', description='The version of the routine code that you want to publish.', example='1620876959997924701'),
}

model PublishRoutineCodeRevisionShrinkRequest {
  envsShrink?: string(name='Envs', description='The environment to which you want to publish the code.

> 
*   production: the name of the environment, including the environment name (SpecName) and the domain name whitelist (AllowedHosts).
*   presetCanary: **You can add canary release environments based on your business requirements. This parameter is optional.', example='["production","presetCanaryZhejiang"]'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
  selectCodeRevision?: string(name='SelectCodeRevision', description='The version of the routine code that you want to publish.', example='1620876959997924701'),
}

model PublishRoutineCodeRevisionResponseBody = {
  content?: map[string]any(name='Content', description='The version of the routine code that is published to the specified environment.', example='"CodeRevision": "1620876959997924701"'),
  requestId?: string(name='RequestId', description='The ID of the region.', example='A513734D-D17B-411E-864D-XXXX'),
}

model PublishRoutineCodeRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishRoutineCodeRevisionResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param tmpReq PublishRoutineCodeRevisionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return PublishRoutineCodeRevisionResponse
 */
async function publishRoutineCodeRevisionWithOptions(tmpReq: PublishRoutineCodeRevisionRequest, runtime: Util.RuntimeOptions): PublishRoutineCodeRevisionResponse {
  Util.validateModel(tmpReq);
  var request = new PublishRoutineCodeRevisionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.envs)) {
    request.envsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.envs, 'Envs', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.envsShrink)) {
    body['Envs'] = request.envsShrink;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.selectCodeRevision)) {
    body['SelectCodeRevision'] = request.selectCodeRevision;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishRoutineCodeRevision',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request PublishRoutineCodeRevisionRequest
  * @return PublishRoutineCodeRevisionResponse
 */
async function publishRoutineCodeRevision(request: PublishRoutineCodeRevisionRequest): PublishRoutineCodeRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishRoutineCodeRevisionWithOptions(request, runtime);
}

model RefreshDcdnObjectCachesRequest {
  objectPath?: string(name='ObjectPath', description='The path of the objects that you want to refresh. Separate multiple URLs with line feed characters (\\n) or a pair of carriage return and line feed characters (\\r\\n).', example='example.com/example.txt'),
  objectType?: string(name='ObjectType', description='The refresh type. Default value: File. Valid values:

*   **File**: URL
*   **Directory**: directory', example='File'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RefreshDcdnObjectCachesResponseBody = {
  refreshTaskId?: string(name='RefreshTaskId', description='The ID of the refresh task. Multiple IDs are separated by commas (,).', example='95248880'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E5BD4B50-7A02-493A-AE0B-97B9024B4135'),
}

model RefreshDcdnObjectCachesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshDcdnObjectCachesResponseBody(name='body'),
}

/**
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests in which parameters are sent as a form.
  * *   You can call the [RefreshDcdnObjectCaches](~~130620~~) operation to refresh content and call the [PreloadDcdnObjectCaches](~~130636~~) operation to prefetch content.
  * *   By default, each Alibaba Cloud account can refresh content from a maximum of 10,000 URLs and 100 directories per day, including subdirectories. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to apply for an increased upper limit. Alibaba Cloud will review your application and then increase the quota accordingly.
  * *   You can specify up to 1,000 URLs or 100 directories that you want to refresh in each request.
  * *   You can refresh a maximum of 1,000 URLs per minute for each domain name.
  * *   You can call this operation up to 30 times per second per account.
  * - After a refresh task is submitted and completed, your resources that are stored on CDN POPs are removed. When a POP receives a request your resources, the request is redirected to the origin server to retrieve the resources. Then, the resources are returned to the client and cached on the POP. If you frequently run refresh tasks, more requests will be redirected back to the origin server for resources, which result in high bandwidth costs and undue pressure on the origin server.
  * - A refresh task takes effect five to six minutes after being submitted. This means that if the resource you want to refresh has a TTL of less than five minutes, you wait for it to expire instead of manually running a refresh task.
  * - If you want to use Resource Access Management (RAM) users to refresh or prefetch resources, you must acquire the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/to-grant-the-ram-users-refresh-and-preheating-permissions).
  *
  * @param request RefreshDcdnObjectCachesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RefreshDcdnObjectCachesResponse
 */
async function refreshDcdnObjectCachesWithOptions(request: RefreshDcdnObjectCachesRequest, runtime: Util.RuntimeOptions): RefreshDcdnObjectCachesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.objectPath)) {
    query['ObjectPath'] = request.objectPath;
  }
  if (!Util.isUnset(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshDcdnObjectCaches',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Alibaba Cloud Dynamic Route for CDN (DCDN) supports POST requests in which parameters are sent as a form.
  * *   You can call the [RefreshDcdnObjectCaches](~~130620~~) operation to refresh content and call the [PreloadDcdnObjectCaches](~~130636~~) operation to prefetch content.
  * *   By default, each Alibaba Cloud account can refresh content from a maximum of 10,000 URLs and 100 directories per day, including subdirectories. If the daily peak bandwidth value of your workloads exceeds 200 Mbit/s, you can [submit a ticket](https://account.alibabacloud.com/login/login.htm?oauth_callback=https%3A//ticket-intl.console.aliyun.com/%23/ticket/createIndex) to apply for an increased upper limit. Alibaba Cloud will review your application and then increase the quota accordingly.
  * *   You can specify up to 1,000 URLs or 100 directories that you want to refresh in each request.
  * *   You can refresh a maximum of 1,000 URLs per minute for each domain name.
  * *   You can call this operation up to 30 times per second per account.
  * - After a refresh task is submitted and completed, your resources that are stored on CDN POPs are removed. When a POP receives a request your resources, the request is redirected to the origin server to retrieve the resources. Then, the resources are returned to the client and cached on the POP. If you frequently run refresh tasks, more requests will be redirected back to the origin server for resources, which result in high bandwidth costs and undue pressure on the origin server.
  * - A refresh task takes effect five to six minutes after being submitted. This means that if the resource you want to refresh has a TTL of less than five minutes, you wait for it to expire instead of manually running a refresh task.
  * - If you want to use Resource Access Management (RAM) users to refresh or prefetch resources, you must acquire the required permissions. For more information, see [Authorize a RAM user to prefetch and refresh resources](https://www.alibabacloud.com/help/en/dynamic-route-for-cdn/latest/to-grant-the-ram-users-refresh-and-preheating-permissions).
  *
  * @param request RefreshDcdnObjectCachesRequest
  * @return RefreshDcdnObjectCachesResponse
 */
async function refreshDcdnObjectCaches(request: RefreshDcdnObjectCachesRequest): RefreshDcdnObjectCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshDcdnObjectCachesWithOptions(request, runtime);
}

model RollbackDcdnStagingConfigRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name in each call.', example='example.com'),
}

model RollbackDcdnStagingConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model RollbackDcdnStagingConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackDcdnStagingConfigResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request RollbackDcdnStagingConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RollbackDcdnStagingConfigResponse
 */
async function rollbackDcdnStagingConfigWithOptions(request: RollbackDcdnStagingConfigRequest, runtime: Util.RuntimeOptions): RollbackDcdnStagingConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackDcdnStagingConfig',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request RollbackDcdnStagingConfigRequest
  * @return RollbackDcdnStagingConfigResponse
 */
async function rollbackDcdnStagingConfig(request: RollbackDcdnStagingConfigRequest): RollbackDcdnStagingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackDcdnStagingConfigWithOptions(request, runtime);
}

model SetDcdnDomainCertificateRequest {
  certName?: string(name='CertName', description='The name of the certificate.', example='yourCertName'),
  certType?: string(name='CertType', description='The type of the certificate.

*   **upload**: a user-uploaded SSL certificate.
*   **cas**: a certificate that is acquired through SSL Certificates Service.
*   **free**: a free certificate.

> 
*   If the value of the CertType parameter is **cas**, the **SSLPri** parameter is not required.
*   If the value of the CertType parameter is **free**, the **SSLPri** and **SSLPub** parameters are not required.', example='cas'),
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name.

HTTPS acceleration must be enabled for the accelerated domain name.', example='example.com'),
  forceSet?: string(name='ForceSet', description='Specifies whether to check the certificate name for duplicates. If you set the value to 1, the system does not perform the check and overwrites the information about the existing certificate that uses the same name.', example='1'),
  ownerId?: long(name='OwnerId'),
  region?: string(name='Region', description='The region. Default value: ch-hangzhou.', example='cn-shanghai'),
  SSLPri?: string(name='SSLPri', description='The private key. This parameter is required only if you enable the SSL certificate.', example='SSLPri'),
  SSLProtocol?: string(name='SSLProtocol', description='Specifies whether to enable the SSL certificate. Default value: off. Valid values:

*   **on**: enables the SSL certificate.
*   **off**: disables the SSL certificate.', example='on'),
  SSLPub?: string(name='SSLPub', description='The content of the certificate. This parameter is required only if you enable the SSL certificate.', example='SSLPub'),
  securityToken?: string(name='SecurityToken'),
}

model SetDcdnDomainCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model SetDcdnDomainCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDcdnDomainCertificateResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request SetDcdnDomainCertificateRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetDcdnDomainCertificateResponse
 */
async function setDcdnDomainCertificateWithOptions(request: SetDcdnDomainCertificateRequest, runtime: Util.RuntimeOptions): SetDcdnDomainCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certName)) {
    query['CertName'] = request.certName;
  }
  if (!Util.isUnset(request.certType)) {
    query['CertType'] = request.certType;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.forceSet)) {
    query['ForceSet'] = request.forceSet;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.SSLPri)) {
    query['SSLPri'] = request.SSLPri;
  }
  if (!Util.isUnset(request.SSLProtocol)) {
    query['SSLProtocol'] = request.SSLProtocol;
  }
  if (!Util.isUnset(request.SSLPub)) {
    query['SSLPub'] = request.SSLPub;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDcdnDomainCertificate',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request SetDcdnDomainCertificateRequest
  * @return SetDcdnDomainCertificateResponse
 */
async function setDcdnDomainCertificate(request: SetDcdnDomainCertificateRequest): SetDcdnDomainCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDcdnDomainCertificateWithOptions(request, runtime);
}

model SetDcdnDomainSMCertificateRequest {
  certIdentifier?: string(name='CertIdentifier', description='The identifier of the certificate. The value must be Certificate ID-cn-hangzhou. If the ID of the certificate is 123, CertIdentifier is set to 123-cn-hangzhou.', example='123-cn-hangzhou'),
  domainName?: string(name='DomainName', description='The accelerated domain name for which the SM certificate is configured.

>  HTTPS acceleration must be enabled for the accelerated domain name.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  SSLProtocol?: string(name='SSLProtocol', description='Specifies whether to enable the SSL certificate. Valid values:

*   **on**
*   **off**', example='on'),
  securityToken?: string(name='SecurityToken'),
}

model SetDcdnDomainSMCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C8'),
}

model SetDcdnDomainSMCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDcdnDomainSMCertificateResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request SetDcdnDomainSMCertificateRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetDcdnDomainSMCertificateResponse
 */
async function setDcdnDomainSMCertificateWithOptions(request: SetDcdnDomainSMCertificateRequest, runtime: Util.RuntimeOptions): SetDcdnDomainSMCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.SSLProtocol)) {
    query['SSLProtocol'] = request.SSLProtocol;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDcdnDomainSMCertificate',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request SetDcdnDomainSMCertificateRequest
  * @return SetDcdnDomainSMCertificateResponse
 */
async function setDcdnDomainSMCertificate(request: SetDcdnDomainSMCertificateRequest): SetDcdnDomainSMCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDcdnDomainSMCertificateWithOptions(request, runtime);
}

model SetDcdnDomainStagingConfigRequest {
  domainName?: string(name='DomainName', description='The accelerated domain names. Separate multiple accelerated domain names with commas (,).', example='example.com'),
  functions?: string(name='Functions', description='The list of features. Specify the features in the following format:

`[{"functionArgs":[{"argName":"parameter key","argValue":"parameter value"},{"argName":"xx","argValue":"xx"}],"functionName": feature name"}]`

>  Separate multiple parameters with commas (,).', example='[{\\"functionArgs\\":[{\\"argName\\":\\"enable\\",\\"argValue\\":\\"on\\",\\"argName\\":\\"pri\\",\\"argValue\\":\\"1\\",\\"argName\\":\\"rule\\",\\"argValue\\":\\"xxx\\"}],\\"functionName\\":\\"edge_function\\"}]'),
}

model SetDcdnDomainStagingConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model SetDcdnDomainStagingConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDcdnDomainStagingConfigResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 30.
  *
  * @param request SetDcdnDomainStagingConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetDcdnDomainStagingConfigResponse
 */
async function setDcdnDomainStagingConfigWithOptions(request: SetDcdnDomainStagingConfigRequest, runtime: Util.RuntimeOptions): SetDcdnDomainStagingConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.functions)) {
    query['Functions'] = request.functions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDcdnDomainStagingConfig',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 30.
  *
  * @param request SetDcdnDomainStagingConfigRequest
  * @return SetDcdnDomainStagingConfigResponse
 */
async function setDcdnDomainStagingConfig(request: SetDcdnDomainStagingConfigRequest): SetDcdnDomainStagingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDcdnDomainStagingConfigWithOptions(request, runtime);
}

model SetDcdnUserConfigRequest {
  configs?: string(name='Configs', description='The configuration parameters of the features.', example='\\"argId\\":12,\\"argValue\\":\\"on\\"'),
  functionId?: int32(name='FunctionId', description='The ID of the feature.', example='6'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model SetDcdnUserConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F8AA0364-0FDB-4AD5-AC74-D69FAB8924ED'),
}

model SetDcdnUserConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDcdnUserConfigResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second.
  *
  * @param request SetDcdnUserConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetDcdnUserConfigResponse
 */
async function setDcdnUserConfigWithOptions(request: SetDcdnUserConfigRequest, runtime: Util.RuntimeOptions): SetDcdnUserConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configs)) {
    query['Configs'] = request.configs;
  }
  if (!Util.isUnset(request.functionId)) {
    query['FunctionId'] = request.functionId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDcdnUserConfig',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second.
  *
  * @param request SetDcdnUserConfigRequest
  * @return SetDcdnUserConfigResponse
 */
async function setDcdnUserConfig(request: SetDcdnUserConfigRequest): SetDcdnUserConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDcdnUserConfigWithOptions(request, runtime);
}

model SetRoutineSubdomainRequest {
  subdomains?: map[string]any(name='Subdomains', description='The parameters of the subdomain.

The parameters are in the following format:

```

Subdomains: [
    "subdomain-test"
]
```', example='["subdomain-test"]'),
}

model SetRoutineSubdomainShrinkRequest {
  subdomainsShrink?: string(name='Subdomains', description='The parameters of the subdomain.

The parameters are in the following format:

```

Subdomains: [
    "subdomain-test"
]
```', example='["subdomain-test"]'),
}

model SetRoutineSubdomainResponseBody = {
  content?: map[string]any(name='Content', description='The message returned, such as ""Status": "OK"".', example='"Status": "OK"'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model SetRoutineSubdomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetRoutineSubdomainResponseBody(name='body'),
}

/**
  * > 
  * *   Each subdomain is globally unique. Resource Access Management (RAM) users cannot create duplicate subdomains.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param tmpReq SetRoutineSubdomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return SetRoutineSubdomainResponse
 */
async function setRoutineSubdomainWithOptions(tmpReq: SetRoutineSubdomainRequest, runtime: Util.RuntimeOptions): SetRoutineSubdomainResponse {
  Util.validateModel(tmpReq);
  var request = new SetRoutineSubdomainShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.subdomains)) {
    request.subdomainsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subdomains, 'Subdomains', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.subdomainsShrink)) {
    body['Subdomains'] = request.subdomainsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetRoutineSubdomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   Each subdomain is globally unique. Resource Access Management (RAM) users cannot create duplicate subdomains.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request SetRoutineSubdomainRequest
  * @return SetRoutineSubdomainResponse
 */
async function setRoutineSubdomain(request: SetRoutineSubdomainRequest): SetRoutineSubdomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRoutineSubdomainWithOptions(request, runtime);
}

model StartDcdnDomainRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain to be enabled. You can specify only one domain name.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model StartDcdnDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model StartDcdnDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartDcdnDomainResponseBody(name='body'),
}

/**
  * > 
  * *   If an accelerated domain is in an invalid state or your account has an overdue payment, the accelerated domain cannot be enabled.
  * *   The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request StartDcdnDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StartDcdnDomainResponse
 */
async function startDcdnDomainWithOptions(request: StartDcdnDomainRequest, runtime: Util.RuntimeOptions): StartDcdnDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartDcdnDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   If an accelerated domain is in an invalid state or your account has an overdue payment, the accelerated domain cannot be enabled.
  * *   The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request StartDcdnDomainRequest
  * @return StartDcdnDomainResponse
 */
async function startDcdnDomain(request: StartDcdnDomainRequest): StartDcdnDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDcdnDomainWithOptions(request, runtime);
}

model StartDcdnIpaDomainRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain to be enabled. You can specify only one accelerated domain name at a time.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model StartDcdnIpaDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model StartDcdnIpaDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartDcdnIpaDomainResponseBody(name='body'),
}

/**
  * > 
  * *   The maximum number of times that users can call this operation per second is 20.
  * *   If an accelerated domain is in an invalid state or your account has an overdue payment, the accelerated domain cannot be enabled.
  *
  * @param request StartDcdnIpaDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StartDcdnIpaDomainResponse
 */
async function startDcdnIpaDomainWithOptions(request: StartDcdnIpaDomainRequest, runtime: Util.RuntimeOptions): StartDcdnIpaDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartDcdnIpaDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   The maximum number of times that users can call this operation per second is 20.
  * *   If an accelerated domain is in an invalid state or your account has an overdue payment, the accelerated domain cannot be enabled.
  *
  * @param request StartDcdnIpaDomainRequest
  * @return StartDcdnIpaDomainResponse
 */
async function startDcdnIpaDomain(request: StartDcdnIpaDomainRequest): StartDcdnIpaDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDcdnIpaDomainWithOptions(request, runtime);
}

model StopDcdnDomainRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain to be disabled. You can specify only one domain name.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model StopDcdnDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model StopDcdnDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopDcdnDomainResponseBody(name='body'),
}

/**
  * > 
  * *   After the accelerated domain is disabled, Dynamic Route for CDN retains its information and reroutes all the requests that are destined for the accelerated domain to the origin.
  * *   The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request StopDcdnDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StopDcdnDomainResponse
 */
async function stopDcdnDomainWithOptions(request: StopDcdnDomainRequest, runtime: Util.RuntimeOptions): StopDcdnDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopDcdnDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   After the accelerated domain is disabled, Dynamic Route for CDN retains its information and reroutes all the requests that are destined for the accelerated domain to the origin.
  * *   The maximum number of times that each user can call this operation per second is 30.
  *
  * @param request StopDcdnDomainRequest
  * @return StopDcdnDomainResponse
 */
async function stopDcdnDomain(request: StopDcdnDomainRequest): StopDcdnDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDcdnDomainWithOptions(request, runtime);
}

model StopDcdnIpaDomainRequest {
  domainName?: string(name='DomainName', description='The name of the accelerated domain that you want to disable. You can specify only one domain name at a time.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model StopDcdnIpaDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
}

model StopDcdnIpaDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopDcdnIpaDomainResponseBody(name='body'),
}

/**
  * > 
  * *   The maximum number of times that users can call this operation per second is 20.
  * *   If you disable an accelerated domain, the configurations of the accelerated domain are still retained. The system automatically forwards all the requests that are destined for this domain to the origin.
  *
  * @param request StopDcdnIpaDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StopDcdnIpaDomainResponse
 */
async function stopDcdnIpaDomainWithOptions(request: StopDcdnIpaDomainRequest, runtime: Util.RuntimeOptions): StopDcdnIpaDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopDcdnIpaDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   The maximum number of times that users can call this operation per second is 20.
  * *   If you disable an accelerated domain, the configurations of the accelerated domain are still retained. The system automatically forwards all the requests that are destined for this domain to the origin.
  *
  * @param request StopDcdnIpaDomainRequest
  * @return StopDcdnIpaDomainResponse
 */
async function stopDcdnIpaDomain(request: StopDcdnIpaDomainRequest): StopDcdnIpaDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDcdnIpaDomainWithOptions(request, runtime);
}

model TagDcdnResourcesRequest {
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource. Valid values of N: **1** to **50**.', example='example.com'),
  resourceType?: string(name='ResourceType', description='The type of the resources from which you want to detach tags. Set this value to **DOMAIN**.', example='DOMAIN'),
  tag?: [ 
    {
      key?: string(name='Key', description='The value of the tag. Valid values of N: **1** to **20**.', example='env'),
      value?: string(name='Value', description='The value of a tag. Valid values of N: **1** to **20**.', example='value'),
    }
  ](name='Tag', description='Details about the tags.'),
}

model TagDcdnResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='97C68796-EB7F-4D41-9D5B-12B909D76508'),
}

model TagDcdnResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagDcdnResourcesResponseBody(name='body'),
}

/**
  * >  You can call this API operation up to 100 times per second per account.
  *
  * @param request TagDcdnResourcesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return TagDcdnResourcesResponse
 */
async function tagDcdnResourcesWithOptions(request: TagDcdnResourcesRequest, runtime: Util.RuntimeOptions): TagDcdnResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagDcdnResources',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this API operation up to 100 times per second per account.
  *
  * @param request TagDcdnResourcesRequest
  * @return TagDcdnResourcesResponse
 */
async function tagDcdnResources(request: TagDcdnResourcesRequest): TagDcdnResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagDcdnResourcesWithOptions(request, runtime);
}

model UntagDcdnResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to delete all tags. Valid values:

*   **true**: yes
*   **false**: no

Default value: **false**.', example='false'),
  resourceId?: [ string ](name='ResourceId', description='The ID of the resource. Valid values of N: **1** to **50**.', example='example.com'),
  resourceType?: string(name='ResourceType', description='The type of the resources from which you want to detach tags. The resource type. Set this value to **DOMAIN**.', example='DOMAIN'),
  tagKey?: [ string ](name='TagKey', description='The key of a tag. Valid values of N: **1** to **20**.', example='env'),
}

model UntagDcdnResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='97C68796-EB7F-4D41-9D5B-12B909D76508'),
}

model UntagDcdnResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagDcdnResourcesResponseBody(name='body'),
}

/**
  * >  You can call this API operation up to 100 times per second per account.
  *
  * @param request UntagDcdnResourcesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UntagDcdnResourcesResponse
 */
async function untagDcdnResourcesWithOptions(request: UntagDcdnResourcesRequest, runtime: Util.RuntimeOptions): UntagDcdnResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagDcdnResources',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this API operation up to 100 times per second per account.
  *
  * @param request UntagDcdnResourcesRequest
  * @return UntagDcdnResourcesResponse
 */
async function untagDcdnResources(request: UntagDcdnResourcesRequest): UntagDcdnResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagDcdnResourcesWithOptions(request, runtime);
}

model UpdateDcdnDeliverTaskRequest {
  deliver?: string(name='Deliver', description='The method that is used to send operations reports. Operations reports are sent to you only by email. The settings must be escaped in JSON.', example='{"email":{"subject":"subject name","to":["username@example.com","username@example.com"]}}'),
  deliverId?: long(name='DeliverId', description='The ID of the tracking task that you want to update.', example='92'),
  domainName?: string(name='DomainName', description='The domain names from which the tracking task collects data. Separate domain names with commas (,). If you do not specify a domain name, the task collects data from all domain names that belong to your Alibaba Cloud account.', example='www.example.com'),
  name?: string(name='Name', description='The name of the tracking task.', example='Domain Subscription'),
  reports?: string(name='Reports', description='The operations reports that are tracked by the task. The data must be escaped in JSON.', example='[{\\"reportId\\":2,\\"conditions\\":[{\\"field\\":\\"prov\\",\\"op\\":\\"in\\",\\"value\\":[\\ "Heilongjiang\\",\\"Beijing\\"]}]}]'),
  schedule?: string(name='Schedule', description='The parameters that specify the time interval at which the tracking task sends operations reports. The settings must be escaped in JSON.', example='{"schedName":"subscription task name","description":"description","crontab":"000**?","frequency":"d","status":"enable","effectiveFrom": "2020-09-17T00:00:00Z","effectiveEnd":"2020-11-17T00:00:00Z"}'),
}

model UpdateDcdnDeliverTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model UpdateDcdnDeliverTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDcdnDeliverTaskResponseBody(name='body'),
}

/**
  * >  You can call this operation up to three times per second per account.
  *
  * @param request UpdateDcdnDeliverTaskRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateDcdnDeliverTaskResponse
 */
async function updateDcdnDeliverTaskWithOptions(request: UpdateDcdnDeliverTaskRequest, runtime: Util.RuntimeOptions): UpdateDcdnDeliverTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deliver)) {
    body['Deliver'] = request.deliver;
  }
  if (!Util.isUnset(request.deliverId)) {
    body['DeliverId'] = request.deliverId;
  }
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.reports)) {
    body['Reports'] = request.reports;
  }
  if (!Util.isUnset(request.schedule)) {
    body['Schedule'] = request.schedule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDcdnDeliverTask',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to three times per second per account.
  *
  * @param request UpdateDcdnDeliverTaskRequest
  * @return UpdateDcdnDeliverTaskResponse
 */
async function updateDcdnDeliverTask(request: UpdateDcdnDeliverTaskRequest): UpdateDcdnDeliverTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDcdnDeliverTaskWithOptions(request, runtime);
}

model UpdateDcdnDomainRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name. You can specify only one domain name in each call.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-xxxxx'),
  securityToken?: string(name='SecurityToken'),
  sources?: string(name='Sources', description='The information about the addresses of origin servers.', example='[{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80}]'),
  topLevelDomain?: string(name='TopLevelDomain', description='The top-level domain name.', example='yourTopLevelDomain'),
}

model UpdateDcdnDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model UpdateDcdnDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDcdnDomainResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request UpdateDcdnDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateDcdnDomainResponse
 */
async function updateDcdnDomainWithOptions(request: UpdateDcdnDomainRequest, runtime: Util.RuntimeOptions): UpdateDcdnDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sources)) {
    query['Sources'] = request.sources;
  }
  if (!Util.isUnset(request.topLevelDomain)) {
    query['TopLevelDomain'] = request.topLevelDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDcdnDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 30 times per second per account.
  *
  * @param request UpdateDcdnDomainRequest
  * @return UpdateDcdnDomainResponse
 */
async function updateDcdnDomain(request: UpdateDcdnDomainRequest): UpdateDcdnDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDcdnDomainWithOptions(request, runtime);
}

model UpdateDcdnIpaDomainRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name that you want to modify. You can specify only one domain name in each call.', example='example.com'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmyuji4b6r4**'),
  securityToken?: string(name='SecurityToken'),
  sources?: string(name='Sources', description='The list of origin URLs.', example='[{"content":"10.10.10.10","type":"ipaddr","priority":"20","port":80,"weight":"15"}]'),
  topLevelDomain?: string(name='TopLevelDomain', description='The top-level domain name.', example='example.edu'),
}

model UpdateDcdnIpaDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
}

model UpdateDcdnIpaDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDcdnIpaDomainResponseBody(name='body'),
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request UpdateDcdnIpaDomainRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateDcdnIpaDomainResponse
 */
async function updateDcdnIpaDomainWithOptions(request: UpdateDcdnIpaDomainRequest, runtime: Util.RuntimeOptions): UpdateDcdnIpaDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.sources)) {
    query['Sources'] = request.sources;
  }
  if (!Util.isUnset(request.topLevelDomain)) {
    query['TopLevelDomain'] = request.topLevelDomain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDcdnIpaDomain',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that users can call this operation per second is 20.
  *
  * @param request UpdateDcdnIpaDomainRequest
  * @return UpdateDcdnIpaDomainResponse
 */
async function updateDcdnIpaDomain(request: UpdateDcdnIpaDomainRequest): UpdateDcdnIpaDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDcdnIpaDomainWithOptions(request, runtime);
}

model UpdateDcdnSLSRealtimeLogDeliveryRequest {
  dataCenter?: string(name='DataCenter', description='The region from which logs are collected.

*   **cn**: Chinese mainland
*   **sg**: Singapore
*   **in**: India
*   **eu**: Europe
*   **us**: United States', example='cn'),
  domainName?: string(name='DomainName', description='The domain names. You can specify one or more domain names. Separate multiple domain names with commas (,).', example='example.com'),
  projectName?: string(name='ProjectName', description='The name of the real-time log delivery project.', example='example'),
  SLSLogStore?: string(name='SLSLogStore', description='The name of the Logstore.', example='example-cn'),
  SLSProject?: string(name='SLSProject', description='The name of the Log Service project.', example='example-cn'),
  SLSRegion?: string(name='SLSRegion', description='The region to which logs are delivered.', example='cn-hangzhou'),
  samplingRate?: string(name='SamplingRate', description='The sampling rate.', example='1.0'),
}

model UpdateDcdnSLSRealtimeLogDeliveryResponseBody = {
  content?: {
    domains?: [ 
    {
      desc?: string(name='Desc', description='The description of the returned result.', example='created'),
      domainName?: string(name='DomainName', description='The domain name for which the real-time log delivery project was updated.', example='example.com'),
      region?: string(name='Region', description='The region from which logs were collected.', example='cn'),
      status?: string(name='Status', description='Indicates whether the real-time log delivery project was successfully updated. Valid values:

*   **success**
*   **fail**', example='success'),
    }
  ](name='Domains')
  }(name='Content', description='The configuration results of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F32C57AA-7BF8-49AE-A2CC-9F42390F5A19'),
}

model UpdateDcdnSLSRealtimeLogDeliveryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDcdnSLSRealtimeLogDeliveryResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request UpdateDcdnSLSRealtimeLogDeliveryRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateDcdnSLSRealtimeLogDeliveryResponse
 */
async function updateDcdnSLSRealtimeLogDeliveryWithOptions(request: UpdateDcdnSLSRealtimeLogDeliveryRequest, runtime: Util.RuntimeOptions): UpdateDcdnSLSRealtimeLogDeliveryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataCenter)) {
    body['DataCenter'] = request.dataCenter;
  }
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.SLSLogStore)) {
    body['SLSLogStore'] = request.SLSLogStore;
  }
  if (!Util.isUnset(request.SLSProject)) {
    body['SLSProject'] = request.SLSProject;
  }
  if (!Util.isUnset(request.SLSRegion)) {
    body['SLSRegion'] = request.SLSRegion;
  }
  if (!Util.isUnset(request.samplingRate)) {
    body['SamplingRate'] = request.samplingRate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDcdnSLSRealtimeLogDelivery',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request UpdateDcdnSLSRealtimeLogDeliveryRequest
  * @return UpdateDcdnSLSRealtimeLogDeliveryResponse
 */
async function updateDcdnSLSRealtimeLogDelivery(request: UpdateDcdnSLSRealtimeLogDeliveryRequest): UpdateDcdnSLSRealtimeLogDeliveryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDcdnSLSRealtimeLogDeliveryWithOptions(request, runtime);
}

model UpdateDcdnSubTaskRequest {
  domainName?: string(name='DomainName', description='The domain names that you want to include in the operations report. If you do not specify a domain name, all domain names that belong to your Alibaba Cloud account are included.', example='www.example.com'),
  endTime?: string(name='EndTime', description='The end time of the operations report. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-06-17T00:00:00Z'),
  reportIds?: string(name='ReportIds', description='The IDs of operations reports that you want to update. Separate IDs with commas (,). You can call the [DescribeDcdnSubList](~~270075~~) operation to query report IDs.', example='2,4,6'),
  startTime?: string(name='StartTime', description='The start time of the operations report. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-04-17T00:00:00Z'),
}

model UpdateDcdnSubTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model UpdateDcdnSubTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDcdnSubTaskResponseBody(name='body'),
}

/**
  * >  You can call this operation up to three times per second per account.
  *
  * @param request UpdateDcdnSubTaskRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateDcdnSubTaskResponse
 */
async function updateDcdnSubTaskWithOptions(request: UpdateDcdnSubTaskRequest, runtime: Util.RuntimeOptions): UpdateDcdnSubTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.reportIds)) {
    body['ReportIds'] = request.reportIds;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDcdnSubTask',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to three times per second per account.
  *
  * @param request UpdateDcdnSubTaskRequest
  * @return UpdateDcdnSubTaskResponse
 */
async function updateDcdnSubTask(request: UpdateDcdnSubTaskRequest): UpdateDcdnSubTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDcdnSubTaskWithOptions(request, runtime);
}

model UpdateDcdnUserRealTimeDeliveryFieldRequest {
  businessType?: string(name='BusinessType', description='The type of the collected logs. Default value: cdn_log_access_l1. Valid values:

*   **cdn_log_access_l1**: access logs of L1 Dynamic Route for CDN (DCDN) points of presence (POPs)
*   **cdn_log_origin**: back-to-origin logs
*   **cdn_log_er**: EdgeRoutine logs', example='cdn_log_access_l1'),
  fields?: string(name='Fields', description='The list of fields. Separate multiple fields with commas (,). For more information, see [Fields in a real-time log](~~324199~~).', example='body_bytes_sent,client_ip,content_type'),
}

model UpdateDcdnUserRealTimeDeliveryFieldResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3EACD23C-F49F-4BF7-B9AD-C2CD3BA888C4'),
}

model UpdateDcdnUserRealTimeDeliveryFieldResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDcdnUserRealTimeDeliveryFieldResponseBody(name='body'),
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request UpdateDcdnUserRealTimeDeliveryFieldRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateDcdnUserRealTimeDeliveryFieldResponse
 */
async function updateDcdnUserRealTimeDeliveryFieldWithOptions(request: UpdateDcdnUserRealTimeDeliveryFieldRequest, runtime: Util.RuntimeOptions): UpdateDcdnUserRealTimeDeliveryFieldResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDcdnUserRealTimeDeliveryField',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  You can call this operation up to 100 times per second per account.
  *
  * @param request UpdateDcdnUserRealTimeDeliveryFieldRequest
  * @return UpdateDcdnUserRealTimeDeliveryFieldResponse
 */
async function updateDcdnUserRealTimeDeliveryField(request: UpdateDcdnUserRealTimeDeliveryFieldRequest): UpdateDcdnUserRealTimeDeliveryFieldResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDcdnUserRealTimeDeliveryFieldWithOptions(request, runtime);
}

model UploadRoutineCodeRequest {
  codeDescription?: string(name='CodeDescription', description='The description of the code version.', example='Hello World'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
}

model UploadRoutineCodeResponseBody = {
  content?: map[string]any(name='Content', description='The content returned that includes the code version number and information about code upload.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DFA2027F-86C0-4421-9593-581A7993696C'),
}

model UploadRoutineCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadRoutineCodeResponseBody(name='body'),
}

/**
  * > 
  * *   Each time you submit code, a version of the code is generated. You can manage and publish code by version.
  * *   Each routine can retain at most 10 versions. If the upper limit is reached, you must call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request UploadRoutineCodeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UploadRoutineCodeResponse
 */
async function uploadRoutineCodeWithOptions(request: UploadRoutineCodeRequest, runtime: Util.RuntimeOptions): UploadRoutineCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.codeDescription)) {
    body['CodeDescription'] = request.codeDescription;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadRoutineCode',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   Each time you submit code, a version of the code is generated. You can manage and publish code by version.
  * *   Each routine can retain at most 10 versions. If the upper limit is reached, you must call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
  * *   You can call this operation up to 100 times per second per account.
  *
  * @param request UploadRoutineCodeRequest
  * @return UploadRoutineCodeResponse
 */
async function uploadRoutineCode(request: UploadRoutineCodeRequest): UploadRoutineCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadRoutineCodeWithOptions(request, runtime);
}

model UploadStagingRoutineCodeRequest {
  codeDescription?: string(name='CodeDescription', description='The description of the version.', example='desc'),
  name?: string(name='Name', description='The name of the routine. The name must be unique among the routines that belong to the same Alibaba Cloud account.', example='test'),
}

model UploadStagingRoutineCodeResponseBody = {
  content?: map[string]any(name='Content', description='The parameters required by the code.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DFA2027F-86C0-4421-9593-581A7993696C'),
}

model UploadStagingRoutineCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadStagingRoutineCodeResponseBody(name='body'),
}

/**
  * > 
  * *   Each time you upload code to a routine, a version is generated. The number of versions is counted by CodeRev. The uploaded code is used only for testing.
  * *   The code is automatically published to a staging environment.
  * *   Each routine can retain at most 10 versions. If the upper limit is reached, you must call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
  * *   The call frequency of the API is no more than 100 queries per second.
  *
  * @param request UploadStagingRoutineCodeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UploadStagingRoutineCodeResponse
 */
async function uploadStagingRoutineCodeWithOptions(request: UploadStagingRoutineCodeRequest, runtime: Util.RuntimeOptions): UploadStagingRoutineCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.codeDescription)) {
    body['CodeDescription'] = request.codeDescription;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadStagingRoutineCode',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > 
  * *   Each time you upload code to a routine, a version is generated. The number of versions is counted by CodeRev. The uploaded code is used only for testing.
  * *   The code is automatically published to a staging environment.
  * *   Each routine can retain at most 10 versions. If the upper limit is reached, you must call the DeleteRoutineCodeRevision operation to manually delete versions that are no longer needed before new versions can be saved.
  * *   The call frequency of the API is no more than 100 queries per second.
  *
  * @param request UploadStagingRoutineCodeRequest
  * @return UploadStagingRoutineCodeResponse
 */
async function uploadStagingRoutineCode(request: UploadStagingRoutineCodeRequest): UploadStagingRoutineCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadStagingRoutineCodeWithOptions(request, runtime);
}

model VerifyDcdnDomainOwnerRequest {
  domainName?: string(name='DomainName', description='The domain name of which you want to verify the ownership. You can specify only one domain name in each call.', example='**example**.com'),
  verifyType?: string(name='VerifyType', description='The verification method, value:

*   dnsCheck: DNS verification
*   fileCheck: File verification', example='dnsCheck'),
}

model VerifyDcdnDomainOwnerResponseBody = {
  content?: string(name='Content', description='The verification information.', example='verify_dffeb6610035dcb77b413a59c32cd9**'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='34AB41F1-04A5-496F-8C8D-634BDBE6A9FB'),
}

model VerifyDcdnDomainOwnerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyDcdnDomainOwnerResponseBody(name='body'),
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request VerifyDcdnDomainOwnerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return VerifyDcdnDomainOwnerResponse
 */
async function verifyDcdnDomainOwnerWithOptions(request: VerifyDcdnDomainOwnerRequest, runtime: Util.RuntimeOptions): VerifyDcdnDomainOwnerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.verifyType)) {
    query['VerifyType'] = request.verifyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyDcdnDomainOwner',
    version = '2018-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  The maximum number of times that each user can call this operation per second is 100.
  *
  * @param request VerifyDcdnDomainOwnerRequest
  * @return VerifyDcdnDomainOwnerResponse
 */
async function verifyDcdnDomainOwner(request: VerifyDcdnDomainOwnerRequest): VerifyDcdnDomainOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyDcdnDomainOwnerWithOptions(request, runtime);
}

