/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('dypnsapi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateVerifySchemeRequest {
  appName?: string(name='AppName'),
  bundleId?: string(name='BundleId'),
  osType?: string(name='OsType'),
  ownerId?: long(name='OwnerId'),
  packName?: string(name='PackName'),
  packSign?: string(name='PackSign'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  schemeName?: string(name='SchemeName'),
}

model CreateVerifySchemeResponseBody = {
  code?: string(name='Code'),
  gateVerifySchemeDTO?: {
    schemeCode?: string(name='SchemeCode'),
  }(name='GateVerifySchemeDTO'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateVerifySchemeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVerifySchemeResponseBody(name='body'),
}

async function createVerifySchemeWithOptions(request: CreateVerifySchemeRequest, runtime: Util.RuntimeOptions): CreateVerifySchemeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.bundleId)) {
    query['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.packName)) {
    query['PackName'] = request.packName;
  }
  if (!Util.isUnset(request.packSign)) {
    query['PackSign'] = request.packSign;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.schemeName)) {
    query['SchemeName'] = request.schemeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVerifyScheme',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVerifyScheme(request: CreateVerifySchemeRequest): CreateVerifySchemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVerifySchemeWithOptions(request, runtime);
}

model DeleteVerifySchemeRequest {
  customerId?: long(name='CustomerId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  schemeCode?: string(name='SchemeCode'),
}

model DeleteVerifySchemeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model DeleteVerifySchemeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVerifySchemeResponseBody(name='body'),
}

async function deleteVerifySchemeWithOptions(request: DeleteVerifySchemeRequest, runtime: Util.RuntimeOptions): DeleteVerifySchemeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customerId)) {
    query['CustomerId'] = request.customerId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.schemeCode)) {
    query['SchemeCode'] = request.schemeCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVerifyScheme',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVerifyScheme(request: DeleteVerifySchemeRequest): DeleteVerifySchemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVerifySchemeWithOptions(request, runtime);
}

model DescribeVerifySchemeRequest {
  customerId?: long(name='CustomerId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  schemeCode?: string(name='SchemeCode'),
}

model DescribeVerifySchemeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  schemeQueryResultDTO?: {
    appEncryptInfo?: string(name='AppEncryptInfo'),
  }(name='SchemeQueryResultDTO'),
}

model DescribeVerifySchemeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVerifySchemeResponseBody(name='body'),
}

async function describeVerifySchemeWithOptions(request: DescribeVerifySchemeRequest, runtime: Util.RuntimeOptions): DescribeVerifySchemeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customerId)) {
    query['CustomerId'] = request.customerId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.schemeCode)) {
    query['SchemeCode'] = request.schemeCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVerifyScheme',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVerifyScheme(request: DescribeVerifySchemeRequest): DescribeVerifySchemeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVerifySchemeWithOptions(request, runtime);
}

model GetAuthTokenRequest {
  origin?: string(name='Origin'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  url?: string(name='Url'),
}

model GetAuthTokenResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  tokenInfo?: {
    accessToken?: string(name='AccessToken'),
    jwtToken?: string(name='JwtToken'),
  }(name='TokenInfo'),
}

model GetAuthTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetAuthTokenResponseBody(name='body'),
}

async function getAuthTokenWithOptions(request: GetAuthTokenRequest, runtime: Util.RuntimeOptions): GetAuthTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.origin)) {
    query['Origin'] = request.origin;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAuthToken',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAuthToken(request: GetAuthTokenRequest): GetAuthTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthTokenWithOptions(request, runtime);
}

model GetAuthorizationUrlRequest {
  endDate?: string(name='EndDate'),
  ownerId?: long(name='OwnerId'),
  phoneNo?: string(name='PhoneNo'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  schemeId?: long(name='SchemeId'),
}

model GetAuthorizationUrlResponseBody = {
  code?: string(name='Code'),
  data?: {
    authorizationUrl?: string(name='AuthorizationUrl'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetAuthorizationUrlResponse = {
  headers: map[string]string(name='headers'),
  body: GetAuthorizationUrlResponseBody(name='body'),
}

async function getAuthorizationUrlWithOptions(request: GetAuthorizationUrlRequest, runtime: Util.RuntimeOptions): GetAuthorizationUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.phoneNo)) {
    query['PhoneNo'] = request.phoneNo;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.schemeId)) {
    query['SchemeId'] = request.schemeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAuthorizationUrl',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAuthorizationUrl(request: GetAuthorizationUrlRequest): GetAuthorizationUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthorizationUrlWithOptions(request, runtime);
}

model GetCertifyResultRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  token?: string(name='Token'),
}

model GetCertifyResultResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      deviceToken?: string(name='DeviceToken'),
      identityInfo?: string(name='IdentityInfo'),
      materialInfo?: string(name='MaterialInfo'),
      verifyDesc?: string(name='VerifyDesc'),
      verifyResult?: string(name='VerifyResult'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetCertifyResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetCertifyResultResponseBody(name='body'),
}

async function getCertifyResultWithOptions(request: GetCertifyResultRequest, runtime: Util.RuntimeOptions): GetCertifyResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCertifyResult',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCertifyResult(request: GetCertifyResultRequest): GetCertifyResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCertifyResultWithOptions(request, runtime);
}

model GetMobileRequest {
  accessToken?: string(name='AccessToken'),
  outId?: string(name='OutId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GetMobileResponseBody = {
  code?: string(name='Code'),
  getMobileResultDTO?: {
    mobile?: string(name='Mobile'),
  }(name='GetMobileResultDTO'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetMobileResponse = {
  headers: map[string]string(name='headers'),
  body: GetMobileResponseBody(name='body'),
}

async function getMobileWithOptions(request: GetMobileRequest, runtime: Util.RuntimeOptions): GetMobileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.outId)) {
    query['OutId'] = request.outId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMobile',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMobile(request: GetMobileRequest): GetMobileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMobileWithOptions(request, runtime);
}

model GetSmsAuthTokensRequest {
  bundleId?: string(name='BundleId'),
  expire?: long(name='Expire'),
  osType?: string(name='OsType'),
  ownerId?: long(name='OwnerId'),
  packageName?: string(name='PackageName'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sceneCode?: string(name='SceneCode'),
  signName?: string(name='SignName'),
  smsCodeExpire?: int32(name='SmsCodeExpire'),
  smsTemplateCode?: string(name='SmsTemplateCode'),
}

model GetSmsAuthTokensResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizToken?: string(name='BizToken'),
    expireTime?: long(name='ExpireTime'),
    stsAccessKeyId?: string(name='StsAccessKeyId'),
    stsAccessKeySecret?: string(name='StsAccessKeySecret'),
    stsToken?: string(name='StsToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetSmsAuthTokensResponse = {
  headers: map[string]string(name='headers'),
  body: GetSmsAuthTokensResponseBody(name='body'),
}

async function getSmsAuthTokensWithOptions(request: GetSmsAuthTokensRequest, runtime: Util.RuntimeOptions): GetSmsAuthTokensResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bundleId)) {
    query['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.expire)) {
    query['Expire'] = request.expire;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.packageName)) {
    query['PackageName'] = request.packageName;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sceneCode)) {
    query['SceneCode'] = request.sceneCode;
  }
  if (!Util.isUnset(request.signName)) {
    query['SignName'] = request.signName;
  }
  if (!Util.isUnset(request.smsCodeExpire)) {
    query['SmsCodeExpire'] = request.smsCodeExpire;
  }
  if (!Util.isUnset(request.smsTemplateCode)) {
    query['SmsTemplateCode'] = request.smsTemplateCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSmsAuthTokens',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSmsAuthTokens(request: GetSmsAuthTokensRequest): GetSmsAuthTokensResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSmsAuthTokensWithOptions(request, runtime);
}

model QueryGateVerifyBillingPublicRequest {
  authenticationType?: int32(name='AuthenticationType'),
  month?: string(name='Month'),
  ownerId?: long(name='OwnerId'),
  prodCode?: string(name='ProdCode'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryGateVerifyBillingPublicResponseBody = {
  code?: string(name='Code'),
  data?: {
    amountSum?: string(name='AmountSum'),
    sceneBillingList?: [ 
      {
        add?: string(name='Add'),
        amount?: string(name='Amount'),
        appName?: string(name='AppName'),
        itemName?: string(name='ItemName'),
        sceneCode?: string(name='SceneCode'),
        sceneName?: string(name='SceneName'),
        singlePrice?: string(name='SinglePrice'),
      }
    ](name='SceneBillingList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryGateVerifyBillingPublicResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGateVerifyBillingPublicResponseBody(name='body'),
}

async function queryGateVerifyBillingPublicWithOptions(request: QueryGateVerifyBillingPublicRequest, runtime: Util.RuntimeOptions): QueryGateVerifyBillingPublicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authenticationType)) {
    query['AuthenticationType'] = request.authenticationType;
  }
  if (!Util.isUnset(request.month)) {
    query['Month'] = request.month;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.prodCode)) {
    query['ProdCode'] = request.prodCode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGateVerifyBillingPublic',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGateVerifyBillingPublic(request: QueryGateVerifyBillingPublicRequest): QueryGateVerifyBillingPublicResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGateVerifyBillingPublicWithOptions(request, runtime);
}

model QueryGateVerifyStatisticPublicRequest {
  authenticationType?: int32(name='AuthenticationType'),
  endDate?: string(name='EndDate'),
  osType?: string(name='OsType'),
  ownerId?: long(name='OwnerId'),
  prodCode?: string(name='ProdCode'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sceneCode?: string(name='SceneCode'),
  startDate?: string(name='StartDate'),
}

model QueryGateVerifyStatisticPublicResponseBody = {
  code?: string(name='Code'),
  data?: {
    dayStatistic?: [ 
      {
        statisticDateStr?: string(name='StatisticDateStr'),
        totalFail?: long(name='TotalFail'),
        totalSuccess?: long(name='TotalSuccess'),
        totalUnknown?: long(name='TotalUnknown'),
      }
    ](name='DayStatistic'),
    total?: long(name='Total'),
    totalFail?: long(name='TotalFail'),
    totalSuccess?: long(name='TotalSuccess'),
    totalUnknown?: long(name='TotalUnknown'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryGateVerifyStatisticPublicResponse = {
  headers: map[string]string(name='headers'),
  body: QueryGateVerifyStatisticPublicResponseBody(name='body'),
}

async function queryGateVerifyStatisticPublicWithOptions(request: QueryGateVerifyStatisticPublicRequest, runtime: Util.RuntimeOptions): QueryGateVerifyStatisticPublicResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authenticationType)) {
    query['AuthenticationType'] = request.authenticationType;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.prodCode)) {
    query['ProdCode'] = request.prodCode;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sceneCode)) {
    query['SceneCode'] = request.sceneCode;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryGateVerifyStatisticPublic',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryGateVerifyStatisticPublic(request: QueryGateVerifyStatisticPublicRequest): QueryGateVerifyStatisticPublicResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryGateVerifyStatisticPublicWithOptions(request, runtime);
}

model VerifyMobileRequest {
  accessCode?: string(name='AccessCode'),
  outId?: string(name='OutId'),
  ownerId?: long(name='OwnerId'),
  phoneNumber?: string(name='PhoneNumber'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model VerifyMobileResponseBody = {
  code?: string(name='Code'),
  gateVerifyResultDTO?: {
    verifyId?: string(name='VerifyId'),
    verifyResult?: string(name='VerifyResult'),
  }(name='GateVerifyResultDTO'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model VerifyMobileResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyMobileResponseBody(name='body'),
}

async function verifyMobileWithOptions(request: VerifyMobileRequest, runtime: Util.RuntimeOptions): VerifyMobileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessCode)) {
    query['AccessCode'] = request.accessCode;
  }
  if (!Util.isUnset(request.outId)) {
    query['OutId'] = request.outId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.phoneNumber)) {
    query['PhoneNumber'] = request.phoneNumber;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyMobile',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyMobile(request: VerifyMobileRequest): VerifyMobileResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyMobileWithOptions(request, runtime);
}

model VerifyPhoneWithTokenRequest {
  ownerId?: long(name='OwnerId'),
  phoneNumber?: string(name='PhoneNumber'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spToken?: string(name='SpToken'),
}

model VerifyPhoneWithTokenResponseBody = {
  code?: string(name='Code'),
  gateVerify?: {
    verifyId?: string(name='VerifyId'),
    verifyResult?: string(name='VerifyResult'),
  }(name='GateVerify'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model VerifyPhoneWithTokenResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyPhoneWithTokenResponseBody(name='body'),
}

async function verifyPhoneWithTokenWithOptions(request: VerifyPhoneWithTokenRequest, runtime: Util.RuntimeOptions): VerifyPhoneWithTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.phoneNumber)) {
    query['PhoneNumber'] = request.phoneNumber;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.spToken)) {
    query['SpToken'] = request.spToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyPhoneWithToken',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyPhoneWithToken(request: VerifyPhoneWithTokenRequest): VerifyPhoneWithTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyPhoneWithTokenWithOptions(request, runtime);
}

model VerifySmsCodeRequest {
  phoneNumber?: string(name='PhoneNumber'),
  smsCode?: string(name='SmsCode'),
  smsToken?: string(name='SmsToken'),
}

model VerifySmsCodeResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model VerifySmsCodeResponse = {
  headers: map[string]string(name='headers'),
  body: VerifySmsCodeResponseBody(name='body'),
}

async function verifySmsCodeWithOptions(request: VerifySmsCodeRequest, runtime: Util.RuntimeOptions): VerifySmsCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.phoneNumber)) {
    query['PhoneNumber'] = request.phoneNumber;
  }
  if (!Util.isUnset(request.smsCode)) {
    query['SmsCode'] = request.smsCode;
  }
  if (!Util.isUnset(request.smsToken)) {
    query['SmsToken'] = request.smsToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifySmsCode',
    version = '2017-05-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifySmsCode(request: VerifySmsCodeRequest): VerifySmsCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifySmsCodeWithOptions(request, runtime);
}

